Index: resources/ui.qrc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><RCC>\r\n    <qresource>\r\n        <file>icons/app.png</file>\r\n        <file>icons/print.png</file>\r\n        <file>icons/save.png</file>\r\n        <file>icons/undo.png</file>\r\n    </qresource>\r\n</RCC>\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/resources/ui.qrc b/resources/ui.qrc
--- a/resources/ui.qrc	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/resources/ui.qrc	(date 1729410604250)
@@ -1,8 +1,0 @@
-<RCC>
-    <qresource>
-        <file>icons/app.png</file>
-        <file>icons/print.png</file>
-        <file>icons/save.png</file>
-        <file>icons/undo.png</file>
-    </qresource>
-</RCC>
Index: FileIO/src/graphml.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// gml.cpp\r\n//\t: program file gml\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Nov 2 15:02:45 2021\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include \"graphml.h\"\r\n\r\nnamespace FileIO {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPrivate Functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tProtected Functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPublic functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tConstructors & Destructors\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  GraphML::GraphML --\tconstructor\r\n    //\r\n    //  Inputs\r\n    //\tnone\r\n    //\r\n    //  Outputs\r\n    //\tnone\r\n    //\r\n    GraphML::GraphML( void )\r\n    {\r\n\t\t_isWithGeometry = false;\r\n\t\t_maxLevel = 0;\r\n\t    _subGraphNodeIndex = 0;\r\n\t    \r\n\t\t_subGraphMap.clear();\r\n    }\r\n\r\n    //\r\n    //  GraphML::GraphML --\tcopy constructor\r\n    //\r\n    //  Input\r\n    //\tnone\r\n    //\r\n    //  Output\r\n    //\tnone\r\n    //\r\n    GraphML::GraphML( const GraphML & v )\r\n    {\r\n\t\t_isWithGeometry = v._isWithGeometry;\r\n\t\t_maxLevel       = v._maxLevel;\r\n\t    _subGraphNodeIndex = v._subGraphNodeIndex;\r\n\t\r\n\t    _graphmlTree    = v._graphmlTree;\r\n\t    _subGraphMap    = v._subGraphMap;\r\n\t}\r\n    \r\n    \r\n    //\r\n    //  GraphML::loadGroup --\tloadGroup function\r\n    //\r\n    //  Input\r\n    //\tQDomElement: xml element\r\n    //\r\n    //  Output\r\n    //\tnone\r\n    //\r\n    void GraphML::loadGroup( QDomElement &parentElement, int parentID )\r\n    {\r\n    \t// element level\r\n    \tunsigned int level = parentElement.attribute( \"level\" ).toUInt();\r\n\t\tif( level > _maxLevel ) _maxLevel = level;\r\n//\t    cerr << \"level = \" << level << endl;\r\n\t\t\r\n\t\t// element name\r\n    \tQString name = parentElement.attribute( \"name\" );\r\n//    \tcerr << \"name = \" << name.toStdString() << endl;\r\n\t\r\n\t\t// add _graphmlTree node\r\n\t    Graph::TreeDirectedGraph::vertex_descriptor vdNew = add_vertex( _graphmlTree );\r\n\t    _graphmlTree[ vdNew ].id = num_vertices( _graphmlTree ) - 1;\r\n\t    _graphmlTree[ vdNew ].namePtr = new string( name.toStdString() );\r\n\t    _graphmlTree[ vdNew ].level = level;\r\n\t    _graphmlTree[ vdNew ].initID = 0;\r\n\t    _graphmlTree[ vdNew ].parentID = parentID;\r\n\t    _graphmlTree[ vdNew ].isSelected = false;\r\n\t    _graphmlTree[ vdNew ].coordPtr = new KeiRo::Base::Coord2( 0, 0 );\r\n\t\r\n\t\t// load group attribute\r\n\t    XML::getStyleElement( parentElement,\r\n\t                          _graphmlTree[ vdNew ].attribute.fill(), _graphmlTree[ vdNew ].attribute.stroke(),\r\n\t                          _graphmlTree[ vdNew ].attribute.strokeWidth() );\r\n\t\t\r\n\t    // add _graphmlTree edge\r\n\t\tif( parentID != -1 ){\r\n\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdP = vertex( parentID, _graphmlTree );\r\n\t\t\tpair< Graph::TreeDirectedGraph::edge_descriptor, unsigned int > foreE = add_edge( vdP, vdNew, _graphmlTree );\r\n\t\t\tGraph::TreeDirectedGraph::edge_descriptor foreED = foreE.first;\r\n\t\t\t_graphmlTree[ foreED ].id = num_edges( _graphmlTree ) - 1;\r\n\t\t}\r\n\t\r\n\t    QDomNodeList groupList = parentElement.childNodes();\r\n    \tfor( unsigned int i = 0; i < groupList.size(); i++ ) {\r\n\r\n    \t\t// Select from the node list\r\n    \t\tQDomElement groupElement = groupList.item( i ).toElement();\r\n    \t\t// cerr << \"name = \" << groupElement.tagName().toStdString() << endl;\r\n\r\n    \t\tif( groupElement.tagName() == QString( \"group\" ) ){\r\n    \t\t\tloadGroup( groupElement, _graphmlTree[ vdNew ].id );\r\n    \t\t}\r\n    \t\telse if( groupElement.tagName() == QString( \"node\" ) ){\r\n    \t\t\tloadNode( groupElement, _graphmlTree[ vdNew ].id );\r\n    \t\t}\r\n    \t\telse{\r\n    \t\t\tcerr << \"Unrecognized tagName at \" << __LINE__ << \" in \" << __FILE__ << endl;\r\n    \t\t}\r\n    \t}\r\n    }\r\n    \r\n    //\r\n    //  GraphML::loadNode --\tloadNode function\r\n    //\r\n    //  Input\r\n    //\tQDomElement: xml element\r\n    //\r\n    //  Output\r\n    //\tnone\r\n    //\r\n    void GraphML::loadNode( QDomElement & nodeElement, int parentID )\r\n    {\r\n\t    // element level\r\n\t    unsigned int level = nodeElement.attribute( \"level\" ).toUInt();\r\n \t    if( level > _maxLevel ) _maxLevel = level;\r\n//\t    cerr << \"node level = \" << level << \" _maxLevel = \" << _maxLevel\r\n//\t\t\t << \" level > _maxLevel = \" << (level > _maxLevel) << endl;\r\n//\t    cerr << \"node level = \" << level.toStdString() << endl;\r\n\t\r\n\t    Graph::BaseUndirectedGraph *subGraphPtr;\r\n\t    map< unsigned int, Graph::BaseUndirectedGraph >::iterator itSubG = _subGraphMap.find( parentID );\r\n\t\tif( itSubG == _subGraphMap.end() ){\r\n\t\t\tGraph::BaseUndirectedGraph g;\r\n\t\t\t_subGraphMap.insert( pair< unsigned int, Graph::BaseUndirectedGraph >( parentID, g ) );\r\n\t\t\titSubG = _subGraphMap.find( parentID );\r\n\t\t\tsubGraphPtr = &itSubG->second;\r\n\t\t}\r\n\t\telse{\r\n\t\t\tsubGraphPtr = &itSubG->second;\r\n//\t\t\tcerr << \" num_vertices( itSubG->second ) = \" << num_vertices( itSubG->second ) << endl;\r\n//\t\t\tcerr << \" num_vertices( *subGraphPtr ) = \" << num_vertices( *subGraphPtr ) << endl;\r\n\t\t}\r\n\r\n\t    // element id\r\n        QString id = nodeElement.attribute( \"id\" );\r\n//        cerr << \"id = \" << id.toStdString() << endl;\r\n\t    // element name\r\n\t    QString name = nodeElement.attribute( \"name\" );\r\n\r\n        QDomNodeList dataList = nodeElement.childNodes();\r\n\t\tdouble x = 0.0, y = 0.0;\r\n        // cerr << \"dataList.size() = \" << dataList.size() << endl;\r\n        for( unsigned int j = 0; j < dataList.size(); j++ ){\r\n\r\n            // Select from the node list\r\n            QDomElement dataElement = dataList.item( j ).toElement();\r\n\t\t\t\r\n            // element key\r\n            QString key = dataElement.attribute( \"key\" );\r\n//\t\t\tcerr << \"key = \" << key.toStdString() << endl;\r\n            if( key == QString( \"d0\" ) )\r\n            {\r\n\t\t\t\tx = dataElement.firstChild().toText().data().toDouble();\r\n//\t            cerr << \"x = \" << x << endl;\r\n\t\t\t}\r\n            else if( key == QString( \"d1\" ) ) {\r\n\t\t\t\ty = dataElement.firstChild().toText().data().toDouble();\r\n//\t            cerr << \"y = \" << y << endl;\r\n\t\t\t}\r\n            else {\r\n\t            cerr << \"sth is wrong here at \" << __LINE__ << \" in \" << __FILE__ << endl;\r\n\t\t\t}\r\n        }\r\n\t\r\n\t    Graph::BaseUndirectedGraph::vertex_descriptor vdNew = add_vertex( *subGraphPtr );\r\n\t    (*subGraphPtr)[ vdNew ].id = num_vertices( *subGraphPtr ) - 1;\r\n\t    (*subGraphPtr)[ vdNew ].namePtr = new string( name.toStdString() );\r\n\t    (*subGraphPtr)[ vdNew ].namePixelWidthPtr = new double( 0.0 );\r\n\t    (*subGraphPtr)[ vdNew ].namePixelHeightPtr = new double( 0.0 );\r\n\t    (*subGraphPtr)[ vdNew ].initID  = _subGraphNodeIndex;\r\n\t    (*subGraphPtr)[ vdNew ].level   = level;\r\n\t    (*subGraphPtr)[ vdNew ].isSelected   = false;\r\n\t    (*subGraphPtr)[ vdNew ].coordPtr = new KeiRo::Base::Coord2( x, y );\r\n\r\n\t    // read vertex style\r\n\t    XML::getStyleElement( nodeElement,\r\n\t                          (*subGraphPtr)[ vdNew ].attribute.fill(), (*subGraphPtr)[ vdNew ].attribute.stroke(),\r\n\t                          (*subGraphPtr)[ vdNew ].attribute.strokeWidth() );\r\n\r\n#ifdef DEBUG\r\n\t\tcerr << \" pid = \" << parentID\r\n\t\t\t << \" nid = \" << (*subGraphPtr)[ vdNew ].id\r\n\t\t\t << \" num_vertices( *subGraphPtr ) = \" << num_vertices( *subGraphPtr ) << endl;\r\n#endif // DEBUG\r\n\t    _subGraphNodeIndex++;\r\n    }\r\n\t\r\n\t//\r\n\t//  GraphML::findNodesinSubGraphs --\tfind nodes in subGraphs\r\n\t//\r\n\t//  Input\r\n\t//\tidS, idT, initS, initT, subGSPtr, subGTPtr\r\n\t//\r\n\t//  Output\r\n\t//\tnone\r\n\t//\r\n\tvoid GraphML::findNodesinSubGraphs( unsigned int idS, unsigned int idT,\r\n\t                                    unsigned int &idSinSubG, unsigned int &idTinSubG,\r\n\t                                    unsigned int &idGS, unsigned int &idGT,\r\n\t                                    Graph::BaseUndirectedGraph **subGraphSPtr,\r\n\t\t\t\t\t\t\t\t\t\tGraph::BaseUndirectedGraph **subGraphTPtr )\r\n\t{\r\n\t\tfor( map< unsigned int, Graph::BaseUndirectedGraph >::iterator it = _subGraphMap.begin();\r\n\t\t\t it != _subGraphMap.end(); it++ ){\r\n\t\t\t\r\n\t\t\tGraph::BaseUndirectedGraph *subGPtr = &it->second;\r\n\t\t\t\r\n\t\t\tBGL_FORALL_VERTICES( vd, *subGPtr, Graph::BaseUndirectedGraph ) {\r\n\t\t\t\tif( (*subGPtr)[vd].initID == idS ){\r\n\t\t\t\t\tidSinSubG = (*subGPtr)[vd].id;\r\n\t\t\t\t\tidGS = it->first;\r\n\t\t\t\t\t*subGraphSPtr = subGPtr;\r\n\t\t\t\t}\r\n\t\t\t\tif( (*subGPtr)[vd].initID == idT ){\r\n\t\t\t\t\tidTinSubG = (*subGPtr)[vd].id;\r\n\t\t\t\t\tidGT = it->first;\r\n\t\t\t\t\t*subGraphTPtr = subGPtr;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n    //\r\n    //  GraphML::loadEdge --\tloadEdge function\r\n    //\r\n    //  Input\r\n    //\tQDomElement: xml element\r\n    //\r\n    //  Output\r\n    //\tnone\r\n    //\r\n    void GraphML::loadEdge( QDomElement & graphElement )\r\n    {\r\n    \tQDomNodeList edgeList = graphElement.elementsByTagName( \"edge\" );\r\n\t\t\r\n\t\tcerr << \"edgeList.size() = \" << edgeList.size() << endl;\r\n\t\t\r\n    \tfor( unsigned int i = 0; i < edgeList.size(); i++ ) {\r\n\r\n    \t\t// Select from the node list\r\n    \t\tQDomElement edgeElement = edgeList.item( i ).toElement();\r\n\r\n    \t\t// element source\r\n    \t\tQString source = edgeElement.attribute( \"source\" );\r\n\t\t\tunsigned int idS = source.toUInt();\r\n\r\n    \t\t// element target\r\n    \t\tQString target = edgeElement.attribute( \"target\" );\r\n\t\t    unsigned int idT = target.toUInt();\r\n\t\t\t\r\n\t\t    Graph::BaseUndirectedGraph *subGraphSPtr, *subGraphTPtr;\r\n\t\t    unsigned int idSinSubG, idTinSubG, idGS, idGT;\r\n\t\t\tfindNodesinSubGraphs( idS, idT,\r\n\t\t\t                      idSinSubG, idTinSubG,\r\n\t\t\t\t\t\t\t\t  idGS, idGT,\r\n\t\t\t                      &subGraphSPtr, &subGraphTPtr );\r\n#ifdef DEBUG\r\n\t\t    cerr << \"(source, target) = (\" << idS << \", \" << idT << \")\"<< endl;\r\n\t\t    cerr << \"(initIDS, initIDT) = (\" << initIDS << \", \" << initIDT << \")\"<< endl;\r\n#endif // DEBUG\r\n\t\t\tif( subGraphSPtr == subGraphTPtr ){\r\n\r\n\t\t\t\t// local edge\r\n\t\t\t\tGraph::BaseUndirectedGraph::vertex_descriptor vdS= vertex( idSinSubG, *subGraphSPtr );\r\n\t\t\t\tGraph::BaseUndirectedGraph::vertex_descriptor vdT= vertex( idTinSubG, *subGraphTPtr );\r\n\t\t\t\t\r\n\t\t\t\tbool found = false;\r\n\t\t\t\tGraph::BaseUndirectedGraph::edge_descriptor oldED;\r\n\t\t\t\ttie( oldED, found ) = edge( vdS, vdT, *subGraphSPtr );\r\n\r\n\t\t\t\tif( found == false ){\r\n\t\t\t\t\t\r\n\t\t\t\t\tpair< Graph::BaseUndirectedGraph::edge_descriptor, unsigned int > foreE = add_edge( vdS, vdT, *subGraphSPtr );\r\n\t\t\t\t\tGraph::BaseUndirectedGraph::edge_descriptor foreED = foreE.first;\r\n\t\t\t\t\t(*subGraphSPtr)[ foreED ].id = num_edges( *subGraphSPtr ) - 1;\r\n\r\n\t\t\t\t\t// read edge page\r\n\t\t\t\t\tXML::getEdgeDElement( edgeElement,\r\n\t\t\t\t\t\t\t\t\t\t  (*subGraphSPtr)[ foreED ].edge, (*subGraphSPtr)[ foreED ].edge.isClosed() );\r\n\t\t\t\t\t// read edge style\r\n\t\t\t\t\tXML::getStyleElement( edgeElement,\r\n\t\t\t\t\t\t\t\t\t\t\t  (*subGraphSPtr)[ foreED ].edge.fill(), (*subGraphSPtr)[ foreED ].edge.stroke(),\r\n\t\t\t\t\t\t\t\t\t\t\t  (*subGraphSPtr)[ foreED ].edge.strokeWidth() );\r\n#ifdef DEBUG\r\n\t\t\t\t\tcerr << \"(*subGraphSPtr)[ foreED ].edge.size() = \" << (*subGraphSPtr)[ foreED ].edge.elements().size() << endl;\r\n\t\t\t\t\tcerr << \"(*subGraphSPtr)[ foreED ].strokeWidth = \" << (*subGraphSPtr)[ foreED ].edge.strokeWidth() << endl;\r\n#endif // DEBUG\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\t\r\n\t\t\t\t// global path\r\n\t\t\t\t_globalPathMap.insert( pair< KeiRo::Base::Common::UIDPair,\r\n\t\t\t\t\t\tKeiRo::Base::Common::UIDPair >( pair< unsigned int, unsigned int >( idGS, idSinSubG ),\r\n\t\t\t\t                                        pair< unsigned int, unsigned int >( idGT, idTinSubG ) ) );\r\n\t\t\t\tKeiRo::Base::Edge2 edge;\r\n\r\n\t\t\t\t// read edge style\r\n\t\t\t\tXML::getStyleElement( edgeElement, edge.fill(),\r\n\t\t\t\t\t\t\t\t\t  edge.stroke(), edge.strokeWidth() );\r\n\t\t\t\t_globalPathAttributeMap.insert( pair< pair< KeiRo::Base::Common::UIDPair, KeiRo::Base::Common::UIDPair >,\r\n\t\t\t\t        KeiRo::Base::Edge2 >( pair< pair< unsigned int, unsigned int >, pair< unsigned int, unsigned int > >(\r\n\t\t\t\t\t\tpair< unsigned int, unsigned int >( idGS, idSinSubG ),\r\n\t\t\t\t\t\tpair< unsigned int, unsigned int >( idGT, idTinSubG ) ), edge ) );\r\n\t\t\t}\r\n#ifdef DEBUG\r\n\t\t    cerr << \"num_edges( *subGraphSPtr ) = \" << num_edges( *subGraphSPtr ) << endl;\r\n#endif // DEBUG\r\n    \t}\r\n#ifdef DEBUG\r\n\t\tfor( multimap< KeiRo::Base::Common::UIDPair, KeiRo::Base::Common::UIDPair >::iterator it = _globalPath.begin();\r\n\t\t\t it != _globalPath.end(); it++ ){\r\n\t\t\tcerr << \"(\" << it->first.first << \", \" << it->first.second << \")\" << \" -- \"\r\n\t\t\t\t << \"(\" << it->second.first << \", \" << it->second.second << \")\" << endl;\r\n\t\t}\r\n#endif // DEBUG\r\n    }\r\n\t\r\n\t//\r\n\t//  GraphML::computeGroupBoundary --\tload function\r\n\t//\r\n\t//  Input\r\n\t//\tnone\r\n\t//\r\n\t//  Output\r\n\t//\tnone\r\n\t//\r\n\tvoid GraphML::computeGroupBoundary( void )\r\n\t{\r\n\t\t// leaf nodes\r\n\t\tfor( map< unsigned int, Graph::BaseUndirectedGraph >::iterator it = _subGraphMap.begin();\r\n\t\t     it != _subGraphMap.end(); it++ ){\r\n\t\t\t\r\n\t\t\tunsigned int parentID = it->first;\r\n\t\t\tGraph::BaseUndirectedGraph *subGPtr = &it->second;\r\n\t\t\tGraph::TreeDirectedGraph::vertex_descriptor parentVD = vertex( parentID, _graphmlTree );\r\n\r\n\t\t\tdouble minX = INFINITY, minY = INFINITY, maxX = -INFINITY, maxY = -INFINITY;\r\n\t\t\tBGL_FORALL_VERTICES( vd, *subGPtr, Graph::BaseUndirectedGraph ) {\r\n\t\t\t\t\r\n\t\t\t\tKeiRo::Base::Coord2 &coord = *(*subGPtr)[vd].coordPtr;\r\n\t\t\t\tif( minX > coord.x() ) minX = coord.x();\r\n\t\t\t\tif( minY > coord.y() ) minY = coord.y();\r\n\t\t\t\tif( maxX < coord.x() ) maxX = coord.x();\r\n\t\t\t\tif( maxY < coord.y() ) maxY = coord.y();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t_graphmlTree[ parentVD ].boundingBoxPtr = new KeiRo::Base::Rectangle2( minX, minY, maxX-minX, maxY-minY );\r\n\t\t\t\r\n#ifdef DEBUG\r\n\t\t\tcerr << \"cid = \" << parentID\r\n \t\t\t\t << \" level = \" << _graphmlTree[ parentVD ].level\r\n\t\t\t\t << \" w = \" << *_graphmlTree[ parentVD ].widthPtr\r\n\t\t\t\t << \" h = \" << *_graphmlTree[ parentVD ].heightPtr\r\n\t\t\t\t << \" lb = \" << *_graphmlTree[ parentVD ].leftBottomCoordPtr;\r\n#endif // DEBUG\r\n\t\t}\r\n\t\t\r\n\t\t// non-leaf nodes\r\n\t\t// cerr << \"_maxLevel = \" << _maxLevel << endl;\r\n\t\tfor( int i = _maxLevel-2; i >= 0; i-- ){\r\n\t\t\t\r\n\t\t\tBGL_FORALL_VERTICES( vd, _graphmlTree, Graph::TreeDirectedGraph ) {\r\n\r\n//\t\t\t\tcerr << \"level = \" << _graphmlTree[ vd ].level << endl;\r\n//\t\t\t\tcerr << \"i = \" << i << endl;\r\n\t\t\t\tif( i == _graphmlTree[ vd ].level ){\r\n\t\t\t\t\t\r\n\t\t\t\t\tdouble minX = INFINITY, minY = INFINITY, maxX = -INFINITY, maxY = -INFINITY;\r\n\t\t\t\t\tGraph::TreeDirectedGraph::out_edge_iterator e, e_end;\r\n\t\t\t\t\tfor( tie( e, e_end ) = out_edges( vd, _graphmlTree ); e != e_end; ++e ) {\r\n\t\t\t\t\t\tGraph::TreeDirectedGraph::edge_descriptor ed = *e;\r\n\t\t\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdS = source( ed, _graphmlTree );\r\n\t\t\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdT = target( ed, _graphmlTree );\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif( minX > _graphmlTree[ vdT ].boundingBoxPtr->leftBottom().x() )\r\n\t\t\t\t\t\t\tminX = _graphmlTree[ vdT ].boundingBoxPtr->leftBottom().x();\r\n\t\t\t\t\t\tif( minY > _graphmlTree[ vdT ].boundingBoxPtr->leftBottom().y() )\r\n\t\t\t\t\t\t\tminY = _graphmlTree[ vdT ].boundingBoxPtr->leftBottom().y();\r\n\t\t\t\t\t\tif( maxX < _graphmlTree[ vdT ].boundingBoxPtr->leftBottom().x() + _graphmlTree[ vdT ].boundingBoxPtr->width() )\r\n\t\t\t\t\t\t\tmaxX = _graphmlTree[ vdT ].boundingBoxPtr->leftBottom().x() + _graphmlTree[ vdT ].boundingBoxPtr->width();\r\n\t\t\t\t\t\tif( maxY < _graphmlTree[ vdT ].boundingBoxPtr->leftBottom().y() + _graphmlTree[ vdT ].boundingBoxPtr->height() )\r\n\t\t\t\t\t\t\tmaxY = _graphmlTree[ vdT ].boundingBoxPtr->leftBottom().y() + _graphmlTree[ vdT ].boundingBoxPtr->height();\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t_graphmlTree[ vd ].boundingBoxPtr = new KeiRo::Base::Rectangle2( minX, minY, maxX-minX, maxY-minY );\r\n\r\n#ifdef DEBUG\r\n\t\t\t\t\tcerr << \"cid = \" << _graphmlTree[ vd ].id\r\n\t\t\t\t\t     << \" level = \" << _graphmlTree[ vd ].level\r\n\t\t\t\t\t\t << \" bbox = \" << *_graphmlTree[ vd ].boundingBoxPtr\r\n\t\t\t\t\t\t << \" obbox = \" << _graphmlTree[ vd ].boundingBoxPtr->oldWidth() << endl;\r\n//\t\t\t\t\t\t << \" w = \" << *_graphmlTree[ vd ].widthPtr\r\n//\t\t\t\t\t     << \" h = \" << *_graphmlTree[ vd ].heightPtr\r\n//\t\t\t\t\t     << \" lb = \" << *_graphmlTree[ vd ].leftBottomCoordPtr;\r\n#endif // DEBUG\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n#ifdef DEBUG\r\n\t\tBGL_FORALL_VERTICES( vd, _graphmlTree, Graph::TreeDirectedGraph ) {\r\n\t\t\t\tcerr << \" id = \" << _graphmlTree[ vd ].id\r\n\t\t\t\t     << \" boundingBox = \" << *_graphmlTree[ vd ].boundingBoxPtr;\r\n\t\t}\r\n#endif // DEBUG\r\n\t\r\n\t}\r\n\t\r\n\t//\r\n\t//  GraphML::normalize --\tnormalize the data\r\n\t//\r\n\t//  Input\r\n\t//\tnone\r\n\t//\r\n\t//  Output\r\n\t//\tnone\r\n\t//\r\n\tvoid GraphML::normalize( void )\r\n\t{\r\n\t\t// leaf nodes\r\n\t\tdouble minX = INFINITY, minY = INFINITY, maxX = -INFINITY, maxY = -INFINITY;\r\n\t\tfor( map< unsigned int, Graph::BaseUndirectedGraph >::iterator it = _subGraphMap.begin();\r\n\t\t     it != _subGraphMap.end(); it++ ){\r\n\t\t\t\r\n\t\t\tunsigned int parentID = it->first;\r\n\t\t\tGraph::BaseUndirectedGraph *subGPtr = &it->second;\r\n\t\t\t\r\n\t\t\t// iterate edge sample points\r\n\t\t\tBGL_FORALL_EDGES( ed, *subGPtr, Graph::BaseUndirectedGraph ) {\r\n\t\t\t\tKeiRo::Base::Edge2 &edge = (*subGPtr)[ed].edge;\r\n\t\t\t\tfor( unsigned int i = 0; i < edge.elements().size(); i++ ){\r\n\t\t\t\t\tKeiRo::Base::Coord2 &coord = edge.elements()[i];\r\n\r\n\t\t\t\t\tif( minX > coord.x() ) minX = coord.x();\r\n\t\t\t\t\tif( minY > coord.y() ) minY = coord.y();\r\n\t\t\t\t\tif( maxX < coord.x() ) maxX = coord.x();\r\n\t\t\t\t\tif( maxY < coord.y() ) maxY = coord.y();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// iterate vertices\r\n\t\t\tBGL_FORALL_VERTICES( vd, *subGPtr, Graph::BaseUndirectedGraph ) {\r\n\t\t\t\t\r\n\t\t\t\tKeiRo::Base::Coord2 &coord = *(*subGPtr)[vd].coordPtr;\r\n\r\n\t\t\t\tif( minX > coord.x() ) minX = coord.x();\r\n\t\t\t\tif( minY > coord.y() ) minY = coord.y();\r\n\t\t\t\tif( maxX < coord.x() ) maxX = coord.x();\r\n\t\t\t\tif( maxY < coord.y() ) maxY = coord.y();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// update the coordinates\r\n\t\tfor( map< unsigned int, Graph::BaseUndirectedGraph >::iterator it = _subGraphMap.begin();\r\n\t\t     it != _subGraphMap.end(); it++ ){\r\n\t\t\t\r\n\t\t\tunsigned int parentID = it->first;\r\n\t\t\tGraph::BaseUndirectedGraph *subGPtr = &it->second;\r\n\t\t\t\r\n\t\t\t// iterate edge sample points\r\n\t\t\tBGL_FORALL_EDGES( ed, *subGPtr, Graph::BaseUndirectedGraph ) {\r\n\t\t\t\tKeiRo::Base::Edge2 &edge = (*subGPtr)[ed].edge;\r\n\t\t\t\tfor( unsigned int i = 0; i < edge.elements().size(); i++ ){\r\n\r\n\t\t\t\t\tKeiRo::Base::Coord2 &coord = edge.elements()[i];\r\n\t\t\t\t\tcoord.x() = ( coord.x() - minX ) / ( maxX - minX ) * KeiRo::Base::Common::getMainwidgetWidth() - 0.5 * KeiRo::Base::Common::getMainwidgetWidth();\r\n\t\t\t\t\tcoord.y() = ( coord.y() - minY ) / ( maxY - minY ) * KeiRo::Base::Common::getMainwidgetHeight() - 0.5 * KeiRo::Base::Common::getMainwidgetHeight();\r\n\t\t\t\t\tcoord.updateOldElement();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// iterate vertices\r\n\t\t\tBGL_FORALL_VERTICES( vd, *subGPtr, Graph::BaseUndirectedGraph ) {\r\n\t\t\t\t\r\n\t\t\t\tKeiRo::Base::Coord2 &coord = *(*subGPtr)[vd].coordPtr;\r\n\t\t\t\tcoord.x() = ( coord.x() - minX ) / ( maxX - minX ) * KeiRo::Base::Common::getMainwidgetWidth() - 0.5 * KeiRo::Base::Common::getMainwidgetWidth();\r\n\t\t\t\tcoord.y() = ( coord.y() - minY ) / ( maxY - minY ) * KeiRo::Base::Common::getMainwidgetHeight() - 0.5 * KeiRo::Base::Common::getMainwidgetHeight();\r\n\t\t\t\tcoord.updateOldElement();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n    //\r\n    //  GraphML::load --\tload function\r\n    //\r\n    //  Input\r\n    //\tstring: file name\r\n    //\r\n    //  Output\r\n    //\tnone\r\n    //\r\n    void GraphML::load( const string filename )\r\n    {\r\n\t\t// initialization\r\n\t    _maxLevel = 0;\r\n\r\n    \tQString fileName = QString::fromStdString( filename );\r\n    \t\t\t\r\n        // document object\r\n        QDomDocument doc;\r\n    \t// Open your GraphML-file\r\n    \tQFile file( fileName );\r\n\r\n    \t// If it is not opened, or have failed to transmit the contents in QDocDocument\r\n    \tif ( !file.open( QIODevice::ReadOnly ) || !doc.setContent( &file ) ) {\r\n    \t\t// the refund list, but empty\r\n    \t\tcerr << \"something is wrong here... at \" << __LINE__ << \" in \" << __FILE__ << endl;\r\n    \t\tcerr << \"fileName = \" << fileName.toStdString() << endl;\r\n    \t\treturn;\r\n    \t}\r\n    \t\r\n    \t// read the xml file\r\n    \t// get root names and attributes\r\n    \tQDomNodeList rootNodeList = doc.documentElement().childNodes();\r\n    \tQDomElement graphElement;\r\n    \tfor( unsigned int i = 0; i < rootNodeList.size(); i++ ) {\r\n    \t\tif( rootNodeList.item( i ).toElement().tagName() == QString( \"graph\" ) ){\r\n    \t\t\tcerr << \"rootElem.tagName() = \" << rootNodeList.item( i ).toElement().tagName().toStdString() << endl;\r\n    \t\t\tgraphElement = rootNodeList.item( i ).toElement();\r\n    \t\t}\r\n    \t}\r\n\t\t\r\n\t\t// add root node for the _graphmlTree\r\n\t    Graph::TreeDirectedGraph::vertex_descriptor vdNew = add_vertex( _graphmlTree );\r\n\t    _graphmlTree[ vdNew ].id = 0;\r\n\t    _graphmlTree[ vdNew ].namePtr = new string( \"root\" );\r\n\t    _graphmlTree[ vdNew ].level = 0;\r\n\t    _graphmlTree[ vdNew ].initID = 0;\r\n\t    _graphmlTree[ vdNew ].parentID = 0;\r\n\t    _graphmlTree[ vdNew ].isSelected = false;\r\n\t    _graphmlTree[ vdNew ].coordPtr = new KeiRo::Base::Coord2( 5, 0 );\r\n\t\t\r\n    \t// load nodes\r\n    \tif( graphElement.firstChild().toElement().tagName() == QString( \"node\" ) ){\r\n    \t\tQDomNodeList nodeList = graphElement.childNodes();\r\n    \t\tfor( unsigned int i = 0; i < nodeList.size(); i++ ){\r\n    \t\t\tQDomElement nodeElement = nodeList.item( i ).toElement();\r\n    \t\t\tif( nodeElement.tagName() == QString( \"node\" ) )\r\n\t                loadNode( nodeElement );\r\n    \t\t}\r\n    \t}\r\n    \t// load groups\r\n    \telse if( graphElement.firstChild().toElement().tagName() == QString( \"group\" ) ){\r\n    \t\tQDomNodeList groupList = graphElement.childNodes();\r\n    \t\t// cerr << \"groupList = \" << groupList.size() << endl;\r\n    \t\tfor( unsigned int i = 0; i < groupList.size(); i++ ){\r\n    \t\t\tQDomElement groupElement = groupList.item( i ).toElement();\r\n    \t\t\tif( groupElement.tagName() == QString( \"group\" ) )\r\n    \t\t\t\tloadGroup( groupElement, 0 );\r\n    \t\t}\r\n    \t}\r\n    \telse{\r\n    \t\tcerr << \"Unrecognized tagName \" << graphElement.firstChild().toElement().tagName().toStdString() << \" at \" << __LINE__ << \" in \" << __FILE__ << endl;\r\n    \t}\r\n\t\r\n    \t// load edges\r\n\t    loadEdge( graphElement );\r\n\r\n\t\t// nomalization\r\n\t\tnormalize();\r\n\t\t\r\n\t\t// compute group boundary\r\n\t    computeGroupBoundary();\r\n#ifdef DEBUG\r\n\t    cerr << \"*****************************\" << endl;\r\n\t\tcerr << \"_maxLevel = \" << _maxLevel << endl;\r\n\t    Graph::printGraph( _graphmlTree );\r\n\t    cerr << \"*****************************\" << endl;\r\n\r\n\t\tfor( map< unsigned int, Graph::BaseUndirectedGraph >::iterator it = _subGraphMap.begin();\r\n\t\t\t it != _subGraphMap.end(); it++ ){\r\n\t\t\tcerr << \"gid = \" << it->first << endl;\r\n\t\t\tGraph::printGraph( it->second );\r\n\t\t\tcerr << \"*****************************\" << endl;\r\n\t\t}\r\n#endif // DEBUG\r\n    }\r\n\t\r\n} // namespace FilIO\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/FileIO/src/graphml.cpp b/FileIO/src/graphml.cpp
--- a/FileIO/src/graphml.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/FileIO/src/graphml.cpp	(date 1729410604270)
@@ -1,610 +1,0 @@
-//******************************************************************************
-// gml.cpp
-//	: program file gml
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Nov 2 15:02:45 2021
-//
-//******************************************************************************
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include "graphml.h"
-
-namespace FileIO {
-
-    //------------------------------------------------------------------------------
-    //	Private Functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Protected Functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Public functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Constructors & Destructors
-    //------------------------------------------------------------------------------
-    //
-    //  GraphML::GraphML --	constructor
-    //
-    //  Inputs
-    //	none
-    //
-    //  Outputs
-    //	none
-    //
-    GraphML::GraphML( void )
-    {
-		_isWithGeometry = false;
-		_maxLevel = 0;
-	    _subGraphNodeIndex = 0;
-	    
-		_subGraphMap.clear();
-    }
-
-    //
-    //  GraphML::GraphML --	copy constructor
-    //
-    //  Input
-    //	none
-    //
-    //  Output
-    //	none
-    //
-    GraphML::GraphML( const GraphML & v )
-    {
-		_isWithGeometry = v._isWithGeometry;
-		_maxLevel       = v._maxLevel;
-	    _subGraphNodeIndex = v._subGraphNodeIndex;
-	
-	    _graphmlTree    = v._graphmlTree;
-	    _subGraphMap    = v._subGraphMap;
-	}
-    
-    
-    //
-    //  GraphML::loadGroup --	loadGroup function
-    //
-    //  Input
-    //	QDomElement: xml element
-    //
-    //  Output
-    //	none
-    //
-    void GraphML::loadGroup( QDomElement &parentElement, int parentID )
-    {
-    	// element level
-    	unsigned int level = parentElement.attribute( "level" ).toUInt();
-		if( level > _maxLevel ) _maxLevel = level;
-//	    cerr << "level = " << level << endl;
-		
-		// element name
-    	QString name = parentElement.attribute( "name" );
-//    	cerr << "name = " << name.toStdString() << endl;
-	
-		// add _graphmlTree node
-	    Graph::TreeDirectedGraph::vertex_descriptor vdNew = add_vertex( _graphmlTree );
-	    _graphmlTree[ vdNew ].id = num_vertices( _graphmlTree ) - 1;
-	    _graphmlTree[ vdNew ].namePtr = new string( name.toStdString() );
-	    _graphmlTree[ vdNew ].level = level;
-	    _graphmlTree[ vdNew ].initID = 0;
-	    _graphmlTree[ vdNew ].parentID = parentID;
-	    _graphmlTree[ vdNew ].isSelected = false;
-	    _graphmlTree[ vdNew ].coordPtr = new KeiRo::Base::Coord2( 0, 0 );
-	
-		// load group attribute
-	    XML::getStyleElement( parentElement,
-	                          _graphmlTree[ vdNew ].attribute.fill(), _graphmlTree[ vdNew ].attribute.stroke(),
-	                          _graphmlTree[ vdNew ].attribute.strokeWidth() );
-		
-	    // add _graphmlTree edge
-		if( parentID != -1 ){
-			Graph::TreeDirectedGraph::vertex_descriptor vdP = vertex( parentID, _graphmlTree );
-			pair< Graph::TreeDirectedGraph::edge_descriptor, unsigned int > foreE = add_edge( vdP, vdNew, _graphmlTree );
-			Graph::TreeDirectedGraph::edge_descriptor foreED = foreE.first;
-			_graphmlTree[ foreED ].id = num_edges( _graphmlTree ) - 1;
-		}
-	
-	    QDomNodeList groupList = parentElement.childNodes();
-    	for( unsigned int i = 0; i < groupList.size(); i++ ) {
-
-    		// Select from the node list
-    		QDomElement groupElement = groupList.item( i ).toElement();
-    		// cerr << "name = " << groupElement.tagName().toStdString() << endl;
-
-    		if( groupElement.tagName() == QString( "group" ) ){
-    			loadGroup( groupElement, _graphmlTree[ vdNew ].id );
-    		}
-    		else if( groupElement.tagName() == QString( "node" ) ){
-    			loadNode( groupElement, _graphmlTree[ vdNew ].id );
-    		}
-    		else{
-    			cerr << "Unrecognized tagName at " << __LINE__ << " in " << __FILE__ << endl;
-    		}
-    	}
-    }
-    
-    //
-    //  GraphML::loadNode --	loadNode function
-    //
-    //  Input
-    //	QDomElement: xml element
-    //
-    //  Output
-    //	none
-    //
-    void GraphML::loadNode( QDomElement & nodeElement, int parentID )
-    {
-	    // element level
-	    unsigned int level = nodeElement.attribute( "level" ).toUInt();
- 	    if( level > _maxLevel ) _maxLevel = level;
-//	    cerr << "node level = " << level << " _maxLevel = " << _maxLevel
-//			 << " level > _maxLevel = " << (level > _maxLevel) << endl;
-//	    cerr << "node level = " << level.toStdString() << endl;
-	
-	    Graph::BaseUndirectedGraph *subGraphPtr;
-	    map< unsigned int, Graph::BaseUndirectedGraph >::iterator itSubG = _subGraphMap.find( parentID );
-		if( itSubG == _subGraphMap.end() ){
-			Graph::BaseUndirectedGraph g;
-			_subGraphMap.insert( pair< unsigned int, Graph::BaseUndirectedGraph >( parentID, g ) );
-			itSubG = _subGraphMap.find( parentID );
-			subGraphPtr = &itSubG->second;
-		}
-		else{
-			subGraphPtr = &itSubG->second;
-//			cerr << " num_vertices( itSubG->second ) = " << num_vertices( itSubG->second ) << endl;
-//			cerr << " num_vertices( *subGraphPtr ) = " << num_vertices( *subGraphPtr ) << endl;
-		}
-
-	    // element id
-        QString id = nodeElement.attribute( "id" );
-//        cerr << "id = " << id.toStdString() << endl;
-	    // element name
-	    QString name = nodeElement.attribute( "name" );
-
-        QDomNodeList dataList = nodeElement.childNodes();
-		double x = 0.0, y = 0.0;
-        // cerr << "dataList.size() = " << dataList.size() << endl;
-        for( unsigned int j = 0; j < dataList.size(); j++ ){
-
-            // Select from the node list
-            QDomElement dataElement = dataList.item( j ).toElement();
-			
-            // element key
-            QString key = dataElement.attribute( "key" );
-//			cerr << "key = " << key.toStdString() << endl;
-            if( key == QString( "d0" ) )
-            {
-				x = dataElement.firstChild().toText().data().toDouble();
-//	            cerr << "x = " << x << endl;
-			}
-            else if( key == QString( "d1" ) ) {
-				y = dataElement.firstChild().toText().data().toDouble();
-//	            cerr << "y = " << y << endl;
-			}
-            else {
-	            cerr << "sth is wrong here at " << __LINE__ << " in " << __FILE__ << endl;
-			}
-        }
-	
-	    Graph::BaseUndirectedGraph::vertex_descriptor vdNew = add_vertex( *subGraphPtr );
-	    (*subGraphPtr)[ vdNew ].id = num_vertices( *subGraphPtr ) - 1;
-	    (*subGraphPtr)[ vdNew ].namePtr = new string( name.toStdString() );
-	    (*subGraphPtr)[ vdNew ].namePixelWidthPtr = new double( 0.0 );
-	    (*subGraphPtr)[ vdNew ].namePixelHeightPtr = new double( 0.0 );
-	    (*subGraphPtr)[ vdNew ].initID  = _subGraphNodeIndex;
-	    (*subGraphPtr)[ vdNew ].level   = level;
-	    (*subGraphPtr)[ vdNew ].isSelected   = false;
-	    (*subGraphPtr)[ vdNew ].coordPtr = new KeiRo::Base::Coord2( x, y );
-
-	    // read vertex style
-	    XML::getStyleElement( nodeElement,
-	                          (*subGraphPtr)[ vdNew ].attribute.fill(), (*subGraphPtr)[ vdNew ].attribute.stroke(),
-	                          (*subGraphPtr)[ vdNew ].attribute.strokeWidth() );
-
-#ifdef DEBUG
-		cerr << " pid = " << parentID
-			 << " nid = " << (*subGraphPtr)[ vdNew ].id
-			 << " num_vertices( *subGraphPtr ) = " << num_vertices( *subGraphPtr ) << endl;
-#endif // DEBUG
-	    _subGraphNodeIndex++;
-    }
-	
-	//
-	//  GraphML::findNodesinSubGraphs --	find nodes in subGraphs
-	//
-	//  Input
-	//	idS, idT, initS, initT, subGSPtr, subGTPtr
-	//
-	//  Output
-	//	none
-	//
-	void GraphML::findNodesinSubGraphs( unsigned int idS, unsigned int idT,
-	                                    unsigned int &idSinSubG, unsigned int &idTinSubG,
-	                                    unsigned int &idGS, unsigned int &idGT,
-	                                    Graph::BaseUndirectedGraph **subGraphSPtr,
-										Graph::BaseUndirectedGraph **subGraphTPtr )
-	{
-		for( map< unsigned int, Graph::BaseUndirectedGraph >::iterator it = _subGraphMap.begin();
-			 it != _subGraphMap.end(); it++ ){
-			
-			Graph::BaseUndirectedGraph *subGPtr = &it->second;
-			
-			BGL_FORALL_VERTICES( vd, *subGPtr, Graph::BaseUndirectedGraph ) {
-				if( (*subGPtr)[vd].initID == idS ){
-					idSinSubG = (*subGPtr)[vd].id;
-					idGS = it->first;
-					*subGraphSPtr = subGPtr;
-				}
-				if( (*subGPtr)[vd].initID == idT ){
-					idTinSubG = (*subGPtr)[vd].id;
-					idGT = it->first;
-					*subGraphTPtr = subGPtr;
-				}
-			}
-		}
-	}
-	
-    //
-    //  GraphML::loadEdge --	loadEdge function
-    //
-    //  Input
-    //	QDomElement: xml element
-    //
-    //  Output
-    //	none
-    //
-    void GraphML::loadEdge( QDomElement & graphElement )
-    {
-    	QDomNodeList edgeList = graphElement.elementsByTagName( "edge" );
-		
-		cerr << "edgeList.size() = " << edgeList.size() << endl;
-		
-    	for( unsigned int i = 0; i < edgeList.size(); i++ ) {
-
-    		// Select from the node list
-    		QDomElement edgeElement = edgeList.item( i ).toElement();
-
-    		// element source
-    		QString source = edgeElement.attribute( "source" );
-			unsigned int idS = source.toUInt();
-
-    		// element target
-    		QString target = edgeElement.attribute( "target" );
-		    unsigned int idT = target.toUInt();
-			
-		    Graph::BaseUndirectedGraph *subGraphSPtr, *subGraphTPtr;
-		    unsigned int idSinSubG, idTinSubG, idGS, idGT;
-			findNodesinSubGraphs( idS, idT,
-			                      idSinSubG, idTinSubG,
-								  idGS, idGT,
-			                      &subGraphSPtr, &subGraphTPtr );
-#ifdef DEBUG
-		    cerr << "(source, target) = (" << idS << ", " << idT << ")"<< endl;
-		    cerr << "(initIDS, initIDT) = (" << initIDS << ", " << initIDT << ")"<< endl;
-#endif // DEBUG
-			if( subGraphSPtr == subGraphTPtr ){
-
-				// local edge
-				Graph::BaseUndirectedGraph::vertex_descriptor vdS= vertex( idSinSubG, *subGraphSPtr );
-				Graph::BaseUndirectedGraph::vertex_descriptor vdT= vertex( idTinSubG, *subGraphTPtr );
-				
-				bool found = false;
-				Graph::BaseUndirectedGraph::edge_descriptor oldED;
-				tie( oldED, found ) = edge( vdS, vdT, *subGraphSPtr );
-
-				if( found == false ){
-					
-					pair< Graph::BaseUndirectedGraph::edge_descriptor, unsigned int > foreE = add_edge( vdS, vdT, *subGraphSPtr );
-					Graph::BaseUndirectedGraph::edge_descriptor foreED = foreE.first;
-					(*subGraphSPtr)[ foreED ].id = num_edges( *subGraphSPtr ) - 1;
-
-					// read edge page
-					XML::getEdgeDElement( edgeElement,
-										  (*subGraphSPtr)[ foreED ].edge, (*subGraphSPtr)[ foreED ].edge.isClosed() );
-					// read edge style
-					XML::getStyleElement( edgeElement,
-											  (*subGraphSPtr)[ foreED ].edge.fill(), (*subGraphSPtr)[ foreED ].edge.stroke(),
-											  (*subGraphSPtr)[ foreED ].edge.strokeWidth() );
-#ifdef DEBUG
-					cerr << "(*subGraphSPtr)[ foreED ].edge.size() = " << (*subGraphSPtr)[ foreED ].edge.elements().size() << endl;
-					cerr << "(*subGraphSPtr)[ foreED ].strokeWidth = " << (*subGraphSPtr)[ foreED ].edge.strokeWidth() << endl;
-#endif // DEBUG
-				}
-			}
-			else{
-				
-				// global path
-				_globalPathMap.insert( pair< KeiRo::Base::Common::UIDPair,
-						KeiRo::Base::Common::UIDPair >( pair< unsigned int, unsigned int >( idGS, idSinSubG ),
-				                                        pair< unsigned int, unsigned int >( idGT, idTinSubG ) ) );
-				KeiRo::Base::Edge2 edge;
-
-				// read edge style
-				XML::getStyleElement( edgeElement, edge.fill(),
-									  edge.stroke(), edge.strokeWidth() );
-				_globalPathAttributeMap.insert( pair< pair< KeiRo::Base::Common::UIDPair, KeiRo::Base::Common::UIDPair >,
-				        KeiRo::Base::Edge2 >( pair< pair< unsigned int, unsigned int >, pair< unsigned int, unsigned int > >(
-						pair< unsigned int, unsigned int >( idGS, idSinSubG ),
-						pair< unsigned int, unsigned int >( idGT, idTinSubG ) ), edge ) );
-			}
-#ifdef DEBUG
-		    cerr << "num_edges( *subGraphSPtr ) = " << num_edges( *subGraphSPtr ) << endl;
-#endif // DEBUG
-    	}
-#ifdef DEBUG
-		for( multimap< KeiRo::Base::Common::UIDPair, KeiRo::Base::Common::UIDPair >::iterator it = _globalPath.begin();
-			 it != _globalPath.end(); it++ ){
-			cerr << "(" << it->first.first << ", " << it->first.second << ")" << " -- "
-				 << "(" << it->second.first << ", " << it->second.second << ")" << endl;
-		}
-#endif // DEBUG
-    }
-	
-	//
-	//  GraphML::computeGroupBoundary --	load function
-	//
-	//  Input
-	//	none
-	//
-	//  Output
-	//	none
-	//
-	void GraphML::computeGroupBoundary( void )
-	{
-		// leaf nodes
-		for( map< unsigned int, Graph::BaseUndirectedGraph >::iterator it = _subGraphMap.begin();
-		     it != _subGraphMap.end(); it++ ){
-			
-			unsigned int parentID = it->first;
-			Graph::BaseUndirectedGraph *subGPtr = &it->second;
-			Graph::TreeDirectedGraph::vertex_descriptor parentVD = vertex( parentID, _graphmlTree );
-
-			double minX = INFINITY, minY = INFINITY, maxX = -INFINITY, maxY = -INFINITY;
-			BGL_FORALL_VERTICES( vd, *subGPtr, Graph::BaseUndirectedGraph ) {
-				
-				KeiRo::Base::Coord2 &coord = *(*subGPtr)[vd].coordPtr;
-				if( minX > coord.x() ) minX = coord.x();
-				if( minY > coord.y() ) minY = coord.y();
-				if( maxX < coord.x() ) maxX = coord.x();
-				if( maxY < coord.y() ) maxY = coord.y();
-			}
-			
-			_graphmlTree[ parentVD ].boundingBoxPtr = new KeiRo::Base::Rectangle2( minX, minY, maxX-minX, maxY-minY );
-			
-#ifdef DEBUG
-			cerr << "cid = " << parentID
- 				 << " level = " << _graphmlTree[ parentVD ].level
-				 << " w = " << *_graphmlTree[ parentVD ].widthPtr
-				 << " h = " << *_graphmlTree[ parentVD ].heightPtr
-				 << " lb = " << *_graphmlTree[ parentVD ].leftBottomCoordPtr;
-#endif // DEBUG
-		}
-		
-		// non-leaf nodes
-		// cerr << "_maxLevel = " << _maxLevel << endl;
-		for( int i = _maxLevel-2; i >= 0; i-- ){
-			
-			BGL_FORALL_VERTICES( vd, _graphmlTree, Graph::TreeDirectedGraph ) {
-
-//				cerr << "level = " << _graphmlTree[ vd ].level << endl;
-//				cerr << "i = " << i << endl;
-				if( i == _graphmlTree[ vd ].level ){
-					
-					double minX = INFINITY, minY = INFINITY, maxX = -INFINITY, maxY = -INFINITY;
-					Graph::TreeDirectedGraph::out_edge_iterator e, e_end;
-					for( tie( e, e_end ) = out_edges( vd, _graphmlTree ); e != e_end; ++e ) {
-						Graph::TreeDirectedGraph::edge_descriptor ed = *e;
-						Graph::TreeDirectedGraph::vertex_descriptor vdS = source( ed, _graphmlTree );
-						Graph::TreeDirectedGraph::vertex_descriptor vdT = target( ed, _graphmlTree );
-						
-						if( minX > _graphmlTree[ vdT ].boundingBoxPtr->leftBottom().x() )
-							minX = _graphmlTree[ vdT ].boundingBoxPtr->leftBottom().x();
-						if( minY > _graphmlTree[ vdT ].boundingBoxPtr->leftBottom().y() )
-							minY = _graphmlTree[ vdT ].boundingBoxPtr->leftBottom().y();
-						if( maxX < _graphmlTree[ vdT ].boundingBoxPtr->leftBottom().x() + _graphmlTree[ vdT ].boundingBoxPtr->width() )
-							maxX = _graphmlTree[ vdT ].boundingBoxPtr->leftBottom().x() + _graphmlTree[ vdT ].boundingBoxPtr->width();
-						if( maxY < _graphmlTree[ vdT ].boundingBoxPtr->leftBottom().y() + _graphmlTree[ vdT ].boundingBoxPtr->height() )
-							maxY = _graphmlTree[ vdT ].boundingBoxPtr->leftBottom().y() + _graphmlTree[ vdT ].boundingBoxPtr->height();
-					}
-					
-					_graphmlTree[ vd ].boundingBoxPtr = new KeiRo::Base::Rectangle2( minX, minY, maxX-minX, maxY-minY );
-
-#ifdef DEBUG
-					cerr << "cid = " << _graphmlTree[ vd ].id
-					     << " level = " << _graphmlTree[ vd ].level
-						 << " bbox = " << *_graphmlTree[ vd ].boundingBoxPtr
-						 << " obbox = " << _graphmlTree[ vd ].boundingBoxPtr->oldWidth() << endl;
-//						 << " w = " << *_graphmlTree[ vd ].widthPtr
-//					     << " h = " << *_graphmlTree[ vd ].heightPtr
-//					     << " lb = " << *_graphmlTree[ vd ].leftBottomCoordPtr;
-#endif // DEBUG
-				}
-			}
-		}
-		
-#ifdef DEBUG
-		BGL_FORALL_VERTICES( vd, _graphmlTree, Graph::TreeDirectedGraph ) {
-				cerr << " id = " << _graphmlTree[ vd ].id
-				     << " boundingBox = " << *_graphmlTree[ vd ].boundingBoxPtr;
-		}
-#endif // DEBUG
-	
-	}
-	
-	//
-	//  GraphML::normalize --	normalize the data
-	//
-	//  Input
-	//	none
-	//
-	//  Output
-	//	none
-	//
-	void GraphML::normalize( void )
-	{
-		// leaf nodes
-		double minX = INFINITY, minY = INFINITY, maxX = -INFINITY, maxY = -INFINITY;
-		for( map< unsigned int, Graph::BaseUndirectedGraph >::iterator it = _subGraphMap.begin();
-		     it != _subGraphMap.end(); it++ ){
-			
-			unsigned int parentID = it->first;
-			Graph::BaseUndirectedGraph *subGPtr = &it->second;
-			
-			// iterate edge sample points
-			BGL_FORALL_EDGES( ed, *subGPtr, Graph::BaseUndirectedGraph ) {
-				KeiRo::Base::Edge2 &edge = (*subGPtr)[ed].edge;
-				for( unsigned int i = 0; i < edge.elements().size(); i++ ){
-					KeiRo::Base::Coord2 &coord = edge.elements()[i];
-
-					if( minX > coord.x() ) minX = coord.x();
-					if( minY > coord.y() ) minY = coord.y();
-					if( maxX < coord.x() ) maxX = coord.x();
-					if( maxY < coord.y() ) maxY = coord.y();
-				}
-			}
-			// iterate vertices
-			BGL_FORALL_VERTICES( vd, *subGPtr, Graph::BaseUndirectedGraph ) {
-				
-				KeiRo::Base::Coord2 &coord = *(*subGPtr)[vd].coordPtr;
-
-				if( minX > coord.x() ) minX = coord.x();
-				if( minY > coord.y() ) minY = coord.y();
-				if( maxX < coord.x() ) maxX = coord.x();
-				if( maxY < coord.y() ) maxY = coord.y();
-			}
-		}
-
-		// update the coordinates
-		for( map< unsigned int, Graph::BaseUndirectedGraph >::iterator it = _subGraphMap.begin();
-		     it != _subGraphMap.end(); it++ ){
-			
-			unsigned int parentID = it->first;
-			Graph::BaseUndirectedGraph *subGPtr = &it->second;
-			
-			// iterate edge sample points
-			BGL_FORALL_EDGES( ed, *subGPtr, Graph::BaseUndirectedGraph ) {
-				KeiRo::Base::Edge2 &edge = (*subGPtr)[ed].edge;
-				for( unsigned int i = 0; i < edge.elements().size(); i++ ){
-
-					KeiRo::Base::Coord2 &coord = edge.elements()[i];
-					coord.x() = ( coord.x() - minX ) / ( maxX - minX ) * KeiRo::Base::Common::getMainwidgetWidth() - 0.5 * KeiRo::Base::Common::getMainwidgetWidth();
-					coord.y() = ( coord.y() - minY ) / ( maxY - minY ) * KeiRo::Base::Common::getMainwidgetHeight() - 0.5 * KeiRo::Base::Common::getMainwidgetHeight();
-					coord.updateOldElement();
-				}
-			}
-			// iterate vertices
-			BGL_FORALL_VERTICES( vd, *subGPtr, Graph::BaseUndirectedGraph ) {
-				
-				KeiRo::Base::Coord2 &coord = *(*subGPtr)[vd].coordPtr;
-				coord.x() = ( coord.x() - minX ) / ( maxX - minX ) * KeiRo::Base::Common::getMainwidgetWidth() - 0.5 * KeiRo::Base::Common::getMainwidgetWidth();
-				coord.y() = ( coord.y() - minY ) / ( maxY - minY ) * KeiRo::Base::Common::getMainwidgetHeight() - 0.5 * KeiRo::Base::Common::getMainwidgetHeight();
-				coord.updateOldElement();
-			}
-		}
-	}
-	
-    //
-    //  GraphML::load --	load function
-    //
-    //  Input
-    //	string: file name
-    //
-    //  Output
-    //	none
-    //
-    void GraphML::load( const string filename )
-    {
-		// initialization
-	    _maxLevel = 0;
-
-    	QString fileName = QString::fromStdString( filename );
-    			
-        // document object
-        QDomDocument doc;
-    	// Open your GraphML-file
-    	QFile file( fileName );
-
-    	// If it is not opened, or have failed to transmit the contents in QDocDocument
-    	if ( !file.open( QIODevice::ReadOnly ) || !doc.setContent( &file ) ) {
-    		// the refund list, but empty
-    		cerr << "something is wrong here... at " << __LINE__ << " in " << __FILE__ << endl;
-    		cerr << "fileName = " << fileName.toStdString() << endl;
-    		return;
-    	}
-    	
-    	// read the xml file
-    	// get root names and attributes
-    	QDomNodeList rootNodeList = doc.documentElement().childNodes();
-    	QDomElement graphElement;
-    	for( unsigned int i = 0; i < rootNodeList.size(); i++ ) {
-    		if( rootNodeList.item( i ).toElement().tagName() == QString( "graph" ) ){
-    			cerr << "rootElem.tagName() = " << rootNodeList.item( i ).toElement().tagName().toStdString() << endl;
-    			graphElement = rootNodeList.item( i ).toElement();
-    		}
-    	}
-		
-		// add root node for the _graphmlTree
-	    Graph::TreeDirectedGraph::vertex_descriptor vdNew = add_vertex( _graphmlTree );
-	    _graphmlTree[ vdNew ].id = 0;
-	    _graphmlTree[ vdNew ].namePtr = new string( "root" );
-	    _graphmlTree[ vdNew ].level = 0;
-	    _graphmlTree[ vdNew ].initID = 0;
-	    _graphmlTree[ vdNew ].parentID = 0;
-	    _graphmlTree[ vdNew ].isSelected = false;
-	    _graphmlTree[ vdNew ].coordPtr = new KeiRo::Base::Coord2( 5, 0 );
-		
-    	// load nodes
-    	if( graphElement.firstChild().toElement().tagName() == QString( "node" ) ){
-    		QDomNodeList nodeList = graphElement.childNodes();
-    		for( unsigned int i = 0; i < nodeList.size(); i++ ){
-    			QDomElement nodeElement = nodeList.item( i ).toElement();
-    			if( nodeElement.tagName() == QString( "node" ) )
-	                loadNode( nodeElement );
-    		}
-    	}
-    	// load groups
-    	else if( graphElement.firstChild().toElement().tagName() == QString( "group" ) ){
-    		QDomNodeList groupList = graphElement.childNodes();
-    		// cerr << "groupList = " << groupList.size() << endl;
-    		for( unsigned int i = 0; i < groupList.size(); i++ ){
-    			QDomElement groupElement = groupList.item( i ).toElement();
-    			if( groupElement.tagName() == QString( "group" ) )
-    				loadGroup( groupElement, 0 );
-    		}
-    	}
-    	else{
-    		cerr << "Unrecognized tagName " << graphElement.firstChild().toElement().tagName().toStdString() << " at " << __LINE__ << " in " << __FILE__ << endl;
-    	}
-	
-    	// load edges
-	    loadEdge( graphElement );
-
-		// nomalization
-		normalize();
-		
-		// compute group boundary
-	    computeGroupBoundary();
-#ifdef DEBUG
-	    cerr << "*****************************" << endl;
-		cerr << "_maxLevel = " << _maxLevel << endl;
-	    Graph::printGraph( _graphmlTree );
-	    cerr << "*****************************" << endl;
-
-		for( map< unsigned int, Graph::BaseUndirectedGraph >::iterator it = _subGraphMap.begin();
-			 it != _subGraphMap.end(); it++ ){
-			cerr << "gid = " << it->first << endl;
-			Graph::printGraph( it->second );
-			cerr << "*****************************" << endl;
-		}
-#endif // DEBUG
-    }
-	
-} // namespace FilIO
Index: Graph/src/SchematicGraph.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//==============================================================================\r\n// BaseGraph.cpp\r\n//      : program file for graph function\r\n//\r\n//==============================================================================\r\n\r\n#include \"SchematicGraph.h\"\r\n\r\nnamespace Graph {\r\n//------------------------------------------------------------------------------\r\n//\tCustomized Vertex Functions\r\n//------------------------------------------------------------------------------\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tCustomized Edge Functions\r\n//------------------------------------------------------------------------------\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tCustomized Layout Functions\r\n//------------------------------------------------------------------------------\r\n\r\n//------------------------------------------------------------------------------\r\n//\tCustomized SchematicGraph Functions\r\n//------------------------------------------------------------------------------\r\n//\r\n//  SchematicGraph::resetVisitedTimes -- reset edge visitedTimes values.\r\n//\r\n//  Inputs\r\n//  g   : object of Graph\r\n//\r\n//  Outputs\r\n//  none\r\n//\r\n\tvoid resetVisitedTimes( SchematicGraph &graph ) {\r\n\t\tBGL_FORALL_EDGES( ed, graph, SchematicGraph )\r\n\t\t{\r\n\t\t\t\r\n\t\t\tgraph[ ed ].visitedTimes = -1;\r\n\t\t}\r\n\t}\r\n\r\n//\r\n//  SchematicGraph::printGraph -- print the graph.\r\n//\r\n//  Inputs\r\n//  g   : object of Graph\r\n//\r\n//  Outputs\r\n//  none\r\n//\r\n\tvoid printGraph( const SchematicGraph &graph ) {\r\n\t\tcerr << \"Printing SchematicGraph...\" << endl;\r\n\t\tcerr << \"num_vertices = \" << num_vertices( graph ) << endl;\r\n\t\tcerr << \"num_edges = \" << num_edges( graph ) << endl;\r\n\r\n//#ifdef  DEBUG\r\n\t\t// print vertex information\r\n\t\tBGL_FORALL_VERTICES( vd, graph, SchematicGraph )\r\n\t\t{\r\n\t\t\t\r\n\t\t\tSchematicGraph::degree_size_type degrees = out_degree( vd, graph );\r\n\t\t\tcerr << \"id = \" << graph[ vd ].id << endl;\r\n\t\t\t//cerr << \"initID = \" << graph[ vd ].initID << endl;\r\n\t\t\t//cerr << \"lineID.size() = \" << graph[ vd ].lineID.size() << endl;\r\n\t\t\t//cerr << \"isFixed = \" << graph[ vd ].isFixed << endl;\r\n\t\t\t\r\n\t\t\t//cerr << \"coord = \" << *graph[ vd ].coordPtr;\r\n\t\t\t//cerr << \"geo = \" << *graph[ vd ].geoPtr;\r\n\t\t\t//cerr << \"smooth = \" << *graph[ vd ].smoothPtr;\r\n\t\t\t//v1cerr << \"centroid = \" << *graph[ vd ].centroidPtr;\r\n\t\t}\r\n//#endif  // DEBUG\r\n\r\n//#ifdef  DEBUG\r\n\t\t// print edge information\r\n\t\tBGL_FORALL_EDGES( ed, graph, SchematicGraph )\r\n\t\t{\r\n\t\t\t\r\n\t\t\tSchematicGraph::vertex_descriptor vdS = source( ed, graph );\r\n\t\t\tSchematicGraph::vertex_descriptor vdT = target( ed, graph );\r\n\t\t\t\r\n\t\t\tcerr << \"eid = \" << graph[ ed ].id << \" ( \" << graph[ vdS ].id << \" == \" << graph[ vdT ].id << \" ) \"\r\n\t\t\t     << endl;\r\n\t\t\t//cerr << \"w = \" << graph[ ed ].weight << endl;\r\n\t\t\t//cerr << \"angle = \" << graph[ ed ].angle << endl;\r\n\t\t\t//cerr << \"geoangle = \" << graph[ ed ].geoAngle << endl;\r\n\t\t\t//cerr << \"smoangle = \" << graph[ ed ].smoothAngle << endl;\r\n\t\t\t//cerr << \"targetangle = \" << graph[ ed ].targetAngle << endl;\r\n\t\t}\r\n//#endif  // DEBUG\r\n\t}\r\n\r\n//\r\n//  SchematicGraph::clearGraph -- clear the graph.\r\n//\r\n//  Inputs\r\n//  g   : object of Grpah\r\n//\r\n//  Outputs\r\n//  none\r\n//\r\n\tvoid clearGraph( SchematicGraph &graph ) {\r\n\t\t// clear edges\r\n\t\tSchematicGraph::edge_iterator ei, ei_end, e_next;\r\n\t\ttie( ei, ei_end ) = edges( graph );\r\n\t\tfor( e_next = ei; ei != ei_end; ei = e_next ) {\r\n\t\t\te_next++;\r\n\t\t\tremove_edge( *ei, graph );\r\n\t\t}\r\n\r\n#ifdef  SKIP\r\n\t\tBGL_FORALL_EDGES( edge, graph, BaseGraph )\r\n\t\t{\r\n\t\t\tremove_edge( edge, graph );\r\n\t\t}\r\n#endif  // SKIP\r\n\t\t\r\n\t\t// clear vertices\r\n\t\tpair <SchematicGraph::vertex_iterator, SchematicGraph::vertex_iterator> vp;\r\n\t\tfor( vp = vertices( graph ); vp.first != vp.second; ) {\r\n\t\t\tSchematicGraph::vertex_descriptor vd = ( *vp.first );\r\n\t\t\t++vp.first;\r\n\t\t\tclear_vertex( vd, graph );\r\n\t\t\tremove_vertex( vd, graph );\r\n\t\t}\r\n\t}\r\n\t\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Graph/src/SchematicGraph.cpp b/Graph/src/SchematicGraph.cpp
--- a/Graph/src/SchematicGraph.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Graph/src/SchematicGraph.cpp	(date 1729410604280)
@@ -1,130 +1,0 @@
-//==============================================================================
-// BaseGraph.cpp
-//      : program file for graph function
-//
-//==============================================================================
-
-#include "SchematicGraph.h"
-
-namespace Graph {
-//------------------------------------------------------------------------------
-//	Customized Vertex Functions
-//------------------------------------------------------------------------------
-
-
-//------------------------------------------------------------------------------
-//	Customized Edge Functions
-//------------------------------------------------------------------------------
-
-
-//------------------------------------------------------------------------------
-//	Customized Layout Functions
-//------------------------------------------------------------------------------
-
-//------------------------------------------------------------------------------
-//	Customized SchematicGraph Functions
-//------------------------------------------------------------------------------
-//
-//  SchematicGraph::resetVisitedTimes -- reset edge visitedTimes values.
-//
-//  Inputs
-//  g   : object of Graph
-//
-//  Outputs
-//  none
-//
-	void resetVisitedTimes( SchematicGraph &graph ) {
-		BGL_FORALL_EDGES( ed, graph, SchematicGraph )
-		{
-			
-			graph[ ed ].visitedTimes = -1;
-		}
-	}
-
-//
-//  SchematicGraph::printGraph -- print the graph.
-//
-//  Inputs
-//  g   : object of Graph
-//
-//  Outputs
-//  none
-//
-	void printGraph( const SchematicGraph &graph ) {
-		cerr << "Printing SchematicGraph..." << endl;
-		cerr << "num_vertices = " << num_vertices( graph ) << endl;
-		cerr << "num_edges = " << num_edges( graph ) << endl;
-
-//#ifdef  DEBUG
-		// print vertex information
-		BGL_FORALL_VERTICES( vd, graph, SchematicGraph )
-		{
-			
-			SchematicGraph::degree_size_type degrees = out_degree( vd, graph );
-			cerr << "id = " << graph[ vd ].id << endl;
-			//cerr << "initID = " << graph[ vd ].initID << endl;
-			//cerr << "lineID.size() = " << graph[ vd ].lineID.size() << endl;
-			//cerr << "isFixed = " << graph[ vd ].isFixed << endl;
-			
-			//cerr << "coord = " << *graph[ vd ].coordPtr;
-			//cerr << "geo = " << *graph[ vd ].geoPtr;
-			//cerr << "smooth = " << *graph[ vd ].smoothPtr;
-			//v1cerr << "centroid = " << *graph[ vd ].centroidPtr;
-		}
-//#endif  // DEBUG
-
-//#ifdef  DEBUG
-		// print edge information
-		BGL_FORALL_EDGES( ed, graph, SchematicGraph )
-		{
-			
-			SchematicGraph::vertex_descriptor vdS = source( ed, graph );
-			SchematicGraph::vertex_descriptor vdT = target( ed, graph );
-			
-			cerr << "eid = " << graph[ ed ].id << " ( " << graph[ vdS ].id << " == " << graph[ vdT ].id << " ) "
-			     << endl;
-			//cerr << "w = " << graph[ ed ].weight << endl;
-			//cerr << "angle = " << graph[ ed ].angle << endl;
-			//cerr << "geoangle = " << graph[ ed ].geoAngle << endl;
-			//cerr << "smoangle = " << graph[ ed ].smoothAngle << endl;
-			//cerr << "targetangle = " << graph[ ed ].targetAngle << endl;
-		}
-//#endif  // DEBUG
-	}
-
-//
-//  SchematicGraph::clearGraph -- clear the graph.
-//
-//  Inputs
-//  g   : object of Grpah
-//
-//  Outputs
-//  none
-//
-	void clearGraph( SchematicGraph &graph ) {
-		// clear edges
-		SchematicGraph::edge_iterator ei, ei_end, e_next;
-		tie( ei, ei_end ) = edges( graph );
-		for( e_next = ei; ei != ei_end; ei = e_next ) {
-			e_next++;
-			remove_edge( *ei, graph );
-		}
-
-#ifdef  SKIP
-		BGL_FORALL_EDGES( edge, graph, BaseGraph )
-		{
-			remove_edge( edge, graph );
-		}
-#endif  // SKIP
-		
-		// clear vertices
-		pair <SchematicGraph::vertex_iterator, SchematicGraph::vertex_iterator> vp;
-		for( vp = vertices( graph ); vp.first != vp.second; ) {
-			SchematicGraph::vertex_descriptor vd = ( *vp.first );
-			++vp.first;
-			clear_vertex( vd, graph );
-			remove_vertex( vd, graph );
-		}
-	}
-	
-}
\ No newline at end of file
Index: Graph/src/GridGraphProperty.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// GridGraphProperty.cpp\r\n//\t: program file for grid graph\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Dec 27 23:15:32 2017\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <iostream>\r\n#include <iomanip>\r\n#include <cctype>\r\n#include <cmath>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\n#include \"GridGraphProperty.h\"\r\n\r\nnamespace Graph {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPrivate Functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tProtected Functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  GridGraphProperty::_init -- initialize the graph.\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void GridGraphProperty::_init( double &width, double &height )\r\n    {\r\n        BaseGraphProperty::_init( width, height );\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPublic functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tConstructors & Destructors\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  GridGraphProperty::GridGraphProperty -- default constructor\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    GridGraphProperty::GridGraphProperty()\r\n    {\r\n        //BaseGraphProperty::init();\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tAssignment operators\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tI/O functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  operator << --\toutput\r\n    //\r\n    //  Inputs\r\n    //\tstream\t: reference to output stream\r\n    //\tobj\t: GridGraphProperty\r\n    //\r\n    //  Outputs\r\n    //\treference to output stream\r\n    //\r\n    ostream & operator << ( ostream & stream, const GridGraphProperty & obj )\r\n    {\r\n        // set the output formatting\r\n        stream << setiosflags( ios::showpoint );\r\n        stream << setprecision( 8 );\r\n        stream << endl;\r\n\r\n        return stream;\r\n    }\r\n\r\n\r\n    //\r\n    //  operator >> --\tinput\r\n    //\r\n    //  Inputs\r\n    //\tstream\t: reference to output stream\r\n    //\tobj\t: GridGraphProperty\r\n    //\r\n    //  Outputs\r\n    //\treference to input stream\r\n    //\r\n    istream & operator >> ( istream & stream, GridGraphProperty & obj )\r\n    {\r\n        return stream;\r\n    }\r\n\r\n} // namespace Graph
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Graph/src/GridGraphProperty.cpp b/Graph/src/GridGraphProperty.cpp
--- a/Graph/src/GridGraphProperty.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Graph/src/GridGraphProperty.cpp	(date 1729410604290)
@@ -1,112 +1,0 @@
-//******************************************************************************
-// GridGraphProperty.cpp
-//	: program file for grid graph
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Dec 27 23:15:32 2017
-//
-//******************************************************************************
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <iostream>
-#include <iomanip>
-#include <cctype>
-#include <cmath>
-#include <algorithm>
-
-using namespace std;
-
-#include "GridGraphProperty.h"
-
-namespace Graph {
-
-    //------------------------------------------------------------------------------
-    //	Private Functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Protected Functions
-    //------------------------------------------------------------------------------
-    //
-    //  GridGraphProperty::_init -- initialize the graph.
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    //
-    void GridGraphProperty::_init( double &width, double &height )
-    {
-        BaseGraphProperty::_init( width, height );
-    }
-
-    //------------------------------------------------------------------------------
-    //	Public functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Constructors & Destructors
-    //------------------------------------------------------------------------------
-    //
-    //  GridGraphProperty::GridGraphProperty -- default constructor
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    //
-    GridGraphProperty::GridGraphProperty()
-    {
-        //BaseGraphProperty::init();
-    }
-
-    //------------------------------------------------------------------------------
-    //	Assignment operators
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	I/O functions
-    //------------------------------------------------------------------------------
-    //
-    //  operator << --	output
-    //
-    //  Inputs
-    //	stream	: reference to output stream
-    //	obj	: GridGraphProperty
-    //
-    //  Outputs
-    //	reference to output stream
-    //
-    ostream & operator << ( ostream & stream, const GridGraphProperty & obj )
-    {
-        // set the output formatting
-        stream << setiosflags( ios::showpoint );
-        stream << setprecision( 8 );
-        stream << endl;
-
-        return stream;
-    }
-
-
-    //
-    //  operator >> --	input
-    //
-    //  Inputs
-    //	stream	: reference to output stream
-    //	obj	: GridGraphProperty
-    //
-    //  Outputs
-    //	reference to input stream
-    //
-    istream & operator >> ( istream & stream, GridGraphProperty & obj )
-    {
-        return stream;
-    }
-
-} // namespace Graph
\ No newline at end of file
Index: Graph/src/TreeDirectedGraph.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// TreeDirectedGraph.cpp\r\n//\t: program file for tree graph\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Dec 27 23:16:12 2018\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n#include \"TreeDirectedGraph.h\"\r\n\r\nnamespace Graph {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tCustomized Vertex Functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tCustomized Edge Functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tCustomized Layout Functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tSpecial functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  TreeDirectedGraph::printGraph -- print the graph.\r\n    //\r\n    //  Inputs\r\n    //  g   : object of Grpah\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void printGraph( const TreeDirectedGraph & graph )\r\n    {\r\n    \tcerr << \"TreeDirectedGraph:\" << endl;\r\n        cerr << \"num_vertices = \" << num_vertices( graph ) << endl;\r\n        cerr << \"num_edges = \" << num_edges( graph ) << endl;\r\n\r\n//\t#ifdef  DEBUG\r\n        // print vertex information\r\n\t    BGL_FORALL_VERTICES( vd, graph, TreeDirectedGraph ) {\r\n\t\t\r\n\t\t    TreeDirectedGraph ::degree_size_type      degrees         = out_degree( vd, graph );\r\n\t\t    cerr << \"vid = \" << graph[vd].id\r\n\t\t\t     << \" name = \" << *graph[vd].namePtr\r\n\t\t\t     << \" level = \" << graph[vd].level\r\n\t\t         << \" childSize = \" << graph[vd].childMap.size() << \" ?= \" << degrees\r\n\t\t\t     << \" parentID = \" << graph[vd].parentID\r\n\t\t\t     << \" coord = \" << *graph[vd].coordPtr;\r\n\t    }\r\n//\t#endif  // DEBUG\r\n\r\n//    #ifdef  DEBUG\r\n        // print edge information\r\n        BGL_FORALL_EDGES( ed, graph, TreeDirectedGraph ) {\r\n\r\n            TreeDirectedGraph::vertex_descriptor vdS = source( ed, graph );\r\n            TreeDirectedGraph::vertex_descriptor vdT = target( ed, graph );\r\n\r\n            cerr << \"eid = \" << graph[ ed ].id << \" ( \" << graph[ vdS ].id << \" == \" << graph[ vdT ].id << \" ) \" << endl;\r\n        }\r\n//    #endif  // DEBUG\r\n    }\r\n\r\n    //\r\n    //  TreeDirectedGraph::clearGraph -- clear the graph.\r\n    //\r\n    //  Inputs\r\n    //  g   : object of Grpah\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void clearGraph( TreeDirectedGraph & graph )\r\n    {\r\n        // clear edges\r\n        TreeDirectedGraph::edge_iterator ei, ei_end, e_next;\r\n        tie( ei, ei_end ) = edges( graph );\r\n        for ( e_next = ei; ei != ei_end; ei = e_next ) {\r\n            e_next++;\r\n            remove_edge( *ei, graph );\r\n        }\r\n\r\n    #ifdef  SKIP\r\n        BGL_FORALL_EDGES( edge, graph, BaseGraph )\r\n        {\r\n            remove_edge( edge, graph );\r\n        }\r\n    #endif  // SKIP\r\n\r\n        // clear vertices\r\n        pair< TreeDirectedGraph::vertex_iterator, TreeDirectedGraph::vertex_iterator > vp;\r\n        for ( vp = vertices( graph ); vp.first != vp.second;  ) {\r\n            TreeDirectedGraph::vertex_descriptor vd = (*vp.first);\r\n            ++vp.first;\r\n            clear_vertex( vd, graph );\r\n            remove_vertex( vd, graph );\r\n        }\r\n    }\r\n\r\n} // namespace Graph
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Graph/src/TreeDirectedGraph.cpp b/Graph/src/TreeDirectedGraph.cpp
--- a/Graph/src/TreeDirectedGraph.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Graph/src/TreeDirectedGraph.cpp	(date 1729410604300)
@@ -1,110 +1,0 @@
-//******************************************************************************
-// TreeDirectedGraph.cpp
-//	: program file for tree graph
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Dec 27 23:16:12 2018
-//
-//******************************************************************************
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-#include "TreeDirectedGraph.h"
-
-namespace Graph {
-
-    //------------------------------------------------------------------------------
-    //	Customized Vertex Functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Customized Edge Functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Customized Layout Functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Special functions
-    //------------------------------------------------------------------------------
-    //
-    //  TreeDirectedGraph::printGraph -- print the graph.
-    //
-    //  Inputs
-    //  g   : object of Grpah
-    //
-    //  Outputs
-    //  none
-    //
-    void printGraph( const TreeDirectedGraph & graph )
-    {
-    	cerr << "TreeDirectedGraph:" << endl;
-        cerr << "num_vertices = " << num_vertices( graph ) << endl;
-        cerr << "num_edges = " << num_edges( graph ) << endl;
-
-//	#ifdef  DEBUG
-        // print vertex information
-	    BGL_FORALL_VERTICES( vd, graph, TreeDirectedGraph ) {
-		
-		    TreeDirectedGraph ::degree_size_type      degrees         = out_degree( vd, graph );
-		    cerr << "vid = " << graph[vd].id
-			     << " name = " << *graph[vd].namePtr
-			     << " level = " << graph[vd].level
-		         << " childSize = " << graph[vd].childMap.size() << " ?= " << degrees
-			     << " parentID = " << graph[vd].parentID
-			     << " coord = " << *graph[vd].coordPtr;
-	    }
-//	#endif  // DEBUG
-
-//    #ifdef  DEBUG
-        // print edge information
-        BGL_FORALL_EDGES( ed, graph, TreeDirectedGraph ) {
-
-            TreeDirectedGraph::vertex_descriptor vdS = source( ed, graph );
-            TreeDirectedGraph::vertex_descriptor vdT = target( ed, graph );
-
-            cerr << "eid = " << graph[ ed ].id << " ( " << graph[ vdS ].id << " == " << graph[ vdT ].id << " ) " << endl;
-        }
-//    #endif  // DEBUG
-    }
-
-    //
-    //  TreeDirectedGraph::clearGraph -- clear the graph.
-    //
-    //  Inputs
-    //  g   : object of Grpah
-    //
-    //  Outputs
-    //  none
-    //
-    void clearGraph( TreeDirectedGraph & graph )
-    {
-        // clear edges
-        TreeDirectedGraph::edge_iterator ei, ei_end, e_next;
-        tie( ei, ei_end ) = edges( graph );
-        for ( e_next = ei; ei != ei_end; ei = e_next ) {
-            e_next++;
-            remove_edge( *ei, graph );
-        }
-
-    #ifdef  SKIP
-        BGL_FORALL_EDGES( edge, graph, BaseGraph )
-        {
-            remove_edge( edge, graph );
-        }
-    #endif  // SKIP
-
-        // clear vertices
-        pair< TreeDirectedGraph::vertex_iterator, TreeDirectedGraph::vertex_iterator > vp;
-        for ( vp = vertices( graph ); vp.first != vp.second;  ) {
-            TreeDirectedGraph::vertex_descriptor vd = (*vp.first);
-            ++vp.first;
-            clear_vertex( vd, graph );
-            remove_vertex( vd, graph );
-        }
-    }
-
-} // namespace Graph
\ No newline at end of file
Index: Graph/src/SchematicGraphProperty.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// BoundaryGraphProperty.cc\r\n//\t: program file for 2D coordinatse\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Dec 27 23:15:32 2017\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <iostream>\r\n#include <iomanip>\r\n#include <cctype>\r\n#include <cmath>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\n#include \"SchematicGraphProperty.h\"\r\n\r\nnamespace Graph {\r\n//------------------------------------------------------------------------------\r\n//\tMacro Definitions\r\n//------------------------------------------------------------------------------\r\n\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tProtected Functions\r\n//------------------------------------------------------------------------------\r\n//\r\n//  BoundaryGraphProperty::_init -- initialize the graph.\r\n//\r\n//  Inputs\r\n//  none\r\n//\r\n//  Outputs\r\n//  none\r\n//\r\n\tvoid SchematicGraphProperty::_init( double &width, double &height ) {\r\n\t\tBaseGraphProperty::_init( width, height );\r\n\t}\r\n\r\n//------------------------------------------------------------------------------\r\n//\tPublic functions\r\n//------------------------------------------------------------------------------\r\n\r\n//------------------------------------------------------------------------------\r\n//\tConstructors\r\n//------------------------------------------------------------------------------\r\n\r\n//\r\n//  BoundaryGraphProperty::BoundaryGraphProperty -- default constructor\r\n//\r\n//  Inputs\r\n//  none\r\n//\r\n//  Outputs\r\n//  none\r\n//\r\n\tSchematicGraphProperty::SchematicGraphProperty() {\r\n\t\t// BaseGraphProperty::_init( width, height );\r\n\t}\r\n\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tAssignment opereators\r\n//------------------------------------------------------------------------------\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tI/O functions\r\n//------------------------------------------------------------------------------\r\n\r\n//\r\n//  operator << --\toutput\r\n//\r\n//  Inputs\r\n//\tstream\t: reference to output stream\r\n//\tobj\t: BoundaryGraphProperty\r\n//\r\n//  Outputs\r\n//\treference to output stream\r\n//\r\n\tostream &operator<<( ostream &stream, const SchematicGraphProperty &obj ) {\r\n\t\t// set the output formatting\r\n\t\tstream << setiosflags( ios::showpoint );\r\n\t\tstream << setprecision( 8 );\r\n\t\tstream << endl;\r\n\t\t\r\n\t\treturn stream;\r\n\t}\r\n\r\n\r\n//\r\n//  operator >> --\tinput\r\n//\r\n//  Inputs\r\n//\tstream\t: reference to output stream\r\n//\tobj\t: BoundaryGraphProperty\r\n//\r\n//  Outputs\r\n//\treference to input stream\r\n//\r\n\tistream &operator>>( istream &stream, SchematicGraphProperty &obj ) {\r\n\t\treturn stream;\r\n\t}\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Graph/src/SchematicGraphProperty.cpp b/Graph/src/SchematicGraphProperty.cpp
--- a/Graph/src/SchematicGraphProperty.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Graph/src/SchematicGraphProperty.cpp	(date 1729410604310)
@@ -1,113 +1,0 @@
-//******************************************************************************
-// BoundaryGraphProperty.cc
-//	: program file for 2D coordinatse
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Dec 27 23:15:32 2017
-//
-//******************************************************************************
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <iostream>
-#include <iomanip>
-#include <cctype>
-#include <cmath>
-#include <algorithm>
-
-using namespace std;
-
-#include "SchematicGraphProperty.h"
-
-namespace Graph {
-//------------------------------------------------------------------------------
-//	Macro Definitions
-//------------------------------------------------------------------------------
-
-
-
-//------------------------------------------------------------------------------
-//	Protected Functions
-//------------------------------------------------------------------------------
-//
-//  BoundaryGraphProperty::_init -- initialize the graph.
-//
-//  Inputs
-//  none
-//
-//  Outputs
-//  none
-//
-	void SchematicGraphProperty::_init( double &width, double &height ) {
-		BaseGraphProperty::_init( width, height );
-	}
-
-//------------------------------------------------------------------------------
-//	Public functions
-//------------------------------------------------------------------------------
-
-//------------------------------------------------------------------------------
-//	Constructors
-//------------------------------------------------------------------------------
-
-//
-//  BoundaryGraphProperty::BoundaryGraphProperty -- default constructor
-//
-//  Inputs
-//  none
-//
-//  Outputs
-//  none
-//
-	SchematicGraphProperty::SchematicGraphProperty() {
-		// BaseGraphProperty::_init( width, height );
-	}
-
-
-
-//------------------------------------------------------------------------------
-//	Assignment opereators
-//------------------------------------------------------------------------------
-
-
-//------------------------------------------------------------------------------
-//	I/O functions
-//------------------------------------------------------------------------------
-
-//
-//  operator << --	output
-//
-//  Inputs
-//	stream	: reference to output stream
-//	obj	: BoundaryGraphProperty
-//
-//  Outputs
-//	reference to output stream
-//
-	ostream &operator<<( ostream &stream, const SchematicGraphProperty &obj ) {
-		// set the output formatting
-		stream << setiosflags( ios::showpoint );
-		stream << setprecision( 8 );
-		stream << endl;
-		
-		return stream;
-	}
-
-
-//
-//  operator >> --	input
-//
-//  Inputs
-//	stream	: reference to output stream
-//	obj	: BoundaryGraphProperty
-//
-//  Outputs
-//	reference to input stream
-//
-	istream &operator>>( istream &stream, SchematicGraphProperty &obj ) {
-		return stream;
-	}
-}
\ No newline at end of file
Index: Graph/src/TreeVertexProperty.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// TreeVertexProperty.h\r\n//\t: program file for tree vertex property\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Sun Feb 09 23:16:12 2020\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <iostream>\r\n#include <iomanip>\r\n#include <cctype>\r\n#include <cmath>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\n#include \"TreeVertexProperty.h\"\r\n\r\nnamespace Graph {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPrivate Functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tProtected Functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  TreeVertexProperty::_init -- initialize the graph.\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void TreeVertexProperty::_init( void )\r\n    {\r\n        BaseVertexProperty::_init();\r\n\r\n        // leafID              = -1;\r\n        meanCoord.x()       = 0.0;\r\n        meanCoord.y()       = 0.0;\r\n        // leafVec.clear();\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPublic functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tConstructors & Destructors\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  TreeVertexProperty::TreeVertexProperty -- default constructor\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    TreeVertexProperty::TreeVertexProperty()\r\n    {\r\n        _init();\r\n    }\r\n\r\n\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tAssignment operators\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tI/O functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  operator << --\toutput\r\n    //\r\n    //  Inputs\r\n    //\tstream\t: reference to output stream\r\n    //\tobj\t: TreeVertexProperty\r\n    //\r\n    //  Outputs\r\n    //\treference to output stream\r\n    //\r\n    ostream & operator << ( ostream & stream, const TreeVertexProperty & obj )\r\n    {\r\n        // set the output formatting\r\n        stream << setiosflags( ios::showpoint );\r\n        stream << setprecision( 8 );\r\n        stream << endl;\r\n\r\n        return stream;\r\n    }\r\n\r\n\r\n    //\r\n    //  operator >> --\tinput\r\n    //\r\n    //  Inputs\r\n    //\tstream\t: reference to output stream\r\n    //\tobj\t: TreeVertexProperty\r\n    //\r\n    //  Outputs\r\n    //\treference to input stream\r\n    //\r\n    istream & operator >> ( istream & stream, TreeVertexProperty & obj )\r\n    {\r\n        return stream;\r\n    }\r\n\r\n} // namespace Graph
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Graph/src/TreeVertexProperty.cpp b/Graph/src/TreeVertexProperty.cpp
--- a/Graph/src/TreeVertexProperty.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Graph/src/TreeVertexProperty.cpp	(date 1729410604320)
@@ -1,119 +1,0 @@
-//******************************************************************************
-// TreeVertexProperty.h
-//	: program file for tree vertex property
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Sun Feb 09 23:16:12 2020
-//
-//******************************************************************************
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <iostream>
-#include <iomanip>
-#include <cctype>
-#include <cmath>
-#include <algorithm>
-
-using namespace std;
-
-#include "TreeVertexProperty.h"
-
-namespace Graph {
-
-    //------------------------------------------------------------------------------
-    //	Private Functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Protected Functions
-    //------------------------------------------------------------------------------
-    //
-    //  TreeVertexProperty::_init -- initialize the graph.
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    //
-    void TreeVertexProperty::_init( void )
-    {
-        BaseVertexProperty::_init();
-
-        // leafID              = -1;
-        meanCoord.x()       = 0.0;
-        meanCoord.y()       = 0.0;
-        // leafVec.clear();
-    }
-
-    //------------------------------------------------------------------------------
-    //	Public functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Constructors & Destructors
-    //------------------------------------------------------------------------------
-    //
-    //  TreeVertexProperty::TreeVertexProperty -- default constructor
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    //
-    TreeVertexProperty::TreeVertexProperty()
-    {
-        _init();
-    }
-
-
-
-    //------------------------------------------------------------------------------
-    //	Assignment operators
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	I/O functions
-    //------------------------------------------------------------------------------
-    //
-    //  operator << --	output
-    //
-    //  Inputs
-    //	stream	: reference to output stream
-    //	obj	: TreeVertexProperty
-    //
-    //  Outputs
-    //	reference to output stream
-    //
-    ostream & operator << ( ostream & stream, const TreeVertexProperty & obj )
-    {
-        // set the output formatting
-        stream << setiosflags( ios::showpoint );
-        stream << setprecision( 8 );
-        stream << endl;
-
-        return stream;
-    }
-
-
-    //
-    //  operator >> --	input
-    //
-    //  Inputs
-    //	stream	: reference to output stream
-    //	obj	: TreeVertexProperty
-    //
-    //  Outputs
-    //	reference to input stream
-    //
-    istream & operator >> ( istream & stream, TreeVertexProperty & obj )
-    {
-        return stream;
-    }
-
-} // namespace Graph
\ No newline at end of file
Index: Graph/src/GridVertexProperty.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// GridVertexProperty.h\r\n//\t: header file for tree vertex property\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Sun Feb 09 23:16:12 2020\r\n//\r\n//******************************************************************************\r\n\r\n#ifndef\t_Graph_GridVertexProperty_H\r\n#define _Graph_GridVertexProperty_H\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n#include <iostream>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\n#include \"Coord2.h\"\r\n#include \"Common.h\"\r\n#include \"BaseVertexProperty.h\"\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Macros\r\n//------------------------------------------------------------------------------\r\n#define VERTEX_CAPACITY (1)\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Macros\r\n//------------------------------------------------------------------------------\r\n\r\nnamespace Graph {\r\n\r\n    enum GRID_VERTEX_TYPE{ GRID_VERTEX_DEFAULT, GRID_VERTEX_CORNER,\r\n                           GRID_VERTEX_BOUNDARY_ONX, GRID_VERTEX_BOUNDARY_ONY, GRID_VERTEX_FREE };\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tDefining Classes\r\n    //------------------------------------------------------------------------------\r\n    class GridVertexProperty: public BaseVertexProperty {\r\n\r\n    private:\r\n\r\n    protected:\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tSpecial functions\r\n        //------------------------------------------------------------------------------\r\n          void\t\t    _init( void );\r\n\r\n    public:\r\n\r\n        // gird type\r\n        GRID_VERTEX_TYPE                        gridVType;\r\n        // initial position\r\n        KeiRo::Base::Coord2 *                   geoPtr;\r\n        // position after deformation\r\n        KeiRo::Base::Coord2 *                   smoothPtr;\r\n        // flag on if the pixel is occupied\r\n        bool                            isOccupied;\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tConstructors & Destructors\r\n        //------------------------------------------------------------------------------\r\n        // default constructor\r\n        GridVertexProperty( void );\r\n        // copy constructor\r\n        GridVertexProperty( const GridVertexProperty & c ) {}\r\n        // destructor\r\n        virtual ~GridVertexProperty( void ) {}\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tAssignment operators\r\n        //------------------------------------------------------------------------------\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tReference to elements\r\n        //------------------------------------------------------------------------------\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tSpecial functions\r\n        //------------------------------------------------------------------------------\r\n\r\n        void        init( void )\t\t{ _init(); }\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tFriend functions\r\n        //------------------------------------------------------------------------------\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tI/O functions\r\n        //------------------------------------------------------------------------------\r\n        // output\r\n        friend ostream &\toperator << ( ostream & s, const GridVertexProperty & v );\r\n        // input\r\n        friend istream &\toperator >> ( istream & s, GridVertexProperty & v );\r\n        // class name\r\n        virtual const char * className( void ) const { return \"GridVertexProperty\"; }\r\n\r\n    };\r\n\r\n} // namespace Graph\r\n\r\n#endif // _Graph_GridVertexProperty_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Graph/src/GridVertexProperty.h b/Graph/src/GridVertexProperty.h
--- a/Graph/src/GridVertexProperty.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Graph/src/GridVertexProperty.h	(date 1729410604330)
@@ -1,107 +1,0 @@
-//******************************************************************************
-// GridVertexProperty.h
-//	: header file for tree vertex property
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Sun Feb 09 23:16:12 2020
-//
-//******************************************************************************
-
-#ifndef	_Graph_GridVertexProperty_H
-#define _Graph_GridVertexProperty_H
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-#include <iostream>
-#include <vector>
-
-using namespace std;
-
-#include "Coord2.h"
-#include "Common.h"
-#include "BaseVertexProperty.h"
-
-//------------------------------------------------------------------------------
-//	Defining Macros
-//------------------------------------------------------------------------------
-#define VERTEX_CAPACITY (1)
-
-//------------------------------------------------------------------------------
-//	Defining Macros
-//------------------------------------------------------------------------------
-
-namespace Graph {
-
-    enum GRID_VERTEX_TYPE{ GRID_VERTEX_DEFAULT, GRID_VERTEX_CORNER,
-                           GRID_VERTEX_BOUNDARY_ONX, GRID_VERTEX_BOUNDARY_ONY, GRID_VERTEX_FREE };
-
-    //------------------------------------------------------------------------------
-    //	Defining Classes
-    //------------------------------------------------------------------------------
-    class GridVertexProperty: public BaseVertexProperty {
-
-    private:
-
-    protected:
-
-        //------------------------------------------------------------------------------
-        //	Special functions
-        //------------------------------------------------------------------------------
-          void		    _init( void );
-
-    public:
-
-        // gird type
-        GRID_VERTEX_TYPE                        gridVType;
-        // initial position
-        KeiRo::Base::Coord2 *                   geoPtr;
-        // position after deformation
-        KeiRo::Base::Coord2 *                   smoothPtr;
-        // flag on if the pixel is occupied
-        bool                            isOccupied;
-
-        //------------------------------------------------------------------------------
-        //	Constructors & Destructors
-        //------------------------------------------------------------------------------
-        // default constructor
-        GridVertexProperty( void );
-        // copy constructor
-        GridVertexProperty( const GridVertexProperty & c ) {}
-        // destructor
-        virtual ~GridVertexProperty( void ) {}
-
-        //------------------------------------------------------------------------------
-        //	Assignment operators
-        //------------------------------------------------------------------------------
-
-        //------------------------------------------------------------------------------
-        //	Reference to elements
-        //------------------------------------------------------------------------------
-
-        //------------------------------------------------------------------------------
-        //	Special functions
-        //------------------------------------------------------------------------------
-
-        void        init( void )		{ _init(); }
-
-        //------------------------------------------------------------------------------
-        //	Friend functions
-        //------------------------------------------------------------------------------
-
-        //------------------------------------------------------------------------------
-        //	I/O functions
-        //------------------------------------------------------------------------------
-        // output
-        friend ostream &	operator << ( ostream & s, const GridVertexProperty & v );
-        // input
-        friend istream &	operator >> ( istream & s, GridVertexProperty & v );
-        // class name
-        virtual const char * className( void ) const { return "GridVertexProperty"; }
-
-    };
-
-} // namespace Graph
-
-#endif // _Graph_GridVertexProperty_H
Index: Graph/src/BaseEdgeProperty.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// BaseEdgeProperty.cpp\r\n//\t: program file for 2D coordinates\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Dec 27 23:15:32 2017\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <iostream>\r\n#include <iomanip>\r\n#include <cctype>\r\n#include <cmath>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\n#include \"BaseEdgeProperty.h\"\r\n\r\nnamespace Graph {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPrivate Functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tProtected Functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  BaseEdgeProperty::_init -- initialize the graph.\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void BaseEdgeProperty::_init( void )\r\n    {\r\n        id = 0;\r\n        angle = 0;\r\n        weight = 1.0;\r\n        visit = 0;\r\n        visitedTimes = 0;\r\n        isFore = false;\r\n        isBack = false;\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPublic functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tConstructors & Destructors\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  BaseEdgeProperty::BaseEdgeProperty -- default constructor\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    BaseEdgeProperty::BaseEdgeProperty()\r\n    {\r\n        _init();\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tAssignment operators\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tI/O functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  operator << --\toutput\r\n    //\r\n    //  Inputs\r\n    //\tstream\t: reference to output stream\r\n    //\tobj\t: BaseEdgeProperty\r\n    //\r\n    //  Outputs\r\n    //\treference to output stream\r\n    //\r\n    ostream & operator << ( ostream & stream, const BaseEdgeProperty & obj )\r\n    {\r\n        // set the output formatting\r\n        stream << setiosflags( ios::showpoint );\r\n        stream << setprecision( 8 );\r\n        stream << endl;\r\n\r\n        return stream;\r\n    }\r\n\r\n\r\n    //\r\n    //  operator >> --\tinput\r\n    //\r\n    //  Inputs\r\n    //\tstream\t: reference to output stream\r\n    //\tobj\t: BaseEdgeProperty\r\n    //\r\n    //  Outputs\r\n    //\treference to input stream\r\n    //\r\n    istream & operator >> ( istream & stream, BaseEdgeProperty & obj )\r\n    {\r\n        return stream;\r\n    }\r\n\r\n} // namespace Graph
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Graph/src/BaseEdgeProperty.cpp b/Graph/src/BaseEdgeProperty.cpp
--- a/Graph/src/BaseEdgeProperty.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Graph/src/BaseEdgeProperty.cpp	(date 1729410604340)
@@ -1,118 +1,0 @@
-//******************************************************************************
-// BaseEdgeProperty.cpp
-//	: program file for 2D coordinates
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Dec 27 23:15:32 2017
-//
-//******************************************************************************
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <iostream>
-#include <iomanip>
-#include <cctype>
-#include <cmath>
-#include <algorithm>
-
-using namespace std;
-
-#include "BaseEdgeProperty.h"
-
-namespace Graph {
-
-    //------------------------------------------------------------------------------
-    //	Private Functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Protected Functions
-    //------------------------------------------------------------------------------
-    //
-    //  BaseEdgeProperty::_init -- initialize the graph.
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    //
-    void BaseEdgeProperty::_init( void )
-    {
-        id = 0;
-        angle = 0;
-        weight = 1.0;
-        visit = 0;
-        visitedTimes = 0;
-        isFore = false;
-        isBack = false;
-    }
-
-    //------------------------------------------------------------------------------
-    //	Public functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Constructors & Destructors
-    //------------------------------------------------------------------------------
-    //
-    //  BaseEdgeProperty::BaseEdgeProperty -- default constructor
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    //
-    BaseEdgeProperty::BaseEdgeProperty()
-    {
-        _init();
-    }
-
-    //------------------------------------------------------------------------------
-    //	Assignment operators
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	I/O functions
-    //------------------------------------------------------------------------------
-    //
-    //  operator << --	output
-    //
-    //  Inputs
-    //	stream	: reference to output stream
-    //	obj	: BaseEdgeProperty
-    //
-    //  Outputs
-    //	reference to output stream
-    //
-    ostream & operator << ( ostream & stream, const BaseEdgeProperty & obj )
-    {
-        // set the output formatting
-        stream << setiosflags( ios::showpoint );
-        stream << setprecision( 8 );
-        stream << endl;
-
-        return stream;
-    }
-
-
-    //
-    //  operator >> --	input
-    //
-    //  Inputs
-    //	stream	: reference to output stream
-    //	obj	: BaseEdgeProperty
-    //
-    //  Outputs
-    //	reference to input stream
-    //
-    istream & operator >> ( istream & stream, BaseEdgeProperty & obj )
-    {
-        return stream;
-    }
-
-} // namespace Graph
\ No newline at end of file
Index: Graph/src/SchematicGraph.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#ifndef _BoundaryGraph_H\r\n#define _BoundaryGraph_H\r\n\r\n\r\n#include <string>\r\n#include <iostream>\r\n#include <fstream>\r\n#include <vector>\r\n#include <map>\r\n#include <algorithm>\r\n#include <ctime>\r\n#include <cstdlib>\r\n\r\nusing namespace std;\r\n\r\n#include <boost/config.hpp>\r\n#include <boost/graph/graph_traits.hpp>\r\n#include <boost/graph/adjacency_list.hpp>\r\n#include <boost/graph/iteration_macros.hpp>\r\n\r\n// force-directed layout\r\n#include <boost/graph/fruchterman_reingold.hpp>\r\n//#include <boost/graph/kamada_kawai_spring_layout.hpp>\r\n#include <boost/graph/random_layout.hpp>\r\n#include <boost/graph/topology.hpp>\r\n#include <boost/lexical_cast.hpp>\r\n#include <boost/graph/connected_components.hpp>\r\n\r\nusing namespace boost;\r\n\r\n#include \"Coord2.h\"\r\n//#include \"Grid2.h\"\r\n#include \"SchematicGraphProperty.h\"\r\n#include \"SchematicVertexProperty.h\"\r\n#include \"SchematicEdgeProperty.h\"\r\n\r\nnamespace Graph {\r\n\t\r\n\ttypedef adjacency_list< listS, listS, undirectedS,\r\n\t\t\tSchematicVertexProperty, SchematicEdgeProperty,\r\n\t\t\tSchematicGraphProperty > SchematicGraph;\r\n\t\r\n\ttypedef pair< SchematicGraph::vertex_descriptor,\r\n\t\t\tSchematicGraph::edge_descriptor > VEPair;\r\n//\ttypedef map< Grid2, VEPair > VEMap;\r\n\r\n//------------------------------------------------------------------------------\r\n//\tCustomized BaseGraph Functions\r\n//------------------------------------------------------------------------------\r\n\t\r\n\tvoid printGraph( const SchematicGraph &g );\r\n\t\r\n\tvoid clearGraph( SchematicGraph &g );\r\n\t\r\n\tvoid resetVisitedTimes( SchematicGraph &g );\r\n}\r\n#endif  // _BoundaryGraph_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Graph/src/SchematicGraph.h b/Graph/src/SchematicGraph.h
--- a/Graph/src/SchematicGraph.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Graph/src/SchematicGraph.h	(date 1729410604350)
@@ -1,57 +1,0 @@
-#ifndef _BoundaryGraph_H
-#define _BoundaryGraph_H
-
-
-#include <string>
-#include <iostream>
-#include <fstream>
-#include <vector>
-#include <map>
-#include <algorithm>
-#include <ctime>
-#include <cstdlib>
-
-using namespace std;
-
-#include <boost/config.hpp>
-#include <boost/graph/graph_traits.hpp>
-#include <boost/graph/adjacency_list.hpp>
-#include <boost/graph/iteration_macros.hpp>
-
-// force-directed layout
-#include <boost/graph/fruchterman_reingold.hpp>
-//#include <boost/graph/kamada_kawai_spring_layout.hpp>
-#include <boost/graph/random_layout.hpp>
-#include <boost/graph/topology.hpp>
-#include <boost/lexical_cast.hpp>
-#include <boost/graph/connected_components.hpp>
-
-using namespace boost;
-
-#include "Coord2.h"
-//#include "Grid2.h"
-#include "SchematicGraphProperty.h"
-#include "SchematicVertexProperty.h"
-#include "SchematicEdgeProperty.h"
-
-namespace Graph {
-	
-	typedef adjacency_list< listS, listS, undirectedS,
-			SchematicVertexProperty, SchematicEdgeProperty,
-			SchematicGraphProperty > SchematicGraph;
-	
-	typedef pair< SchematicGraph::vertex_descriptor,
-			SchematicGraph::edge_descriptor > VEPair;
-//	typedef map< Grid2, VEPair > VEMap;
-
-//------------------------------------------------------------------------------
-//	Customized BaseGraph Functions
-//------------------------------------------------------------------------------
-	
-	void printGraph( const SchematicGraph &g );
-	
-	void clearGraph( SchematicGraph &g );
-	
-	void resetVisitedTimes( SchematicGraph &g );
-}
-#endif  // _BoundaryGraph_H
Index: Graph/src/TreeGraph.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// TreeGraph.cpp\r\n//\t: program file for tree graph\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Dec 27 23:16:12 2018\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n#include \"TreeGraph.h\"\r\n\r\nnamespace Graph {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tCustomized Vertex Functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tCustomized Edge Functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tCustomized Layout Functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tSpecial functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  TreeGraph::printGraph -- print the graph.\r\n    //\r\n    //  Inputs\r\n    //  g   : object of Grpah\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void printGraph( const TreeGraph & graph )\r\n    {\r\n    \tcerr << \"TreeGraph:\" << endl;\r\n        cerr << \"num_vertices = \" << num_vertices( graph ) << endl;\r\n        cerr << \"num_edges = \" << num_edges( graph ) << endl;\r\n\r\n    #ifdef  DEBUG\r\n        // print vertex information\r\n        BGL_FORALL_VERTICES( vd, graph, TreeGraph ) {\r\n\r\n            TreeGraph::degree_size_type      degrees         = out_degree( vd, graph );\r\n            cerr << \"vid = \" << graph[vd].id << \" level = \" << graph[vd].level\r\n                 << \" childSize = \" << graph[vd].childMap.size() << \" ?= \" << degrees\r\n                 << \" parentID = \" << graph[vd].parentID << endl;\r\n        }\r\n    #endif  // DEBUG\r\n\r\n    #ifdef  DEBUG\r\n        // print edge information\r\n        BGL_FORALL_EDGES( ed, graph, TreeGraph ) {\r\n\r\n            TreeGraph::vertex_descriptor vdS = source( ed, graph );\r\n            TreeGraph::vertex_descriptor vdT = target( ed, graph );\r\n\r\n            cerr << \"eid = \" << graph[ ed ].id << \" ( \" << graph[ vdS ].id << \" == \" << graph[ vdT ].id << \" ) \" << endl;\r\n        }\r\n    #endif  // DEBUG\r\n    }\r\n\r\n    //\r\n    //  TreeGraph::clearGraph -- clear the graph.\r\n    //\r\n    //  Inputs\r\n    //  g   : object of Grpah\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void clearGraph( TreeGraph & graph )\r\n    {\r\n        // clear edges\r\n        TreeGraph::edge_iterator ei, ei_end, e_next;\r\n        tie( ei, ei_end ) = edges( graph );\r\n        for ( e_next = ei; ei != ei_end; ei = e_next ) {\r\n            e_next++;\r\n            remove_edge( *ei, graph );\r\n        }\r\n\r\n    #ifdef  SKIP\r\n        BGL_FORALL_EDGES( edge, graph, BaseGraph )\r\n        {\r\n            remove_edge( edge, graph );\r\n        }\r\n    #endif  // SKIP\r\n\r\n        // clear vertices\r\n        pair< TreeGraph::vertex_iterator, TreeGraph::vertex_iterator > vp;\r\n        for ( vp = vertices( graph ); vp.first != vp.second;  ) {\r\n            TreeGraph::vertex_descriptor vd = (*vp.first);\r\n            ++vp.first;\r\n            clear_vertex( vd, graph );\r\n            remove_vertex( vd, graph );\r\n        }\r\n    }\r\n\r\n} // namespace Graph
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Graph/src/TreeGraph.cpp b/Graph/src/TreeGraph.cpp
--- a/Graph/src/TreeGraph.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Graph/src/TreeGraph.cpp	(date 1729410604370)
@@ -1,107 +1,0 @@
-//******************************************************************************
-// TreeGraph.cpp
-//	: program file for tree graph
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Dec 27 23:16:12 2018
-//
-//******************************************************************************
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-#include "TreeGraph.h"
-
-namespace Graph {
-
-    //------------------------------------------------------------------------------
-    //	Customized Vertex Functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Customized Edge Functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Customized Layout Functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Special functions
-    //------------------------------------------------------------------------------
-    //
-    //  TreeGraph::printGraph -- print the graph.
-    //
-    //  Inputs
-    //  g   : object of Grpah
-    //
-    //  Outputs
-    //  none
-    //
-    void printGraph( const TreeGraph & graph )
-    {
-    	cerr << "TreeGraph:" << endl;
-        cerr << "num_vertices = " << num_vertices( graph ) << endl;
-        cerr << "num_edges = " << num_edges( graph ) << endl;
-
-    #ifdef  DEBUG
-        // print vertex information
-        BGL_FORALL_VERTICES( vd, graph, TreeGraph ) {
-
-            TreeGraph::degree_size_type      degrees         = out_degree( vd, graph );
-            cerr << "vid = " << graph[vd].id << " level = " << graph[vd].level
-                 << " childSize = " << graph[vd].childMap.size() << " ?= " << degrees
-                 << " parentID = " << graph[vd].parentID << endl;
-        }
-    #endif  // DEBUG
-
-    #ifdef  DEBUG
-        // print edge information
-        BGL_FORALL_EDGES( ed, graph, TreeGraph ) {
-
-            TreeGraph::vertex_descriptor vdS = source( ed, graph );
-            TreeGraph::vertex_descriptor vdT = target( ed, graph );
-
-            cerr << "eid = " << graph[ ed ].id << " ( " << graph[ vdS ].id << " == " << graph[ vdT ].id << " ) " << endl;
-        }
-    #endif  // DEBUG
-    }
-
-    //
-    //  TreeGraph::clearGraph -- clear the graph.
-    //
-    //  Inputs
-    //  g   : object of Grpah
-    //
-    //  Outputs
-    //  none
-    //
-    void clearGraph( TreeGraph & graph )
-    {
-        // clear edges
-        TreeGraph::edge_iterator ei, ei_end, e_next;
-        tie( ei, ei_end ) = edges( graph );
-        for ( e_next = ei; ei != ei_end; ei = e_next ) {
-            e_next++;
-            remove_edge( *ei, graph );
-        }
-
-    #ifdef  SKIP
-        BGL_FORALL_EDGES( edge, graph, BaseGraph )
-        {
-            remove_edge( edge, graph );
-        }
-    #endif  // SKIP
-
-        // clear vertices
-        pair< TreeGraph::vertex_iterator, TreeGraph::vertex_iterator > vp;
-        for ( vp = vertices( graph ); vp.first != vp.second;  ) {
-            TreeGraph::vertex_descriptor vd = (*vp.first);
-            ++vp.first;
-            clear_vertex( vd, graph );
-            remove_vertex( vd, graph );
-        }
-    }
-
-} // namespace Graph
\ No newline at end of file
Index: Graph/src/BaseUndirectedGraph.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// BaseUndirectedGraph.h\r\n//\t: header file for base undirected graph\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Dec 27 23:16:12 2018\r\n//\r\n//******************************************************************************\r\n\r\n#ifndef _Graph_BaseUndirectedGraph_H\r\n#define _Graph_BaseUndirectedGraph_H\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <string>\r\n#include <iostream>\r\n#include <fstream>\r\n#include <vector>\r\n#include <map>\r\n#include <algorithm>\r\n#include <ctime>\r\n#include <cstdlib>\r\n\r\nusing namespace std;\r\n\r\n#include <boost/config.hpp>\r\n#include <boost/graph/graph_traits.hpp>\r\n#include <boost/graph/adjacency_list.hpp>\r\n#include <boost/graph/iteration_macros.hpp>\r\n\r\n// force-directed layout\r\n#include <boost/graph/fruchterman_reingold.hpp>\r\n#include <boost/graph/kamada_kawai_spring_layout.hpp>\r\n#include <boost/graph/random_layout.hpp>\r\n#include <boost/graph/topology.hpp>\r\n#include <boost/lexical_cast.hpp>\r\n#include <boost/graph/connected_components.hpp>\r\n\r\nusing namespace boost;\r\n\r\n#include \"Coord2.h\"\r\n#include \"BaseGraphProperty.h\"\r\n#include \"BaseVertexProperty.h\"\r\n#include \"BaseEdgeProperty.h\"\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Macros\r\n//------------------------------------------------------------------------------\r\n\r\nnamespace Graph {\r\n\r\n    typedef adjacency_list< listS, listS, undirectedS,\r\n            BaseVertexProperty, BaseEdgeProperty,\r\n            BaseGraphProperty >  BaseUndirectedGraph;\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tSpecial functions\r\n    //------------------------------------------------------------------------------\r\n    void printGraph( const BaseUndirectedGraph & g );\r\n    void clearGraph( BaseUndirectedGraph & g );\r\n\r\n} // namespace Graph\r\n\r\n#endif  // _Graph_BaseUndirectedGraph_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Graph/src/BaseUndirectedGraph.h b/Graph/src/BaseUndirectedGraph.h
--- a/Graph/src/BaseUndirectedGraph.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Graph/src/BaseUndirectedGraph.h	(date 1729410604380)
@@ -1,67 +1,0 @@
-//******************************************************************************
-// BaseUndirectedGraph.h
-//	: header file for base undirected graph
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Dec 27 23:16:12 2018
-//
-//******************************************************************************
-
-#ifndef _Graph_BaseUndirectedGraph_H
-#define _Graph_BaseUndirectedGraph_H
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <string>
-#include <iostream>
-#include <fstream>
-#include <vector>
-#include <map>
-#include <algorithm>
-#include <ctime>
-#include <cstdlib>
-
-using namespace std;
-
-#include <boost/config.hpp>
-#include <boost/graph/graph_traits.hpp>
-#include <boost/graph/adjacency_list.hpp>
-#include <boost/graph/iteration_macros.hpp>
-
-// force-directed layout
-#include <boost/graph/fruchterman_reingold.hpp>
-#include <boost/graph/kamada_kawai_spring_layout.hpp>
-#include <boost/graph/random_layout.hpp>
-#include <boost/graph/topology.hpp>
-#include <boost/lexical_cast.hpp>
-#include <boost/graph/connected_components.hpp>
-
-using namespace boost;
-
-#include "Coord2.h"
-#include "BaseGraphProperty.h"
-#include "BaseVertexProperty.h"
-#include "BaseEdgeProperty.h"
-
-//------------------------------------------------------------------------------
-//	Defining Macros
-//------------------------------------------------------------------------------
-
-namespace Graph {
-
-    typedef adjacency_list< listS, listS, undirectedS,
-            BaseVertexProperty, BaseEdgeProperty,
-            BaseGraphProperty >  BaseUndirectedGraph;
-
-    //------------------------------------------------------------------------------
-    //	Special functions
-    //------------------------------------------------------------------------------
-    void printGraph( const BaseUndirectedGraph & g );
-    void clearGraph( BaseUndirectedGraph & g );
-
-} // namespace Graph
-
-#endif  // _Graph_BaseUndirectedGraph_H
Index: Graph/src/BaseUndirectedGraph.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// BaseUndirectedGraph.cpp\r\n//      : program file for graph function\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Mon Mar 14 02:16:23 2019\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include \"BaseUndirectedGraph.h\"\r\n\r\nnamespace Graph {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tCustomized Vertex Functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tCustomized Edge Functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tCustomized Layout Functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tSpecial functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  BaseUndirectedGraph::printGraph -- print the graph.\r\n    //\r\n    //  Inputs\r\n    //  g   : object of Grpah\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void printGraph( const BaseUndirectedGraph & graph )\r\n    {\r\n        cerr << \"num_vertices = \" << num_vertices( graph ) << endl;\r\n        cerr << \"num_edges = \" << num_edges( graph ) << endl;\r\n\r\n    //#ifdef  DEBUG\r\n        // print vertex information\r\n        BGL_FORALL_VERTICES( vd, graph, BaseUndirectedGraph ) {\r\n\r\n            //BaseUndirectedGraph::degree_size_type      degrees         = out_degree( vd, graph );\r\n            cerr << \" id = \" << graph[vd].id\r\n \t             << \" name = \" << *graph[vd].namePtr\r\n\t\t         << \" level = \" << graph[vd].level\r\n\t             << \" initID = \" << graph[vd].initID\r\n                 << \" coord = \" << *graph[ vd ].coordPtr;\r\n        }\r\n    //#endif  // DEBUG\r\n\r\n    //#ifdef  DEBUG\r\n        // print edge information\r\n        BGL_FORALL_EDGES( ed, graph, BaseUndirectedGraph ) {\r\n\r\n            BaseUndirectedGraph::vertex_descriptor vdS = source( ed, graph );\r\n            BaseUndirectedGraph::vertex_descriptor vdT = target( ed, graph );\r\n\r\n            cerr << \"eid = \" << graph[ ed ].id << \" ( \" << graph[ vdS ].id << \" == \" << graph[ vdT ].id << \" ) \"\r\n                 << \" w = \" << graph[ ed ].weight << endl;\r\n        }\r\n    //#endif  // DEBUG\r\n    }\r\n\r\n    //\r\n    //  BaseUndirectedGraph::clearGraph -- clear the graph.\r\n    //\r\n    //  Inputs\r\n    //  g   : object of Graph\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void clearGraph( BaseUndirectedGraph & graph )\r\n    {\r\n        // clear edges\r\n        BaseUndirectedGraph::edge_iterator ei, ei_end, e_next;\r\n        tie( ei, ei_end ) = edges( graph );\r\n        for ( e_next = ei; ei != ei_end; ei = e_next ) {\r\n            e_next++;\r\n            remove_edge( *ei, graph );\r\n        }\r\n\r\n    #ifdef  SKIP\r\n        BGL_FORALL_EDGES( edge, graph, BaseGraph )\r\n        {\r\n            remove_edge( edge, graph );\r\n        }\r\n    #endif  // SKIP\r\n\r\n        // clear vertices\r\n        pair< BaseUndirectedGraph::vertex_iterator, BaseUndirectedGraph::vertex_iterator > vp;\r\n        for ( vp = vertices( graph ); vp.first != vp.second;  ) {\r\n            BaseUndirectedGraph::vertex_descriptor vd = (*vp.first);\r\n            ++vp.first;\r\n            clear_vertex( vd, graph );\r\n            remove_vertex( vd, graph );\r\n        }\r\n    }\r\n\r\n} // namespace Graph
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Graph/src/BaseUndirectedGraph.cpp b/Graph/src/BaseUndirectedGraph.cpp
--- a/Graph/src/BaseUndirectedGraph.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Graph/src/BaseUndirectedGraph.cpp	(date 1729410604390)
@@ -1,110 +1,0 @@
-//******************************************************************************
-// BaseUndirectedGraph.cpp
-//      : program file for graph function
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Mon Mar 14 02:16:23 2019
-//
-//******************************************************************************
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include "BaseUndirectedGraph.h"
-
-namespace Graph {
-
-    //------------------------------------------------------------------------------
-    //	Customized Vertex Functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Customized Edge Functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Customized Layout Functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Special functions
-    //------------------------------------------------------------------------------
-    //
-    //  BaseUndirectedGraph::printGraph -- print the graph.
-    //
-    //  Inputs
-    //  g   : object of Grpah
-    //
-    //  Outputs
-    //  none
-    //
-    void printGraph( const BaseUndirectedGraph & graph )
-    {
-        cerr << "num_vertices = " << num_vertices( graph ) << endl;
-        cerr << "num_edges = " << num_edges( graph ) << endl;
-
-    //#ifdef  DEBUG
-        // print vertex information
-        BGL_FORALL_VERTICES( vd, graph, BaseUndirectedGraph ) {
-
-            //BaseUndirectedGraph::degree_size_type      degrees         = out_degree( vd, graph );
-            cerr << " id = " << graph[vd].id
- 	             << " name = " << *graph[vd].namePtr
-		         << " level = " << graph[vd].level
-	             << " initID = " << graph[vd].initID
-                 << " coord = " << *graph[ vd ].coordPtr;
-        }
-    //#endif  // DEBUG
-
-    //#ifdef  DEBUG
-        // print edge information
-        BGL_FORALL_EDGES( ed, graph, BaseUndirectedGraph ) {
-
-            BaseUndirectedGraph::vertex_descriptor vdS = source( ed, graph );
-            BaseUndirectedGraph::vertex_descriptor vdT = target( ed, graph );
-
-            cerr << "eid = " << graph[ ed ].id << " ( " << graph[ vdS ].id << " == " << graph[ vdT ].id << " ) "
-                 << " w = " << graph[ ed ].weight << endl;
-        }
-    //#endif  // DEBUG
-    }
-
-    //
-    //  BaseUndirectedGraph::clearGraph -- clear the graph.
-    //
-    //  Inputs
-    //  g   : object of Graph
-    //
-    //  Outputs
-    //  none
-    //
-    void clearGraph( BaseUndirectedGraph & graph )
-    {
-        // clear edges
-        BaseUndirectedGraph::edge_iterator ei, ei_end, e_next;
-        tie( ei, ei_end ) = edges( graph );
-        for ( e_next = ei; ei != ei_end; ei = e_next ) {
-            e_next++;
-            remove_edge( *ei, graph );
-        }
-
-    #ifdef  SKIP
-        BGL_FORALL_EDGES( edge, graph, BaseGraph )
-        {
-            remove_edge( edge, graph );
-        }
-    #endif  // SKIP
-
-        // clear vertices
-        pair< BaseUndirectedGraph::vertex_iterator, BaseUndirectedGraph::vertex_iterator > vp;
-        for ( vp = vertices( graph ); vp.first != vp.second;  ) {
-            BaseUndirectedGraph::vertex_descriptor vd = (*vp.first);
-            ++vp.first;
-            clear_vertex( vd, graph );
-            remove_vertex( vd, graph );
-        }
-    }
-
-} // namespace Graph
\ No newline at end of file
Index: Graph/src/GridGraph.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// GridGraph.h\r\n//\t: header file for grid graph\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Sun Feb 09 23:16:12 2020\r\n//\r\n//******************************************************************************\r\n\r\n#ifndef _Graph_GridGraph_H\r\n#define _Graph_GridGraph_H\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <string>\r\n#include <iostream>\r\n#include <fstream>\r\n#include <vector>\r\n#include <map>\r\n#include <algorithm>\r\n#include <ctime>\r\n#include <cstdlib>\r\n\r\nusing namespace std;\r\n\r\n#include <boost/config.hpp>\r\n#include <boost/graph/graph_traits.hpp>\r\n#include <boost/graph/adjacency_list.hpp>\r\n#include <boost/graph/iteration_macros.hpp>\r\n\r\nusing namespace boost;\r\n\r\n#include \"Coord2.h\"\r\n#include \"GridGraphProperty.h\"\r\n#include \"GridVertexProperty.h\"\r\n#include \"GridEdgeProperty.h\"\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Macros\r\n//------------------------------------------------------------------------------\r\n\r\nnamespace Graph {\r\n\r\n    typedef adjacency_list< listS, listS, undirectedS,\r\n            GridVertexProperty, GridEdgeProperty,\r\n            GridGraphProperty >  GridGraph;\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tSpecial functions\r\n    //------------------------------------------------------------------------------\r\n    void printGraph( const GridGraph & g );\r\n    void clearGraph( GridGraph & g );\r\n\r\n} // namespace Graph\r\n\r\n#endif  // _Graph_GridGraph_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Graph/src/GridGraph.h b/Graph/src/GridGraph.h
--- a/Graph/src/GridGraph.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Graph/src/GridGraph.h	(date 1729410604400)
@@ -1,59 +1,0 @@
-//******************************************************************************
-// GridGraph.h
-//	: header file for grid graph
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Sun Feb 09 23:16:12 2020
-//
-//******************************************************************************
-
-#ifndef _Graph_GridGraph_H
-#define _Graph_GridGraph_H
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <string>
-#include <iostream>
-#include <fstream>
-#include <vector>
-#include <map>
-#include <algorithm>
-#include <ctime>
-#include <cstdlib>
-
-using namespace std;
-
-#include <boost/config.hpp>
-#include <boost/graph/graph_traits.hpp>
-#include <boost/graph/adjacency_list.hpp>
-#include <boost/graph/iteration_macros.hpp>
-
-using namespace boost;
-
-#include "Coord2.h"
-#include "GridGraphProperty.h"
-#include "GridVertexProperty.h"
-#include "GridEdgeProperty.h"
-
-//------------------------------------------------------------------------------
-//	Defining Macros
-//------------------------------------------------------------------------------
-
-namespace Graph {
-
-    typedef adjacency_list< listS, listS, undirectedS,
-            GridVertexProperty, GridEdgeProperty,
-            GridGraphProperty >  GridGraph;
-
-    //------------------------------------------------------------------------------
-    //	Special functions
-    //------------------------------------------------------------------------------
-    void printGraph( const GridGraph & g );
-    void clearGraph( GridGraph & g );
-
-} // namespace Graph
-
-#endif  // _Graph_GridGraph_H
Index: Graph/src/GridGraphProperty.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// GridGraphProperty.h\r\n//\t: header file for tree graph property\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Sun Feb 09 23:16:12 2020\r\n//\r\n//******************************************************************************\r\n\r\n#ifndef\t_Graph__GridGraphProperty_H\r\n#define _Graph__GridGraphProperty_H\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\n#include \"Coord2.h\"\r\n#include \"Common.h\"\r\n#include \"BaseGraphProperty.h\"\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Macros\r\n//------------------------------------------------------------------------------\r\n\r\nnamespace Graph {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tDefining Classes\r\n    //------------------------------------------------------------------------------\r\n    class GridGraphProperty: public BaseGraphProperty {\r\n\r\n    private:\r\n\r\n    protected:\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tSpecial functions\r\n        //------------------------------------------------------------------------------\r\n         void\t\t    _init( double &width, double &height );\r\n\r\n    public:\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tConstructors & Destructors\r\n        //------------------------------------------------------------------------------\r\n        // default constructor\r\n        GridGraphProperty( void );\r\n        // copy constructor\r\n        GridGraphProperty( const GridGraphProperty & c ) {}\r\n        // destructor\r\n        virtual ~GridGraphProperty( void ) {}\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tAssignment operators\r\n        //------------------------------------------------------------------------------\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tReference to elements\r\n        //------------------------------------------------------------------------------\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tSpecial functions\r\n        //------------------------------------------------------------------------------\r\n\r\n        void        init( double &__width, double &__height ) {\r\n            _init( __width, __height );\r\n        }\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tFriend functions\r\n        //------------------------------------------------------------------------------\r\n\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tI/O functions\r\n        //------------------------------------------------------------------------------\r\n        // output\r\n        friend ostream &\toperator << ( ostream & s, const GridGraphProperty & v );\r\n        // input\r\n        friend istream &\toperator >> ( istream & s, GridGraphProperty & v );\r\n        // class name\r\n        virtual const char * className( void ) const { return \"GridGraphProperty\"; }\r\n\r\n    };\r\n\r\n} // namespace Graph\r\n\r\n#endif // _Graph_GridGraphProperty_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Graph/src/GridGraphProperty.h b/Graph/src/GridGraphProperty.h
--- a/Graph/src/GridGraphProperty.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Graph/src/GridGraphProperty.h	(date 1729410604410)
@@ -1,94 +1,0 @@
-//******************************************************************************
-// GridGraphProperty.h
-//	: header file for tree graph property
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Sun Feb 09 23:16:12 2020
-//
-//******************************************************************************
-
-#ifndef	_Graph__GridGraphProperty_H
-#define _Graph__GridGraphProperty_H
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <iostream>
-
-using namespace std;
-
-#include "Coord2.h"
-#include "Common.h"
-#include "BaseGraphProperty.h"
-
-
-//------------------------------------------------------------------------------
-//	Defining Macros
-//------------------------------------------------------------------------------
-
-namespace Graph {
-
-    //------------------------------------------------------------------------------
-    //	Defining Classes
-    //------------------------------------------------------------------------------
-    class GridGraphProperty: public BaseGraphProperty {
-
-    private:
-
-    protected:
-
-        //------------------------------------------------------------------------------
-        //	Special functions
-        //------------------------------------------------------------------------------
-         void		    _init( double &width, double &height );
-
-    public:
-
-        //------------------------------------------------------------------------------
-        //	Constructors & Destructors
-        //------------------------------------------------------------------------------
-        // default constructor
-        GridGraphProperty( void );
-        // copy constructor
-        GridGraphProperty( const GridGraphProperty & c ) {}
-        // destructor
-        virtual ~GridGraphProperty( void ) {}
-
-        //------------------------------------------------------------------------------
-        //	Assignment operators
-        //------------------------------------------------------------------------------
-
-        //------------------------------------------------------------------------------
-        //	Reference to elements
-        //------------------------------------------------------------------------------
-
-        //------------------------------------------------------------------------------
-        //	Special functions
-        //------------------------------------------------------------------------------
-
-        void        init( double &__width, double &__height ) {
-            _init( __width, __height );
-        }
-
-        //------------------------------------------------------------------------------
-        //	Friend functions
-        //------------------------------------------------------------------------------
-
-
-        //------------------------------------------------------------------------------
-        //	I/O functions
-        //------------------------------------------------------------------------------
-        // output
-        friend ostream &	operator << ( ostream & s, const GridGraphProperty & v );
-        // input
-        friend istream &	operator >> ( istream & s, GridGraphProperty & v );
-        // class name
-        virtual const char * className( void ) const { return "GridGraphProperty"; }
-
-    };
-
-} // namespace Graph
-
-#endif // _Graph_GridGraphProperty_H
Index: Graph/src/SchematicEdgeProperty.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// BaseEdgeProperty.cc\r\n//\t: program file for 2D coordinatse\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Dec 27 23:15:32 2017\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <iostream>\r\n#include <iomanip>\r\n#include <cctype>\r\n#include <cmath>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\n#include \"SchematicEdgeProperty.h\"\r\n\r\nnamespace Graph {\r\n//------------------------------------------------------------------------------\r\n//\tMacro Definitions\r\n//------------------------------------------------------------------------------\r\n\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tProtected Functions\r\n//------------------------------------------------------------------------------\r\n//\r\n//  BoundaryEdgeProperty::_init -- initialize the graph.\r\n//\r\n//  Inputs\r\n//  none\r\n//\r\n//  Outputs\r\n//  none\r\n//\r\n\tvoid SchematicEdgeProperty::_init( void ) {\r\n\t\tid = 0;\r\n\t\tweight = 1.0;\r\n\t\tvisitedTimes = -1;\r\n\t}\r\n\r\n//------------------------------------------------------------------------------\r\n//\tPublic functions\r\n//------------------------------------------------------------------------------\r\n\r\n//------------------------------------------------------------------------------\r\n//\tConstuructors\r\n//------------------------------------------------------------------------------\r\n\r\n//\r\n//  BoundaryEdgeProperty::BoundaryEdgeProperty -- default constructor\r\n//\r\n//  Inputs\r\n//  none\r\n//\r\n//  Outputs\r\n//  none\r\n//\r\n\tSchematicEdgeProperty::SchematicEdgeProperty() {\r\n\t\t_init();\r\n\t}\r\n\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tAssignment operators\r\n//------------------------------------------------------------------------------\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tI/O functions\r\n//------------------------------------------------------------------------------\r\n\r\n//\r\n//  operator << --\toutput\r\n//\r\n//  Inputs\r\n//\tstream\t: reference to output stream\r\n//\tobj\t: BoundaryEdgeProperty\r\n//\r\n//  Outputs\r\n//\treference to output stream\r\n//\r\n\tostream &operator<<( ostream &stream, const SchematicEdgeProperty &obj ) {\r\n\t\t// set the output formatting\r\n\t\tstream << setiosflags( ios::showpoint );\r\n\t\tstream << setprecision( 8 );\r\n\t\tstream << endl;\r\n\t\t\r\n\t\treturn stream;\r\n\t}\r\n\r\n\r\n//\r\n//  operator >> --\tinput\r\n//\r\n//  Inputs\r\n//\tstream\t: reference to output stream\r\n//\tobj\t: BoundaryEdgeProperty\r\n//\r\n//  Outputs\r\n//\treference to input stream\r\n//\r\n\tistream &operator>>( istream &stream, SchematicEdgeProperty &obj ) {\r\n\t\treturn stream;\r\n\t}\r\n\t\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Graph/src/SchematicEdgeProperty.cpp b/Graph/src/SchematicEdgeProperty.cpp
--- a/Graph/src/SchematicEdgeProperty.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Graph/src/SchematicEdgeProperty.cpp	(date 1729410604420)
@@ -1,116 +1,0 @@
-//******************************************************************************
-// BaseEdgeProperty.cc
-//	: program file for 2D coordinatse
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Dec 27 23:15:32 2017
-//
-//******************************************************************************
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <iostream>
-#include <iomanip>
-#include <cctype>
-#include <cmath>
-#include <algorithm>
-
-using namespace std;
-
-#include "SchematicEdgeProperty.h"
-
-namespace Graph {
-//------------------------------------------------------------------------------
-//	Macro Definitions
-//------------------------------------------------------------------------------
-
-
-
-//------------------------------------------------------------------------------
-//	Protected Functions
-//------------------------------------------------------------------------------
-//
-//  BoundaryEdgeProperty::_init -- initialize the graph.
-//
-//  Inputs
-//  none
-//
-//  Outputs
-//  none
-//
-	void SchematicEdgeProperty::_init( void ) {
-		id = 0;
-		weight = 1.0;
-		visitedTimes = -1;
-	}
-
-//------------------------------------------------------------------------------
-//	Public functions
-//------------------------------------------------------------------------------
-
-//------------------------------------------------------------------------------
-//	Constuructors
-//------------------------------------------------------------------------------
-
-//
-//  BoundaryEdgeProperty::BoundaryEdgeProperty -- default constructor
-//
-//  Inputs
-//  none
-//
-//  Outputs
-//  none
-//
-	SchematicEdgeProperty::SchematicEdgeProperty() {
-		_init();
-	}
-
-
-
-//------------------------------------------------------------------------------
-//	Assignment operators
-//------------------------------------------------------------------------------
-
-
-//------------------------------------------------------------------------------
-//	I/O functions
-//------------------------------------------------------------------------------
-
-//
-//  operator << --	output
-//
-//  Inputs
-//	stream	: reference to output stream
-//	obj	: BoundaryEdgeProperty
-//
-//  Outputs
-//	reference to output stream
-//
-	ostream &operator<<( ostream &stream, const SchematicEdgeProperty &obj ) {
-		// set the output formatting
-		stream << setiosflags( ios::showpoint );
-		stream << setprecision( 8 );
-		stream << endl;
-		
-		return stream;
-	}
-
-
-//
-//  operator >> --	input
-//
-//  Inputs
-//	stream	: reference to output stream
-//	obj	: BoundaryEdgeProperty
-//
-//  Outputs
-//	reference to input stream
-//
-	istream &operator>>( istream &stream, SchematicEdgeProperty &obj ) {
-		return stream;
-	}
-	
-}
\ No newline at end of file
Index: Graph/src/BaseVertexProperty.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// BaseVertexProperty.h\r\n//\t: header file for base vertex property\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Dec 27 23:16:12 2018\r\n//\r\n//******************************************************************************\r\n\r\n#ifndef\t_Graph_BaseVertexProperty_H\r\n#define _Graph_BaseVertexProperty_H\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <iostream>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\n#include \"Object.h\"\r\n#include \"Coord2.h\"\r\n#include \"Common.h\"\r\n//#include \"GraphicsBallItem.h\"\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Macros\r\n//------------------------------------------------------------------------------\r\n\r\nnamespace Graph {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tDefining Classes\r\n    //------------------------------------------------------------------------------\r\n    class BaseVertexProperty {\r\n\r\n    private:\r\n\r\n    protected:\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tSpecial functions\r\n        //------------------------------------------------------------------------------\r\n        void\t\t    _init( void );\r\n\r\n    public:\r\n\r\n        unsigned int                id;\r\n        unsigned int                initID;                 // initial id\r\n        unsigned int                groupID;                // group id\r\n        unsigned int                componentID;            // component id\r\n\r\n        string *                    namePtr;\r\n        double *                    namePixelWidthPtr;      // pixel width of the name\r\n        double *                    namePixelHeightPtr;     // pixel height of the name\r\n\r\n        double                      size;                   // size of the vertex\r\n        double                      weight;                 // weight of the vertex\r\n\t\tdouble                      aspectRatio;            // aspect ratio of the vertex\r\n        \r\n        KeiRo::Base::Coord2 *       coordPtr;               // center coordinates\r\n        double *                    widthPtr;               // vertex width\r\n        double *                    heightPtr;              // vertex height\r\n        int *                       gridWidthPtr;           // vertex width\r\n        int *                       gridHeightPtr;          // vertex height\r\n        double *                    areaPtr;                // vertex area\r\n\r\n        int                         level;                  // vertex level\r\n        int                         color;                  // color type\r\n        bool                        flag;                   // flag\r\n\t\tbool                        isSelected;             // if the vertex is selected\r\n\t\t\r\n\t    unsigned int                itemID;                 // item ID for graphics\r\n\t    KeiRo::Base::Object         attribute;              // attribue (e.g., xml style)\r\n\t    // Ui::Vector::GraphicsBallItem * itemPtr;\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tConstructors & Destructors\r\n        //------------------------------------------------------------------------------\r\n        // default constructor\r\n        BaseVertexProperty( void );\r\n        // copy constructor\r\n        BaseVertexProperty( const BaseVertexProperty & c ) {}\r\n        // destructor\r\n        virtual ~BaseVertexProperty( void ) {}\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tAssignment operators\r\n        //------------------------------------------------------------------------------\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tReference to elements\r\n        //------------------------------------------------------------------------------\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tSpecial functions\r\n        //------------------------------------------------------------------------------\r\n\r\n        void        init( void )\t\t{ _init(); }\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tFriend functions\r\n        //------------------------------------------------------------------------------\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tI/O functions\r\n        //------------------------------------------------------------------------------\r\n        // output\r\n        friend ostream &\toperator << ( ostream & s, const BaseVertexProperty & v );\r\n        // input\r\n        friend istream &\toperator >> ( istream & s, BaseVertexProperty & v );\r\n        // class name\r\n        virtual const char * className( void ) const { return \"BaseVertexProperty\"; }\r\n\r\n    };\r\n\r\n} // namespace Graph\r\n\r\n#endif // _Graph_BaseVertexProperty_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Graph/src/BaseVertexProperty.h b/Graph/src/BaseVertexProperty.h
--- a/Graph/src/BaseVertexProperty.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Graph/src/BaseVertexProperty.h	(date 1729410604430)
@@ -1,121 +1,0 @@
-//******************************************************************************
-// BaseVertexProperty.h
-//	: header file for base vertex property
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Dec 27 23:16:12 2018
-//
-//******************************************************************************
-
-#ifndef	_Graph_BaseVertexProperty_H
-#define _Graph_BaseVertexProperty_H
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <iostream>
-#include <vector>
-
-using namespace std;
-
-#include "Object.h"
-#include "Coord2.h"
-#include "Common.h"
-//#include "GraphicsBallItem.h"
-
-//------------------------------------------------------------------------------
-//	Defining Macros
-//------------------------------------------------------------------------------
-
-namespace Graph {
-
-    //------------------------------------------------------------------------------
-    //	Defining Classes
-    //------------------------------------------------------------------------------
-    class BaseVertexProperty {
-
-    private:
-
-    protected:
-
-        //------------------------------------------------------------------------------
-        //	Special functions
-        //------------------------------------------------------------------------------
-        void		    _init( void );
-
-    public:
-
-        unsigned int                id;
-        unsigned int                initID;                 // initial id
-        unsigned int                groupID;                // group id
-        unsigned int                componentID;            // component id
-
-        string *                    namePtr;
-        double *                    namePixelWidthPtr;      // pixel width of the name
-        double *                    namePixelHeightPtr;     // pixel height of the name
-
-        double                      size;                   // size of the vertex
-        double                      weight;                 // weight of the vertex
-		double                      aspectRatio;            // aspect ratio of the vertex
-        
-        KeiRo::Base::Coord2 *       coordPtr;               // center coordinates
-        double *                    widthPtr;               // vertex width
-        double *                    heightPtr;              // vertex height
-        int *                       gridWidthPtr;           // vertex width
-        int *                       gridHeightPtr;          // vertex height
-        double *                    areaPtr;                // vertex area
-
-        int                         level;                  // vertex level
-        int                         color;                  // color type
-        bool                        flag;                   // flag
-		bool                        isSelected;             // if the vertex is selected
-		
-	    unsigned int                itemID;                 // item ID for graphics
-	    KeiRo::Base::Object         attribute;              // attribue (e.g., xml style)
-	    // Ui::Vector::GraphicsBallItem * itemPtr;
-
-        //------------------------------------------------------------------------------
-        //	Constructors & Destructors
-        //------------------------------------------------------------------------------
-        // default constructor
-        BaseVertexProperty( void );
-        // copy constructor
-        BaseVertexProperty( const BaseVertexProperty & c ) {}
-        // destructor
-        virtual ~BaseVertexProperty( void ) {}
-
-        //------------------------------------------------------------------------------
-        //	Assignment operators
-        //------------------------------------------------------------------------------
-
-        //------------------------------------------------------------------------------
-        //	Reference to elements
-        //------------------------------------------------------------------------------
-
-        //------------------------------------------------------------------------------
-        //	Special functions
-        //------------------------------------------------------------------------------
-
-        void        init( void )		{ _init(); }
-
-        //------------------------------------------------------------------------------
-        //	Friend functions
-        //------------------------------------------------------------------------------
-
-        //------------------------------------------------------------------------------
-        //	I/O functions
-        //------------------------------------------------------------------------------
-        // output
-        friend ostream &	operator << ( ostream & s, const BaseVertexProperty & v );
-        // input
-        friend istream &	operator >> ( istream & s, BaseVertexProperty & v );
-        // class name
-        virtual const char * className( void ) const { return "BaseVertexProperty"; }
-
-    };
-
-} // namespace Graph
-
-#endif // _Graph_BaseVertexProperty_H
Index: Graph/src/GridEdgeProperty.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// GridEdgeProperty.xpp\r\n//\t: program file for grid edge property\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Feb 09 23:16:12 2020\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <iostream>\r\n#include <iomanip>\r\n#include <cctype>\r\n#include <cmath>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\n#include \"GridEdgeProperty.h\"\r\n\r\nnamespace Graph {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPrivate Functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tProtected Functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  GridEdgeProperty::_init -- initialize the graph.\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void GridEdgeProperty::_init( void )\r\n    {\r\n        BaseEdgeProperty::_init();\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPublic functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tConstructors & Destructors\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  GridEdgeProperty::GridEdgeProperty -- default constructor\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    GridEdgeProperty::GridEdgeProperty()\r\n    {\r\n        _init();\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tAssignment operators\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tI/O functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  operator << --\toutput\r\n    //\r\n    //  Inputs\r\n    //\tstream\t: reference to output stream\r\n    //\tobj\t: GridEdgeProperty\r\n    //\r\n    //  Outputs\r\n    //\treference to output stream\r\n    //\r\n    ostream & operator << ( ostream & stream, const GridEdgeProperty & obj )\r\n    {\r\n        // set the output formatting\r\n        stream << setiosflags( ios::showpoint );\r\n        stream << setprecision( 8 );\r\n        stream << endl;\r\n\r\n        return stream;\r\n    }\r\n\r\n\r\n    //\r\n    //  operator >> --\tinput\r\n    //\r\n    //  Inputs\r\n    //\tstream\t: reference to output stream\r\n    //\tobj\t: GridEdgeProperty\r\n    //\r\n    //  Outputs\r\n    //\treference to input stream\r\n    //\r\n    istream & operator >> ( istream & stream, GridEdgeProperty & obj )\r\n    {\r\n        return stream;\r\n    }\r\n\r\n} // namespace Graph
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Graph/src/GridEdgeProperty.cpp b/Graph/src/GridEdgeProperty.cpp
--- a/Graph/src/GridEdgeProperty.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Graph/src/GridEdgeProperty.cpp	(date 1729410604450)
@@ -1,112 +1,0 @@
-//******************************************************************************
-// GridEdgeProperty.xpp
-//	: program file for grid edge property
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Feb 09 23:16:12 2020
-//
-//******************************************************************************
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <iostream>
-#include <iomanip>
-#include <cctype>
-#include <cmath>
-#include <algorithm>
-
-using namespace std;
-
-#include "GridEdgeProperty.h"
-
-namespace Graph {
-
-    //------------------------------------------------------------------------------
-    //	Private Functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Protected Functions
-    //------------------------------------------------------------------------------
-    //
-    //  GridEdgeProperty::_init -- initialize the graph.
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    //
-    void GridEdgeProperty::_init( void )
-    {
-        BaseEdgeProperty::_init();
-    }
-
-    //------------------------------------------------------------------------------
-    //	Public functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Constructors & Destructors
-    //------------------------------------------------------------------------------
-    //
-    //  GridEdgeProperty::GridEdgeProperty -- default constructor
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    //
-    GridEdgeProperty::GridEdgeProperty()
-    {
-        _init();
-    }
-
-    //------------------------------------------------------------------------------
-    //	Assignment operators
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	I/O functions
-    //------------------------------------------------------------------------------
-    //
-    //  operator << --	output
-    //
-    //  Inputs
-    //	stream	: reference to output stream
-    //	obj	: GridEdgeProperty
-    //
-    //  Outputs
-    //	reference to output stream
-    //
-    ostream & operator << ( ostream & stream, const GridEdgeProperty & obj )
-    {
-        // set the output formatting
-        stream << setiosflags( ios::showpoint );
-        stream << setprecision( 8 );
-        stream << endl;
-
-        return stream;
-    }
-
-
-    //
-    //  operator >> --	input
-    //
-    //  Inputs
-    //	stream	: reference to output stream
-    //	obj	: GridEdgeProperty
-    //
-    //  Outputs
-    //	reference to input stream
-    //
-    istream & operator >> ( istream & stream, GridEdgeProperty & obj )
-    {
-        return stream;
-    }
-
-} // namespace Graph
\ No newline at end of file
Index: Graph/src/SchematicGraphProperty.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// BoundaryGraphProperty.h\r\n//\t: header file for 2D coordinaes\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Dec 27 23:16:12 2011\r\n//\r\n//******************************************************************************\r\n\r\n#ifndef _BoundaryGraphProperty_H\r\n#define _BoundaryGraphProperty_H\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\n#include \"Coord2.h\"\r\n#include \"Common.h\"\r\n#include \"BaseGraphProperty.h\"\r\n\r\nnamespace Graph {\r\n//------------------------------------------------------------------------------\r\n//\tDefining Macros\r\n//------------------------------------------------------------------------------\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Classes\r\n//------------------------------------------------------------------------------\r\n\t\r\n\tclass SchematicGraphProperty : public BaseGraphProperty {\r\n\t\r\n\tprotected:\r\n\t\t\r\n\t\tvoid _init( double &width, double &height );\r\n\t\r\n\tpublic:\r\n\r\n//------------------------------------------------------------------------------\r\n//\tConstructors\r\n//------------------------------------------------------------------------------\r\n\t\tSchematicGraphProperty();                // constructor (default)\r\n\t\tSchematicGraphProperty( const SchematicGraphProperty &v ) {\r\n\t\t}                    // copy constructor\r\n\t\tvirtual ~SchematicGraphProperty() {}        // destructor\r\n\r\n//------------------------------------------------------------------------------\r\n//\tAssignment operators\r\n//------------------------------------------------------------------------------\r\n\r\n//------------------------------------------------------------------------------\r\n//\tReference to elements\r\n//------------------------------------------------------------------------------\r\n\r\n//------------------------------------------------------------------------------\r\n//\tSpecial functions\r\n//------------------------------------------------------------------------------\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIntersection check\r\n//------------------------------------------------------------------------------\r\n\r\n//------------------------------------------------------------------------------\r\n//\tFriend functions\r\n//------------------------------------------------------------------------------\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tI/O functions\r\n//------------------------------------------------------------------------------\r\n\t\tfriend ostream &operator<<( ostream &s, const SchematicGraphProperty &v );\r\n\t\t\r\n\t\t// Output\r\n\t\tfriend istream &operator>>( istream &s, SchematicGraphProperty &v );\r\n\t\t\r\n\t\t// Input\r\n\t\tvirtual const char *className( void ) const { return \"BoundaryGraphProperty\"; }\r\n\t\t// class name\r\n\t\t\r\n\t};\r\n}\r\n#endif // _BoundaryGraphProperty_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Graph/src/SchematicGraphProperty.h b/Graph/src/SchematicGraphProperty.h
--- a/Graph/src/SchematicGraphProperty.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Graph/src/SchematicGraphProperty.h	(date 1729410604460)
@@ -1,86 +1,0 @@
-//******************************************************************************
-// BoundaryGraphProperty.h
-//	: header file for 2D coordinaes
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Dec 27 23:16:12 2011
-//
-//******************************************************************************
-
-#ifndef _BoundaryGraphProperty_H
-#define _BoundaryGraphProperty_H
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-#include <iostream>
-
-using namespace std;
-
-#include "Coord2.h"
-#include "Common.h"
-#include "BaseGraphProperty.h"
-
-namespace Graph {
-//------------------------------------------------------------------------------
-//	Defining Macros
-//------------------------------------------------------------------------------
-
-
-//------------------------------------------------------------------------------
-//	Defining Classes
-//------------------------------------------------------------------------------
-	
-	class SchematicGraphProperty : public BaseGraphProperty {
-	
-	protected:
-		
-		void _init( double &width, double &height );
-	
-	public:
-
-//------------------------------------------------------------------------------
-//	Constructors
-//------------------------------------------------------------------------------
-		SchematicGraphProperty();                // constructor (default)
-		SchematicGraphProperty( const SchematicGraphProperty &v ) {
-		}                    // copy constructor
-		virtual ~SchematicGraphProperty() {}        // destructor
-
-//------------------------------------------------------------------------------
-//	Assignment operators
-//------------------------------------------------------------------------------
-
-//------------------------------------------------------------------------------
-//	Reference to elements
-//------------------------------------------------------------------------------
-
-//------------------------------------------------------------------------------
-//	Special functions
-//------------------------------------------------------------------------------
-
-//------------------------------------------------------------------------------
-//	Intersection check
-//------------------------------------------------------------------------------
-
-//------------------------------------------------------------------------------
-//	Friend functions
-//------------------------------------------------------------------------------
-
-
-//------------------------------------------------------------------------------
-//	I/O functions
-//------------------------------------------------------------------------------
-		friend ostream &operator<<( ostream &s, const SchematicGraphProperty &v );
-		
-		// Output
-		friend istream &operator>>( istream &s, SchematicGraphProperty &v );
-		
-		// Input
-		virtual const char *className( void ) const { return "BoundaryGraphProperty"; }
-		// class name
-		
-	};
-}
-#endif // _BoundaryGraphProperty_H
Index: Graph/src/BaseGraphProperty.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// BaseGraphProperty.cpp\r\n//\t: program file for 2D coordinates\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Dec 27 23:15:32 2017\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <iostream>\r\n#include <iomanip>\r\n#include <cctype>\r\n#include <cmath>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\n#include \"BaseGraphProperty.h\"\r\n\r\nnamespace Graph {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPrivate Functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tProtected Functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  BaseGraphProperty::_init -- initialize the graph.\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void BaseGraphProperty::_init( double &width, double &height )\r\n    {\r\n        centerPtr   = NULL;\r\n        widthPtr    = &width;\r\n        heightPtr   = &height;\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPublic functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tConstructors & Destructors\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  BaseGraphProperty::BaseGraphProperty -- default constructor\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    BaseGraphProperty::BaseGraphProperty()\r\n    {\r\n        // _init();\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tAssignment operators\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tI/O functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  operator << --\toutput\r\n    //\r\n    //  Inputs\r\n    //\tstream\t: reference to output stream\r\n    //\tobj\t: BaseGraphProperty\r\n    //\r\n    //  Outputs\r\n    //\treference to output stream\r\n    //\r\n    ostream & operator << ( ostream & stream, const BaseGraphProperty & obj )\r\n    {\r\n        // set the output formatting\r\n        stream << setiosflags( ios::showpoint );\r\n        stream << setprecision( 8 );\r\n        stream << endl;\r\n\r\n        return stream;\r\n    }\r\n\r\n\r\n    //\r\n    //  operator >> --\tinput\r\n    //\r\n    //  Inputs\r\n    //\tstream\t: reference to output stream\r\n    //\tobj\t: BaseGraphProperty\r\n    //\r\n    //  Outputs\r\n    //\treference to input stream\r\n    //\r\n    istream & operator >> ( istream & stream, BaseGraphProperty & obj )\r\n    {\r\n        return stream;\r\n    }\r\n\r\n} // namespace Graph
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Graph/src/BaseGraphProperty.cpp b/Graph/src/BaseGraphProperty.cpp
--- a/Graph/src/BaseGraphProperty.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Graph/src/BaseGraphProperty.cpp	(date 1729410604470)
@@ -1,114 +1,0 @@
-//******************************************************************************
-// BaseGraphProperty.cpp
-//	: program file for 2D coordinates
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Dec 27 23:15:32 2017
-//
-//******************************************************************************
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <iostream>
-#include <iomanip>
-#include <cctype>
-#include <cmath>
-#include <algorithm>
-
-using namespace std;
-
-#include "BaseGraphProperty.h"
-
-namespace Graph {
-
-    //------------------------------------------------------------------------------
-    //	Private Functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Protected Functions
-    //------------------------------------------------------------------------------
-    //
-    //  BaseGraphProperty::_init -- initialize the graph.
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    //
-    void BaseGraphProperty::_init( double &width, double &height )
-    {
-        centerPtr   = NULL;
-        widthPtr    = &width;
-        heightPtr   = &height;
-    }
-
-    //------------------------------------------------------------------------------
-    //	Public functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Constructors & Destructors
-    //------------------------------------------------------------------------------
-    //
-    //  BaseGraphProperty::BaseGraphProperty -- default constructor
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    //
-    BaseGraphProperty::BaseGraphProperty()
-    {
-        // _init();
-    }
-
-    //------------------------------------------------------------------------------
-    //	Assignment operators
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	I/O functions
-    //------------------------------------------------------------------------------
-    //
-    //  operator << --	output
-    //
-    //  Inputs
-    //	stream	: reference to output stream
-    //	obj	: BaseGraphProperty
-    //
-    //  Outputs
-    //	reference to output stream
-    //
-    ostream & operator << ( ostream & stream, const BaseGraphProperty & obj )
-    {
-        // set the output formatting
-        stream << setiosflags( ios::showpoint );
-        stream << setprecision( 8 );
-        stream << endl;
-
-        return stream;
-    }
-
-
-    //
-    //  operator >> --	input
-    //
-    //  Inputs
-    //	stream	: reference to output stream
-    //	obj	: BaseGraphProperty
-    //
-    //  Outputs
-    //	reference to input stream
-    //
-    istream & operator >> ( istream & stream, BaseGraphProperty & obj )
-    {
-        return stream;
-    }
-
-} // namespace Graph
\ No newline at end of file
Index: Graph/src/GridVertexProperty.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// GridVertexProperty.h\r\n//\t: program file for grid vertex property\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Sun Feb 09 23:16:12 2020\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <iostream>\r\n#include <iomanip>\r\n#include <cctype>\r\n#include <cmath>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\n#include \"GridVertexProperty.h\"\r\n\r\nnamespace Graph {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPrivate Functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tProtected Functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  GridVertexProperty::_init -- initialize the graph.\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void GridVertexProperty::_init( void )\r\n    {\r\n        BaseVertexProperty::_init();\r\n\r\n        isOccupied          = false;\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPublic functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tConstructors & Destructors\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  GridVertexProperty::GridVertexProperty -- default constructor\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    GridVertexProperty::GridVertexProperty()\r\n    {\r\n        _init();\r\n    }\r\n\r\n\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tAssignment operators\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tI/O functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  operator << --\toutput\r\n    //\r\n    //  Inputs\r\n    //\tstream\t: reference to output stream\r\n    //\tobj\t: GridVertexProperty\r\n    //\r\n    //  Outputs\r\n    //\treference to output stream\r\n    //\r\n    ostream & operator << ( ostream & stream, const GridVertexProperty & obj )\r\n    {\r\n        // set the output formatting\r\n        stream << setiosflags( ios::showpoint );\r\n        stream << setprecision( 8 );\r\n        stream << endl;\r\n\r\n        return stream;\r\n    }\r\n\r\n\r\n    //\r\n    //  operator >> --\tinput\r\n    //\r\n    //  Inputs\r\n    //\tstream\t: reference to output stream\r\n    //\tobj\t: GridVertexProperty\r\n    //\r\n    //  Outputs\r\n    //\treference to input stream\r\n    //\r\n    istream & operator >> ( istream & stream, GridVertexProperty & obj )\r\n    {\r\n        return stream;\r\n    }\r\n\r\n} // namespace Graph
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Graph/src/GridVertexProperty.cpp b/Graph/src/GridVertexProperty.cpp
--- a/Graph/src/GridVertexProperty.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Graph/src/GridVertexProperty.cpp	(date 1729410604480)
@@ -1,116 +1,0 @@
-//******************************************************************************
-// GridVertexProperty.h
-//	: program file for grid vertex property
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Sun Feb 09 23:16:12 2020
-//
-//******************************************************************************
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <iostream>
-#include <iomanip>
-#include <cctype>
-#include <cmath>
-#include <algorithm>
-
-using namespace std;
-
-#include "GridVertexProperty.h"
-
-namespace Graph {
-
-    //------------------------------------------------------------------------------
-    //	Private Functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Protected Functions
-    //------------------------------------------------------------------------------
-    //
-    //  GridVertexProperty::_init -- initialize the graph.
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    //
-    void GridVertexProperty::_init( void )
-    {
-        BaseVertexProperty::_init();
-
-        isOccupied          = false;
-    }
-
-    //------------------------------------------------------------------------------
-    //	Public functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Constructors & Destructors
-    //------------------------------------------------------------------------------
-    //
-    //  GridVertexProperty::GridVertexProperty -- default constructor
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    //
-    GridVertexProperty::GridVertexProperty()
-    {
-        _init();
-    }
-
-
-
-    //------------------------------------------------------------------------------
-    //	Assignment operators
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	I/O functions
-    //------------------------------------------------------------------------------
-    //
-    //  operator << --	output
-    //
-    //  Inputs
-    //	stream	: reference to output stream
-    //	obj	: GridVertexProperty
-    //
-    //  Outputs
-    //	reference to output stream
-    //
-    ostream & operator << ( ostream & stream, const GridVertexProperty & obj )
-    {
-        // set the output formatting
-        stream << setiosflags( ios::showpoint );
-        stream << setprecision( 8 );
-        stream << endl;
-
-        return stream;
-    }
-
-
-    //
-    //  operator >> --	input
-    //
-    //  Inputs
-    //	stream	: reference to output stream
-    //	obj	: GridVertexProperty
-    //
-    //  Outputs
-    //	reference to input stream
-    //
-    istream & operator >> ( istream & stream, GridVertexProperty & obj )
-    {
-        return stream;
-    }
-
-} // namespace Graph
\ No newline at end of file
Index: Graph/src/SchematicVertexProperty.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// BoundaryVertexProperty.h\r\n//\t: header file for 2D coordinaes\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Dec 27 23:16:12 2011\r\n//\r\n//******************************************************************************\r\n\r\n#ifndef _BoundaryVertexProperty_H\r\n#define _BoundaryVertexProperty_H\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n#include <iostream>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\n#include \"Coord2.h\"\r\n#include \"Common.h\"\r\n#include \"BaseVertexProperty.h\"\r\n//#include \"ui/GraphicsVertexItem.h\"\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Macros\r\n//------------------------------------------------------------------------------\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Classes\r\n//------------------------------------------------------------------------------\r\nnamespace Graph {\r\n\tclass SchematicVertexProperty : public BaseVertexProperty {\r\n\t\r\n\tprotected:\r\n\t\t\r\n\t\tvoid _init( void );\r\n\t\r\n\tpublic:\r\n\r\n//------------------------------------------------------------------------------\r\n//\tConstructors\r\n//------------------------------------------------------------------------------\r\n\t\tSchematicVertexProperty();                // constructor (default)\r\n\t\tSchematicVertexProperty( const SchematicVertexProperty &v ) {\r\n\t\t}                    // copy constructor\r\n\t\tvirtual ~SchematicVertexProperty() {}        // destructor\r\n\r\n//------------------------------------------------------------------------------\r\n//\tAssignment operators\r\n//------------------------------------------------------------------------------\r\n\r\n//------------------------------------------------------------------------------\r\n//\tReference to elements\r\n//------------------------------------------------------------------------------\r\n\t\tunsigned int initID;\r\n\t\tbool isFixed;\r\n\t\t\r\n\t\tKeiRo::Base::Coord2 *geoPtr;         // initial position\r\n\t\tKeiRo::Base::Coord2 *smoothPtr;\r\n\t\tKeiRo::Base::Coord2 *centroidPtr;\r\n//\t\tGraphicsVertexItem *itemPtr;\r\n\r\n//------------------------------------------------------------------------------\r\n//\tSpecial functions\r\n//------------------------------------------------------------------------------\r\n\t\t\r\n\t\tvoid init( void ) { _init(); }\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIntersection check\r\n//------------------------------------------------------------------------------\r\n\r\n//------------------------------------------------------------------------------\r\n//\tFriend functions\r\n//------------------------------------------------------------------------------\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tI/O functions\r\n//------------------------------------------------------------------------------\r\n\t\t\r\n\t\tfriend ostream &operator<<( ostream &s, const SchematicVertexProperty &v );\r\n\t\t\r\n\t\t// Output\r\n\t\tfriend istream &operator>>( istream &s, SchematicVertexProperty &v );\r\n\t\t\r\n\t\t// Input\r\n\t\tvirtual const char *className( void ) const { return \"BoundaryVertexProperty\"; }\r\n\t\t// class name\r\n\t\t\r\n\t};\r\n}\r\n#endif // _BoundaryVertexProperty_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Graph/src/SchematicVertexProperty.h b/Graph/src/SchematicVertexProperty.h
--- a/Graph/src/SchematicVertexProperty.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Graph/src/SchematicVertexProperty.h	(date 1729410604490)
@@ -1,97 +1,0 @@
-//******************************************************************************
-// BoundaryVertexProperty.h
-//	: header file for 2D coordinaes
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Dec 27 23:16:12 2011
-//
-//******************************************************************************
-
-#ifndef _BoundaryVertexProperty_H
-#define _BoundaryVertexProperty_H
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-#include <iostream>
-#include <vector>
-
-using namespace std;
-
-#include "Coord2.h"
-#include "Common.h"
-#include "BaseVertexProperty.h"
-//#include "ui/GraphicsVertexItem.h"
-
-//------------------------------------------------------------------------------
-//	Defining Macros
-//------------------------------------------------------------------------------
-
-
-//------------------------------------------------------------------------------
-//	Defining Classes
-//------------------------------------------------------------------------------
-namespace Graph {
-	class SchematicVertexProperty : public BaseVertexProperty {
-	
-	protected:
-		
-		void _init( void );
-	
-	public:
-
-//------------------------------------------------------------------------------
-//	Constructors
-//------------------------------------------------------------------------------
-		SchematicVertexProperty();                // constructor (default)
-		SchematicVertexProperty( const SchematicVertexProperty &v ) {
-		}                    // copy constructor
-		virtual ~SchematicVertexProperty() {}        // destructor
-
-//------------------------------------------------------------------------------
-//	Assignment operators
-//------------------------------------------------------------------------------
-
-//------------------------------------------------------------------------------
-//	Reference to elements
-//------------------------------------------------------------------------------
-		unsigned int initID;
-		bool isFixed;
-		
-		KeiRo::Base::Coord2 *geoPtr;         // initial position
-		KeiRo::Base::Coord2 *smoothPtr;
-		KeiRo::Base::Coord2 *centroidPtr;
-//		GraphicsVertexItem *itemPtr;
-
-//------------------------------------------------------------------------------
-//	Special functions
-//------------------------------------------------------------------------------
-		
-		void init( void ) { _init(); }
-
-//------------------------------------------------------------------------------
-//	Intersection check
-//------------------------------------------------------------------------------
-
-//------------------------------------------------------------------------------
-//	Friend functions
-//------------------------------------------------------------------------------
-
-
-//------------------------------------------------------------------------------
-//	I/O functions
-//------------------------------------------------------------------------------
-		
-		friend ostream &operator<<( ostream &s, const SchematicVertexProperty &v );
-		
-		// Output
-		friend istream &operator>>( istream &s, SchematicVertexProperty &v );
-		
-		// Input
-		virtual const char *className( void ) const { return "BoundaryVertexProperty"; }
-		// class name
-		
-	};
-}
-#endif // _BoundaryVertexProperty_H
Index: Graph/src/TreeVertexProperty.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// TreeVertexProperty.h\r\n//\t: header file for tree vertex property\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Sun Feb 09 23:16:12 2020\r\n//\r\n//******************************************************************************\r\n\r\n#ifndef\t_Graph_TreeVertexProperty_H\r\n#define _Graph_TreeVertexProperty_H\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n#include <iostream>\r\n#include <vector>\r\n#include <map>\r\n\r\nusing namespace std;\r\n\r\n#include \"Coord2.h\"\r\n#include \"Rectangle2.h\"\r\n#include \"Common.h\"\r\n#include \"BaseVertexProperty.h\"\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Macros\r\n//------------------------------------------------------------------------------\r\n#define VERTEX_CAPACITY (1)\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Macros\r\n//------------------------------------------------------------------------------\r\n\r\nnamespace Graph {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tDefining Classes\r\n    //------------------------------------------------------------------------------\r\n    class TreeVertexProperty: public BaseVertexProperty {\r\n\r\n    private:\r\n\r\n    protected:\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tSpecial functions\r\n        //------------------------------------------------------------------------------\r\n          void\t\t    _init( void );\r\n\r\n    public:\r\n\r\n        unsigned int                level;                  // hierarchical level\r\n        unsigned int                attributeID;            // external attribute ID\r\n\t\r\n\t    KeiRo::Base::Coord2         meanCoord;\r\n\t    KeiRo::Base::Coord2         *leftBottomCoordPtr;    // area of the tree cell\r\n\t    double                      *areaCoveragePtr;       // area coverage of the tree node\r\n\t    KeiRo::Base::Rectangle2     *boundingBoxPtr;        // bounding box of the tree cell\r\n\t\r\n\t    vector< unsigned int >      leafIDVec;              // id in samples\r\n\t    map< unsigned int, unsigned int >      childMap;    // vid of children in TreeGraph\r\n\t\tunsigned int                parentID;               // each tree node has one parent node, the root has the parent node as itself\r\n\t    \r\n        //------------------------------------------------------------------------------\r\n        //\tConstructors & Destructors\r\n        //------------------------------------------------------------------------------\r\n        // default constructor\r\n        TreeVertexProperty( void );\r\n        // copy constructor\r\n        TreeVertexProperty( const TreeVertexProperty & c ) {}\r\n        // destructor\r\n        virtual ~TreeVertexProperty( void ) {}\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tAssignment operators\r\n        //------------------------------------------------------------------------------\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tReference to elements\r\n        //------------------------------------------------------------------------------\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tSpecial functions\r\n        //------------------------------------------------------------------------------\r\n\r\n        void        init( void )\t\t{ _init(); }\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tFriend functions\r\n        //------------------------------------------------------------------------------\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tI/O functions\r\n        //------------------------------------------------------------------------------\r\n        // output\r\n        friend ostream &\toperator << ( ostream & s, const TreeVertexProperty & v );\r\n        // input\r\n        friend istream &\toperator >> ( istream & s, TreeVertexProperty & v );\r\n        // class name\r\n        virtual const char * className( void ) const { return \"TreeVertexProperty\"; }\r\n\r\n    };\r\n\r\n} // namespace Graph\r\n\r\n#endif // _Graph_TreeVertexProperty_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Graph/src/TreeVertexProperty.h b/Graph/src/TreeVertexProperty.h
--- a/Graph/src/TreeVertexProperty.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Graph/src/TreeVertexProperty.h	(date 1729410604500)
@@ -1,109 +1,0 @@
-//******************************************************************************
-// TreeVertexProperty.h
-//	: header file for tree vertex property
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Sun Feb 09 23:16:12 2020
-//
-//******************************************************************************
-
-#ifndef	_Graph_TreeVertexProperty_H
-#define _Graph_TreeVertexProperty_H
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-#include <iostream>
-#include <vector>
-#include <map>
-
-using namespace std;
-
-#include "Coord2.h"
-#include "Rectangle2.h"
-#include "Common.h"
-#include "BaseVertexProperty.h"
-
-//------------------------------------------------------------------------------
-//	Defining Macros
-//------------------------------------------------------------------------------
-#define VERTEX_CAPACITY (1)
-
-//------------------------------------------------------------------------------
-//	Defining Macros
-//------------------------------------------------------------------------------
-
-namespace Graph {
-
-    //------------------------------------------------------------------------------
-    //	Defining Classes
-    //------------------------------------------------------------------------------
-    class TreeVertexProperty: public BaseVertexProperty {
-
-    private:
-
-    protected:
-
-        //------------------------------------------------------------------------------
-        //	Special functions
-        //------------------------------------------------------------------------------
-          void		    _init( void );
-
-    public:
-
-        unsigned int                level;                  // hierarchical level
-        unsigned int                attributeID;            // external attribute ID
-	
-	    KeiRo::Base::Coord2         meanCoord;
-	    KeiRo::Base::Coord2         *leftBottomCoordPtr;    // area of the tree cell
-	    double                      *areaCoveragePtr;       // area coverage of the tree node
-	    KeiRo::Base::Rectangle2     *boundingBoxPtr;        // bounding box of the tree cell
-	
-	    vector< unsigned int >      leafIDVec;              // id in samples
-	    map< unsigned int, unsigned int >      childMap;    // vid of children in TreeGraph
-		unsigned int                parentID;               // each tree node has one parent node, the root has the parent node as itself
-	    
-        //------------------------------------------------------------------------------
-        //	Constructors & Destructors
-        //------------------------------------------------------------------------------
-        // default constructor
-        TreeVertexProperty( void );
-        // copy constructor
-        TreeVertexProperty( const TreeVertexProperty & c ) {}
-        // destructor
-        virtual ~TreeVertexProperty( void ) {}
-
-        //------------------------------------------------------------------------------
-        //	Assignment operators
-        //------------------------------------------------------------------------------
-
-        //------------------------------------------------------------------------------
-        //	Reference to elements
-        //------------------------------------------------------------------------------
-
-        //------------------------------------------------------------------------------
-        //	Special functions
-        //------------------------------------------------------------------------------
-
-        void        init( void )		{ _init(); }
-
-        //------------------------------------------------------------------------------
-        //	Friend functions
-        //------------------------------------------------------------------------------
-
-        //------------------------------------------------------------------------------
-        //	I/O functions
-        //------------------------------------------------------------------------------
-        // output
-        friend ostream &	operator << ( ostream & s, const TreeVertexProperty & v );
-        // input
-        friend istream &	operator >> ( istream & s, TreeVertexProperty & v );
-        // class name
-        virtual const char * className( void ) const { return "TreeVertexProperty"; }
-
-    };
-
-} // namespace Graph
-
-#endif // _Graph_TreeVertexProperty_H
Index: Graph/src/SchematicVertexProperty.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// BaseVertexProperty.cc\r\n//\t: program file for 2D coordinates\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Dec 27 23:15:32 2017\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <iostream>\r\n#include <iomanip>\r\n#include <cctype>\r\n#include <cmath>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\n#include \"SchematicVertexProperty.h\"\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tMacro Definitions\r\n//------------------------------------------------------------------------------\r\n\r\nnamespace Graph {\r\n\r\n//------------------------------------------------------------------------------\r\n//\tProtected Functions\r\n//------------------------------------------------------------------------------\r\n//\r\n//  BoundaryVertexProperty::_init -- initialize the graph.\r\n//\r\n//  Inputs\r\n//  none\r\n//\r\n//  Outputs\r\n//  none\r\n//\r\n\tvoid SchematicVertexProperty::_init( void ) {\r\n\t\tBaseVertexProperty::init();\r\n\t\t\r\n\t\tinitID = 0;\r\n\t\tisFixed = false;\r\n\t\t\r\n\t\tgeoPtr = NULL;\r\n\t\tsmoothPtr = NULL;\r\n\t\tcentroidPtr = NULL;\r\n\t}\r\n\r\n//------------------------------------------------------------------------------\r\n//\tPublic functions\r\n//------------------------------------------------------------------------------\r\n\r\n//------------------------------------------------------------------------------\r\n//\tConstructors\r\n//------------------------------------------------------------------------------\r\n\r\n//\r\n//  BoundaryVertexProperty::BoundaryVertexProperty -- default constructor\r\n//\r\n//  Inputs\r\n//  none\r\n//\r\n//  Outputs\r\n//  none\r\n//\r\n\tSchematicVertexProperty::SchematicVertexProperty() {\r\n\t\t_init();\r\n\t}\r\n\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tAssignment operators\r\n//------------------------------------------------------------------------------\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tI/O functions\r\n//------------------------------------------------------------------------------\r\n\r\n//\r\n//  operator << --\toutput\r\n//\r\n//  Inputs\r\n//\tstream\t: reference to output stream\r\n//\tobj\t: BoundaryVertexProperty\r\n//\r\n//  Outputs\r\n//\treference to output stream\r\n//\r\n\tostream &operator<<( ostream &stream, const SchematicVertexProperty &obj ) {\r\n\t\t// set the output formatting\r\n\t\tstream << setiosflags( ios::showpoint );\r\n\t\tstream << setprecision( 8 );\r\n\t\tstream << endl;\r\n\t\t\r\n\t\treturn stream;\r\n\t}\r\n\r\n\r\n//\r\n//  operator >> --\tinput\r\n//\r\n//  Inputs\r\n//\tstream\t: reference to output stream\r\n//\tobj\t: BoundaryVertexProperty\r\n//\r\n//  Outputs\r\n//\treference to input stream\r\n//\r\n\tistream &operator>>( istream &stream, SchematicVertexProperty &obj ) {\r\n\t\treturn stream;\r\n\t}\r\n\t\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Graph/src/SchematicVertexProperty.cpp b/Graph/src/SchematicVertexProperty.cpp
--- a/Graph/src/SchematicVertexProperty.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Graph/src/SchematicVertexProperty.cpp	(date 1729410604510)
@@ -1,121 +1,0 @@
-//******************************************************************************
-// BaseVertexProperty.cc
-//	: program file for 2D coordinates
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Dec 27 23:15:32 2017
-//
-//******************************************************************************
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <iostream>
-#include <iomanip>
-#include <cctype>
-#include <cmath>
-#include <algorithm>
-
-using namespace std;
-
-#include "SchematicVertexProperty.h"
-
-
-//------------------------------------------------------------------------------
-//	Macro Definitions
-//------------------------------------------------------------------------------
-
-namespace Graph {
-
-//------------------------------------------------------------------------------
-//	Protected Functions
-//------------------------------------------------------------------------------
-//
-//  BoundaryVertexProperty::_init -- initialize the graph.
-//
-//  Inputs
-//  none
-//
-//  Outputs
-//  none
-//
-	void SchematicVertexProperty::_init( void ) {
-		BaseVertexProperty::init();
-		
-		initID = 0;
-		isFixed = false;
-		
-		geoPtr = NULL;
-		smoothPtr = NULL;
-		centroidPtr = NULL;
-	}
-
-//------------------------------------------------------------------------------
-//	Public functions
-//------------------------------------------------------------------------------
-
-//------------------------------------------------------------------------------
-//	Constructors
-//------------------------------------------------------------------------------
-
-//
-//  BoundaryVertexProperty::BoundaryVertexProperty -- default constructor
-//
-//  Inputs
-//  none
-//
-//  Outputs
-//  none
-//
-	SchematicVertexProperty::SchematicVertexProperty() {
-		_init();
-	}
-
-
-
-//------------------------------------------------------------------------------
-//	Assignment operators
-//------------------------------------------------------------------------------
-
-
-//------------------------------------------------------------------------------
-//	I/O functions
-//------------------------------------------------------------------------------
-
-//
-//  operator << --	output
-//
-//  Inputs
-//	stream	: reference to output stream
-//	obj	: BoundaryVertexProperty
-//
-//  Outputs
-//	reference to output stream
-//
-	ostream &operator<<( ostream &stream, const SchematicVertexProperty &obj ) {
-		// set the output formatting
-		stream << setiosflags( ios::showpoint );
-		stream << setprecision( 8 );
-		stream << endl;
-		
-		return stream;
-	}
-
-
-//
-//  operator >> --	input
-//
-//  Inputs
-//	stream	: reference to output stream
-//	obj	: BoundaryVertexProperty
-//
-//  Outputs
-//	reference to input stream
-//
-	istream &operator>>( istream &stream, SchematicVertexProperty &obj ) {
-		return stream;
-	}
-	
-}
\ No newline at end of file
Index: Graph/src/GridEdgeProperty.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// GridEdgeProperty.h\r\n//\t: header file for grid edge property\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Feb 09 23:16:12 2020\r\n//\r\n//******************************************************************************\r\n\r\n#ifndef\t_Graph_GridEdgeProperty_H\r\n#define _Graph_GridEdgeProperty_H\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <iostream>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\n#include \"Coord2.h\"\r\n#include \"BaseEdgeProperty.h\"\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Macros\r\n//------------------------------------------------------------------------------\r\n\r\nnamespace Graph {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tDefining Classes\r\n    //------------------------------------------------------------------------------\r\n    class GridEdgeProperty: public BaseEdgeProperty {\r\n\r\n    private:\r\n\r\n    protected:\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tSpecial functions\r\n        //------------------------------------------------------------------------------\r\n        void\t\t    _init( void );\r\n\r\n    public:\r\n\r\n        double            geoAngle;\r\n        double            smoothAngle;\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tConstructors\r\n        //------------------------------------------------------------------------------\r\n        // default constructor\r\n        GridEdgeProperty( void );\r\n        // copy constructor\r\n        GridEdgeProperty( const GridEdgeProperty & e ) {\r\n           id\t    = e.id;\r\n           weight\t= e.weight;\r\n        }\r\n        // destructor\r\n        virtual ~GridEdgeProperty( void ) {}\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tAssignment operators\r\n        //------------------------------------------------------------------------------\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tReference to elements\r\n        //------------------------------------------------------------------------------\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tSpecial functions\r\n        //------------------------------------------------------------------------------\r\n\r\n        void        init( void )\t\t      { _init(); }\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tFriend functions\r\n        //------------------------------------------------------------------------------\r\n\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tI/O functions\r\n        //------------------------------------------------------------------------------\r\n        // output\r\n        friend ostream &\toperator << ( ostream & s, const GridEdgeProperty & v );\r\n        // input\r\n        friend istream &\toperator >> ( istream & s, GridEdgeProperty & v );\r\n        // class name\r\n        virtual const char * className( void ) const { return \"GridEdgeProperty\"; }\r\n\r\n    };\r\n\r\n} // namespace Graph\r\n\r\n#endif // _Graph_GridEdgeProperty_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Graph/src/GridEdgeProperty.h b/Graph/src/GridEdgeProperty.h
--- a/Graph/src/GridEdgeProperty.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Graph/src/GridEdgeProperty.h	(date 1729410604520)
@@ -1,97 +1,0 @@
-//******************************************************************************
-// GridEdgeProperty.h
-//	: header file for grid edge property
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Feb 09 23:16:12 2020
-//
-//******************************************************************************
-
-#ifndef	_Graph_GridEdgeProperty_H
-#define _Graph_GridEdgeProperty_H
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <iostream>
-#include <vector>
-
-using namespace std;
-
-#include "Coord2.h"
-#include "BaseEdgeProperty.h"
-
-//------------------------------------------------------------------------------
-//	Defining Macros
-//------------------------------------------------------------------------------
-
-namespace Graph {
-
-    //------------------------------------------------------------------------------
-    //	Defining Classes
-    //------------------------------------------------------------------------------
-    class GridEdgeProperty: public BaseEdgeProperty {
-
-    private:
-
-    protected:
-
-        //------------------------------------------------------------------------------
-        //	Special functions
-        //------------------------------------------------------------------------------
-        void		    _init( void );
-
-    public:
-
-        double            geoAngle;
-        double            smoothAngle;
-
-        //------------------------------------------------------------------------------
-        //	Constructors
-        //------------------------------------------------------------------------------
-        // default constructor
-        GridEdgeProperty( void );
-        // copy constructor
-        GridEdgeProperty( const GridEdgeProperty & e ) {
-           id	    = e.id;
-           weight	= e.weight;
-        }
-        // destructor
-        virtual ~GridEdgeProperty( void ) {}
-
-        //------------------------------------------------------------------------------
-        //	Assignment operators
-        //------------------------------------------------------------------------------
-
-        //------------------------------------------------------------------------------
-        //	Reference to elements
-        //------------------------------------------------------------------------------
-
-        //------------------------------------------------------------------------------
-        //	Special functions
-        //------------------------------------------------------------------------------
-
-        void        init( void )		      { _init(); }
-
-        //------------------------------------------------------------------------------
-        //	Friend functions
-        //------------------------------------------------------------------------------
-
-
-        //------------------------------------------------------------------------------
-        //	I/O functions
-        //------------------------------------------------------------------------------
-        // output
-        friend ostream &	operator << ( ostream & s, const GridEdgeProperty & v );
-        // input
-        friend istream &	operator >> ( istream & s, GridEdgeProperty & v );
-        // class name
-        virtual const char * className( void ) const { return "GridEdgeProperty"; }
-
-    };
-
-} // namespace Graph
-
-#endif // _Graph_GridEdgeProperty_H
Index: Graph/src/TreeEdgeProperty.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// TreeEdgeProperty.xpp\r\n//\t: program file for tree edge property\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Feb 09 23:16:12 2020\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <iostream>\r\n#include <iomanip>\r\n#include <cctype>\r\n#include <cmath>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\n#include \"TreeEdgeProperty.h\"\r\n\r\nnamespace Graph {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPrivate Functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tProtected Functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  TreeEdgeProperty::_init -- initialize the graph.\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void TreeEdgeProperty::_init( void )\r\n    {\r\n        BaseEdgeProperty::_init();\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPublic functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tConstructors & Destructors\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  TreeEdgeProperty::TreeEdgeProperty -- default constructor\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    TreeEdgeProperty::TreeEdgeProperty()\r\n    {\r\n        _init();\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tAssignment operators\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tI/O functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  operator << --\toutput\r\n    //\r\n    //  Inputs\r\n    //\tstream\t: reference to output stream\r\n    //\tobj\t: TreeEdgeProperty\r\n    //\r\n    //  Outputs\r\n    //\treference to output stream\r\n    //\r\n    ostream & operator << ( ostream & stream, const TreeEdgeProperty & obj )\r\n    {\r\n        // set the output formatting\r\n        stream << setiosflags( ios::showpoint );\r\n        stream << setprecision( 8 );\r\n        stream << endl;\r\n\r\n        return stream;\r\n    }\r\n\r\n\r\n    //\r\n    //  operator >> --\tinput\r\n    //\r\n    //  Inputs\r\n    //\tstream\t: reference to output stream\r\n    //\tobj\t: TreeEdgeProperty\r\n    //\r\n    //  Outputs\r\n    //\treference to input stream\r\n    //\r\n    istream & operator >> ( istream & stream, TreeEdgeProperty & obj )\r\n    {\r\n        return stream;\r\n    }\r\n\r\n} // namespace Graph
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Graph/src/TreeEdgeProperty.cpp b/Graph/src/TreeEdgeProperty.cpp
--- a/Graph/src/TreeEdgeProperty.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Graph/src/TreeEdgeProperty.cpp	(date 1729410604540)
@@ -1,112 +1,0 @@
-//******************************************************************************
-// TreeEdgeProperty.xpp
-//	: program file for tree edge property
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Feb 09 23:16:12 2020
-//
-//******************************************************************************
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <iostream>
-#include <iomanip>
-#include <cctype>
-#include <cmath>
-#include <algorithm>
-
-using namespace std;
-
-#include "TreeEdgeProperty.h"
-
-namespace Graph {
-
-    //------------------------------------------------------------------------------
-    //	Private Functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Protected Functions
-    //------------------------------------------------------------------------------
-    //
-    //  TreeEdgeProperty::_init -- initialize the graph.
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    //
-    void TreeEdgeProperty::_init( void )
-    {
-        BaseEdgeProperty::_init();
-    }
-
-    //------------------------------------------------------------------------------
-    //	Public functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Constructors & Destructors
-    //------------------------------------------------------------------------------
-    //
-    //  TreeEdgeProperty::TreeEdgeProperty -- default constructor
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    //
-    TreeEdgeProperty::TreeEdgeProperty()
-    {
-        _init();
-    }
-
-    //------------------------------------------------------------------------------
-    //	Assignment operators
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	I/O functions
-    //------------------------------------------------------------------------------
-    //
-    //  operator << --	output
-    //
-    //  Inputs
-    //	stream	: reference to output stream
-    //	obj	: TreeEdgeProperty
-    //
-    //  Outputs
-    //	reference to output stream
-    //
-    ostream & operator << ( ostream & stream, const TreeEdgeProperty & obj )
-    {
-        // set the output formatting
-        stream << setiosflags( ios::showpoint );
-        stream << setprecision( 8 );
-        stream << endl;
-
-        return stream;
-    }
-
-
-    //
-    //  operator >> --	input
-    //
-    //  Inputs
-    //	stream	: reference to output stream
-    //	obj	: TreeEdgeProperty
-    //
-    //  Outputs
-    //	reference to input stream
-    //
-    istream & operator >> ( istream & stream, TreeEdgeProperty & obj )
-    {
-        return stream;
-    }
-
-} // namespace Graph
\ No newline at end of file
Index: Graph/src/BaseGraphProperty.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// BaseGraphProperty.h\r\n//\t: header file for base graph property\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Dec 27 23:16:12 2018\r\n//\r\n//******************************************************************************\r\n\r\n#ifndef\t_Graph_BaseGraphProperty_H\r\n#define _Graph_BaseGraphProperty_H\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\n#include \"Coord2.h\"\r\n#include \"Common.h\"\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Macros\r\n//------------------------------------------------------------------------------\r\n\r\nnamespace Graph {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tDefining Classes\r\n    //------------------------------------------------------------------------------\r\n    class BaseGraphProperty {\r\n\r\n    private:\r\n\r\n    protected:\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tSpecial functions\r\n        //------------------------------------------------------------------------------\r\n        void\t\t    _init( double &width, double &height );\r\n\r\n    public:\r\n\r\n        KeiRo::Base::Coord2 *              centerPtr;\r\n        const double *              widthPtr;\r\n        const double *              heightPtr;\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tConstructors & Destructors\r\n        //------------------------------------------------------------------------------\r\n        // default constructor\r\n        BaseGraphProperty( void );\r\n        // copy constructor\r\n        BaseGraphProperty( const BaseGraphProperty & c ) {}\r\n        // destructor\r\n        virtual ~BaseGraphProperty( void ) {}\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tAssignment operators\r\n        //------------------------------------------------------------------------------\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tReference to elements\r\n        //------------------------------------------------------------------------------\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tSpecial functions\r\n        //------------------------------------------------------------------------------\r\n\r\n        void        init( double &__width, double &__height ) {\r\n            _init( __width, __height );\r\n        }\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tFriend functions\r\n        //------------------------------------------------------------------------------\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tI/O functions\r\n        //------------------------------------------------------------------------------\r\n        // output\r\n        friend ostream &\toperator << ( ostream & s, const BaseGraphProperty & v );\r\n        // input\r\n        friend istream &\toperator >> ( istream & s, BaseGraphProperty & v );\r\n        // class name\r\n        virtual const char * className( void ) const { return \"BaseGraphProperty\"; }\r\n\r\n    };\r\n\r\n} // namespace Graph\r\n\r\n#endif // _Graph_BaseGraphProperty_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Graph/src/BaseGraphProperty.h b/Graph/src/BaseGraphProperty.h
--- a/Graph/src/BaseGraphProperty.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Graph/src/BaseGraphProperty.h	(date 1729410604550)
@@ -1,96 +1,0 @@
-//******************************************************************************
-// BaseGraphProperty.h
-//	: header file for base graph property
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Dec 27 23:16:12 2018
-//
-//******************************************************************************
-
-#ifndef	_Graph_BaseGraphProperty_H
-#define _Graph_BaseGraphProperty_H
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <iostream>
-
-using namespace std;
-
-#include "Coord2.h"
-#include "Common.h"
-
-
-//------------------------------------------------------------------------------
-//	Defining Macros
-//------------------------------------------------------------------------------
-
-namespace Graph {
-
-    //------------------------------------------------------------------------------
-    //	Defining Classes
-    //------------------------------------------------------------------------------
-    class BaseGraphProperty {
-
-    private:
-
-    protected:
-
-        //------------------------------------------------------------------------------
-        //	Special functions
-        //------------------------------------------------------------------------------
-        void		    _init( double &width, double &height );
-
-    public:
-
-        KeiRo::Base::Coord2 *              centerPtr;
-        const double *              widthPtr;
-        const double *              heightPtr;
-
-        //------------------------------------------------------------------------------
-        //	Constructors & Destructors
-        //------------------------------------------------------------------------------
-        // default constructor
-        BaseGraphProperty( void );
-        // copy constructor
-        BaseGraphProperty( const BaseGraphProperty & c ) {}
-        // destructor
-        virtual ~BaseGraphProperty( void ) {}
-
-        //------------------------------------------------------------------------------
-        //	Assignment operators
-        //------------------------------------------------------------------------------
-
-        //------------------------------------------------------------------------------
-        //	Reference to elements
-        //------------------------------------------------------------------------------
-
-        //------------------------------------------------------------------------------
-        //	Special functions
-        //------------------------------------------------------------------------------
-
-        void        init( double &__width, double &__height ) {
-            _init( __width, __height );
-        }
-
-        //------------------------------------------------------------------------------
-        //	Friend functions
-        //------------------------------------------------------------------------------
-
-        //------------------------------------------------------------------------------
-        //	I/O functions
-        //------------------------------------------------------------------------------
-        // output
-        friend ostream &	operator << ( ostream & s, const BaseGraphProperty & v );
-        // input
-        friend istream &	operator >> ( istream & s, BaseGraphProperty & v );
-        // class name
-        virtual const char * className( void ) const { return "BaseGraphProperty"; }
-
-    };
-
-} // namespace Graph
-
-#endif // _Graph_BaseGraphProperty_H
Index: Graph/src/GridGraph.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// GridGraph.cpp\r\n//\t: program file for grid graph\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Dec 27 23:16:12 2018\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n#include \"GridGraph.h\"\r\n\r\nnamespace Graph {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tCustomized Vertex Functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tCustomized Edge Functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tCustomized Layout Functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tSpecial functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  GridGraph::printGraph -- print the graph.\r\n    //\r\n    //  Inputs\r\n    //  g   : object of Grpah\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void printGraph( const GridGraph & graph )\r\n    {\r\n        cerr << \"num_vertices = \" << num_vertices( graph ) << endl;\r\n        cerr << \"num_edges = \" << num_edges( graph ) << endl;\r\n\r\n    #ifdef  DEBUG\r\n        // print vertex information\r\n        int count = 0;\r\n        BGL_FORALL_VERTICES( vd, graph, GridGraph ) {\r\n\r\n            //GridGraph::degree_size_type      degrees         = out_degree( vd, graph );\r\n            //cerr << \"vid = \" << graph[vd].id << \" level = \" << graph[vd].level\r\n            //     << \" leafSize = \" << graph[vd].leafVec.size() << endl;\r\n            //if( graph[vd].leafVec.size() == 1 ) count++;\r\n        }\r\n        cerr << \"count = \" << count << \" ?= nVertices = \" << num_vertices( graph ) << endl;\r\n    #endif  // DEBUG\r\n\r\n    #ifdef  DEBUG\r\n        // print edge information\r\n        BGL_FORALL_EDGES( ed, graph, GridGraph ) {\r\n\r\n            GridGraph::vertex_descriptor vdS = source( ed, graph );\r\n            GridGraph::vertex_descriptor vdT = target( ed, graph );\r\n\r\n            cerr << \"eid = \" << graph[ ed ].id << \" ( \" << graph[ vdS ].id << \" == \" << graph[ vdT ].id << \" ) \" << endl;\r\n        }\r\n    #endif  // DEBUG\r\n    }\r\n\r\n    //\r\n    //  GridGraph::clearGraph -- clear the graph.\r\n    //\r\n    //  Inputs\r\n    //  g   : object of Grpah\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void clearGraph( GridGraph & graph )\r\n    {\r\n        // clear edges\r\n        GridGraph::edge_iterator ei, ei_end, e_next;\r\n        tie( ei, ei_end ) = edges( graph );\r\n        for ( e_next = ei; ei != ei_end; ei = e_next ) {\r\n            e_next++;\r\n            remove_edge( *ei, graph );\r\n        }\r\n\r\n    #ifdef  SKIP\r\n        BGL_FORALL_EDGES( edge, graph, BaseGraph )\r\n        {\r\n            remove_edge( edge, graph );\r\n        }\r\n    #endif  // SKIP\r\n\r\n        // clear vertices\r\n        pair< GridGraph::vertex_iterator, GridGraph::vertex_iterator > vp;\r\n        for ( vp = vertices( graph ); vp.first != vp.second;  ) {\r\n            GridGraph::vertex_descriptor vd = (*vp.first);\r\n            ++vp.first;\r\n            clear_vertex( vd, graph );\r\n            remove_vertex( vd, graph );\r\n        }\r\n    }\r\n\r\n} // namespace Graph
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Graph/src/GridGraph.cpp b/Graph/src/GridGraph.cpp
--- a/Graph/src/GridGraph.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Graph/src/GridGraph.cpp	(date 1729410604570)
@@ -1,108 +1,0 @@
-//******************************************************************************
-// GridGraph.cpp
-//	: program file for grid graph
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Dec 27 23:16:12 2018
-//
-//******************************************************************************
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-#include "GridGraph.h"
-
-namespace Graph {
-
-    //------------------------------------------------------------------------------
-    //	Customized Vertex Functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Customized Edge Functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Customized Layout Functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Special functions
-    //------------------------------------------------------------------------------
-    //
-    //  GridGraph::printGraph -- print the graph.
-    //
-    //  Inputs
-    //  g   : object of Grpah
-    //
-    //  Outputs
-    //  none
-    //
-    void printGraph( const GridGraph & graph )
-    {
-        cerr << "num_vertices = " << num_vertices( graph ) << endl;
-        cerr << "num_edges = " << num_edges( graph ) << endl;
-
-    #ifdef  DEBUG
-        // print vertex information
-        int count = 0;
-        BGL_FORALL_VERTICES( vd, graph, GridGraph ) {
-
-            //GridGraph::degree_size_type      degrees         = out_degree( vd, graph );
-            //cerr << "vid = " << graph[vd].id << " level = " << graph[vd].level
-            //     << " leafSize = " << graph[vd].leafVec.size() << endl;
-            //if( graph[vd].leafVec.size() == 1 ) count++;
-        }
-        cerr << "count = " << count << " ?= nVertices = " << num_vertices( graph ) << endl;
-    #endif  // DEBUG
-
-    #ifdef  DEBUG
-        // print edge information
-        BGL_FORALL_EDGES( ed, graph, GridGraph ) {
-
-            GridGraph::vertex_descriptor vdS = source( ed, graph );
-            GridGraph::vertex_descriptor vdT = target( ed, graph );
-
-            cerr << "eid = " << graph[ ed ].id << " ( " << graph[ vdS ].id << " == " << graph[ vdT ].id << " ) " << endl;
-        }
-    #endif  // DEBUG
-    }
-
-    //
-    //  GridGraph::clearGraph -- clear the graph.
-    //
-    //  Inputs
-    //  g   : object of Grpah
-    //
-    //  Outputs
-    //  none
-    //
-    void clearGraph( GridGraph & graph )
-    {
-        // clear edges
-        GridGraph::edge_iterator ei, ei_end, e_next;
-        tie( ei, ei_end ) = edges( graph );
-        for ( e_next = ei; ei != ei_end; ei = e_next ) {
-            e_next++;
-            remove_edge( *ei, graph );
-        }
-
-    #ifdef  SKIP
-        BGL_FORALL_EDGES( edge, graph, BaseGraph )
-        {
-            remove_edge( edge, graph );
-        }
-    #endif  // SKIP
-
-        // clear vertices
-        pair< GridGraph::vertex_iterator, GridGraph::vertex_iterator > vp;
-        for ( vp = vertices( graph ); vp.first != vp.second;  ) {
-            GridGraph::vertex_descriptor vd = (*vp.first);
-            ++vp.first;
-            clear_vertex( vd, graph );
-            remove_vertex( vd, graph );
-        }
-    }
-
-} // namespace Graph
\ No newline at end of file
Index: Graph/src/TreeEdgeProperty.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// TreeEdgeProperty.h\r\n//\t: header file for tree edge property\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Feb 09 23:16:12 2020\r\n//\r\n//******************************************************************************\r\n\r\n#ifndef\t_Graph_TreeEdgeProperty_H\r\n#define _Graph_TreeEdgeProperty_H\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <iostream>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\n#include \"Coord2.h\"\r\n#include \"BaseEdgeProperty.h\"\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Macros\r\n//------------------------------------------------------------------------------\r\n\r\nnamespace Graph {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tDefining Classes\r\n    //------------------------------------------------------------------------------\r\n    class TreeEdgeProperty: public BaseEdgeProperty {\r\n\r\n    private:\r\n    protected:\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tSpecial functions\r\n        //------------------------------------------------------------------------------\r\n        void\t\t    _init( void );\r\n\r\n    public:\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tConstructors\r\n        //------------------------------------------------------------------------------\r\n        // default constructor\r\n        TreeEdgeProperty( void );\r\n        // copy constructor\r\n        TreeEdgeProperty( const TreeEdgeProperty & e ) {\r\n           id\t    = e.id;\r\n           weight\t= e.weight;\r\n        }\r\n        // destructor\r\n        virtual ~TreeEdgeProperty( void ) {}\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tAssignment operators\r\n        //------------------------------------------------------------------------------\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tReference to elements\r\n        //------------------------------------------------------------------------------\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tSpecial functions\r\n        //------------------------------------------------------------------------------\r\n\r\n        void        init( void )\t\t      { _init(); }\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tFriend functions\r\n        //------------------------------------------------------------------------------\r\n\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tI/O functions\r\n        //------------------------------------------------------------------------------\r\n        // output\r\n        friend ostream &\toperator << ( ostream & s, const TreeEdgeProperty & v );\r\n        // input\r\n        friend istream &\toperator >> ( istream & s, TreeEdgeProperty & v );\r\n        // class name\r\n        virtual const char * className( void ) const { return \"TreeEdgeProperty\"; }\r\n\r\n    };\r\n\r\n} // namespace Graph\r\n\r\n#endif // _Graph_TreeEdgeProperty_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Graph/src/TreeEdgeProperty.h b/Graph/src/TreeEdgeProperty.h
--- a/Graph/src/TreeEdgeProperty.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Graph/src/TreeEdgeProperty.h	(date 1729410604580)
@@ -1,93 +1,0 @@
-//******************************************************************************
-// TreeEdgeProperty.h
-//	: header file for tree edge property
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Feb 09 23:16:12 2020
-//
-//******************************************************************************
-
-#ifndef	_Graph_TreeEdgeProperty_H
-#define _Graph_TreeEdgeProperty_H
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <iostream>
-#include <vector>
-
-using namespace std;
-
-#include "Coord2.h"
-#include "BaseEdgeProperty.h"
-
-//------------------------------------------------------------------------------
-//	Defining Macros
-//------------------------------------------------------------------------------
-
-namespace Graph {
-
-    //------------------------------------------------------------------------------
-    //	Defining Classes
-    //------------------------------------------------------------------------------
-    class TreeEdgeProperty: public BaseEdgeProperty {
-
-    private:
-    protected:
-
-        //------------------------------------------------------------------------------
-        //	Special functions
-        //------------------------------------------------------------------------------
-        void		    _init( void );
-
-    public:
-
-        //------------------------------------------------------------------------------
-        //	Constructors
-        //------------------------------------------------------------------------------
-        // default constructor
-        TreeEdgeProperty( void );
-        // copy constructor
-        TreeEdgeProperty( const TreeEdgeProperty & e ) {
-           id	    = e.id;
-           weight	= e.weight;
-        }
-        // destructor
-        virtual ~TreeEdgeProperty( void ) {}
-
-        //------------------------------------------------------------------------------
-        //	Assignment operators
-        //------------------------------------------------------------------------------
-
-        //------------------------------------------------------------------------------
-        //	Reference to elements
-        //------------------------------------------------------------------------------
-
-        //------------------------------------------------------------------------------
-        //	Special functions
-        //------------------------------------------------------------------------------
-
-        void        init( void )		      { _init(); }
-
-        //------------------------------------------------------------------------------
-        //	Friend functions
-        //------------------------------------------------------------------------------
-
-
-        //------------------------------------------------------------------------------
-        //	I/O functions
-        //------------------------------------------------------------------------------
-        // output
-        friend ostream &	operator << ( ostream & s, const TreeEdgeProperty & v );
-        // input
-        friend istream &	operator >> ( istream & s, TreeEdgeProperty & v );
-        // class name
-        virtual const char * className( void ) const { return "TreeEdgeProperty"; }
-
-    };
-
-} // namespace Graph
-
-#endif // _Graph_TreeEdgeProperty_H
Index: Graph/src/TreeGraphProperty.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// TreeGraphProperty.cpp\r\n//\t: program file for tree graph\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Dec 27 23:15:32 2017\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <iostream>\r\n#include <iomanip>\r\n#include <cctype>\r\n#include <cmath>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\n#include \"TreeGraphProperty.h\"\r\n\r\nnamespace Graph {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPrivate Functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tProtected Functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  TreeGraphProperty::_init -- initialize the graph.\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void TreeGraphProperty::_init( double &width, double &height )\r\n    {\r\n        BaseGraphProperty::_init( width, height );\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPublic functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tConstructors & Destructors\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  TreeGraphProperty::TreeGraphProperty -- default constructor\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    TreeGraphProperty::TreeGraphProperty()\r\n    {\r\n        //BaseGraphProperty::init();\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tAssignment operators\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tI/O functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  operator << --\toutput\r\n    //\r\n    //  Inputs\r\n    //\tstream\t: reference to output stream\r\n    //\tobj\t: TreeGraphProperty\r\n    //\r\n    //  Outputs\r\n    //\treference to output stream\r\n    //\r\n    ostream & operator << ( ostream & stream, const TreeGraphProperty & obj )\r\n    {\r\n        // set the output formatting\r\n        stream << setiosflags( ios::showpoint );\r\n        stream << setprecision( 8 );\r\n        stream << endl;\r\n\r\n        return stream;\r\n    }\r\n\r\n\r\n    //\r\n    //  operator >> --\tinput\r\n    //\r\n    //  Inputs\r\n    //\tstream\t: reference to output stream\r\n    //\tobj\t: TreeGraphProperty\r\n    //\r\n    //  Outputs\r\n    //\treference to input stream\r\n    //\r\n    istream & operator >> ( istream & stream, TreeGraphProperty & obj )\r\n    {\r\n        return stream;\r\n    }\r\n\r\n} // namespace Graph
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Graph/src/TreeGraphProperty.cpp b/Graph/src/TreeGraphProperty.cpp
--- a/Graph/src/TreeGraphProperty.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Graph/src/TreeGraphProperty.cpp	(date 1729410604590)
@@ -1,112 +1,0 @@
-//******************************************************************************
-// TreeGraphProperty.cpp
-//	: program file for tree graph
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Dec 27 23:15:32 2017
-//
-//******************************************************************************
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <iostream>
-#include <iomanip>
-#include <cctype>
-#include <cmath>
-#include <algorithm>
-
-using namespace std;
-
-#include "TreeGraphProperty.h"
-
-namespace Graph {
-
-    //------------------------------------------------------------------------------
-    //	Private Functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Protected Functions
-    //------------------------------------------------------------------------------
-    //
-    //  TreeGraphProperty::_init -- initialize the graph.
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    //
-    void TreeGraphProperty::_init( double &width, double &height )
-    {
-        BaseGraphProperty::_init( width, height );
-    }
-
-    //------------------------------------------------------------------------------
-    //	Public functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Constructors & Destructors
-    //------------------------------------------------------------------------------
-    //
-    //  TreeGraphProperty::TreeGraphProperty -- default constructor
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    //
-    TreeGraphProperty::TreeGraphProperty()
-    {
-        //BaseGraphProperty::init();
-    }
-
-    //------------------------------------------------------------------------------
-    //	Assignment operators
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	I/O functions
-    //------------------------------------------------------------------------------
-    //
-    //  operator << --	output
-    //
-    //  Inputs
-    //	stream	: reference to output stream
-    //	obj	: TreeGraphProperty
-    //
-    //  Outputs
-    //	reference to output stream
-    //
-    ostream & operator << ( ostream & stream, const TreeGraphProperty & obj )
-    {
-        // set the output formatting
-        stream << setiosflags( ios::showpoint );
-        stream << setprecision( 8 );
-        stream << endl;
-
-        return stream;
-    }
-
-
-    //
-    //  operator >> --	input
-    //
-    //  Inputs
-    //	stream	: reference to output stream
-    //	obj	: TreeGraphProperty
-    //
-    //  Outputs
-    //	reference to input stream
-    //
-    istream & operator >> ( istream & stream, TreeGraphProperty & obj )
-    {
-        return stream;
-    }
-
-} // namespace Graph
\ No newline at end of file
Index: Graph/src/BaseEdgeProperty.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// BaseEdgeProperty.h\r\n//\t: header file for base edge property\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Dec 27 23:16:12 2018\r\n//\r\n//******************************************************************************\r\n\r\n#ifndef\t_Graph_BaseEdgeProperty_H\r\n#define _Graph_BaseEdgeProperty_H\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <iostream>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\n#include \"Coord2.h\"\r\n#include \"Edge2.h\"\r\n//#include \"GraphicsEdgeItem.h\"\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Macros\r\n//------------------------------------------------------------------------------\r\n\r\nnamespace Graph {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tDefining Classes\r\n    //------------------------------------------------------------------------------\r\n    class BaseEdgeProperty {\r\n\r\n    private:\r\n\r\n    protected:\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tSpecial functions\r\n        //------------------------------------------------------------------------------\r\n        void\t\t    _init( void );\r\n\r\n    public:\r\n\r\n        unsigned int                id;\r\n\r\n        double                      angle;\r\n        double                      weight;\r\n        bool                        visit;\r\n        int                         visitedTimes;\r\n\t\tint                         level;\r\n        \r\n        bool                        isFore;\r\n        bool                        isBack;\r\n        bool                        isShow;\r\n\r\n        unsigned int                itemID;             // item ID for graphics\r\n\t    KeiRo::Base::Edge2          edge;               // store non-straight-line edge\r\n\t\t\r\n        //Ui::Vector::GraphicsEdgeItem * itemPtr;\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tConstructors & Destructors\r\n        //------------------------------------------------------------------------------\r\n        // default constructor\r\n        BaseEdgeProperty( void );\r\n        // copy constructor\r\n        BaseEdgeProperty( const BaseEdgeProperty & e ) {\r\n            id\t    = e.id;\r\n            weight\t= e.weight;\r\n        }\r\n        // destructor\r\n        virtual ~BaseEdgeProperty( void ) {}\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tAssignment operators\r\n        //------------------------------------------------------------------------------\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tReference to elements\r\n        //------------------------------------------------------------------------------\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tSpecial functions\r\n        //------------------------------------------------------------------------------\r\n\r\n        void        init( void )\t\t      { _init(); }\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tFriend functions\r\n        //------------------------------------------------------------------------------\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tI/O functions\r\n        //------------------------------------------------------------------------------\r\n        // output\r\n        friend ostream &\toperator << ( ostream & s, const BaseEdgeProperty & v );\r\n        // input\r\n        friend istream &\toperator >> ( istream & s, BaseEdgeProperty & v );\r\n        // class name\r\n        virtual const char * className( void ) const { return \"BaseEdgeProperty\"; }\r\n    };\r\n\r\n} // namespace Graph\r\n\r\n#endif // _Graph_BaseEdgeProperty_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Graph/src/BaseEdgeProperty.h b/Graph/src/BaseEdgeProperty.h
--- a/Graph/src/BaseEdgeProperty.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Graph/src/BaseEdgeProperty.h	(date 1729410604600)
@@ -1,110 +1,0 @@
-//******************************************************************************
-// BaseEdgeProperty.h
-//	: header file for base edge property
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Dec 27 23:16:12 2018
-//
-//******************************************************************************
-
-#ifndef	_Graph_BaseEdgeProperty_H
-#define _Graph_BaseEdgeProperty_H
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <iostream>
-#include <vector>
-
-using namespace std;
-
-#include "Coord2.h"
-#include "Edge2.h"
-//#include "GraphicsEdgeItem.h"
-
-//------------------------------------------------------------------------------
-//	Defining Macros
-//------------------------------------------------------------------------------
-
-namespace Graph {
-
-    //------------------------------------------------------------------------------
-    //	Defining Classes
-    //------------------------------------------------------------------------------
-    class BaseEdgeProperty {
-
-    private:
-
-    protected:
-
-        //------------------------------------------------------------------------------
-        //	Special functions
-        //------------------------------------------------------------------------------
-        void		    _init( void );
-
-    public:
-
-        unsigned int                id;
-
-        double                      angle;
-        double                      weight;
-        bool                        visit;
-        int                         visitedTimes;
-		int                         level;
-        
-        bool                        isFore;
-        bool                        isBack;
-        bool                        isShow;
-
-        unsigned int                itemID;             // item ID for graphics
-	    KeiRo::Base::Edge2          edge;               // store non-straight-line edge
-		
-        //Ui::Vector::GraphicsEdgeItem * itemPtr;
-
-        //------------------------------------------------------------------------------
-        //	Constructors & Destructors
-        //------------------------------------------------------------------------------
-        // default constructor
-        BaseEdgeProperty( void );
-        // copy constructor
-        BaseEdgeProperty( const BaseEdgeProperty & e ) {
-            id	    = e.id;
-            weight	= e.weight;
-        }
-        // destructor
-        virtual ~BaseEdgeProperty( void ) {}
-
-        //------------------------------------------------------------------------------
-        //	Assignment operators
-        //------------------------------------------------------------------------------
-
-        //------------------------------------------------------------------------------
-        //	Reference to elements
-        //------------------------------------------------------------------------------
-
-        //------------------------------------------------------------------------------
-        //	Special functions
-        //------------------------------------------------------------------------------
-
-        void        init( void )		      { _init(); }
-
-        //------------------------------------------------------------------------------
-        //	Friend functions
-        //------------------------------------------------------------------------------
-
-        //------------------------------------------------------------------------------
-        //	I/O functions
-        //------------------------------------------------------------------------------
-        // output
-        friend ostream &	operator << ( ostream & s, const BaseEdgeProperty & v );
-        // input
-        friend istream &	operator >> ( istream & s, BaseEdgeProperty & v );
-        // class name
-        virtual const char * className( void ) const { return "BaseEdgeProperty"; }
-    };
-
-} // namespace Graph
-
-#endif // _Graph_BaseEdgeProperty_H
Index: Graph/src/BaseDirectedGraph.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// BaseDirectedGraph.cpp\r\n//      : program file for graph function\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Mon Mar 14 02:16:23 2019\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include \"graph/BaseDirectedGraph.h\"\r\n\r\nnamespace Graph {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tCustomized Vertex Functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tCustomized Edge Functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tCustomized Layout Functions\r\n    //------------------------------------------------------------------------------\r\n    void randomGraphLayout( BaseDirectedGraph & graph, double width, double height )\r\n    {\r\n        boost::random::minstd_rand gen;\r\n        topologyType topo( gen, -width/2.0, -height/2.0, width/2.0, height/2.0 );\r\n\r\n        PositionVec positionVec( num_vertices( graph ) );\r\n        //PositionMap position( positionVec.begin(), get( vertex_index, graph ) );\r\n        PositionMap position( positionVec.begin(), get( &BaseVertexProperty::id, graph ) );\r\n\r\n        random_graph_layout( graph, position, topo );\r\n\r\n        // write the posotion\r\n        BGL_FORALL_VERTICES( vd, graph, BaseDirectedGraph ) {\r\n                graph[ vd ].coordPtr->x() = position[ vd ][0];\r\n                graph[ vd ].coordPtr->y() = position[ vd ][1];\r\n                //cerr << \"vertexIndex[ \" << vertexIndex[ vd ] << \" ] = \" << vertexCoord[ vd ] << endl;\r\n            }\r\n    }\r\n\r\n    void fruchtermanGraphLayout( BaseDirectedGraph & graph, double width, double height )\r\n    {\r\n        boost::random::minstd_rand gen;\r\n        double shift = 1e-5;\r\n        //topologyType topo( gen, -DEFAULT_WIDTH/2.0, -DEFAULT_HEIGHT/2.0, DEFAULT_WIDTH/2.0, DEFAULT_HEIGHT/2.0 );\r\n        //topologyType topo( gen, -DEFAULT_WIDTH/shift, -DEFAULT_HEIGHT/shift, DEFAULT_WIDTH/shift, DEFAULT_HEIGHT/shift );\r\n        //topologyType topo2( gen, -DEFAULT_WIDTH/2.0, -DEFAULT_HEIGHT/2.0, DEFAULT_WIDTH/2.0, DEFAULT_HEIGHT/2.0 );\r\n        topologyType topo( gen, -1.0, -1.0, 1.0, 1.0 );\r\n        //topologyType topo( gen, -shift, -shift, shift, shift );\r\n\r\n        PositionVec positionVec( num_vertices( graph ) );\r\n        //PositionMap position( positionVec.begin(), get( vertex_index, graph ) );\r\n        PositionMap position( positionVec.begin(), get( &BaseVertexProperty::id, graph ) );\r\n        DifferenceVec differenceVec( num_vertices( graph ) );\r\n        //DifferenceMap difference( differenceVec.begin(), get( vertex_index, graph ) );\r\n        DifferenceMap difference( differenceVec.begin(), get( &BaseVertexProperty::id, graph ) );\r\n\r\n\r\n        BGL_FORALL_VERTICES( vd, graph, BaseDirectedGraph ) {\r\n                position[ vd ][0] = position[ vd ][0] * shift;\r\n                position[ vd ][1] = position[ vd ][1] * shift;\r\n                //cerr << \"vertexIndex[ \" << vertexIndex[ vd ] << \" ] = \" << position[ vd ][0] << \", \" << position[ vd ][1] << endl;\r\n            }\r\n\r\n        //fruchterman_reingold_force_directed_layout( graph, position, topo );\r\n        fruchterman_reingold_force_directed_layout( graph, position, topo,\r\n                                                    square_distance_attractive_force(),\r\n                                                    square_distance_repulsive_force(),\r\n                                                    make_grid_force_pairs( topo, position, graph ),\r\n                                                    linear_cooling< double >( 100 ),\r\n                                                    difference );\r\n\r\n        //kamada_kawai_spring_layout( graph, position, edgeWeight, topo, true, done );\r\n        //detail::graph::edge_or_side<EdgeOrSideLength, double> edge_or_side_length;\r\n        //kamada_kawai_spring_layout( graph, position, edgeWeight, topo, true );\r\n        //                            , edge_or_side_length,\r\n        //                            layout_tolerance< double >(),\r\n        //                            weight_type(1.0) );\r\n\r\n        // write the posotion\r\n        BGL_FORALL_VERTICES( vd, graph, BaseDirectedGraph ) {\r\n            graph[ vd ].coordPtr->x() = position[ vd ][0]*width/4.0;\r\n            graph[ vd ].coordPtr->y() = position[ vd ][1]*height/4.0;\r\n            //cerr << \"vertexIndex[ \" << vertexIndex[ vd ] << \" ] = \" << position[ vd ][0] << \", \" << position[ vd ][1] << endl;\r\n            //cerr << \"vertexIndex[ \" << vertexIndex[ vd ] << \" ] = \" << vertexCoord[ vd ] << endl;\r\n        }\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tSpecial functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  BaseDirectedGraph::printGraph -- print the graph.\r\n    //\r\n    //  Inputs\r\n    //  g   : object of Grpah\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void printGraph( BaseDirectedGraph & graph )\r\n    {\r\n        cerr << \"num_vertices = \" << num_vertices( graph ) << endl;\r\n        cerr << \"num_edges = \" << num_edges( graph ) << endl;\r\n\r\n    #ifdef  DEBUG\r\n        // print vertex information\r\n        BGL_FORALL_VERTICES( vd, graph, BaseDirectedGraph ) {\r\n\r\n            BaseDirectedGraph::degree_size_type      degrees         = out_degree( vd, graph );\r\n        }\r\n    #endif  // DEBUG\r\n\r\n    #ifdef  DEBUG\r\n        // print edge information\r\n        BGL_FORALL_EDGES( ed, graph, BaseDirectedGraph ) {\r\n\r\n            BaseDirectedGraph::vertex_descriptor vdS = source( ed, graph );\r\n            BaseDirectedGraph::vertex_descriptor vdT = target( ed, graph );\r\n\r\n            cerr << \"eid = \" << graph[ ed ].id << \" ( \" << graph[ vdS ].id << \" == \" << graph[ vdT ].id << \" ) \" << endl;\r\n        }\r\n    #endif  // DEBUG\r\n    }\r\n\r\n    //\r\n    //  BaseDirectedGraph::clearGraph -- clear the graph.\r\n    //\r\n    //  Inputs\r\n    //  g   : object of Graph\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void clearGraph( BaseDirectedGraph & graph )\r\n    {\r\n        // clear edges\r\n        BaseDirectedGraph::edge_iterator ei, ei_end, e_next;\r\n        tie( ei, ei_end ) = edges( graph );\r\n        for ( e_next = ei; ei != ei_end; ei = e_next ) {\r\n            e_next++;\r\n            remove_edge( *ei, graph );\r\n        }\r\n\r\n        // clear vertices\r\n        pair< BaseDirectedGraph::vertex_iterator, BaseDirectedGraph::vertex_iterator > vp;\r\n        for ( vp = vertices( graph ); vp.first != vp.second;  ) {\r\n            BaseDirectedGraph::vertex_descriptor vd = (*vp.first);\r\n            ++vp.first;\r\n            clear_vertex( vd, graph );\r\n            remove_vertex( vd, graph );\r\n        }\r\n    }\r\n\r\n} // namespace Graph
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Graph/src/BaseDirectedGraph.cpp b/Graph/src/BaseDirectedGraph.cpp
--- a/Graph/src/BaseDirectedGraph.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Graph/src/BaseDirectedGraph.cpp	(date 1729410604620)
@@ -1,163 +1,0 @@
-//******************************************************************************
-// BaseDirectedGraph.cpp
-//      : program file for graph function
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Mon Mar 14 02:16:23 2019
-//
-//******************************************************************************
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include "graph/BaseDirectedGraph.h"
-
-namespace Graph {
-
-    //------------------------------------------------------------------------------
-    //	Customized Vertex Functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Customized Edge Functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Customized Layout Functions
-    //------------------------------------------------------------------------------
-    void randomGraphLayout( BaseDirectedGraph & graph, double width, double height )
-    {
-        boost::random::minstd_rand gen;
-        topologyType topo( gen, -width/2.0, -height/2.0, width/2.0, height/2.0 );
-
-        PositionVec positionVec( num_vertices( graph ) );
-        //PositionMap position( positionVec.begin(), get( vertex_index, graph ) );
-        PositionMap position( positionVec.begin(), get( &BaseVertexProperty::id, graph ) );
-
-        random_graph_layout( graph, position, topo );
-
-        // write the posotion
-        BGL_FORALL_VERTICES( vd, graph, BaseDirectedGraph ) {
-                graph[ vd ].coordPtr->x() = position[ vd ][0];
-                graph[ vd ].coordPtr->y() = position[ vd ][1];
-                //cerr << "vertexIndex[ " << vertexIndex[ vd ] << " ] = " << vertexCoord[ vd ] << endl;
-            }
-    }
-
-    void fruchtermanGraphLayout( BaseDirectedGraph & graph, double width, double height )
-    {
-        boost::random::minstd_rand gen;
-        double shift = 1e-5;
-        //topologyType topo( gen, -DEFAULT_WIDTH/2.0, -DEFAULT_HEIGHT/2.0, DEFAULT_WIDTH/2.0, DEFAULT_HEIGHT/2.0 );
-        //topologyType topo( gen, -DEFAULT_WIDTH/shift, -DEFAULT_HEIGHT/shift, DEFAULT_WIDTH/shift, DEFAULT_HEIGHT/shift );
-        //topologyType topo2( gen, -DEFAULT_WIDTH/2.0, -DEFAULT_HEIGHT/2.0, DEFAULT_WIDTH/2.0, DEFAULT_HEIGHT/2.0 );
-        topologyType topo( gen, -1.0, -1.0, 1.0, 1.0 );
-        //topologyType topo( gen, -shift, -shift, shift, shift );
-
-        PositionVec positionVec( num_vertices( graph ) );
-        //PositionMap position( positionVec.begin(), get( vertex_index, graph ) );
-        PositionMap position( positionVec.begin(), get( &BaseVertexProperty::id, graph ) );
-        DifferenceVec differenceVec( num_vertices( graph ) );
-        //DifferenceMap difference( differenceVec.begin(), get( vertex_index, graph ) );
-        DifferenceMap difference( differenceVec.begin(), get( &BaseVertexProperty::id, graph ) );
-
-
-        BGL_FORALL_VERTICES( vd, graph, BaseDirectedGraph ) {
-                position[ vd ][0] = position[ vd ][0] * shift;
-                position[ vd ][1] = position[ vd ][1] * shift;
-                //cerr << "vertexIndex[ " << vertexIndex[ vd ] << " ] = " << position[ vd ][0] << ", " << position[ vd ][1] << endl;
-            }
-
-        //fruchterman_reingold_force_directed_layout( graph, position, topo );
-        fruchterman_reingold_force_directed_layout( graph, position, topo,
-                                                    square_distance_attractive_force(),
-                                                    square_distance_repulsive_force(),
-                                                    make_grid_force_pairs( topo, position, graph ),
-                                                    linear_cooling< double >( 100 ),
-                                                    difference );
-
-        //kamada_kawai_spring_layout( graph, position, edgeWeight, topo, true, done );
-        //detail::graph::edge_or_side<EdgeOrSideLength, double> edge_or_side_length;
-        //kamada_kawai_spring_layout( graph, position, edgeWeight, topo, true );
-        //                            , edge_or_side_length,
-        //                            layout_tolerance< double >(),
-        //                            weight_type(1.0) );
-
-        // write the posotion
-        BGL_FORALL_VERTICES( vd, graph, BaseDirectedGraph ) {
-            graph[ vd ].coordPtr->x() = position[ vd ][0]*width/4.0;
-            graph[ vd ].coordPtr->y() = position[ vd ][1]*height/4.0;
-            //cerr << "vertexIndex[ " << vertexIndex[ vd ] << " ] = " << position[ vd ][0] << ", " << position[ vd ][1] << endl;
-            //cerr << "vertexIndex[ " << vertexIndex[ vd ] << " ] = " << vertexCoord[ vd ] << endl;
-        }
-    }
-
-    //------------------------------------------------------------------------------
-    //	Special functions
-    //------------------------------------------------------------------------------
-    //
-    //  BaseDirectedGraph::printGraph -- print the graph.
-    //
-    //  Inputs
-    //  g   : object of Grpah
-    //
-    //  Outputs
-    //  none
-    //
-    void printGraph( BaseDirectedGraph & graph )
-    {
-        cerr << "num_vertices = " << num_vertices( graph ) << endl;
-        cerr << "num_edges = " << num_edges( graph ) << endl;
-
-    #ifdef  DEBUG
-        // print vertex information
-        BGL_FORALL_VERTICES( vd, graph, BaseDirectedGraph ) {
-
-            BaseDirectedGraph::degree_size_type      degrees         = out_degree( vd, graph );
-        }
-    #endif  // DEBUG
-
-    #ifdef  DEBUG
-        // print edge information
-        BGL_FORALL_EDGES( ed, graph, BaseDirectedGraph ) {
-
-            BaseDirectedGraph::vertex_descriptor vdS = source( ed, graph );
-            BaseDirectedGraph::vertex_descriptor vdT = target( ed, graph );
-
-            cerr << "eid = " << graph[ ed ].id << " ( " << graph[ vdS ].id << " == " << graph[ vdT ].id << " ) " << endl;
-        }
-    #endif  // DEBUG
-    }
-
-    //
-    //  BaseDirectedGraph::clearGraph -- clear the graph.
-    //
-    //  Inputs
-    //  g   : object of Graph
-    //
-    //  Outputs
-    //  none
-    //
-    void clearGraph( BaseDirectedGraph & graph )
-    {
-        // clear edges
-        BaseDirectedGraph::edge_iterator ei, ei_end, e_next;
-        tie( ei, ei_end ) = edges( graph );
-        for ( e_next = ei; ei != ei_end; ei = e_next ) {
-            e_next++;
-            remove_edge( *ei, graph );
-        }
-
-        // clear vertices
-        pair< BaseDirectedGraph::vertex_iterator, BaseDirectedGraph::vertex_iterator > vp;
-        for ( vp = vertices( graph ); vp.first != vp.second;  ) {
-            BaseDirectedGraph::vertex_descriptor vd = (*vp.first);
-            ++vp.first;
-            clear_vertex( vd, graph );
-            remove_vertex( vd, graph );
-        }
-    }
-
-} // namespace Graph
\ No newline at end of file
Index: Geometry/src/Seed.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\r\n#ifndef _Seed_H        // beginning of header file\r\n#define _Seed_H        // notifying that this file is included\r\n\r\n#include \"Coord2.h\"\r\n#include \"Polygon2.h\"\r\n\r\nclass Seed {\r\n\r\npublic:\r\n\t\r\n\tunsigned int id;                // id\r\n\tunsigned int gid;               // group id\r\n\tdouble weight;                  // weight\r\n\tKeiRo::Base::Coord2 *coordPtr;               // position\r\n\tKeiRo::Base::Polygon2 *voronoiCellPtr;       // cell polygon\r\n};\r\n\r\n#endif // _Seed_H\r\n\r\n// end of header file\r\n// Do not add any stuff under this line.
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Geometry/src/Seed.h b/Geometry/src/Seed.h
--- a/Geometry/src/Seed.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Geometry/src/Seed.h	(date 1729410604630)
@@ -1,22 +1,0 @@
-
-#ifndef _Seed_H        // beginning of header file
-#define _Seed_H        // notifying that this file is included
-
-#include "Coord2.h"
-#include "Polygon2.h"
-
-class Seed {
-
-public:
-	
-	unsigned int id;                // id
-	unsigned int gid;               // group id
-	double weight;                  // weight
-	KeiRo::Base::Coord2 *coordPtr;               // position
-	KeiRo::Base::Polygon2 *voronoiCellPtr;       // cell polygon
-};
-
-#endif // _Seed_H
-
-// end of header file
-// Do not add any stuff under this line.
\ No newline at end of file
Index: Graph/src/TreeGraph.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// TreeGraph.h\r\n//\t: header file for tree graph\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Sun Feb 09 23:16:12 2020\r\n//\r\n//******************************************************************************\r\n\r\n#ifndef _Graph_TreeGraph_H\r\n#define _Graph_TreeGraph_H\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <string>\r\n#include <iostream>\r\n#include <fstream>\r\n#include <vector>\r\n#include <map>\r\n#include <algorithm>\r\n#include <ctime>\r\n#include <cstdlib>\r\n\r\nusing namespace std;\r\n\r\n#include <boost/config.hpp>\r\n#include <boost/graph/graph_traits.hpp>\r\n#include <boost/graph/adjacency_list.hpp>\r\n#include <boost/graph/iteration_macros.hpp>\r\n\r\nusing namespace boost;\r\n\r\n#include \"Coord2.h\"\r\n#include \"TreeGraphProperty.h\"\r\n#include \"TreeVertexProperty.h\"\r\n#include \"TreeEdgeProperty.h\"\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Macros\r\n//------------------------------------------------------------------------------\r\n\r\nnamespace Graph {\r\n\r\n    typedef adjacency_list< listS, listS, undirectedS,\r\n            TreeVertexProperty, TreeEdgeProperty,\r\n            TreeGraphProperty >  TreeGraph;\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tSpecial functions\r\n    //------------------------------------------------------------------------------\r\n    void printGraph( const TreeGraph & g );\r\n    void clearGraph( TreeGraph & g );\r\n\r\n} // namespace Graph\r\n\r\n#endif  // _Graph_TreeGraph_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Graph/src/TreeGraph.h b/Graph/src/TreeGraph.h
--- a/Graph/src/TreeGraph.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Graph/src/TreeGraph.h	(date 1729410604640)
@@ -1,59 +1,0 @@
-//******************************************************************************
-// TreeGraph.h
-//	: header file for tree graph
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Sun Feb 09 23:16:12 2020
-//
-//******************************************************************************
-
-#ifndef _Graph_TreeGraph_H
-#define _Graph_TreeGraph_H
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <string>
-#include <iostream>
-#include <fstream>
-#include <vector>
-#include <map>
-#include <algorithm>
-#include <ctime>
-#include <cstdlib>
-
-using namespace std;
-
-#include <boost/config.hpp>
-#include <boost/graph/graph_traits.hpp>
-#include <boost/graph/adjacency_list.hpp>
-#include <boost/graph/iteration_macros.hpp>
-
-using namespace boost;
-
-#include "Coord2.h"
-#include "TreeGraphProperty.h"
-#include "TreeVertexProperty.h"
-#include "TreeEdgeProperty.h"
-
-//------------------------------------------------------------------------------
-//	Defining Macros
-//------------------------------------------------------------------------------
-
-namespace Graph {
-
-    typedef adjacency_list< listS, listS, undirectedS,
-            TreeVertexProperty, TreeEdgeProperty,
-            TreeGraphProperty >  TreeGraph;
-
-    //------------------------------------------------------------------------------
-    //	Special functions
-    //------------------------------------------------------------------------------
-    void printGraph( const TreeGraph & g );
-    void clearGraph( TreeGraph & g );
-
-} // namespace Graph
-
-#endif  // _Graph_TreeGraph_H
Index: Geometry/src/Voronoi.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//==============================================================================\r\n// Voronoi.h\r\n//  : header file for the optimization\r\n//\r\n//==============================================================================\r\n\r\n#ifndef _Voronoi_H        // begining of header file\r\n#define _Voronoi_H        // notifying that this file is included\r\n\r\n//----------------------------------------------------------------------\r\n//  Including header files\r\n//----------------------------------------------------------------------\r\n\r\n#include <iostream>\r\n#include <iomanip>\r\n#include <fstream>\r\n#include <sstream>\r\n#include <cassert>\r\n#include <cstring>\r\n#include <cmath>\r\n\r\nusing namespace std;\r\n\r\n// add to avoid apple clang 11.0.0 parser bug\r\n#define CGAL_DO_NOT_USE_BOOST_MP\r\n\r\n#include <CGAL/Exact_predicates_exact_constructions_kernel.h>\r\n//#include <CGAL/Regular_triangulation_filtered_traits_2.h>\r\n#include <CGAL/Regular_triangulation_adaptation_traits_2.h>\r\n#include <CGAL/Regular_triangulation_adaptation_policies_2.h>\r\n#include <CGAL/Regular_triangulation_2.h>\r\n#include <CGAL/Voronoi_diagram_2.h>\r\n#include <CGAL/Boolean_set_operations_2.h>\r\n#include <CGAL/bounding_box.h>\r\n#include <CGAL/Polygon_2.h>\r\n#include <CGAL/Polygon_2_algorithms.h>\r\n#include <CGAL/centroid.h>\r\n#include <CGAL/double.h>\r\n\r\n#include <boost/lexical_cast.hpp>\r\n#include \"Common.h\"\r\n#include \"Seed.h\"\r\n#include \"Polygon2.h\"\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining data types\r\n//------------------------------------------------------------------------------\r\n\r\n//Used to convert otherwise infinite rays into long line segments\r\nconst int RAY_LENGTH = 1000;\r\nconst int LINE_LENGTH = 1e8;\r\n\r\n\r\ntypedef CGAL::Exact_predicates_exact_constructions_kernel K;\r\n//typedef CGAL::Exact_predicates_inexact_constructions_kernel KI;\r\n\r\n#ifdef __linux__\r\n//typedef CGAL::Regular_triangulation_filtered_traits_2<K>  Traits;\r\n//typedef CGAL::Regular_triangulation_2<Traits> RT2;\r\n#endif  // __linux__\r\n\r\n//#ifdef __APPLE__\r\ntypedef CGAL::Regular_triangulation_2< K > RT2;\r\n//#endif  // __MAC__\r\n\r\ntypedef CGAL::Regular_triangulation_adaptation_traits_2< RT2 > AT;\r\ntypedef CGAL::Regular_triangulation_degeneracy_removal_policy_2< RT2 > DRP;\r\ntypedef CGAL::Voronoi_diagram_2< RT2, AT, DRP > VD;\r\ntypedef CGAL::Polygon_2< K >::Vertex_circulator Vertex_circulator;\r\n\r\nusing CGAL::ORIGIN;\r\n\r\n//----------------------------------------------------------------------\r\n//\tDefining macros\r\n//----------------------------------------------------------------------\r\n\r\nclass Voronoi {\r\n\r\nprivate:\r\n\t\r\n\tunsigned _id;\r\n\t// outer simpleContour of the voronoi diagram\r\n\tKeiRo::Base::Polygon2 *_contourPtr;\r\n\t\r\n\t// seeds\r\n\tvector< Seed > *_seedVecPtr;\r\n\t// map seed points and cell polygon\r\n\tvector< vector< K::Point_2 > > _polyVec2D;\r\n\t\r\n\tK::Segment_2 _convertToSeg( const CGAL::Object seg_obj, bool outgoing,\r\n\t                            bool &isLine, double &slope );\r\n\r\nprotected:\r\n\t\r\n\tvoid _init( vector< Seed > &__seedVec, KeiRo::Base::Polygon2 &__contour );\r\n\t\r\n\tvoid _clear();\r\n\r\npublic:\r\n\t\r\n\tVoronoi();                      // default constructor\r\n\tVoronoi( const Voronoi &obj );  // Copy constructor\r\n\tvirtual ~Voronoi();             // Destructor\r\n\r\n//------------------------------------------------------------------------------\r\n//  Reference to members\r\n//------------------------------------------------------------------------------\r\n\tconst unsigned int &id( void ) const { return _id; }\r\n\t\r\n\tunsigned int &id( void ) { return _id; }\r\n\t\r\n\tconst vector< Seed > *seedVec( void ) const { return _seedVecPtr; }\r\n\t\r\n\tvector< Seed > *seedVec( void ) { return _seedVecPtr; }\r\n\r\n//------------------------------------------------------------------------------\r\n//  Specific functions\r\n//------------------------------------------------------------------------------\r\n\tvoid init( vector< Seed > &__seedVec, KeiRo::Base::Polygon2 &__contour ) {\r\n\t\t_init( __seedVec, __contour );\r\n\t}\r\n\t\r\n\tvoid createVoronoiDiagram( bool isWeighted );\r\n\t\r\n\tvoid mapSeedsandPolygons( void );\r\n\r\n//------------------------------------------------------------------------------\r\n//  Initialization functions\r\n//------------------------------------------------------------------------------\r\n\r\n//------------------------------------------------------------------------------\r\n//  File I/O\r\n//------------------------------------------------------------------------------\r\n\tvoid clear( void ) { _clear(); }\r\n\r\n//------------------------------------------------------------------------------\r\n//      I/O\r\n//------------------------------------------------------------------------------\r\n\tfriend ostream &operator<<( ostream &stream, const Voronoi &obj );\r\n\t\r\n\t// Output\r\n\tfriend istream &operator>>( istream &stream, Voronoi &obj );\r\n\t// Input\r\n\t\r\n\tvirtual const char *className( void ) const { return \"Voronoi\"; }\r\n\t// Class name\r\n};\r\n\r\n#endif // _Voronoi_H\r\n\r\n// end of header file\r\n// Do not add any stuff under this line.\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Geometry/src/Voronoi.h b/Geometry/src/Voronoi.h
--- a/Geometry/src/Voronoi.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Geometry/src/Voronoi.h	(date 1729410604650)
@@ -1,152 +1,0 @@
-//==============================================================================
-// Voronoi.h
-//  : header file for the optimization
-//
-//==============================================================================
-
-#ifndef _Voronoi_H        // begining of header file
-#define _Voronoi_H        // notifying that this file is included
-
-//----------------------------------------------------------------------
-//  Including header files
-//----------------------------------------------------------------------
-
-#include <iostream>
-#include <iomanip>
-#include <fstream>
-#include <sstream>
-#include <cassert>
-#include <cstring>
-#include <cmath>
-
-using namespace std;
-
-// add to avoid apple clang 11.0.0 parser bug
-#define CGAL_DO_NOT_USE_BOOST_MP
-
-#include <CGAL/Exact_predicates_exact_constructions_kernel.h>
-//#include <CGAL/Regular_triangulation_filtered_traits_2.h>
-#include <CGAL/Regular_triangulation_adaptation_traits_2.h>
-#include <CGAL/Regular_triangulation_adaptation_policies_2.h>
-#include <CGAL/Regular_triangulation_2.h>
-#include <CGAL/Voronoi_diagram_2.h>
-#include <CGAL/Boolean_set_operations_2.h>
-#include <CGAL/bounding_box.h>
-#include <CGAL/Polygon_2.h>
-#include <CGAL/Polygon_2_algorithms.h>
-#include <CGAL/centroid.h>
-#include <CGAL/double.h>
-
-#include <boost/lexical_cast.hpp>
-#include "Common.h"
-#include "Seed.h"
-#include "Polygon2.h"
-
-//------------------------------------------------------------------------------
-//	Defining data types
-//------------------------------------------------------------------------------
-
-//Used to convert otherwise infinite rays into long line segments
-const int RAY_LENGTH = 1000;
-const int LINE_LENGTH = 1e8;
-
-
-typedef CGAL::Exact_predicates_exact_constructions_kernel K;
-//typedef CGAL::Exact_predicates_inexact_constructions_kernel KI;
-
-#ifdef __linux__
-//typedef CGAL::Regular_triangulation_filtered_traits_2<K>  Traits;
-//typedef CGAL::Regular_triangulation_2<Traits> RT2;
-#endif  // __linux__
-
-//#ifdef __APPLE__
-typedef CGAL::Regular_triangulation_2< K > RT2;
-//#endif  // __MAC__
-
-typedef CGAL::Regular_triangulation_adaptation_traits_2< RT2 > AT;
-typedef CGAL::Regular_triangulation_degeneracy_removal_policy_2< RT2 > DRP;
-typedef CGAL::Voronoi_diagram_2< RT2, AT, DRP > VD;
-typedef CGAL::Polygon_2< K >::Vertex_circulator Vertex_circulator;
-
-using CGAL::ORIGIN;
-
-//----------------------------------------------------------------------
-//	Defining macros
-//----------------------------------------------------------------------
-
-class Voronoi {
-
-private:
-	
-	unsigned _id;
-	// outer simpleContour of the voronoi diagram
-	KeiRo::Base::Polygon2 *_contourPtr;
-	
-	// seeds
-	vector< Seed > *_seedVecPtr;
-	// map seed points and cell polygon
-	vector< vector< K::Point_2 > > _polyVec2D;
-	
-	K::Segment_2 _convertToSeg( const CGAL::Object seg_obj, bool outgoing,
-	                            bool &isLine, double &slope );
-
-protected:
-	
-	void _init( vector< Seed > &__seedVec, KeiRo::Base::Polygon2 &__contour );
-	
-	void _clear();
-
-public:
-	
-	Voronoi();                      // default constructor
-	Voronoi( const Voronoi &obj );  // Copy constructor
-	virtual ~Voronoi();             // Destructor
-
-//------------------------------------------------------------------------------
-//  Reference to members
-//------------------------------------------------------------------------------
-	const unsigned int &id( void ) const { return _id; }
-	
-	unsigned int &id( void ) { return _id; }
-	
-	const vector< Seed > *seedVec( void ) const { return _seedVecPtr; }
-	
-	vector< Seed > *seedVec( void ) { return _seedVecPtr; }
-
-//------------------------------------------------------------------------------
-//  Specific functions
-//------------------------------------------------------------------------------
-	void init( vector< Seed > &__seedVec, KeiRo::Base::Polygon2 &__contour ) {
-		_init( __seedVec, __contour );
-	}
-	
-	void createVoronoiDiagram( bool isWeighted );
-	
-	void mapSeedsandPolygons( void );
-
-//------------------------------------------------------------------------------
-//  Initialization functions
-//------------------------------------------------------------------------------
-
-//------------------------------------------------------------------------------
-//  File I/O
-//------------------------------------------------------------------------------
-	void clear( void ) { _clear(); }
-
-//------------------------------------------------------------------------------
-//      I/O
-//------------------------------------------------------------------------------
-	friend ostream &operator<<( ostream &stream, const Voronoi &obj );
-	
-	// Output
-	friend istream &operator>>( istream &stream, Voronoi &obj );
-	// Input
-	
-	virtual const char *className( void ) const { return "Voronoi"; }
-	// Class name
-};
-
-#endif // _Voronoi_H
-
-// end of header file
-// Do not add any stuff under this line.
Index: Graph/src/TreeGraphProperty.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// TreeGraphProperty.h\r\n//\t: header file for tree graph property\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Sun Feb 09 23:16:12 2020\r\n//\r\n//******************************************************************************\r\n\r\n#ifndef\t_Graph__TreeGraphProperty_H\r\n#define _Graph__TreeGraphProperty_H\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\n#include \"Coord2.h\"\r\n#include \"Common.h\"\r\n#include \"BaseGraphProperty.h\"\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Macros\r\n//------------------------------------------------------------------------------\r\n\r\nnamespace Graph {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tDefining Classes\r\n    //------------------------------------------------------------------------------\r\n    class TreeGraphProperty: public BaseGraphProperty {\r\n\r\n    private:\r\n\r\n    protected:\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tSpecial functions\r\n        //------------------------------------------------------------------------------\r\n         void\t\t    _init( double &width, double &height );\r\n\r\n    public:\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tConstructors & Destructors\r\n        //------------------------------------------------------------------------------\r\n        // default constructor\r\n        TreeGraphProperty( void );\r\n        // copy constructor\r\n        TreeGraphProperty( const TreeGraphProperty & c ) {}\r\n        // destructor\r\n        virtual ~TreeGraphProperty( void ) {}\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tAssignment operators\r\n        //------------------------------------------------------------------------------\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tReference to elements\r\n        //------------------------------------------------------------------------------\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tSpecial functions\r\n        //------------------------------------------------------------------------------\r\n\r\n        void        init( double &__width, double &__height ) {\r\n            _init( __width, __height );\r\n        }\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tFriend functions\r\n        //------------------------------------------------------------------------------\r\n\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tI/O functions\r\n        //------------------------------------------------------------------------------\r\n        // output\r\n        friend ostream &\toperator << ( ostream & s, const TreeGraphProperty & v );\r\n        // input\r\n        friend istream &\toperator >> ( istream & s, TreeGraphProperty & v );\r\n        // class name\r\n        virtual const char * className( void ) const { return \"TreeGraphProperty\"; }\r\n\r\n    };\r\n\r\n} // namespace Graph\r\n\r\n#endif // _Graph_TreeGraphProperty_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Graph/src/TreeGraphProperty.h b/Graph/src/TreeGraphProperty.h
--- a/Graph/src/TreeGraphProperty.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Graph/src/TreeGraphProperty.h	(date 1729410604660)
@@ -1,94 +1,0 @@
-//******************************************************************************
-// TreeGraphProperty.h
-//	: header file for tree graph property
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Sun Feb 09 23:16:12 2020
-//
-//******************************************************************************
-
-#ifndef	_Graph__TreeGraphProperty_H
-#define _Graph__TreeGraphProperty_H
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <iostream>
-
-using namespace std;
-
-#include "Coord2.h"
-#include "Common.h"
-#include "BaseGraphProperty.h"
-
-
-//------------------------------------------------------------------------------
-//	Defining Macros
-//------------------------------------------------------------------------------
-
-namespace Graph {
-
-    //------------------------------------------------------------------------------
-    //	Defining Classes
-    //------------------------------------------------------------------------------
-    class TreeGraphProperty: public BaseGraphProperty {
-
-    private:
-
-    protected:
-
-        //------------------------------------------------------------------------------
-        //	Special functions
-        //------------------------------------------------------------------------------
-         void		    _init( double &width, double &height );
-
-    public:
-
-        //------------------------------------------------------------------------------
-        //	Constructors & Destructors
-        //------------------------------------------------------------------------------
-        // default constructor
-        TreeGraphProperty( void );
-        // copy constructor
-        TreeGraphProperty( const TreeGraphProperty & c ) {}
-        // destructor
-        virtual ~TreeGraphProperty( void ) {}
-
-        //------------------------------------------------------------------------------
-        //	Assignment operators
-        //------------------------------------------------------------------------------
-
-        //------------------------------------------------------------------------------
-        //	Reference to elements
-        //------------------------------------------------------------------------------
-
-        //------------------------------------------------------------------------------
-        //	Special functions
-        //------------------------------------------------------------------------------
-
-        void        init( double &__width, double &__height ) {
-            _init( __width, __height );
-        }
-
-        //------------------------------------------------------------------------------
-        //	Friend functions
-        //------------------------------------------------------------------------------
-
-
-        //------------------------------------------------------------------------------
-        //	I/O functions
-        //------------------------------------------------------------------------------
-        // output
-        friend ostream &	operator << ( ostream & s, const TreeGraphProperty & v );
-        // input
-        friend istream &	operator >> ( istream & s, TreeGraphProperty & v );
-        // class name
-        virtual const char * className( void ) const { return "TreeGraphProperty"; }
-
-    };
-
-} // namespace Graph
-
-#endif // _Graph_TreeGraphProperty_H
Index: Composite/src/Compression.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// Compression.cpp\r\n//\t: program file for Compression\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Mon Mar 16 07:58:23 2020\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include \"Compression.h\"\r\n\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPrivate Functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  Compression::_closeToSamplesInt --\tfind if the two points are at the same position\r\n    //\r\n    //  Inputs\r\n    //\tcoord\r\n    //  index\r\n    //\r\n    //  Outputs\r\n    //\tnone\r\n    //\r\n    bool Compression::_closeToSamplesInt( KeiRo::Base::Coord2 coordS, KeiRo::Base::Coord2 coordT )\r\n    {\r\n\t\tif( ( coordS - coordT ).norm() == 0 ){\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\telse{\r\n\t\t\treturn false;\r\n\t\t}\r\n    }\r\n    \r\n    //------------------------------------------------------------------------------\r\n    //\tProtected Functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  Compression::_init -- initialize the compressed data\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void Compression::_init( void )\r\n    {\r\n        _clear();\r\n    }\r\n\r\n    //\r\n    //  Compression::_clear -- clear the compressed data\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void Compression::_clear( void )\r\n    {\r\n\t\tclearGraph( _graph );\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPublic functions\r\n    //------------------------------------------------------------------------------\r\n    \r\n    //------------------------------------------------------------------------------\r\n    //\tConstructors & Destructors\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  Compression::Compression --\tdefault constructor\r\n    //\r\n    //  Inputs\r\n    //\tnone\r\n    //\r\n    //  Outputs\r\n    //\tnone\r\n    //\r\n    Compression::Compression( void )\r\n    {\r\n        //------------------------------------------------------------------------------\r\n        // configuration file\r\n        //------------------------------------------------------------------------------\r\n    }\r\n\r\n\t//\r\n\t//  Compression::Compression --\tcopy constructor\r\n\t//\r\n\t//  Inputs\r\n\t//\tnone\r\n\t//\r\n\t//  Outputs\r\n\t//\tnone\r\n\t//\r\n\tCompression::Compression( const Compression & v )\r\n\t{\r\n\t\t_graph        = v._graph;\r\n\t}\r\n\r\n    //\r\n    //  Compression::~Compression --\tdestructor\r\n    //\r\n    //  Inputs\r\n    //\tnone\r\n    //\r\n    //  Outputs\r\n    //\tnone\r\n    //\r\n    Compression::~Compression()\r\n    {\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tAssignment operators\r\n    //------------------------------------------------------------------------------\r\n    Compression & Compression::operator = ( const Compression & v )\r\n    {\r\n\t    if ( this != &v ) {\r\n\t\t    _graph        = v._graph;\r\n\t    }\r\n\t    return *this;\r\n    }\r\n\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tSpecial functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  Compression::findVertex --\tfind if the coordinate has been occupied\r\n    //\r\n    //  Inputs\r\n    //\tcoord\r\n    //  vertex_descriptor\r\n    //\r\n    //  Outputs\r\n    //\tnone\r\n    //\r\n    bool Compression::findVertex( KeiRo::Base::Coord2 coord, unsigned int sortedID, unsigned int &index )\r\n    {\r\n\t\tindex = 0;\r\n\t\tBGL_FORALL_VERTICES( vd, _graph, Graph::BaseUndirectedGraph ) {\r\n\r\n\t\t\tif( _graph[vd].initID == sortedID ){\r\n\t\t\t\tif( _closeToSamplesInt( *_graph[vd].coordPtr, coord ) ){\r\n\t\t\t\t\tindex = _graph[vd].id;\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n    }\r\n\r\n    //\r\n    //  Compression::addVertex --\tadd a new vertex\r\n    //\r\n    //  Inputs\r\n    //\tcoordPtr\r\n    //  level\r\n    //\r\n    //  Outputs\r\n    //\tvertex id\r\n    //\r\n    unsigned int Compression::addVertex( KeiRo::Base::Coord2 coord, unsigned int level, unsigned int sortedID )\r\n    {\r\n\t\tunsigned int vid = num_vertices( _graph );\r\n\t\tGraph::BaseUndirectedGraph::vertex_descriptor vdNew = add_vertex( _graph );\r\n\t\t_graph[ vdNew ].level     = level;\r\n\t\t_graph[ vdNew ].id        = vid;\r\n\t    _graph[ vdNew ].namePtr   = new string( to_string( vid ) );\r\n\t\t_graph[ vdNew ].initID    = sortedID;\r\n\t\t_graph[ vdNew ].weight    = 0;\r\n\t\t_graph[ vdNew ].coordPtr  = new KeiRo::Base::Coord2( coord.x(), coord.y() );\r\n\t\t_graph[ vdNew ].widthPtr  = new double( 10.0 );\r\n\t\t_graph[ vdNew ].heightPtr = new double( 10.0 );\r\n\t\r\n\t\treturn vid;\r\n    }\r\n    \r\n    //\r\n    //  Compression::addEdge --\tadd a new edge\r\n    //\r\n    //  Inputs\r\n    //\tsource vid\r\n    //  target vid\r\n    //  isCompressed\r\n    //\r\n    //  Outputs\r\n    //\tnone\r\n    //\r\n    void Compression::addEdge( unsigned int idS, unsigned int idT, vector< unsigned int > &intermediateVec,\r\n\t\t\t\t\t\t\t   unsigned int sortedID, bool isCompressed )\r\n    {\r\n\t\tunsigned int eid = num_edges( _graph );\r\n//\t    cerr << \"idS = \" << idS << \" idT = \" << idT << endl;\r\n        Graph::BaseUndirectedGraph::vertex_descriptor vdS = vertex( idS, _graph );\r\n        Graph::BaseUndirectedGraph::vertex_descriptor vdT = vertex( idT, _graph );\r\n\r\n        if( isCompressed == true ){\r\n\r\n        \tmap< double, Graph::BaseUndirectedGraph::vertex_descriptor > vdMap;\r\n        \tvector< KeiRo::Base::Coord2 > elements;\r\n        \telements.push_back( *_graph[vdS].coordPtr );\r\n        \telements.push_back( *_graph[vdT].coordPtr );\r\n        \tKeiRo::Base::Edge2 e( elements );\r\n        \t\r\n        \t// sort vertices on the edge\r\n        \tvdMap.insert( pair< double, Graph::BaseUndirectedGraph::vertex_descriptor >( 0, vdS ) );\r\n        \tBGL_FORALL_VERTICES( vd, _graph, Graph::BaseUndirectedGraph ) {\r\n        \t\r\n#ifdef DEBUG_COMPRESSION\r\n        \t\tif( _graph[vdS].id == 12 && _graph[vdT].id == 13 ) {\r\n        \t\t\tcerr << \"vid = \" << _graph[vd].id << endl;\r\n        \t\t\tcerr << \"_graph[vdS].coord = \" << *_graph[vdS].coordPtr;\r\n        \t\t\tcerr << \"_graph[vdT].coord = \" << *_graph[vdT].coordPtr;\r\n        \t\t\tcerr << \"_graph[vd].coord = \" << *_graph[vd].coordPtr;\r\n        \t\t\tcerr << \"e.isOnEdge( *_graph[vd].coordPtr ) = \" << e.isOnEdge( *_graph[vd].coordPtr ) << endl;\r\n        \t\t}\r\n#endif // DEBUG_COMPRESSION\r\n\t\t\t\tif( (vd != vdS) && (vd != vdT) && sortedID == _graph[vd].initID &&\r\n        \t\t    e.isOnEdge( *_graph[vd].coordPtr ) == true ){\r\n        \t\t\tdouble distance = (*_graph[vd].coordPtr - *_graph[vdS].coordPtr).norm();\r\n        \t\t\tvdMap.insert( pair< double, Graph::BaseUndirectedGraph::vertex_descriptor >( distance, vd ) );\r\n        \t\t}\r\n        \t}\r\n        \tvdMap.insert( pair< double, Graph::BaseUndirectedGraph::vertex_descriptor >( (*_graph[vdT].coordPtr - *_graph[vdS].coordPtr).norm(), vdT ) );\r\n        \t\r\n        \t// insert edge segments\r\n//        \tcerr << \"vdMap.size() = \" << vdMap.size() << endl;\r\n        \tfor( unsigned int i = 1; i < vdMap.size(); i++ ){\r\n\r\n        \t\tmap< double, Graph::BaseUndirectedGraph::vertex_descriptor >::iterator itS = vdMap.begin();\r\n        \t\tmap< double, Graph::BaseUndirectedGraph::vertex_descriptor >::iterator itT = vdMap.begin();\r\n        \t\tstd::advance( itS, i-1 );\r\n        \t\tstd::advance( itT, i );\r\n        \t\tGraph::BaseUndirectedGraph::vertex_descriptor vdSS = itS->second;\r\n        \t\tGraph::BaseUndirectedGraph::vertex_descriptor vdST = itT->second;\r\n\t\t        if( i != vdMap.size()-1 ) intermediateVec.push_back( _graph[ vdST ].id );\r\n\r\n        \t\tbool found = false;\r\n        \t\tGraph::BaseUndirectedGraph::edge_descriptor oldED;\r\n        \t\ttie( oldED, found ) = edge( vdSS, vdST, _graph );\r\n\r\n        \t\tif( found == false ){\r\n        \t\t\t\r\n        \t\t\tpair< Graph::BaseUndirectedGraph::edge_descriptor, unsigned int > foreE = add_edge( vdSS, vdST, _graph );\r\n        \t\t\tGraph::BaseUndirectedGraph::edge_descriptor foreED = foreE.first;\r\n\r\n        \t\t\t// base_graph\r\n        \t\t\t_graph[ foreED ].id = eid;\r\n        \t\t\t_graph[ foreED ].level = _graph[vdS].level;\r\n\r\n        \t\t\t_graph[ foreED ].angle = 0.0;\r\n        \t\t\t_graph[ foreED ].weight = (_graph[ foreED ].level + 1) * (*_graph[vdST].coordPtr - *_graph[vdSS].coordPtr).norm();;\r\n        \t\t\t_graph[ foreED ].visit = false;\r\n        \t\t\t_graph[ foreED ].visitedTimes = 0;\r\n\r\n        \t\t\t_graph[ foreED ].isFore = false;\r\n        \t\t\t_graph[ foreED ].isBack = false;\r\n        \t\t\teid++;\r\n#ifdef DEBUG_COMPRESSION\r\n        \t\t\tcerr << \"new edge = ( \" << _graph[ vdSS ].id << \", \" << _graph[ vdST ].id << \" ) \" << endl;\r\n#endif // DEBUG_COMPRESSION\r\n        \t\t}\r\n        \t}\r\n        }\r\n        else{\r\n        \t\r\n        \tbool found = false;\r\n        \tGraph::BaseUndirectedGraph::edge_descriptor oldED;\r\n        \ttie( oldED, found ) = edge( vdS, vdT, _graph );\r\n\r\n        \tif( found == false ){\r\n        \t\tpair< Graph::BaseUndirectedGraph::edge_descriptor, unsigned int > foreE = add_edge( vdS, vdT, _graph );\r\n        \t\tGraph::BaseUndirectedGraph::edge_descriptor foreED = foreE.first;\r\n\r\n        \t\t// base_graph\r\n        \t\t_graph[ foreED ].id = eid;\r\n        \t\t_graph[ foreED ].level = _graph[vdS].level;\r\n\r\n        \t\t_graph[ foreED ].angle = 0.0;\r\n        \t\t_graph[ foreED ].weight = (_graph[ foreED ].level + 1) * (*_graph[vdT].coordPtr - *_graph[vdS].coordPtr).norm();\r\n        \t\t_graph[ foreED ].visit = false;\r\n        \t\t_graph[ foreED ].visitedTimes = 0;\r\n\r\n        \t\t_graph[ foreED ].isFore = false;\r\n        \t\t_graph[ foreED ].isBack = false;\r\n#ifdef DEBUG_COMPRESSION\r\n        \t\tcerr << \"new edge = ( \" << _graph[ vdS ].id << \", \" << _graph[ vdT ].id << \" ) \" << endl;\r\n#endif // DEBUG_COMPRESSION\r\n        \t}\r\n        }\r\n    }\r\n\r\n    //\r\n    //  Compression::addBridgeEdge --\tadd a new bridge edge\r\n    //\r\n    //  Inputs\r\n    //\tsource vid\r\n    //  target vid\r\n    //\r\n    //  Outputs\r\n    //\tnone\r\n    //\r\n    void Compression::addBridgeEdge( unsigned int idS, unsigned int idT )\r\n\t{\r\n\t\tunsigned int eid = num_edges( _graph );\r\n\t\tGraph::BaseUndirectedGraph::vertex_descriptor vdS = vertex( idS, _graph );\r\n\t\tGraph::BaseUndirectedGraph::vertex_descriptor vdT = vertex( idT, _graph );\r\n\r\n\t\tbool found = false;\r\n\t\tGraph::BaseUndirectedGraph::edge_descriptor oldED;\r\n\t\ttie( oldED, found ) = edge( vdS, vdT, _graph );\r\n\r\n\t\tif( found == false ){\r\n\t\t\tpair< Graph::BaseUndirectedGraph::edge_descriptor, unsigned int > foreE = add_edge( vdS, vdT, _graph );\r\n\t\t\tGraph::BaseUndirectedGraph::edge_descriptor foreED = foreE.first;\r\n\t\t\t\r\n\t\t\t// base_graph\r\n\t\t\t_graph[ foreED ].id = eid;\r\n\t\t\t_graph[ foreED ].level = _graph[vdS].level;\r\n\t\t\t\r\n\t\t\t_graph[ foreED ].angle = 0.0;\r\n\t\t\t_graph[ foreED ].weight = 0.0;\r\n\t\t\t_graph[ foreED ].visit = false;\r\n\t\t\t_graph[ foreED ].visitedTimes = 0;\r\n\t\t\t\r\n\t\t\t_graph[ foreED ].isFore = false;\r\n\t\t\t_graph[ foreED ].isBack = false;\r\n#ifdef DEBUG_COMPRESSION\r\n\t\t\tcerr << \"new bridge edge = ( \" << _graph[ vdS ].id << \", \" << _graph[ vdT ].id << \" ) \" << endl;\r\n#endif // DEBUG_COMPRESSION\r\n\t\t}\r\n    }\r\n    //------------------------------------------------------------------------------\r\n    //\tFriend functions\r\n    //------------------------------------------------------------------------------\r\n\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tI/O functions\r\n    //------------------------------------------------------------------------------\r\n\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Composite/src/Compression.cpp b/Composite/src/Compression.cpp
--- a/Composite/src/Compression.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Composite/src/Compression.cpp	(date 1729410604670)
@@ -1,355 +1,0 @@
-//******************************************************************************
-// Compression.cpp
-//	: program file for Compression
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Mon Mar 16 07:58:23 2020
-//
-//******************************************************************************
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include "Compression.h"
-
-
-    //------------------------------------------------------------------------------
-    //	Private Functions
-    //------------------------------------------------------------------------------
-    //
-    //  Compression::_closeToSamplesInt --	find if the two points are at the same position
-    //
-    //  Inputs
-    //	coord
-    //  index
-    //
-    //  Outputs
-    //	none
-    //
-    bool Compression::_closeToSamplesInt( KeiRo::Base::Coord2 coordS, KeiRo::Base::Coord2 coordT )
-    {
-		if( ( coordS - coordT ).norm() == 0 ){
-			return true;
-		}
-		else{
-			return false;
-		}
-    }
-    
-    //------------------------------------------------------------------------------
-    //	Protected Functions
-    //------------------------------------------------------------------------------
-    //
-    //  Compression::_init -- initialize the compressed data
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    //
-    void Compression::_init( void )
-    {
-        _clear();
-    }
-
-    //
-    //  Compression::_clear -- clear the compressed data
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    //
-    void Compression::_clear( void )
-    {
-		clearGraph( _graph );
-    }
-
-    //------------------------------------------------------------------------------
-    //	Public functions
-    //------------------------------------------------------------------------------
-    
-    //------------------------------------------------------------------------------
-    //	Constructors & Destructors
-    //------------------------------------------------------------------------------
-    //
-    //  Compression::Compression --	default constructor
-    //
-    //  Inputs
-    //	none
-    //
-    //  Outputs
-    //	none
-    //
-    Compression::Compression( void )
-    {
-        //------------------------------------------------------------------------------
-        // configuration file
-        //------------------------------------------------------------------------------
-    }
-
-	//
-	//  Compression::Compression --	copy constructor
-	//
-	//  Inputs
-	//	none
-	//
-	//  Outputs
-	//	none
-	//
-	Compression::Compression( const Compression & v )
-	{
-		_graph        = v._graph;
-	}
-
-    //
-    //  Compression::~Compression --	destructor
-    //
-    //  Inputs
-    //	none
-    //
-    //  Outputs
-    //	none
-    //
-    Compression::~Compression()
-    {
-    }
-
-    //------------------------------------------------------------------------------
-    //	Assignment operators
-    //------------------------------------------------------------------------------
-    Compression & Compression::operator = ( const Compression & v )
-    {
-	    if ( this != &v ) {
-		    _graph        = v._graph;
-	    }
-	    return *this;
-    }
-
-
-    //------------------------------------------------------------------------------
-    //	Special functions
-    //------------------------------------------------------------------------------
-    //
-    //  Compression::findVertex --	find if the coordinate has been occupied
-    //
-    //  Inputs
-    //	coord
-    //  vertex_descriptor
-    //
-    //  Outputs
-    //	none
-    //
-    bool Compression::findVertex( KeiRo::Base::Coord2 coord, unsigned int sortedID, unsigned int &index )
-    {
-		index = 0;
-		BGL_FORALL_VERTICES( vd, _graph, Graph::BaseUndirectedGraph ) {
-
-			if( _graph[vd].initID == sortedID ){
-				if( _closeToSamplesInt( *_graph[vd].coordPtr, coord ) ){
-					index = _graph[vd].id;
-					
-					return true;
-				}
-			}
-		}
-		return false;
-    }
-
-    //
-    //  Compression::addVertex --	add a new vertex
-    //
-    //  Inputs
-    //	coordPtr
-    //  level
-    //
-    //  Outputs
-    //	vertex id
-    //
-    unsigned int Compression::addVertex( KeiRo::Base::Coord2 coord, unsigned int level, unsigned int sortedID )
-    {
-		unsigned int vid = num_vertices( _graph );
-		Graph::BaseUndirectedGraph::vertex_descriptor vdNew = add_vertex( _graph );
-		_graph[ vdNew ].level     = level;
-		_graph[ vdNew ].id        = vid;
-	    _graph[ vdNew ].namePtr   = new string( to_string( vid ) );
-		_graph[ vdNew ].initID    = sortedID;
-		_graph[ vdNew ].weight    = 0;
-		_graph[ vdNew ].coordPtr  = new KeiRo::Base::Coord2( coord.x(), coord.y() );
-		_graph[ vdNew ].widthPtr  = new double( 10.0 );
-		_graph[ vdNew ].heightPtr = new double( 10.0 );
-	
-		return vid;
-    }
-    
-    //
-    //  Compression::addEdge --	add a new edge
-    //
-    //  Inputs
-    //	source vid
-    //  target vid
-    //  isCompressed
-    //
-    //  Outputs
-    //	none
-    //
-    void Compression::addEdge( unsigned int idS, unsigned int idT, vector< unsigned int > &intermediateVec,
-							   unsigned int sortedID, bool isCompressed )
-    {
-		unsigned int eid = num_edges( _graph );
-//	    cerr << "idS = " << idS << " idT = " << idT << endl;
-        Graph::BaseUndirectedGraph::vertex_descriptor vdS = vertex( idS, _graph );
-        Graph::BaseUndirectedGraph::vertex_descriptor vdT = vertex( idT, _graph );
-
-        if( isCompressed == true ){
-
-        	map< double, Graph::BaseUndirectedGraph::vertex_descriptor > vdMap;
-        	vector< KeiRo::Base::Coord2 > elements;
-        	elements.push_back( *_graph[vdS].coordPtr );
-        	elements.push_back( *_graph[vdT].coordPtr );
-        	KeiRo::Base::Edge2 e( elements );
-        	
-        	// sort vertices on the edge
-        	vdMap.insert( pair< double, Graph::BaseUndirectedGraph::vertex_descriptor >( 0, vdS ) );
-        	BGL_FORALL_VERTICES( vd, _graph, Graph::BaseUndirectedGraph ) {
-        	
-#ifdef DEBUG_COMPRESSION
-        		if( _graph[vdS].id == 12 && _graph[vdT].id == 13 ) {
-        			cerr << "vid = " << _graph[vd].id << endl;
-        			cerr << "_graph[vdS].coord = " << *_graph[vdS].coordPtr;
-        			cerr << "_graph[vdT].coord = " << *_graph[vdT].coordPtr;
-        			cerr << "_graph[vd].coord = " << *_graph[vd].coordPtr;
-        			cerr << "e.isOnEdge( *_graph[vd].coordPtr ) = " << e.isOnEdge( *_graph[vd].coordPtr ) << endl;
-        		}
-#endif // DEBUG_COMPRESSION
-				if( (vd != vdS) && (vd != vdT) && sortedID == _graph[vd].initID &&
-        		    e.isOnEdge( *_graph[vd].coordPtr ) == true ){
-        			double distance = (*_graph[vd].coordPtr - *_graph[vdS].coordPtr).norm();
-        			vdMap.insert( pair< double, Graph::BaseUndirectedGraph::vertex_descriptor >( distance, vd ) );
-        		}
-        	}
-        	vdMap.insert( pair< double, Graph::BaseUndirectedGraph::vertex_descriptor >( (*_graph[vdT].coordPtr - *_graph[vdS].coordPtr).norm(), vdT ) );
-        	
-        	// insert edge segments
-//        	cerr << "vdMap.size() = " << vdMap.size() << endl;
-        	for( unsigned int i = 1; i < vdMap.size(); i++ ){
-
-        		map< double, Graph::BaseUndirectedGraph::vertex_descriptor >::iterator itS = vdMap.begin();
-        		map< double, Graph::BaseUndirectedGraph::vertex_descriptor >::iterator itT = vdMap.begin();
-        		std::advance( itS, i-1 );
-        		std::advance( itT, i );
-        		Graph::BaseUndirectedGraph::vertex_descriptor vdSS = itS->second;
-        		Graph::BaseUndirectedGraph::vertex_descriptor vdST = itT->second;
-		        if( i != vdMap.size()-1 ) intermediateVec.push_back( _graph[ vdST ].id );
-
-        		bool found = false;
-        		Graph::BaseUndirectedGraph::edge_descriptor oldED;
-        		tie( oldED, found ) = edge( vdSS, vdST, _graph );
-
-        		if( found == false ){
-        			
-        			pair< Graph::BaseUndirectedGraph::edge_descriptor, unsigned int > foreE = add_edge( vdSS, vdST, _graph );
-        			Graph::BaseUndirectedGraph::edge_descriptor foreED = foreE.first;
-
-        			// base_graph
-        			_graph[ foreED ].id = eid;
-        			_graph[ foreED ].level = _graph[vdS].level;
-
-        			_graph[ foreED ].angle = 0.0;
-        			_graph[ foreED ].weight = (_graph[ foreED ].level + 1) * (*_graph[vdST].coordPtr - *_graph[vdSS].coordPtr).norm();;
-        			_graph[ foreED ].visit = false;
-        			_graph[ foreED ].visitedTimes = 0;
-
-        			_graph[ foreED ].isFore = false;
-        			_graph[ foreED ].isBack = false;
-        			eid++;
-#ifdef DEBUG_COMPRESSION
-        			cerr << "new edge = ( " << _graph[ vdSS ].id << ", " << _graph[ vdST ].id << " ) " << endl;
-#endif // DEBUG_COMPRESSION
-        		}
-        	}
-        }
-        else{
-        	
-        	bool found = false;
-        	Graph::BaseUndirectedGraph::edge_descriptor oldED;
-        	tie( oldED, found ) = edge( vdS, vdT, _graph );
-
-        	if( found == false ){
-        		pair< Graph::BaseUndirectedGraph::edge_descriptor, unsigned int > foreE = add_edge( vdS, vdT, _graph );
-        		Graph::BaseUndirectedGraph::edge_descriptor foreED = foreE.first;
-
-        		// base_graph
-        		_graph[ foreED ].id = eid;
-        		_graph[ foreED ].level = _graph[vdS].level;
-
-        		_graph[ foreED ].angle = 0.0;
-        		_graph[ foreED ].weight = (_graph[ foreED ].level + 1) * (*_graph[vdT].coordPtr - *_graph[vdS].coordPtr).norm();
-        		_graph[ foreED ].visit = false;
-        		_graph[ foreED ].visitedTimes = 0;
-
-        		_graph[ foreED ].isFore = false;
-        		_graph[ foreED ].isBack = false;
-#ifdef DEBUG_COMPRESSION
-        		cerr << "new edge = ( " << _graph[ vdS ].id << ", " << _graph[ vdT ].id << " ) " << endl;
-#endif // DEBUG_COMPRESSION
-        	}
-        }
-    }
-
-    //
-    //  Compression::addBridgeEdge --	add a new bridge edge
-    //
-    //  Inputs
-    //	source vid
-    //  target vid
-    //
-    //  Outputs
-    //	none
-    //
-    void Compression::addBridgeEdge( unsigned int idS, unsigned int idT )
-	{
-		unsigned int eid = num_edges( _graph );
-		Graph::BaseUndirectedGraph::vertex_descriptor vdS = vertex( idS, _graph );
-		Graph::BaseUndirectedGraph::vertex_descriptor vdT = vertex( idT, _graph );
-
-		bool found = false;
-		Graph::BaseUndirectedGraph::edge_descriptor oldED;
-		tie( oldED, found ) = edge( vdS, vdT, _graph );
-
-		if( found == false ){
-			pair< Graph::BaseUndirectedGraph::edge_descriptor, unsigned int > foreE = add_edge( vdS, vdT, _graph );
-			Graph::BaseUndirectedGraph::edge_descriptor foreED = foreE.first;
-			
-			// base_graph
-			_graph[ foreED ].id = eid;
-			_graph[ foreED ].level = _graph[vdS].level;
-			
-			_graph[ foreED ].angle = 0.0;
-			_graph[ foreED ].weight = 0.0;
-			_graph[ foreED ].visit = false;
-			_graph[ foreED ].visitedTimes = 0;
-			
-			_graph[ foreED ].isFore = false;
-			_graph[ foreED ].isBack = false;
-#ifdef DEBUG_COMPRESSION
-			cerr << "new bridge edge = ( " << _graph[ vdS ].id << ", " << _graph[ vdT ].id << " ) " << endl;
-#endif // DEBUG_COMPRESSION
-		}
-    }
-    //------------------------------------------------------------------------------
-    //	Friend functions
-    //------------------------------------------------------------------------------
-
-
-    //------------------------------------------------------------------------------
-    //	I/O functions
-    //------------------------------------------------------------------------------
-
-
-
-
Index: Composite/src/Grid2.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// Grid2.cpp\r\n//\t: program file for 2D grid coordinates\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Mon Mar 14 02:16:23 2011\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <iostream>\r\n#include <iomanip>\r\n#include <cctype>\r\n#include <cmath>\r\n\r\nusing namespace std;\r\n\r\n#include \"Grid2.h\"\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPrivate Functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tProtected Functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  Grid2::_init --\tinitialize Grid2\r\n    //\r\n    //  Inputs\r\n    //\tnone\r\n    //\r\n    //  Outputs\r\n    //\tnone\r\n    //\r\n    void Grid2::_init( const double *widthPtr, const double *heightPtr  )\r\n    {\r\n\t    _widthPtr = widthPtr;\r\n\t    _heightPtr = heightPtr;\r\n\r\n        _quadSize = MIN2( KeiRo::Base::Common::getMainwidgetWidth() / (2.0*_minRange),\r\n\t\t\t\t\t\t  KeiRo::Base::Common::getMainwidgetHeight() / (2.0*_minRange) );\r\n        _range[ 0 ] = ceil( KeiRo::Base::Common::getMainwidgetWidth() / ( 2.0*_quadSize ) );\r\n        _range[ 1 ] = ceil( KeiRo::Base::Common::getMainwidgetHeight() / ( 2.0*_quadSize ) );\r\n\r\n#ifdef GRID_DEBUG\r\n        cerr << \"quadSize = \"  << _quadSize << endl;\r\n        cerr << \"xrange = \"  << _range[0] << endl;\r\n        cerr << \"yrange = \"  << _range[1] << endl;\r\n#endif // GRID_DEBUG\r\n\r\n    }\r\n\r\n    //\r\n    //  Grid2::_clear --\t\u001Bclear Grid2\r\n    //\r\n    //  Inputs\r\n    //\tnone\r\n    //\r\n    //  Outputs\r\n    //\tnone\r\n    //\r\n    void Grid2::_clear( void )\r\n    {\r\n        _quadFourCorners.clear();\r\n    }\r\n\r\n\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPublic functions\r\n    //------------------------------------------------------------------------------\r\n    //------------------------------------------------------------------------------\r\n    //\tConstructors & Destructors\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  Grid2::Grid2 --\tconstructor\r\n    //\r\n    //  Inputs\r\n    //\tnone\r\n    //\r\n    //  Outputs\r\n    //\tnone\r\n    //\r\n    Grid2::Grid2( void )\r\n    {\r\n        // initialization\r\n        _range.resize(2);\r\n\r\n        //------------------------------------------------------------------------------\r\n        // configuration file\r\n        //------------------------------------------------------------------------------\r\n        string configFilePath = qApp->applicationDirPath().toStdString() + \"/../config/MainWindow.conf\";\r\n        KeiRo::Base::Config conf( configFilePath );\r\n\r\n        if ( conf.has( \"min_range\" ) ){\r\n            string paramMinRange = conf.gets( \"min_range\" );\r\n            _minRange = stoi( paramMinRange );\r\n        }\r\n\r\n#ifdef GRID_DEBUG\r\n        cerr << \"minRange = \" << _minRange << endl;\r\n#endif // GRID_DEBUG\r\n    }\r\n\r\n    //\r\n    //  Grid2::createDefaultGrid --\t\u001Bcreate a default grid\r\n    //\r\n    //  Inputs\r\n    //\tnone\r\n    //\r\n    //  Outputs\r\n    //\tnone\r\n    //\r\n    void Grid2::createDefaultGrid( void )\r\n    {\r\n\r\n        // initialize grid matrix\r\n        _gridIDMatrix.resize( 2*_range[ 0 ]+1 );\r\n        _gridCoord2Matrix.resize( 2*_range[ 0 ]+1 );\r\n        for( unsigned int i = 0; i < _gridIDMatrix.size(); i++ ){\r\n\r\n            _gridIDMatrix[ i ].resize( 2*_range[ 1 ]+1 );\r\n            _gridCoord2Matrix[ i ].resize( 2*_range[ 1 ]+1 );\r\n\r\n            for( unsigned int j = 0; j < _gridIDMatrix[ i ].size(); j++ ){\r\n                _gridIDMatrix[ i ][ j ].first = -1.0 * (int)_range[ 0 ] + (int)i;\r\n                _gridIDMatrix[ i ][ j ].second = -1.0 * (int)_range[ 1 ] + (int)j;\r\n                _gridCoord2Matrix[ i ][ j ].x() = _gridIDMatrix[ i ][ j ].first * _quadSize;\r\n                _gridCoord2Matrix[ i ][ j ].y() = _gridIDMatrix[ i ][ j ].second * _quadSize;\r\n            }\r\n        }\r\n\r\n        // build grid graph\r\n        unsigned int nVertices = 0, nEdges = 0;\r\n\r\n        _grid[ graph_bundle ].centerPtr        = new KeiRo::Base::Coord2( 0.0, 0.0 );\r\n        _grid[ graph_bundle ].widthPtr         = & KeiRo::Base::Common::getMainwidgetWidth();\r\n        _grid[ graph_bundle ].heightPtr        = & KeiRo::Base::Common::getMainwidgetHeight();\r\n\r\n        // add grid vertices\r\n        unsigned int index = 0;\r\n        for( unsigned int i = 0; i < _gridIDMatrix.size(); i++ ){\r\n            for( unsigned int j = 0; j < _gridIDMatrix[ i ].size(); j++ ){\r\n\r\n                index = i*_gridIDMatrix[ i ].size() + j;\r\n                // cerr << \"index = \" << index << \" id = \" << id << endl;\r\n\r\n                Graph::GridGraph::vertex_descriptor gridVD  = add_vertex( _grid );\r\n\r\n                // base_graph\r\n                _grid[ gridVD ].id                  = nVertices;\r\n                _grid[ gridVD ].initID              = nVertices;\r\n                _grid[ gridVD ].groupID             = 0;\r\n                _grid[ gridVD ].componentID         = 0;\r\n\r\n                _grid[ gridVD ].namePtr             = new string( \"\" );\r\n                _grid[ gridVD ].namePixelWidthPtr   = new double( 0.0 );\r\n                _grid[ gridVD ].namePixelHeightPtr  = new double( 0.0 );\r\n\r\n                _grid[ gridVD ].weight              = 1.0;\r\n\r\n                _grid[ gridVD ].coordPtr            = &_gridCoord2Matrix[ i ][ j ];\r\n                _grid[ gridVD ].widthPtr            = new double( 10.0 );\r\n                _grid[ gridVD ].heightPtr           = new double( 10.0 );\r\n                _grid[ gridVD ].areaPtr             = new double( *_grid[ gridVD ].widthPtr * *_grid[ gridVD ].heightPtr );\r\n\r\n                _grid[ gridVD ].color               = 0;\r\n                _grid[ gridVD ].flag                = false;\r\n\r\n                // grid_graph\r\n                _grid[ gridVD ].gridVType           = Graph::GRID_VERTEX_DEFAULT;\r\n                _grid[ gridVD ].geoPtr              = new KeiRo::Base::Coord2( _gridCoord2Matrix[ i ][ j ].x(),\r\n                                                                  _gridCoord2Matrix[ i ][ j ].y() );\r\n                _grid[ gridVD ].smoothPtr           = new KeiRo::Base::Coord2( _gridCoord2Matrix[ i ][ j ].x(),\r\n                                                                  _gridCoord2Matrix[ i ][ j ].y() );\r\n\r\n                nVertices++;\r\n            }\r\n        }\r\n        assert( index == nVertices-1 );\r\n\r\n        // add grid vertical edges\r\n        for( unsigned int i = 0; i < _gridIDMatrix.size(); i++ ){\r\n            for( unsigned int j = 1; j < _gridIDMatrix[ i ].size(); j++ ){\r\n\r\n                unsigned int idS = i*_gridIDMatrix[ i ].size() + j-1;\r\n                unsigned int idT = i*_gridIDMatrix[ i ].size() + j;\r\n\r\n                Graph::GridGraph::vertex_descriptor vdS  = vertex( idS, _grid );\r\n                Graph::GridGraph::vertex_descriptor vdT  = vertex( idT, _grid );\r\n\r\n                pair< Graph::GridGraph::edge_descriptor, unsigned int > foreE = add_edge( vdS, vdT, _grid );\r\n                Graph::GridGraph::edge_descriptor foreED = foreE.first;\r\n\r\n                // base_graph\r\n                _grid[ foreED ].id              = nEdges;\r\n\r\n                _grid[ foreED ].angle           = 0.0;\r\n                _grid[ foreED ].weight          = 1.0;\r\n                _grid[ foreED ].visit           = false;\r\n                _grid[ foreED ].visitedTimes    = 0;\r\n\r\n                _grid[ foreED ].isFore          = false;\r\n                _grid[ foreED ].isBack          = false;\r\n\r\n                // grid_graph\r\n                // calculate geographical angle\r\n                KeiRo::Base::Coord2 coordO;\r\n                KeiRo::Base::Coord2 coordD;\r\n                if( _grid[ vdS ].id < _grid[ vdT ].id ){\r\n                    coordO = *_grid[ vdS ].coordPtr;\r\n                    coordD = *_grid[ vdT ].coordPtr;\r\n                }\r\n                else{\r\n                    coordO = *_grid[ vdT ].coordPtr;\r\n                    coordD = *_grid[ vdS ].coordPtr;\r\n                }\r\n                double diffX = coordD.x() - coordO.x();\r\n                double diffY = coordD.y() - coordO.y();\r\n                double angle = atan2( diffY, diffX );\r\n\r\n                _grid[ foreED ].geoAngle        = angle;\r\n\r\n                nEdges++;\r\n            }\r\n        }\r\n\r\n        // add grid horizontal edges\r\n        for( unsigned int j = 0; j < _gridIDMatrix[ 0 ].size(); j++ ){\r\n            for( unsigned int i = 1; i < _gridIDMatrix.size(); i++ ){\r\n\r\n                unsigned int idS = (i-1)*_gridIDMatrix[ i-1 ].size() + j;\r\n                unsigned int idT = i*_gridIDMatrix[ i ].size() + j;\r\n\r\n                Graph::GridGraph::vertex_descriptor vdS  = vertex( idS, _grid );\r\n                Graph::GridGraph::vertex_descriptor vdT  = vertex( idT, _grid );\r\n\r\n                pair< Graph::GridGraph::edge_descriptor, unsigned int > foreE = add_edge( vdS, vdT, _grid );\r\n                Graph::GridGraph::edge_descriptor foreED = foreE.first;\r\n\r\n                // base_graph\r\n                _grid[ foreED ].id              = nEdges;\r\n\r\n                _grid[ foreED ].angle           = 0.0;\r\n                _grid[ foreED ].weight          = 1.0;\r\n                _grid[ foreED ].visit           = false;\r\n                _grid[ foreED ].visitedTimes    = 0;\r\n\r\n                _grid[ foreED ].isFore          = false;\r\n                _grid[ foreED ].isBack          = false;\r\n\r\n                // grid_graph\r\n                // calculate geographical angle\r\n                KeiRo::Base::Coord2 coordO;\r\n                KeiRo::Base::Coord2 coordD;\r\n                if( _grid[ vdS ].id < _grid[ vdT ].id ){\r\n                    coordO = *_grid[ vdS ].coordPtr;\r\n                    coordD = *_grid[ vdT ].coordPtr;\r\n                }\r\n                else{\r\n                    coordO = *_grid[ vdT ].coordPtr;\r\n                    coordD = *_grid[ vdS ].coordPtr;\r\n                }\r\n                double diffX = coordD.x() - coordO.x();\r\n                double diffY = coordD.y() - coordO.y();\r\n                double angle = atan2( diffY, diffX );\r\n                _grid[ foreED ].geoAngle        = angle;\r\n\r\n                nEdges++;\r\n            }\r\n        }\r\n\r\n        for( unsigned int i = 0; i < _gridIDMatrix.size()-1; i++ ){\r\n            for( unsigned int j = 0; j < _gridIDMatrix[ i ].size()-1; j++ ){\r\n\r\n                vector< Graph::GridGraph::vertex_descriptor > vdVec;\r\n                getQuadVD( i, j, vdVec );\r\n\r\n                _quadFourCorners.push_back( vdVec );\r\n            }\r\n        }\r\n\r\n        _element[ 0 ] = _element[ 1 ] = 0;\r\n\r\n        // cerr << \"_gridMatrix.size() = \" << _gridMatrix.size() << endl;\r\n\r\n    }\r\n\r\n    //\r\n    //  Grid2::resetGridPosition --\treset grid node position\r\n    //\r\n    //  Inputs\r\n    //\tnone\r\n    //\r\n    //  Outputs\r\n    //\tnone\r\n    //\r\n    void Grid2::resetGridPosition( void )\r\n    {\r\n        // reset grid node position\r\n        BGL_FORALL_VERTICES( vd, _grid, Graph::GridGraph ) {\r\n\r\n            _grid[vd].coordPtr->x() = _grid[vd].smoothPtr->x() = _grid[vd].geoPtr->x();\r\n            _grid[vd].coordPtr->y() = _grid[vd].smoothPtr->y() = _grid[vd].geoPtr->y();\r\n\r\n        }\r\n    }\r\n\r\n\r\n    //\r\n    //  Grid2::Grid2 --\tparameterized constructor\r\n    //\r\n    //  Input\r\n    //\t x, y :\t2D coordinates\r\n    //\r\n    //  Output\r\n    //\tnone\r\n    //\r\n    Grid2::Grid2( const int x, const int y )\r\n    {\r\n        _element[ 0 ]\t= x;\r\n        _element[ 1 ]\t= y;\r\n    }\r\n\r\n    //\r\n    //  Grid2::Grid2 --\tcopy constructor\r\n    //\r\n    //  Input\r\n    //\tv\t: 2D coordinates\r\n    //\r\n    //  Output\r\n    //\tnone\r\n    //\r\n    Grid2::Grid2( const Grid2 & v )\r\n    {\r\n        _element[ 0 ]\t= v._element[ 0 ];\r\n        _element[ 1 ]\t= v._element[ 1 ];\r\n     }\r\n\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tAssignment operators\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  Grid2::operator = --\tassignment\r\n    //\r\n    //  Inputs\r\n    //\tv\t: 2D coordinates\r\n    //\r\n    //  Outputs\r\n    //\treference to this object\r\n    //\r\n    Grid2 & Grid2::operator = ( const Grid2 & v )\r\n    {\r\n        if ( this != &v ) {\r\n            _element[ 0 ]\t= v._element[ 0 ];\r\n            _element[ 1 ]\t= v._element[ 1 ];\r\n        }\r\n        return *this;\r\n    }\r\n\r\n\r\n    //\r\n    //  Grid2::operator += --\taddition + assignment\r\n    //\r\n    //  Inputs\r\n    //\tv\t: 2D coordinates\r\n    //\r\n    //  Outputs\r\n    //\treference to this object\r\n    //\r\n    Grid2 & Grid2::operator += ( const Grid2 & v )\r\n    {\r\n        _element[ 0 ]\t+= v._element[ 0 ];\r\n        _element[ 1 ]\t+= v._element[ 1 ];\r\n        return *this;\r\n    }\r\n\r\n\r\n    //\r\n    //  Grid2::operator -= --\tsubtraction + assignment\r\n    //\r\n    //  Inputs\r\n    //\tv\t: 2D coordinates\r\n    //\r\n    //  Outputs\r\n    //\treference to this object\r\n    //\r\n    Grid2 & Grid2::operator -= ( const Grid2 & v )\r\n    {\r\n        _element[ 0 ]\t-= v._element[ 0 ];\r\n        _element[ 1 ]\t-= v._element[ 1 ];\r\n        return *this;\r\n    }\r\n\r\n\r\n    //\r\n    //  Grid2::operator -= --\tscalar product + assignment\r\n    //\r\n    //  Inputs\r\n    //\td\t: scalar value\r\n    //\r\n    //  Outputs\r\n    //\treference to this object\r\n    //\r\n    Grid2 & Grid2::operator *= ( const int d )\r\n    {\r\n        _element[ 0 ]\t*= d;\r\n        _element[ 1 ]\t*= d;\r\n        return *this;\r\n    }\r\n\r\n\r\n    //\r\n    //  Grid2::operator [] --\treference to an element\r\n    //\r\n    //  Inputs\r\n    //\ti\t: index of the coordinate\r\n    //\r\n    //  Outputs\r\n    //\tthe corresponding coordinate\r\n    //\r\n    const int & Grid2::operator [] ( int i ) const\r\n    {\r\n    #ifdef GRID2_INDEX_CHECK\r\n        const char theName[] = \"Grid2::operator [] : \";\r\n        if ( ( i < 0 ) || ( i > 1 ) ) {\r\n        cerr << theName << \" index = \" << i << endl;\r\n        assert( ( 0 <= i ) && ( i <= 1 ) );\r\n        }\r\n    #endif\t// GRID2_INDEX_CHECK\r\n        return _element[ i ];\r\n    }\r\n\r\n\r\n    //\r\n    //  Grid2::operator [] --\treference to an element\r\n    //\r\n    //  Inputs\r\n    //\ti\t: index of the coordinate\r\n    //\r\n    //  Outputs\r\n    //\tthe corresponding coordinate\r\n    //\r\n    int & Grid2::operator [] ( int i )\r\n    {\r\n    #ifdef GRID2_INDEX_CHECK\r\n        const char theName[] = \"Grid2::operator [] : \";\r\n        if ( ( i < 0 ) || ( i > 1 ) ) {\r\n        cerr << theName << \" index = \" << i << endl;\r\n        assert( ( 0 <= i ) && ( i <= 1 ) );\r\n        }\r\n    #endif\t// GRID2_INDEX_CHECK\r\n        return _element[ i ];\r\n    }\r\n\r\n\r\n    //\r\n    //  Grid2::set --\tset all the coordinates\r\n    //\r\n    //  Inputs\r\n    //\tx, y\t: x and y coordinates\r\n    //\r\n    //  Returns\r\n    //\tnone\r\n    //\r\n    void Grid2::set( const int x, const int y )\r\n    {\r\n        _element[ 0 ]\t= x;\r\n        _element[ 1 ]\t= y;\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tSpecial functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  Grid2::getQuadVID --\tget corner ids of a quad\r\n    //\r\n    //  Inputs\r\n    //\ti\t: x index\r\n    //\tj\t: y index\r\n    //\tvid\t: id vector\r\n    //\r\n    //  Outputs\r\n    //\tnone\r\n    //\r\n    void Grid2::getQuadVD ( unsigned int i, unsigned int j,\r\n                            vector< Graph::GridGraph::vertex_descriptor > &vdVec )\r\n    {\r\n        unsigned int xrange = 2*_range[0]+1;\r\n        unsigned int yrange = 2*_range[1]+1;\r\n\r\n        vdVec.resize( 4 );\r\n\r\n        vdVec[ 0 ] = vertex( i*yrange + j, _grid );\r\n        vdVec[ 1 ] = vertex( (i+1)*yrange + j, _grid );\r\n        vdVec[ 2 ] = vertex( (i+1)*yrange + j+1, _grid );\r\n        vdVec[ 3 ] = vertex( i*yrange + j+1, _grid );\r\n\r\n#ifdef DEBUG\r\n        cerr << \"i = \" << i << \" j = \" << j << endl;\r\n        for( unsigned int k = 0; k < vid.size(); k++ ){\r\n            cerr << vid[ k ] << \" \";\r\n        }\r\n        cerr << endl;\r\n#endif // DEBUG\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tFriend functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  operator - --\tsign change\r\n    //\r\n    //  Inputs\r\n    //\ta\t: 2D coordinates\r\n    //\r\n    //  Outputs\r\n    //\t2D coordinates in the opposite direction\r\n    //\r\n    Grid2 operator - ( const Grid2 & a )\r\n    {\r\n        return Grid2( -a._element[ 0 ], -a._element[ 1 ] );\r\n    }\r\n\r\n\r\n    //\r\n    //  operator + --\taddition\r\n    //\r\n    //  Inputs\r\n    //\ta, b\t: 2D coordinates\r\n    //\r\n    //  Outputs\r\n    //\taddition of the two 2D coordinates\r\n    //\r\n    Grid2 operator + ( const Grid2 & a, const Grid2 & b )\r\n    {\r\n        return Grid2( a._element[ 0 ] + b._element[ 0 ],\r\n              a._element[ 1 ] + b._element[ 1 ] );\r\n    }\r\n\r\n\r\n    //\r\n    //  operator - --\tdifference\r\n    //\r\n    //  Inputs\r\n    //\ta, b\t: 2D coordinates\r\n    //\r\n    //  Outputs\r\n    //\tdifference of the two 2D coordinates\r\n    //\r\n    Grid2 operator - ( const Grid2 & a, const Grid2 & b )\r\n    {\r\n        return Grid2( a._element[ 0 ] - b._element[ 0 ],\r\n              a._element[ 1 ] - b._element[ 1 ] );\r\n    }\r\n\r\n\r\n    //\r\n    //  operator * --\tscalar product\r\n    //\r\n    //  Inputs\r\n    //\td\t: scalar value\r\n    //\ta\t: 2D coordinates\r\n    //\r\n    //  Outputs\r\n    //\tscalar product\r\n    //\r\n    Grid2 operator * ( const int d, const Grid2 & a )\r\n    {\r\n        return Grid2( d * a._element[ 0 ], d * a._element[ 1 ] );\r\n    }\r\n\r\n\r\n    //\r\n    //  operator * --\tinner product\r\n    //\r\n    //  Inputs\r\n    //\ta, b\t: 2D coordinates\r\n    //\r\n    //  Outputs\r\n    //\tinner product\r\n    //\r\n    int operator * ( const Grid2 & a, const Grid2 & b )\r\n    {\r\n        return ( a._element[ 0 ] * b._element[ 0 ] +\r\n             a._element[ 1 ] * b._element[ 1 ] );\r\n    }\r\n\r\n\r\n    //\r\n    //  operator == --\tequivalence\r\n    //\r\n    //  Inputs\r\n    //\ta, b\t: 2D coordinates\r\n    //\r\n    //  Outputs\r\n    //\tboolean value\r\n    //\r\n    int operator == ( const Grid2 & a, const Grid2 & b )\r\n    {\r\n        return ( ( a._element[ 0 ] == b._element[ 0 ] ) &&\r\n             ( a._element[ 1 ] == b._element[ 1 ] ) );\r\n    }\r\n\r\n\r\n    //\r\n    //  operator < --\tcomparison (less than)\r\n    //\r\n    //  Inputs\r\n    //\ta, b\t: 2D coordinates\r\n    //\r\n    //  Outputs\r\n    //\tboolean value\r\n    //\r\n    int operator < ( const Grid2 & a, const Grid2 & b )\r\n    {\r\n        if ( a._element[ 0 ] < b._element[ 0 ] ) return true;\r\n        else if ( a._element[ 0 ] > b._element[ 0 ] ) return false;\r\n        else {\r\n        if ( a._element[ 1 ] < b._element[ 1 ] ) return true;\r\n        else if ( a._element[ 1 ] > b._element[ 1 ] ) return false;\r\n        else return false;\r\n        }\r\n    }\r\n\r\n\r\n    //\r\n    //  operator > --\tcomparison (more than)\r\n    //\r\n    //  Inputs\r\n    //\ta, b\t: 2D coordinates\r\n    //\r\n    //  Outputs\r\n    //\tboolean value\r\n    //\r\n    int operator > ( const Grid2 & a, const Grid2 & b )\r\n    {\r\n        if ( a._element[ 0 ] > b._element[ 0 ] ) return true;\r\n        else if ( a._element[ 0 ] < b._element[ 0 ] ) return false;\r\n        else {\r\n        if ( a._element[ 1 ] > b._element[ 1 ] ) return true;\r\n        else if ( a._element[ 1 ] < b._element[ 1 ] ) return false;\r\n        else return false;\r\n        }\r\n    }\r\n\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tI/O functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  operator << --\toutput\r\n    //\r\n    //  Inputs\r\n    //\ts\t: reference to output stream\r\n    //\tv\t: 2D coordinates\r\n    //\r\n    //  Outputs\r\n    //\treference to output stream\r\n    //\r\n    ostream & operator << ( ostream & stream, const Grid2 & obj )\r\n    {\r\n        // set the output formatting\r\n        int width = 16;\r\n        // print out the elements\r\n        for ( int i = 0; i < 2; i++ ) {\r\n        stream << setw( width ) << obj._element[ i ];\r\n        if ( i != 1 ) stream << \"\\t\";\r\n        }\r\n        stream << endl;\r\n\r\n        return stream;\r\n    }\r\n\r\n\r\n    //\r\n    //  operator >> --\tinput\r\n    //\r\n    //  Inputs\r\n    //\ts\t: reference to input stream\r\n    //\tv\t: 2D coordinates\r\n    //\r\n    //  Outputs\r\n    //\treference to input stream\r\n    //\r\n    istream & operator >> ( istream & stream, Grid2 & obj )\r\n    {\r\n        // reading the elements\r\n        for ( int i = 0; i < 2; i++ )\r\n        stream >> obj._element[ i ];\r\n        return stream;\r\n    }\r\n\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Composite/src/Grid2.cpp b/Composite/src/Grid2.cpp
--- a/Composite/src/Grid2.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Composite/src/Grid2.cpp	(date 1729410604680)
@@ -1,702 +1,0 @@
-//******************************************************************************
-// Grid2.cpp
-//	: program file for 2D grid coordinates
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Mon Mar 14 02:16:23 2011
-//
-//******************************************************************************
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <iostream>
-#include <iomanip>
-#include <cctype>
-#include <cmath>
-
-using namespace std;
-
-#include "Grid2.h"
-
-    //------------------------------------------------------------------------------
-    //	Private Functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Protected Functions
-    //------------------------------------------------------------------------------
-    //
-    //  Grid2::_init --	initialize Grid2
-    //
-    //  Inputs
-    //	none
-    //
-    //  Outputs
-    //	none
-    //
-    void Grid2::_init( const double *widthPtr, const double *heightPtr  )
-    {
-	    _widthPtr = widthPtr;
-	    _heightPtr = heightPtr;
-
-        _quadSize = MIN2( KeiRo::Base::Common::getMainwidgetWidth() / (2.0*_minRange),
-						  KeiRo::Base::Common::getMainwidgetHeight() / (2.0*_minRange) );
-        _range[ 0 ] = ceil( KeiRo::Base::Common::getMainwidgetWidth() / ( 2.0*_quadSize ) );
-        _range[ 1 ] = ceil( KeiRo::Base::Common::getMainwidgetHeight() / ( 2.0*_quadSize ) );
-
-#ifdef GRID_DEBUG
-        cerr << "quadSize = "  << _quadSize << endl;
-        cerr << "xrange = "  << _range[0] << endl;
-        cerr << "yrange = "  << _range[1] << endl;
-#endif // GRID_DEBUG
-
-    }
-
-    //
-    //  Grid2::_clear --	clear Grid2
-    //
-    //  Inputs
-    //	none
-    //
-    //  Outputs
-    //	none
-    //
-    void Grid2::_clear( void )
-    {
-        _quadFourCorners.clear();
-    }
-
-
-
-    //------------------------------------------------------------------------------
-    //	Public functions
-    //------------------------------------------------------------------------------
-    //------------------------------------------------------------------------------
-    //	Constructors & Destructors
-    //------------------------------------------------------------------------------
-    //
-    //  Grid2::Grid2 --	constructor
-    //
-    //  Inputs
-    //	none
-    //
-    //  Outputs
-    //	none
-    //
-    Grid2::Grid2( void )
-    {
-        // initialization
-        _range.resize(2);
-
-        //------------------------------------------------------------------------------
-        // configuration file
-        //------------------------------------------------------------------------------
-        string configFilePath = qApp->applicationDirPath().toStdString() + "/../config/MainWindow.conf";
-        KeiRo::Base::Config conf( configFilePath );
-
-        if ( conf.has( "min_range" ) ){
-            string paramMinRange = conf.gets( "min_range" );
-            _minRange = stoi( paramMinRange );
-        }
-
-#ifdef GRID_DEBUG
-        cerr << "minRange = " << _minRange << endl;
-#endif // GRID_DEBUG
-    }
-
-    //
-    //  Grid2::createDefaultGrid --	create a default grid
-    //
-    //  Inputs
-    //	none
-    //
-    //  Outputs
-    //	none
-    //
-    void Grid2::createDefaultGrid( void )
-    {
-
-        // initialize grid matrix
-        _gridIDMatrix.resize( 2*_range[ 0 ]+1 );
-        _gridCoord2Matrix.resize( 2*_range[ 0 ]+1 );
-        for( unsigned int i = 0; i < _gridIDMatrix.size(); i++ ){
-
-            _gridIDMatrix[ i ].resize( 2*_range[ 1 ]+1 );
-            _gridCoord2Matrix[ i ].resize( 2*_range[ 1 ]+1 );
-
-            for( unsigned int j = 0; j < _gridIDMatrix[ i ].size(); j++ ){
-                _gridIDMatrix[ i ][ j ].first = -1.0 * (int)_range[ 0 ] + (int)i;
-                _gridIDMatrix[ i ][ j ].second = -1.0 * (int)_range[ 1 ] + (int)j;
-                _gridCoord2Matrix[ i ][ j ].x() = _gridIDMatrix[ i ][ j ].first * _quadSize;
-                _gridCoord2Matrix[ i ][ j ].y() = _gridIDMatrix[ i ][ j ].second * _quadSize;
-            }
-        }
-
-        // build grid graph
-        unsigned int nVertices = 0, nEdges = 0;
-
-        _grid[ graph_bundle ].centerPtr        = new KeiRo::Base::Coord2( 0.0, 0.0 );
-        _grid[ graph_bundle ].widthPtr         = & KeiRo::Base::Common::getMainwidgetWidth();
-        _grid[ graph_bundle ].heightPtr        = & KeiRo::Base::Common::getMainwidgetHeight();
-
-        // add grid vertices
-        unsigned int index = 0;
-        for( unsigned int i = 0; i < _gridIDMatrix.size(); i++ ){
-            for( unsigned int j = 0; j < _gridIDMatrix[ i ].size(); j++ ){
-
-                index = i*_gridIDMatrix[ i ].size() + j;
-                // cerr << "index = " << index << " id = " << id << endl;
-
-                Graph::GridGraph::vertex_descriptor gridVD  = add_vertex( _grid );
-
-                // base_graph
-                _grid[ gridVD ].id                  = nVertices;
-                _grid[ gridVD ].initID              = nVertices;
-                _grid[ gridVD ].groupID             = 0;
-                _grid[ gridVD ].componentID         = 0;
-
-                _grid[ gridVD ].namePtr             = new string( "" );
-                _grid[ gridVD ].namePixelWidthPtr   = new double( 0.0 );
-                _grid[ gridVD ].namePixelHeightPtr  = new double( 0.0 );
-
-                _grid[ gridVD ].weight              = 1.0;
-
-                _grid[ gridVD ].coordPtr            = &_gridCoord2Matrix[ i ][ j ];
-                _grid[ gridVD ].widthPtr            = new double( 10.0 );
-                _grid[ gridVD ].heightPtr           = new double( 10.0 );
-                _grid[ gridVD ].areaPtr             = new double( *_grid[ gridVD ].widthPtr * *_grid[ gridVD ].heightPtr );
-
-                _grid[ gridVD ].color               = 0;
-                _grid[ gridVD ].flag                = false;
-
-                // grid_graph
-                _grid[ gridVD ].gridVType           = Graph::GRID_VERTEX_DEFAULT;
-                _grid[ gridVD ].geoPtr              = new KeiRo::Base::Coord2( _gridCoord2Matrix[ i ][ j ].x(),
-                                                                  _gridCoord2Matrix[ i ][ j ].y() );
-                _grid[ gridVD ].smoothPtr           = new KeiRo::Base::Coord2( _gridCoord2Matrix[ i ][ j ].x(),
-                                                                  _gridCoord2Matrix[ i ][ j ].y() );
-
-                nVertices++;
-            }
-        }
-        assert( index == nVertices-1 );
-
-        // add grid vertical edges
-        for( unsigned int i = 0; i < _gridIDMatrix.size(); i++ ){
-            for( unsigned int j = 1; j < _gridIDMatrix[ i ].size(); j++ ){
-
-                unsigned int idS = i*_gridIDMatrix[ i ].size() + j-1;
-                unsigned int idT = i*_gridIDMatrix[ i ].size() + j;
-
-                Graph::GridGraph::vertex_descriptor vdS  = vertex( idS, _grid );
-                Graph::GridGraph::vertex_descriptor vdT  = vertex( idT, _grid );
-
-                pair< Graph::GridGraph::edge_descriptor, unsigned int > foreE = add_edge( vdS, vdT, _grid );
-                Graph::GridGraph::edge_descriptor foreED = foreE.first;
-
-                // base_graph
-                _grid[ foreED ].id              = nEdges;
-
-                _grid[ foreED ].angle           = 0.0;
-                _grid[ foreED ].weight          = 1.0;
-                _grid[ foreED ].visit           = false;
-                _grid[ foreED ].visitedTimes    = 0;
-
-                _grid[ foreED ].isFore          = false;
-                _grid[ foreED ].isBack          = false;
-
-                // grid_graph
-                // calculate geographical angle
-                KeiRo::Base::Coord2 coordO;
-                KeiRo::Base::Coord2 coordD;
-                if( _grid[ vdS ].id < _grid[ vdT ].id ){
-                    coordO = *_grid[ vdS ].coordPtr;
-                    coordD = *_grid[ vdT ].coordPtr;
-                }
-                else{
-                    coordO = *_grid[ vdT ].coordPtr;
-                    coordD = *_grid[ vdS ].coordPtr;
-                }
-                double diffX = coordD.x() - coordO.x();
-                double diffY = coordD.y() - coordO.y();
-                double angle = atan2( diffY, diffX );
-
-                _grid[ foreED ].geoAngle        = angle;
-
-                nEdges++;
-            }
-        }
-
-        // add grid horizontal edges
-        for( unsigned int j = 0; j < _gridIDMatrix[ 0 ].size(); j++ ){
-            for( unsigned int i = 1; i < _gridIDMatrix.size(); i++ ){
-
-                unsigned int idS = (i-1)*_gridIDMatrix[ i-1 ].size() + j;
-                unsigned int idT = i*_gridIDMatrix[ i ].size() + j;
-
-                Graph::GridGraph::vertex_descriptor vdS  = vertex( idS, _grid );
-                Graph::GridGraph::vertex_descriptor vdT  = vertex( idT, _grid );
-
-                pair< Graph::GridGraph::edge_descriptor, unsigned int > foreE = add_edge( vdS, vdT, _grid );
-                Graph::GridGraph::edge_descriptor foreED = foreE.first;
-
-                // base_graph
-                _grid[ foreED ].id              = nEdges;
-
-                _grid[ foreED ].angle           = 0.0;
-                _grid[ foreED ].weight          = 1.0;
-                _grid[ foreED ].visit           = false;
-                _grid[ foreED ].visitedTimes    = 0;
-
-                _grid[ foreED ].isFore          = false;
-                _grid[ foreED ].isBack          = false;
-
-                // grid_graph
-                // calculate geographical angle
-                KeiRo::Base::Coord2 coordO;
-                KeiRo::Base::Coord2 coordD;
-                if( _grid[ vdS ].id < _grid[ vdT ].id ){
-                    coordO = *_grid[ vdS ].coordPtr;
-                    coordD = *_grid[ vdT ].coordPtr;
-                }
-                else{
-                    coordO = *_grid[ vdT ].coordPtr;
-                    coordD = *_grid[ vdS ].coordPtr;
-                }
-                double diffX = coordD.x() - coordO.x();
-                double diffY = coordD.y() - coordO.y();
-                double angle = atan2( diffY, diffX );
-                _grid[ foreED ].geoAngle        = angle;
-
-                nEdges++;
-            }
-        }
-
-        for( unsigned int i = 0; i < _gridIDMatrix.size()-1; i++ ){
-            for( unsigned int j = 0; j < _gridIDMatrix[ i ].size()-1; j++ ){
-
-                vector< Graph::GridGraph::vertex_descriptor > vdVec;
-                getQuadVD( i, j, vdVec );
-
-                _quadFourCorners.push_back( vdVec );
-            }
-        }
-
-        _element[ 0 ] = _element[ 1 ] = 0;
-
-        // cerr << "_gridMatrix.size() = " << _gridMatrix.size() << endl;
-
-    }
-
-    //
-    //  Grid2::resetGridPosition --	reset grid node position
-    //
-    //  Inputs
-    //	none
-    //
-    //  Outputs
-    //	none
-    //
-    void Grid2::resetGridPosition( void )
-    {
-        // reset grid node position
-        BGL_FORALL_VERTICES( vd, _grid, Graph::GridGraph ) {
-
-            _grid[vd].coordPtr->x() = _grid[vd].smoothPtr->x() = _grid[vd].geoPtr->x();
-            _grid[vd].coordPtr->y() = _grid[vd].smoothPtr->y() = _grid[vd].geoPtr->y();
-
-        }
-    }
-
-
-    //
-    //  Grid2::Grid2 --	parameterized constructor
-    //
-    //  Input
-    //	 x, y :	2D coordinates
-    //
-    //  Output
-    //	none
-    //
-    Grid2::Grid2( const int x, const int y )
-    {
-        _element[ 0 ]	= x;
-        _element[ 1 ]	= y;
-    }
-
-    //
-    //  Grid2::Grid2 --	copy constructor
-    //
-    //  Input
-    //	v	: 2D coordinates
-    //
-    //  Output
-    //	none
-    //
-    Grid2::Grid2( const Grid2 & v )
-    {
-        _element[ 0 ]	= v._element[ 0 ];
-        _element[ 1 ]	= v._element[ 1 ];
-     }
-
-
-    //------------------------------------------------------------------------------
-    //	Assignment operators
-    //------------------------------------------------------------------------------
-    //
-    //  Grid2::operator = --	assignment
-    //
-    //  Inputs
-    //	v	: 2D coordinates
-    //
-    //  Outputs
-    //	reference to this object
-    //
-    Grid2 & Grid2::operator = ( const Grid2 & v )
-    {
-        if ( this != &v ) {
-            _element[ 0 ]	= v._element[ 0 ];
-            _element[ 1 ]	= v._element[ 1 ];
-        }
-        return *this;
-    }
-
-
-    //
-    //  Grid2::operator += --	addition + assignment
-    //
-    //  Inputs
-    //	v	: 2D coordinates
-    //
-    //  Outputs
-    //	reference to this object
-    //
-    Grid2 & Grid2::operator += ( const Grid2 & v )
-    {
-        _element[ 0 ]	+= v._element[ 0 ];
-        _element[ 1 ]	+= v._element[ 1 ];
-        return *this;
-    }
-
-
-    //
-    //  Grid2::operator -= --	subtraction + assignment
-    //
-    //  Inputs
-    //	v	: 2D coordinates
-    //
-    //  Outputs
-    //	reference to this object
-    //
-    Grid2 & Grid2::operator -= ( const Grid2 & v )
-    {
-        _element[ 0 ]	-= v._element[ 0 ];
-        _element[ 1 ]	-= v._element[ 1 ];
-        return *this;
-    }
-
-
-    //
-    //  Grid2::operator -= --	scalar product + assignment
-    //
-    //  Inputs
-    //	d	: scalar value
-    //
-    //  Outputs
-    //	reference to this object
-    //
-    Grid2 & Grid2::operator *= ( const int d )
-    {
-        _element[ 0 ]	*= d;
-        _element[ 1 ]	*= d;
-        return *this;
-    }
-
-
-    //
-    //  Grid2::operator [] --	reference to an element
-    //
-    //  Inputs
-    //	i	: index of the coordinate
-    //
-    //  Outputs
-    //	the corresponding coordinate
-    //
-    const int & Grid2::operator [] ( int i ) const
-    {
-    #ifdef GRID2_INDEX_CHECK
-        const char theName[] = "Grid2::operator [] : ";
-        if ( ( i < 0 ) || ( i > 1 ) ) {
-        cerr << theName << " index = " << i << endl;
-        assert( ( 0 <= i ) && ( i <= 1 ) );
-        }
-    #endif	// GRID2_INDEX_CHECK
-        return _element[ i ];
-    }
-
-
-    //
-    //  Grid2::operator [] --	reference to an element
-    //
-    //  Inputs
-    //	i	: index of the coordinate
-    //
-    //  Outputs
-    //	the corresponding coordinate
-    //
-    int & Grid2::operator [] ( int i )
-    {
-    #ifdef GRID2_INDEX_CHECK
-        const char theName[] = "Grid2::operator [] : ";
-        if ( ( i < 0 ) || ( i > 1 ) ) {
-        cerr << theName << " index = " << i << endl;
-        assert( ( 0 <= i ) && ( i <= 1 ) );
-        }
-    #endif	// GRID2_INDEX_CHECK
-        return _element[ i ];
-    }
-
-
-    //
-    //  Grid2::set --	set all the coordinates
-    //
-    //  Inputs
-    //	x, y	: x and y coordinates
-    //
-    //  Returns
-    //	none
-    //
-    void Grid2::set( const int x, const int y )
-    {
-        _element[ 0 ]	= x;
-        _element[ 1 ]	= y;
-    }
-
-    //------------------------------------------------------------------------------
-    //	Special functions
-    //------------------------------------------------------------------------------
-    //
-    //  Grid2::getQuadVID --	get corner ids of a quad
-    //
-    //  Inputs
-    //	i	: x index
-    //	j	: y index
-    //	vid	: id vector
-    //
-    //  Outputs
-    //	none
-    //
-    void Grid2::getQuadVD ( unsigned int i, unsigned int j,
-                            vector< Graph::GridGraph::vertex_descriptor > &vdVec )
-    {
-        unsigned int xrange = 2*_range[0]+1;
-        unsigned int yrange = 2*_range[1]+1;
-
-        vdVec.resize( 4 );
-
-        vdVec[ 0 ] = vertex( i*yrange + j, _grid );
-        vdVec[ 1 ] = vertex( (i+1)*yrange + j, _grid );
-        vdVec[ 2 ] = vertex( (i+1)*yrange + j+1, _grid );
-        vdVec[ 3 ] = vertex( i*yrange + j+1, _grid );
-
-#ifdef DEBUG
-        cerr << "i = " << i << " j = " << j << endl;
-        for( unsigned int k = 0; k < vid.size(); k++ ){
-            cerr << vid[ k ] << " ";
-        }
-        cerr << endl;
-#endif // DEBUG
-    }
-
-    //------------------------------------------------------------------------------
-    //	Friend functions
-    //------------------------------------------------------------------------------
-    //
-    //  operator - --	sign change
-    //
-    //  Inputs
-    //	a	: 2D coordinates
-    //
-    //  Outputs
-    //	2D coordinates in the opposite direction
-    //
-    Grid2 operator - ( const Grid2 & a )
-    {
-        return Grid2( -a._element[ 0 ], -a._element[ 1 ] );
-    }
-
-
-    //
-    //  operator + --	addition
-    //
-    //  Inputs
-    //	a, b	: 2D coordinates
-    //
-    //  Outputs
-    //	addition of the two 2D coordinates
-    //
-    Grid2 operator + ( const Grid2 & a, const Grid2 & b )
-    {
-        return Grid2( a._element[ 0 ] + b._element[ 0 ],
-              a._element[ 1 ] + b._element[ 1 ] );
-    }
-
-
-    //
-    //  operator - --	difference
-    //
-    //  Inputs
-    //	a, b	: 2D coordinates
-    //
-    //  Outputs
-    //	difference of the two 2D coordinates
-    //
-    Grid2 operator - ( const Grid2 & a, const Grid2 & b )
-    {
-        return Grid2( a._element[ 0 ] - b._element[ 0 ],
-              a._element[ 1 ] - b._element[ 1 ] );
-    }
-
-
-    //
-    //  operator * --	scalar product
-    //
-    //  Inputs
-    //	d	: scalar value
-    //	a	: 2D coordinates
-    //
-    //  Outputs
-    //	scalar product
-    //
-    Grid2 operator * ( const int d, const Grid2 & a )
-    {
-        return Grid2( d * a._element[ 0 ], d * a._element[ 1 ] );
-    }
-
-
-    //
-    //  operator * --	inner product
-    //
-    //  Inputs
-    //	a, b	: 2D coordinates
-    //
-    //  Outputs
-    //	inner product
-    //
-    int operator * ( const Grid2 & a, const Grid2 & b )
-    {
-        return ( a._element[ 0 ] * b._element[ 0 ] +
-             a._element[ 1 ] * b._element[ 1 ] );
-    }
-
-
-    //
-    //  operator == --	equivalence
-    //
-    //  Inputs
-    //	a, b	: 2D coordinates
-    //
-    //  Outputs
-    //	boolean value
-    //
-    int operator == ( const Grid2 & a, const Grid2 & b )
-    {
-        return ( ( a._element[ 0 ] == b._element[ 0 ] ) &&
-             ( a._element[ 1 ] == b._element[ 1 ] ) );
-    }
-
-
-    //
-    //  operator < --	comparison (less than)
-    //
-    //  Inputs
-    //	a, b	: 2D coordinates
-    //
-    //  Outputs
-    //	boolean value
-    //
-    int operator < ( const Grid2 & a, const Grid2 & b )
-    {
-        if ( a._element[ 0 ] < b._element[ 0 ] ) return true;
-        else if ( a._element[ 0 ] > b._element[ 0 ] ) return false;
-        else {
-        if ( a._element[ 1 ] < b._element[ 1 ] ) return true;
-        else if ( a._element[ 1 ] > b._element[ 1 ] ) return false;
-        else return false;
-        }
-    }
-
-
-    //
-    //  operator > --	comparison (more than)
-    //
-    //  Inputs
-    //	a, b	: 2D coordinates
-    //
-    //  Outputs
-    //	boolean value
-    //
-    int operator > ( const Grid2 & a, const Grid2 & b )
-    {
-        if ( a._element[ 0 ] > b._element[ 0 ] ) return true;
-        else if ( a._element[ 0 ] < b._element[ 0 ] ) return false;
-        else {
-        if ( a._element[ 1 ] > b._element[ 1 ] ) return true;
-        else if ( a._element[ 1 ] < b._element[ 1 ] ) return false;
-        else return false;
-        }
-    }
-
-
-    //------------------------------------------------------------------------------
-    //	I/O functions
-    //------------------------------------------------------------------------------
-    //
-    //  operator << --	output
-    //
-    //  Inputs
-    //	s	: reference to output stream
-    //	v	: 2D coordinates
-    //
-    //  Outputs
-    //	reference to output stream
-    //
-    ostream & operator << ( ostream & stream, const Grid2 & obj )
-    {
-        // set the output formatting
-        int width = 16;
-        // print out the elements
-        for ( int i = 0; i < 2; i++ ) {
-        stream << setw( width ) << obj._element[ i ];
-        if ( i != 1 ) stream << "\t";
-        }
-        stream << endl;
-
-        return stream;
-    }
-
-
-    //
-    //  operator >> --	input
-    //
-    //  Inputs
-    //	s	: reference to input stream
-    //	v	: 2D coordinates
-    //
-    //  Outputs
-    //	reference to input stream
-    //
-    istream & operator >> ( istream & stream, Grid2 & obj )
-    {
-        // reading the elements
-        for ( int i = 0; i < 2; i++ )
-        stream >> obj._element[ i ];
-        return stream;
-    }
-
-
-
-
Index: Graph/src/SchematicEdgeProperty.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// BoundaryEdgeProperty.h\r\n//\t: header file for 2D coordinaes\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Dec 27 23:16:12 2011\r\n//\r\n//******************************************************************************\r\n\r\n#ifndef _BoundaryEdgeProperty_H\r\n#define _BoundaryEdgeProperty_H\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n#include <iostream>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\n#include \"Coord2.h\"\r\n#include \"Line2.h\"\r\n#include \"BaseEdgeProperty.h\"\r\n//#include \"ui/GraphicsEdgeItem.h\"\r\n\r\nnamespace Graph {\r\n//------------------------------------------------------------------------------\r\n//\tDefining Macros\r\n//------------------------------------------------------------------------------\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Classes\r\n//------------------------------------------------------------------------------\r\n\t\r\n\tclass SchematicEdgeProperty : public BaseEdgeProperty {\r\n\t\r\n\tprotected:\r\n\t\t\r\n\t\tvoid _init( void );\r\n\t\r\n\t\r\n\tpublic:\r\n\r\n//------------------------------------------------------------------------------\r\n//\tConstructors\r\n//------------------------------------------------------------------------------\r\n\t\tSchematicEdgeProperty();                // constructor (default)\r\n\t\tSchematicEdgeProperty( const SchematicEdgeProperty &e ) {\r\n\t\t\tid = e.id;\r\n\t\t\tweight = e.weight;\r\n\t\t}                    // copy constructor\r\n\t\tvirtual ~SchematicEdgeProperty() {}        // destructor\r\n\r\n//------------------------------------------------------------------------------\r\n//\tAssignment operators\r\n//------------------------------------------------------------------------------\r\n\r\n//------------------------------------------------------------------------------\r\n//\tReference to elements\r\n//------------------------------------------------------------------------------\r\n\t\tunsigned int initID;\r\n\t\tvector< unsigned int > lineID;\r\n\t\t\r\n\t\tdouble geoAngle;\r\n\t\tdouble smoothAngle;\r\n\t\tdouble targetAngle;\r\n\r\n//\tGraphicsEdgeItem *itemPtr;        // pointer to graphic objects\r\n\r\n//------------------------------------------------------------------------------\r\n//\tSpecial functions\r\n//------------------------------------------------------------------------------\r\n\t\t\r\n\t\tvoid init( void ) { _init(); }\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIntersection check\r\n//------------------------------------------------------------------------------\r\n\r\n//------------------------------------------------------------------------------\r\n//\tFriend functions\r\n//------------------------------------------------------------------------------\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tI/O functions\r\n//------------------------------------------------------------------------------\r\n\t\tfriend ostream &operator<<( ostream &s, const SchematicEdgeProperty &v );\r\n\t\t\r\n\t\t// Output\r\n\t\tfriend istream &operator>>( istream &s, SchematicEdgeProperty &v );\r\n\t\t\r\n\t\t// Input\r\n\t\tvirtual const char *className( void ) const { return \"BoundaryEdgeProperty\"; }\r\n\t\t// class name\r\n\t\t\r\n\t};\r\n}\r\n#endif // _BoundaryEdgeProperty_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Graph/src/SchematicEdgeProperty.h b/Graph/src/SchematicEdgeProperty.h
--- a/Graph/src/SchematicEdgeProperty.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Graph/src/SchematicEdgeProperty.h	(date 1729410604700)
@@ -1,101 +1,0 @@
-//******************************************************************************
-// BoundaryEdgeProperty.h
-//	: header file for 2D coordinaes
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Dec 27 23:16:12 2011
-//
-//******************************************************************************
-
-#ifndef _BoundaryEdgeProperty_H
-#define _BoundaryEdgeProperty_H
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-#include <iostream>
-#include <vector>
-
-using namespace std;
-
-#include "Coord2.h"
-#include "Line2.h"
-#include "BaseEdgeProperty.h"
-//#include "ui/GraphicsEdgeItem.h"
-
-namespace Graph {
-//------------------------------------------------------------------------------
-//	Defining Macros
-//------------------------------------------------------------------------------
-
-
-//------------------------------------------------------------------------------
-//	Defining Classes
-//------------------------------------------------------------------------------
-	
-	class SchematicEdgeProperty : public BaseEdgeProperty {
-	
-	protected:
-		
-		void _init( void );
-	
-	
-	public:
-
-//------------------------------------------------------------------------------
-//	Constructors
-//------------------------------------------------------------------------------
-		SchematicEdgeProperty();                // constructor (default)
-		SchematicEdgeProperty( const SchematicEdgeProperty &e ) {
-			id = e.id;
-			weight = e.weight;
-		}                    // copy constructor
-		virtual ~SchematicEdgeProperty() {}        // destructor
-
-//------------------------------------------------------------------------------
-//	Assignment operators
-//------------------------------------------------------------------------------
-
-//------------------------------------------------------------------------------
-//	Reference to elements
-//------------------------------------------------------------------------------
-		unsigned int initID;
-		vector< unsigned int > lineID;
-		
-		double geoAngle;
-		double smoothAngle;
-		double targetAngle;
-
-//	GraphicsEdgeItem *itemPtr;        // pointer to graphic objects
-
-//------------------------------------------------------------------------------
-//	Special functions
-//------------------------------------------------------------------------------
-		
-		void init( void ) { _init(); }
-
-//------------------------------------------------------------------------------
-//	Intersection check
-//------------------------------------------------------------------------------
-
-//------------------------------------------------------------------------------
-//	Friend functions
-//------------------------------------------------------------------------------
-
-
-//------------------------------------------------------------------------------
-//	I/O functions
-//------------------------------------------------------------------------------
-		friend ostream &operator<<( ostream &s, const SchematicEdgeProperty &v );
-		
-		// Output
-		friend istream &operator>>( istream &s, SchematicEdgeProperty &v );
-		
-		// Input
-		virtual const char *className( void ) const { return "BoundaryEdgeProperty"; }
-		// class name
-		
-	};
-}
-#endif // _BoundaryEdgeProperty_H
Index: Graph/src/BaseDirectedGraph.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// BaseDirectedGraph.h\r\n//\t: header file for base directed graph\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Dec 27 23:16:12 2018\r\n//\r\n//******************************************************************************\r\n\r\n#ifndef _Graph_BaseDirectedGraph_H\r\n#define _Graph_BaseDirectedGraph_H\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <string>\r\n#include <iostream>\r\n#include <fstream>\r\n#include <vector>\r\n#include <map>\r\n#include <algorithm>\r\n#include <ctime>\r\n#include <cstdlib>\r\n\r\nusing namespace std;\r\n\r\n#include <boost/config.hpp>\r\n#include <boost/graph/graph_traits.hpp>\r\n#include <boost/graph/adjacency_list.hpp>\r\n#include <boost/graph/iteration_macros.hpp>\r\n\r\n// force-directed layout\r\n#include <boost/graph/fruchterman_reingold.hpp>\r\n//#include <boost/graph/kamada_kawai_spring_layout.hpp>\r\n#include <boost/graph/random_layout.hpp>\r\n#include <boost/graph/topology.hpp>\r\n#include <boost/lexical_cast.hpp>\r\n#include <boost/graph/connected_components.hpp>\r\n\r\nusing namespace boost;\r\n\r\n#include \"base/Coord2.h\"\r\n#include \"graph/BaseGraphProperty.h\"\r\n#include \"graph/BaseVertexProperty.h\"\r\n#include \"graph/BaseEdgeProperty.h\"\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Macros\r\n//------------------------------------------------------------------------------\r\n\r\nnamespace Graph {\r\n\r\n    typedef adjacency_list< listS, listS, bidirectionalS,\r\n            BaseVertexProperty, BaseEdgeProperty,\r\n            BaseGraphProperty >  BaseDirectedGraph;\r\n\r\n    // position map\r\n    typedef boost::rectangle_topology<> topologyType;\r\n    typedef topologyType::point_type pointType;\r\n    typedef vector< pointType > PositionVec;\r\n    typedef iterator_property_map< PositionVec::iterator,\r\n            property_map< BaseDirectedGraph, unsigned int BaseVertexProperty::* >::type > PositionMap;\r\n\r\n    // difference map\r\n    typedef boost::convex_topology< 2 >::point_difference PointDifference;\r\n    typedef vector< PointDifference > DifferenceVec;\r\n    typedef iterator_property_map< DifferenceVec::iterator,\r\n            property_map< BaseDirectedGraph, unsigned int BaseVertexProperty::* >::type > DifferenceMap;\r\n    typedef vector< PointDifference > DifferenceVec;\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tSpecial functions\r\n    //------------------------------------------------------------------------------\r\n    void randomGraphLayout( BaseDirectedGraph & graph, double width, double height );\r\n    void fruchtermanGraphLayout( BaseDirectedGraph & graph, double width, double height );\r\n    void printGraph( const  BaseDirectedGraph & g );\r\n    void clearGraph( BaseDirectedGraph & g );\r\n\r\n} // namespace Graph\r\n\r\n#endif  // _Graph_BaseDirectedGraph_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Graph/src/BaseDirectedGraph.h b/Graph/src/BaseDirectedGraph.h
--- a/Graph/src/BaseDirectedGraph.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Graph/src/BaseDirectedGraph.h	(date 1729410604710)
@@ -1,83 +1,0 @@
-//******************************************************************************
-// BaseDirectedGraph.h
-//	: header file for base directed graph
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Dec 27 23:16:12 2018
-//
-//******************************************************************************
-
-#ifndef _Graph_BaseDirectedGraph_H
-#define _Graph_BaseDirectedGraph_H
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <string>
-#include <iostream>
-#include <fstream>
-#include <vector>
-#include <map>
-#include <algorithm>
-#include <ctime>
-#include <cstdlib>
-
-using namespace std;
-
-#include <boost/config.hpp>
-#include <boost/graph/graph_traits.hpp>
-#include <boost/graph/adjacency_list.hpp>
-#include <boost/graph/iteration_macros.hpp>
-
-// force-directed layout
-#include <boost/graph/fruchterman_reingold.hpp>
-//#include <boost/graph/kamada_kawai_spring_layout.hpp>
-#include <boost/graph/random_layout.hpp>
-#include <boost/graph/topology.hpp>
-#include <boost/lexical_cast.hpp>
-#include <boost/graph/connected_components.hpp>
-
-using namespace boost;
-
-#include "base/Coord2.h"
-#include "graph/BaseGraphProperty.h"
-#include "graph/BaseVertexProperty.h"
-#include "graph/BaseEdgeProperty.h"
-
-//------------------------------------------------------------------------------
-//	Defining Macros
-//------------------------------------------------------------------------------
-
-namespace Graph {
-
-    typedef adjacency_list< listS, listS, bidirectionalS,
-            BaseVertexProperty, BaseEdgeProperty,
-            BaseGraphProperty >  BaseDirectedGraph;
-
-    // position map
-    typedef boost::rectangle_topology<> topologyType;
-    typedef topologyType::point_type pointType;
-    typedef vector< pointType > PositionVec;
-    typedef iterator_property_map< PositionVec::iterator,
-            property_map< BaseDirectedGraph, unsigned int BaseVertexProperty::* >::type > PositionMap;
-
-    // difference map
-    typedef boost::convex_topology< 2 >::point_difference PointDifference;
-    typedef vector< PointDifference > DifferenceVec;
-    typedef iterator_property_map< DifferenceVec::iterator,
-            property_map< BaseDirectedGraph, unsigned int BaseVertexProperty::* >::type > DifferenceMap;
-    typedef vector< PointDifference > DifferenceVec;
-
-    //------------------------------------------------------------------------------
-    //	Special functions
-    //------------------------------------------------------------------------------
-    void randomGraphLayout( BaseDirectedGraph & graph, double width, double height );
-    void fruchtermanGraphLayout( BaseDirectedGraph & graph, double width, double height );
-    void printGraph( const  BaseDirectedGraph & g );
-    void clearGraph( BaseDirectedGraph & g );
-
-} // namespace Graph
-
-#endif  // _Graph_BaseDirectedGraph_H
Index: Composite/src/CompressionGrid.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// Compression.cpp\r\n//\t: program file for Compression\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Mon Mar 16 07:58:23 2020\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include \"CompressionGrid.h\"\r\n\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPrivate Functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tProtected Functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  Compression::_init -- initialize the compressed data\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void CompressionGrid::_init( Grid2 * __gridPtr,\r\n                             vector< KeiRo::Base::Polygon2 > *__polygonVecPtr,\r\n                             vector< KeiRo::Base::Line2 > *__polylineVecPtr )\r\n\r\n    {\r\n        _clear();\r\n        _gridPtr        =  __gridPtr;\r\n        _polygonVecPtr  = __polygonVecPtr;\r\n        _polylineVecPtr = __polylineVecPtr;\r\n    }\r\n\r\n    //\r\n    //  Compression::_clear -- clear the compressed data\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void CompressionGrid::_clear( void )\r\n    {\r\n        _fixedSamples.clear();\r\n        _samples.clear();\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPublic functions\r\n    //------------------------------------------------------------------------------\r\n    //------------------------------------------------------------------------------\r\n    //\tConstructors & Destructors\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  Compression::Compression --\tdefault constructor\r\n    //\r\n    //  Inputs\r\n    //\tnone\r\n    //\r\n    //  Outputs\r\n    //\tnone\r\n    //\r\n    CompressionGrid::CompressionGrid( void )\r\n    {\r\n        //------------------------------------------------------------------------------\r\n        // configuration file\r\n        //------------------------------------------------------------------------------\r\n\r\n        string configFilePath = qApp->applicationDirPath().toStdString() + \"/../config/MainWindow.conf\";\r\n\t    KeiRo::Base::Config conf( configFilePath );\r\n\r\n        if ( conf.has( \"min_point_distance\" ) ){\r\n            string paramMinPointDistance = conf.gets( \"min_point_distance\" );\r\n            _min_point_distance = stoi( paramMinPointDistance );\r\n        }\r\n\t\r\n\t    _fixedSamples.clear();\r\n        _samples.clear();\r\n\t\r\n\t    _polygonVecPtr = NULL;\r\n\t    _polylineVecPtr = NULL;\r\n\t    _gridPtr = NULL;\r\n\t    \r\n#ifdef COMPRESSION_DEBUG\r\n        cerr << \"_min_point_distance: \" << _min_point_distance << endl;\r\n#endif // COMPRESSION_DEBUG\r\n\r\n    }\r\n\r\n\t//\r\n\t//  Compression::Compression --\tcopy constructor\r\n\t//\r\n\t//  Inputs\r\n\t//\tnone\r\n\t//\r\n\t//  Outputs\r\n\t//\tnone\r\n\t//\r\n\tCompressionGrid::CompressionGrid( const CompressionGrid & v )\r\n\t{\r\n\t\t_fixedSamples   = v._fixedSamples;\r\n\t\t_samples        = v._samples;\r\n\t\t\r\n\t\t_polygonVecPtr  = v._polygonVecPtr;\r\n\t\t_polylineVecPtr = v._polylineVecPtr;\r\n\t\t_gridPtr        = v._gridPtr;\r\n\t}\r\n    //\r\n    //  Compression::~Compression --\tdestructor\r\n    //\r\n    //  Inputs\r\n    //\tnone\r\n    //\r\n    //  Outputs\r\n    //\tnone\r\n    //\r\n    CompressionGrid::~CompressionGrid()\r\n    {\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tAssignment operators\r\n    //------------------------------------------------------------------------------\r\n    CompressionGrid & CompressionGrid::operator = ( const CompressionGrid & v )\r\n    {\r\n\t    if ( this != &v ) {\r\n\t\t    _fixedSamples   = v._fixedSamples;\r\n\t\t    _samples        = v._samples;\r\n\t\t\r\n\t\t    _polygonVecPtr  = v._polygonVecPtr;\r\n\t\t    _polylineVecPtr = v._polylineVecPtr;\r\n\t\t    _gridPtr        = v._gridPtr;\r\n\t    }\r\n\t    return *this;\r\n    }\r\n\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tSpecial functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  Compression::createCompression --\tcreate compression from polygons and polylines\r\n    //\r\n    //  Inputs\r\n    //\tnone\r\n    //\r\n    //  Outputs\r\n    //\tnone\r\n    //\r\n    bool CompressionGrid::_closeToSamples( KeiRo::Base::Coord2 &coord, unsigned int &index )\r\n    {\r\n\t\treturn false;\r\n        index = 0;\r\n        for( unsigned int i = 0; i < _samples.size(); i++ ){\r\n\r\n            double distance = distanceBetween( coord, _samples[i] );\r\n            if( distance < _min_point_distance ) {\r\n                index = i;\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    //\r\n    //  Compression::createCompressedSamples --\tcreate compression from samples of polygons and polylines\r\n    //\r\n    //  Inputs\r\n    //\tnone\r\n    //\r\n    //  Outputs\r\n    //\tnone\r\n    //\r\n    void CompressionGrid::createCompressedSamples( void )\r\n    {\r\n        // sample size index\r\n        unsigned int nV = 0;\r\n\r\n        // add polygonal objects\r\n        for( unsigned int i = 0; i < _polygonVecPtr->size(); i++ ){\r\n\r\n            vector< KeiRo::Base::Coord2 > &elements = (*_polygonVecPtr)[i].elements();\r\n            vector< unsigned int > &idElements = (*_polygonVecPtr)[i].idElements();\r\n//            cerr << \"i = \" << i << \", elements.size() = \" << elements.size() << endl;\r\n\r\n            for( unsigned int j = 0; j < elements.size(); j++ ){\r\n\t\r\n\t            KeiRo::Base::Coord2 &coord = elements[j];\r\n                unsigned int index = 0;\r\n                if( _closeToSamples( coord, index ) == true ){\r\n                    // cerr << \"index = \" << index << endl;\r\n                    idElements.push_back( index );\r\n                }\r\n                else{\r\n                \tcoord.updateOldElement();\r\n                    _fixedSamples.push_back( coord );\r\n                    _samples.push_back( coord );\r\n                    idElements.push_back( nV );\r\n                    nV++;\r\n                }\r\n            }\r\n        }\r\n        \r\n#ifdef COMPRESSION_DEBUG\r\n        for( unsigned int i = 0; i < _polygonVecPtr->size(); i++ ){\r\n\r\n        \tvector< KeiRo::Base::Coord2 > &elements = (*_polygonVecPtr)[i].elements();\r\n        \tvector< unsigned int > &idElements = (*_polygonVecPtr)[i].idElements();\r\n        \tcerr << \" i = \" << i << \", elements.size() = \" << elements.size() << endl;\r\n        \tcerr << \" i = \" << i << \", idElements.size() = \" << idElements.size() << endl;\r\n        }\r\n\r\n        for( unsigned int i = 0; i < _samples.size(); i++ ){\r\n            cerr << \"ref = \" << &_samples[i] << \", i = \" << i << \" , \" << _samples[i];\r\n        }\r\n        cerr << endl;\r\n        for( unsigned int i = 0; i < _polygonVecPtr->size(); i++ ){\r\n\r\n            cerr << \"i = \" << i << endl;\r\n            vector< KeiRo::Base::Coord2 > &elements = (*_polygonVecPtr)[i].elements();\r\n            vector< unsigned int > &idElements = (*_polygonVecPtr)[i].idElements();\r\n\r\n            for( unsigned int j = 0; j < elements.size(); j++ ){\r\n                // pointerElements[j] = &elements[j];\r\n                cerr << \"j = \" << j << \", \" << idElements[j] << \", c = \" << elements[j];\r\n            }\r\n            cerr << endl;\r\n        }\r\n#endif // COMPRESSION_DEBUG\r\n\r\n        // add line objects\r\n        for( unsigned int i = 0; i < _polylineVecPtr->size(); i++ ){\r\n\r\n            vector< KeiRo::Base::Coord2 > &elements = (*_polylineVecPtr)[i].elements();\r\n            vector< unsigned int > &idElements = (*_polylineVecPtr)[i].idElements();\r\n            for( unsigned int j = 0; j < elements.size(); j++ ){\r\n\t\r\n\t            KeiRo::Base::Coord2 &coord = elements[j];\r\n                unsigned int index = 0;\r\n                if( _closeToSamples( coord, index ) == true ){\r\n                    idElements.push_back( index );\r\n                }\r\n                else{\r\n\t                coord.updateOldElement();\r\n\t                _fixedSamples.push_back( coord );\r\n                    _samples.push_back( coord );\r\n                    idElements.push_back( nV );\r\n                    nV++;\r\n                }\r\n            }\r\n        }\r\n\r\n#ifdef COMPRESSION_DEBUG\r\n        cerr << \"nV = \" << nV << endl;\r\n        cerr << \"nPolygons = \" << _polygonVecPtr->size() << \" _nPolylines = \" << _polylineVecPtr->size() << endl;\r\n        cerr << \"_samples.size() = \" << _samples.size() << \" _fixedSamples.size() = \" << _fixedSamples.size() << endl;\r\n#endif // COMPRESSION_DEBUG\r\n    }\r\n\r\n    //\r\n    //  Compression::createCompressedJoints --\tcreate compression from joints of polygons and polylines\r\n    //\r\n    //  Inputs\r\n    //\tnone\r\n    //\r\n    //  Outputs\r\n    //\tnone\r\n    //\r\n    void CompressionGrid::createCompressedJoints( void )\r\n    {\r\n        // sample size index\r\n        unsigned int nV = 0;\r\n\r\n        // add polygonal x line intersection\r\n        for( unsigned int i = 0; i < _polygonVecPtr->size(); i++ ){\r\n\r\n            // get polygon elements\r\n            vector< KeiRo::Base::Coord2 > newPolygonElements;\r\n            vector< unsigned int > newPolygonIDElements;\r\n            vector< KeiRo::Base::Coord2 > &polygonElements = (*_polygonVecPtr)[i].elements();\r\n            newPolygonElements.push_back( polygonElements[0] );\r\n\r\n            for( unsigned int j = 0; j < polygonElements.size(); j++ ){\r\n\t\r\n\t            KeiRo::Base::Coord2 &coordA = polygonElements[j];\r\n\t            KeiRo::Base::Coord2 &coordB = polygonElements[ (j+1)%polygonElements.size() ];\r\n\t            KeiRo::Base::Coord2 unitBA = (coordA-coordB)/(coordA-coordB).norm();\r\n\t            KeiRo::Base::Coord2 a = coordA + _min_point_distance * unitBA;\r\n\t            KeiRo::Base::Coord2 b = coordB - _min_point_distance * unitBA;\r\n\r\n                // get line elements\r\n                for( unsigned int m = 0; m < _polylineVecPtr->size(); m++ ){\r\n\r\n                    map< double, KeiRo::Base::Coord2 > intersectionMap;\r\n                    vector< KeiRo::Base::Coord2 > &lineElements = (*_polylineVecPtr)[m].elements();\r\n                    //vector< unsigned int > &lineIDElements = (*_polylineVecPtr)[m].idElements();\r\n                    for( unsigned int n = 0; n < lineElements.size()-1; n++ ){\r\n\t\r\n\t                    KeiRo::Base::Coord2 &coordC = lineElements[ n ];\r\n\t                    KeiRo::Base::Coord2 &coordD = lineElements[ n+1 ];\r\n\t                    KeiRo::Base::Coord2 unitDC = (coordC-coordD)/(coordC-coordD).norm();\r\n\t\r\n\t                    KeiRo::Base::Coord2 c = coordC + _min_point_distance * unitDC;\r\n\t                    KeiRo::Base::Coord2 d = coordD - _min_point_distance * unitDC;\r\n\t                    KeiRo::Base::Coord2 intersection;\r\n                        if( isIntersected( a, b, c, d, intersection ) == true ){\r\n\r\n                            // add intermediate sample points\r\n                            double distance = ( intersection-coordA ).norm();\r\n\r\n                            if( !( ( distance < _min_point_distance ) ||\r\n                                   ( ( intersection-coordB ).norm() < _min_point_distance ) ) ) {\r\n                                // cerr << \"intersection = \" << intersection;\r\n                                intersectionMap.insert( pair< double, KeiRo::Base::Coord2 >( distance, intersection ) );\r\n                            }\r\n\r\n#ifdef COMPRESSION_DEBUG\r\n                            cerr << \"isIntersected = \" << true << endl;\r\n                            cerr << setprecision(50) << \" coordC = \" << coordC;\r\n                            cerr << setprecision(50) << \" coordD = \" << coordD;\r\n                            cerr << setprecision(50) << \"intersection = \" << intersection;\r\n                            if( distanceBetween( coordC, intersection ) < 1e-5 ){\r\n                                cerr << \"coordC == intersection\" << endl;\r\n                            }\r\n                            if( distanceBetween( coordD, intersection ) < 1e-5 ){\r\n                                cerr << \"coordD == intersection\" << endl;\r\n                            }\r\n                            cerr << endl;\r\n#endif // COMPRESSION_DEBUG\r\n                        }\r\n                    }\r\n\r\n                    // add intersected nodes\r\n                    // cerr << \"intersectionMap.size() = \" << intersectionMap.size() << endl;\r\n                    if( intersectionMap.size() > 0 ){\r\n\r\n                        map< double, KeiRo::Base::Coord2 >::iterator it = intersectionMap.begin();\r\n                        newPolygonElements.push_back( it->second );\r\n                        map< double, KeiRo::Base::Coord2 >::iterator itPrev = it;\r\n                        it++;\r\n                        for( ; it != intersectionMap.end(); it++ ){\r\n\r\n                            if( ( itPrev->second - it->second ).norm() > _min_point_distance ){\r\n                                newPolygonElements.push_back( it->second );\r\n                            }\r\n                            itPrev = it;\r\n                        }\r\n                    }\r\n\r\n                }\r\n\r\n                if( (j+1)%polygonElements.size() != 0 ){\r\n                    newPolygonElements.push_back( polygonElements[(j+1)%polygonElements.size()] );\r\n                }\r\n            }\r\n\r\n#ifdef COMPRESSION_DEBUG\r\n            cerr << \"ori = \" << polygonElements.size() << endl;\r\n            for( unsigned int j = 0; j < polygonElements.size(); j++ ){\r\n                cerr << \"j = \" << j << \", \" << polygonElements[j];\r\n            }\r\n            cerr << \"new = \" << newPolygonElements.size() << endl;\r\n            for( unsigned int j = 0; j < newPolygonElements.size(); j++ ){\r\n                cerr << \"j = \" << j << \", \" << newPolygonElements[j];\r\n            }\r\n            cerr << endl;\r\n#endif // COMPRESSION_DEBUG\r\n\r\n            (*_polygonVecPtr)[i].elements() = newPolygonElements;\r\n            (*_polygonVecPtr)[i].fixedElements() = newPolygonElements;\r\n        }\r\n\r\n    }\r\n\r\n    //\r\n    //  Compression::createCompressedGridJoints --\tcreate compression from joints of polygons and grids\r\n    //\r\n    //  Inputs\r\n    //\tnone\r\n    //\r\n    //  Outputs\r\n    //\tnone\r\n    //\r\n    void CompressionGrid::createCompressedGridJoints( void )\r\n    {\r\n        Graph::GridGraph & gridG = _gridPtr->gridG();\r\n//        printGraph( gridG );\r\n\r\n        for( unsigned int i = 0; i < _polygonVecPtr->size(); i++ ){\r\n\r\n            // get polygon elements\r\n            vector< KeiRo::Base::Coord2 > newPolygonElements;\r\n            vector< unsigned int > newPolygonIDElements;\r\n            vector< KeiRo::Base::Coord2 > &polygonElements = (*_polygonVecPtr)[i].elements();\r\n            newPolygonElements.push_back( polygonElements[0] );\r\n            for( unsigned int j = 0; j < polygonElements.size(); j++ ) {\r\n\t\r\n\t            KeiRo::Base::Coord2 &coordA = polygonElements[j];\r\n\t            KeiRo::Base::Coord2 &coordB = polygonElements[(j + 1) % polygonElements.size()];\r\n\t            KeiRo::Base::Coord2 unitBA = (coordA - coordB) / (coordA - coordB).norm();\r\n\t            KeiRo::Base::Coord2 a = coordA + _min_point_distance * unitBA;\r\n\t            KeiRo::Base::Coord2 b = coordB - _min_point_distance * unitBA;\r\n\r\n                // draw grid graph edges\r\n                map< double, KeiRo::Base::Coord2 > intersectionMap;\r\n                BGL_FORALL_EDGES( ed, gridG, Graph::GridGraph ) {\r\n\r\n                    Graph::GridGraph::vertex_descriptor vdS = source( ed, gridG );\r\n                    Graph::GridGraph::vertex_descriptor vdT = target( ed, gridG );\r\n                    KeiRo::Base::Coord2 &coordC = *gridG[ vdS ].coordPtr;\r\n                    KeiRo::Base::Coord2 &coordD = *gridG[ vdT ].coordPtr;\r\n                    KeiRo::Base::Coord2 unitDC = (coordC-coordD)/(coordC-coordD).norm();\r\n\r\n                    KeiRo::Base::Coord2 c = coordC + _min_point_distance * unitDC;\r\n                    KeiRo::Base::Coord2 d = coordD - _min_point_distance * unitDC;\r\n                    KeiRo::Base::Coord2 intersection;\r\n                    if( isIntersected( a, b, c, d, intersection ) == true ){\r\n\r\n                        // add intermediate sample points\r\n                        double distance = ( intersection-coordA ).norm();\r\n\r\n                        if( !( ( distance < _min_point_distance ) ||\r\n                            ( ( intersection-coordB ).norm() < _min_point_distance ) ) ) {\r\n                            intersectionMap.insert( pair< double, KeiRo::Base::Coord2 >( distance, intersection ) );\r\n                        }\r\n#ifdef COMPRESSION_DEBUG\r\n                        else{\r\n                            cerr << \"skip... \" << endl;\r\n                        }\r\n                        cerr << \"eid = \" << gridG[ed].id << endl;\r\n                        cerr << \"distance to A = \" << distance << endl;\r\n                        cerr << \"distance to B = \" << ( intersection-coordB ).norm() << endl;\r\n\r\n                        cerr << \"isIntersected = \" << true << endl;\r\n                        cerr << setprecision(50) << \" coordC = \" << coordC;\r\n                        cerr << setprecision(50) << \" coordD = \" << coordD;\r\n                        cerr << setprecision(50) << \"intersection = \" << intersection;\r\n                        if( distanceBetween( coordC, intersection ) < 1e-5 ){\r\n                            cerr << \"coordC == intersection\" << endl;\r\n                        }\r\n                        if( distanceBetween( coordD, intersection ) < 1e-5 ){\r\n                            cerr << \"coordD == intersection\" << endl;\r\n                        }\r\n                        cerr << endl;\r\n#endif // COMPRESSION_DEBUG\r\n                    }\r\n                }\r\n\r\n                // add intersected nodes\r\n                if( intersectionMap.size() > 0 ){\r\n                    map< double, KeiRo::Base::Coord2 >::iterator it = intersectionMap.begin();\r\n                    newPolygonElements.push_back( it->second );\r\n                    map< double, KeiRo::Base::Coord2 >::iterator itPrev = it;\r\n                    it++;\r\n                    for( ; it != intersectionMap.end(); it++ ){\r\n\r\n                        if( ( itPrev->second - it->second ).norm() > _min_point_distance ){\r\n                            newPolygonElements.push_back( it->second );\r\n                        }\r\n                        itPrev = it;\r\n                    }\r\n                }\r\n\r\n#ifdef COMPRESSION_DEBUG\r\n                cerr << \"list = \" << intersectionMap.size() << endl;\r\n                cerr << \"A: \" << coordA;\r\n                map< double, KeiRo::Base::Coord2 >::iterator it = intersectionMap.begin();\r\n                cerr << it->second;\r\n                newPolygonElements.push_back( it->second );\r\n                map< double, KeiRo::Base::Coord2 >::iterator itPrev = it;\r\n                it++;\r\n                for( ; it != intersectionMap.end(); it++ ){\r\n                    if( ( itPrev->second - it->second ).norm() > _min_point_distance ){\r\n                        cerr << \"( itPrev->second - it->second ).norm() = \" << ( itPrev->second - it->second ).norm()\r\n                             << \", \" << it->second;\r\n                    }\r\n                    itPrev = it;\r\n                }\r\n                cerr << \"B: \" << coordB;\r\n                cerr << endl;\r\n#endif // COMPRESSION_DEBUG\r\n\r\n                if( (j+1)%polygonElements.size() != 0 ){\r\n                    newPolygonElements.push_back( polygonElements[(j+1)%polygonElements.size()] );\r\n                }\r\n            }\r\n\r\n            (*_polygonVecPtr)[i].elements() = newPolygonElements;\r\n            (*_polygonVecPtr)[i].fixedElements() = newPolygonElements;\r\n        }\r\n    }\r\n\r\n    //\r\n    //  Compression::createCompression --\tcreate compression from polygons and polylines\r\n    //\r\n    //  Inputs\r\n    //\tnone\r\n    //\r\n    //  Outputs\r\n    //\tnone\r\n    //\r\n    void CompressionGrid::createCompression( bool isOn )\r\n    {\r\n\t\tif( isOn ){\r\n\t        createCompressedGridJoints();\r\n\t        createCompressedJoints();\r\n\t\t}\r\n\t\telse{\r\n\t\t\tcreateCompressedSamples();\r\n\t\t}\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tFriend functions\r\n    //------------------------------------------------------------------------------\r\n\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tI/O functions\r\n    //------------------------------------------------------------------------------\r\n\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Composite/src/CompressionGrid.cpp b/Composite/src/CompressionGrid.cpp
--- a/Composite/src/CompressionGrid.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Composite/src/CompressionGrid.cpp	(date 1729410604720)
@@ -1,537 +1,0 @@
-//******************************************************************************
-// Compression.cpp
-//	: program file for Compression
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Mon Mar 16 07:58:23 2020
-//
-//******************************************************************************
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include "CompressionGrid.h"
-
-
-    //------------------------------------------------------------------------------
-    //	Private Functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Protected Functions
-    //------------------------------------------------------------------------------
-    //
-    //  Compression::_init -- initialize the compressed data
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    //
-    void CompressionGrid::_init( Grid2 * __gridPtr,
-                             vector< KeiRo::Base::Polygon2 > *__polygonVecPtr,
-                             vector< KeiRo::Base::Line2 > *__polylineVecPtr )
-
-    {
-        _clear();
-        _gridPtr        =  __gridPtr;
-        _polygonVecPtr  = __polygonVecPtr;
-        _polylineVecPtr = __polylineVecPtr;
-    }
-
-    //
-    //  Compression::_clear -- clear the compressed data
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    //
-    void CompressionGrid::_clear( void )
-    {
-        _fixedSamples.clear();
-        _samples.clear();
-    }
-
-    //------------------------------------------------------------------------------
-    //	Public functions
-    //------------------------------------------------------------------------------
-    //------------------------------------------------------------------------------
-    //	Constructors & Destructors
-    //------------------------------------------------------------------------------
-    //
-    //  Compression::Compression --	default constructor
-    //
-    //  Inputs
-    //	none
-    //
-    //  Outputs
-    //	none
-    //
-    CompressionGrid::CompressionGrid( void )
-    {
-        //------------------------------------------------------------------------------
-        // configuration file
-        //------------------------------------------------------------------------------
-
-        string configFilePath = qApp->applicationDirPath().toStdString() + "/../config/MainWindow.conf";
-	    KeiRo::Base::Config conf( configFilePath );
-
-        if ( conf.has( "min_point_distance" ) ){
-            string paramMinPointDistance = conf.gets( "min_point_distance" );
-            _min_point_distance = stoi( paramMinPointDistance );
-        }
-	
-	    _fixedSamples.clear();
-        _samples.clear();
-	
-	    _polygonVecPtr = NULL;
-	    _polylineVecPtr = NULL;
-	    _gridPtr = NULL;
-	    
-#ifdef COMPRESSION_DEBUG
-        cerr << "_min_point_distance: " << _min_point_distance << endl;
-#endif // COMPRESSION_DEBUG
-
-    }
-
-	//
-	//  Compression::Compression --	copy constructor
-	//
-	//  Inputs
-	//	none
-	//
-	//  Outputs
-	//	none
-	//
-	CompressionGrid::CompressionGrid( const CompressionGrid & v )
-	{
-		_fixedSamples   = v._fixedSamples;
-		_samples        = v._samples;
-		
-		_polygonVecPtr  = v._polygonVecPtr;
-		_polylineVecPtr = v._polylineVecPtr;
-		_gridPtr        = v._gridPtr;
-	}
-    //
-    //  Compression::~Compression --	destructor
-    //
-    //  Inputs
-    //	none
-    //
-    //  Outputs
-    //	none
-    //
-    CompressionGrid::~CompressionGrid()
-    {
-    }
-
-    //------------------------------------------------------------------------------
-    //	Assignment operators
-    //------------------------------------------------------------------------------
-    CompressionGrid & CompressionGrid::operator = ( const CompressionGrid & v )
-    {
-	    if ( this != &v ) {
-		    _fixedSamples   = v._fixedSamples;
-		    _samples        = v._samples;
-		
-		    _polygonVecPtr  = v._polygonVecPtr;
-		    _polylineVecPtr = v._polylineVecPtr;
-		    _gridPtr        = v._gridPtr;
-	    }
-	    return *this;
-    }
-
-
-    //------------------------------------------------------------------------------
-    //	Special functions
-    //------------------------------------------------------------------------------
-    //
-    //  Compression::createCompression --	create compression from polygons and polylines
-    //
-    //  Inputs
-    //	none
-    //
-    //  Outputs
-    //	none
-    //
-    bool CompressionGrid::_closeToSamples( KeiRo::Base::Coord2 &coord, unsigned int &index )
-    {
-		return false;
-        index = 0;
-        for( unsigned int i = 0; i < _samples.size(); i++ ){
-
-            double distance = distanceBetween( coord, _samples[i] );
-            if( distance < _min_point_distance ) {
-                index = i;
-                return true;
-            }
-        }
-
-        return false;
-    }
-
-    //
-    //  Compression::createCompressedSamples --	create compression from samples of polygons and polylines
-    //
-    //  Inputs
-    //	none
-    //
-    //  Outputs
-    //	none
-    //
-    void CompressionGrid::createCompressedSamples( void )
-    {
-        // sample size index
-        unsigned int nV = 0;
-
-        // add polygonal objects
-        for( unsigned int i = 0; i < _polygonVecPtr->size(); i++ ){
-
-            vector< KeiRo::Base::Coord2 > &elements = (*_polygonVecPtr)[i].elements();
-            vector< unsigned int > &idElements = (*_polygonVecPtr)[i].idElements();
-//            cerr << "i = " << i << ", elements.size() = " << elements.size() << endl;
-
-            for( unsigned int j = 0; j < elements.size(); j++ ){
-	
-	            KeiRo::Base::Coord2 &coord = elements[j];
-                unsigned int index = 0;
-                if( _closeToSamples( coord, index ) == true ){
-                    // cerr << "index = " << index << endl;
-                    idElements.push_back( index );
-                }
-                else{
-                	coord.updateOldElement();
-                    _fixedSamples.push_back( coord );
-                    _samples.push_back( coord );
-                    idElements.push_back( nV );
-                    nV++;
-                }
-            }
-        }
-        
-#ifdef COMPRESSION_DEBUG
-        for( unsigned int i = 0; i < _polygonVecPtr->size(); i++ ){
-
-        	vector< KeiRo::Base::Coord2 > &elements = (*_polygonVecPtr)[i].elements();
-        	vector< unsigned int > &idElements = (*_polygonVecPtr)[i].idElements();
-        	cerr << " i = " << i << ", elements.size() = " << elements.size() << endl;
-        	cerr << " i = " << i << ", idElements.size() = " << idElements.size() << endl;
-        }
-
-        for( unsigned int i = 0; i < _samples.size(); i++ ){
-            cerr << "ref = " << &_samples[i] << ", i = " << i << " , " << _samples[i];
-        }
-        cerr << endl;
-        for( unsigned int i = 0; i < _polygonVecPtr->size(); i++ ){
-
-            cerr << "i = " << i << endl;
-            vector< KeiRo::Base::Coord2 > &elements = (*_polygonVecPtr)[i].elements();
-            vector< unsigned int > &idElements = (*_polygonVecPtr)[i].idElements();
-
-            for( unsigned int j = 0; j < elements.size(); j++ ){
-                // pointerElements[j] = &elements[j];
-                cerr << "j = " << j << ", " << idElements[j] << ", c = " << elements[j];
-            }
-            cerr << endl;
-        }
-#endif // COMPRESSION_DEBUG
-
-        // add line objects
-        for( unsigned int i = 0; i < _polylineVecPtr->size(); i++ ){
-
-            vector< KeiRo::Base::Coord2 > &elements = (*_polylineVecPtr)[i].elements();
-            vector< unsigned int > &idElements = (*_polylineVecPtr)[i].idElements();
-            for( unsigned int j = 0; j < elements.size(); j++ ){
-	
-	            KeiRo::Base::Coord2 &coord = elements[j];
-                unsigned int index = 0;
-                if( _closeToSamples( coord, index ) == true ){
-                    idElements.push_back( index );
-                }
-                else{
-	                coord.updateOldElement();
-	                _fixedSamples.push_back( coord );
-                    _samples.push_back( coord );
-                    idElements.push_back( nV );
-                    nV++;
-                }
-            }
-        }
-
-#ifdef COMPRESSION_DEBUG
-        cerr << "nV = " << nV << endl;
-        cerr << "nPolygons = " << _polygonVecPtr->size() << " _nPolylines = " << _polylineVecPtr->size() << endl;
-        cerr << "_samples.size() = " << _samples.size() << " _fixedSamples.size() = " << _fixedSamples.size() << endl;
-#endif // COMPRESSION_DEBUG
-    }
-
-    //
-    //  Compression::createCompressedJoints --	create compression from joints of polygons and polylines
-    //
-    //  Inputs
-    //	none
-    //
-    //  Outputs
-    //	none
-    //
-    void CompressionGrid::createCompressedJoints( void )
-    {
-        // sample size index
-        unsigned int nV = 0;
-
-        // add polygonal x line intersection
-        for( unsigned int i = 0; i < _polygonVecPtr->size(); i++ ){
-
-            // get polygon elements
-            vector< KeiRo::Base::Coord2 > newPolygonElements;
-            vector< unsigned int > newPolygonIDElements;
-            vector< KeiRo::Base::Coord2 > &polygonElements = (*_polygonVecPtr)[i].elements();
-            newPolygonElements.push_back( polygonElements[0] );
-
-            for( unsigned int j = 0; j < polygonElements.size(); j++ ){
-	
-	            KeiRo::Base::Coord2 &coordA = polygonElements[j];
-	            KeiRo::Base::Coord2 &coordB = polygonElements[ (j+1)%polygonElements.size() ];
-	            KeiRo::Base::Coord2 unitBA = (coordA-coordB)/(coordA-coordB).norm();
-	            KeiRo::Base::Coord2 a = coordA + _min_point_distance * unitBA;
-	            KeiRo::Base::Coord2 b = coordB - _min_point_distance * unitBA;
-
-                // get line elements
-                for( unsigned int m = 0; m < _polylineVecPtr->size(); m++ ){
-
-                    map< double, KeiRo::Base::Coord2 > intersectionMap;
-                    vector< KeiRo::Base::Coord2 > &lineElements = (*_polylineVecPtr)[m].elements();
-                    //vector< unsigned int > &lineIDElements = (*_polylineVecPtr)[m].idElements();
-                    for( unsigned int n = 0; n < lineElements.size()-1; n++ ){
-	
-	                    KeiRo::Base::Coord2 &coordC = lineElements[ n ];
-	                    KeiRo::Base::Coord2 &coordD = lineElements[ n+1 ];
-	                    KeiRo::Base::Coord2 unitDC = (coordC-coordD)/(coordC-coordD).norm();
-	
-	                    KeiRo::Base::Coord2 c = coordC + _min_point_distance * unitDC;
-	                    KeiRo::Base::Coord2 d = coordD - _min_point_distance * unitDC;
-	                    KeiRo::Base::Coord2 intersection;
-                        if( isIntersected( a, b, c, d, intersection ) == true ){
-
-                            // add intermediate sample points
-                            double distance = ( intersection-coordA ).norm();
-
-                            if( !( ( distance < _min_point_distance ) ||
-                                   ( ( intersection-coordB ).norm() < _min_point_distance ) ) ) {
-                                // cerr << "intersection = " << intersection;
-                                intersectionMap.insert( pair< double, KeiRo::Base::Coord2 >( distance, intersection ) );
-                            }
-
-#ifdef COMPRESSION_DEBUG
-                            cerr << "isIntersected = " << true << endl;
-                            cerr << setprecision(50) << " coordC = " << coordC;
-                            cerr << setprecision(50) << " coordD = " << coordD;
-                            cerr << setprecision(50) << "intersection = " << intersection;
-                            if( distanceBetween( coordC, intersection ) < 1e-5 ){
-                                cerr << "coordC == intersection" << endl;
-                            }
-                            if( distanceBetween( coordD, intersection ) < 1e-5 ){
-                                cerr << "coordD == intersection" << endl;
-                            }
-                            cerr << endl;
-#endif // COMPRESSION_DEBUG
-                        }
-                    }
-
-                    // add intersected nodes
-                    // cerr << "intersectionMap.size() = " << intersectionMap.size() << endl;
-                    if( intersectionMap.size() > 0 ){
-
-                        map< double, KeiRo::Base::Coord2 >::iterator it = intersectionMap.begin();
-                        newPolygonElements.push_back( it->second );
-                        map< double, KeiRo::Base::Coord2 >::iterator itPrev = it;
-                        it++;
-                        for( ; it != intersectionMap.end(); it++ ){
-
-                            if( ( itPrev->second - it->second ).norm() > _min_point_distance ){
-                                newPolygonElements.push_back( it->second );
-                            }
-                            itPrev = it;
-                        }
-                    }
-
-                }
-
-                if( (j+1)%polygonElements.size() != 0 ){
-                    newPolygonElements.push_back( polygonElements[(j+1)%polygonElements.size()] );
-                }
-            }
-
-#ifdef COMPRESSION_DEBUG
-            cerr << "ori = " << polygonElements.size() << endl;
-            for( unsigned int j = 0; j < polygonElements.size(); j++ ){
-                cerr << "j = " << j << ", " << polygonElements[j];
-            }
-            cerr << "new = " << newPolygonElements.size() << endl;
-            for( unsigned int j = 0; j < newPolygonElements.size(); j++ ){
-                cerr << "j = " << j << ", " << newPolygonElements[j];
-            }
-            cerr << endl;
-#endif // COMPRESSION_DEBUG
-
-            (*_polygonVecPtr)[i].elements() = newPolygonElements;
-            (*_polygonVecPtr)[i].fixedElements() = newPolygonElements;
-        }
-
-    }
-
-    //
-    //  Compression::createCompressedGridJoints --	create compression from joints of polygons and grids
-    //
-    //  Inputs
-    //	none
-    //
-    //  Outputs
-    //	none
-    //
-    void CompressionGrid::createCompressedGridJoints( void )
-    {
-        Graph::GridGraph & gridG = _gridPtr->gridG();
-//        printGraph( gridG );
-
-        for( unsigned int i = 0; i < _polygonVecPtr->size(); i++ ){
-
-            // get polygon elements
-            vector< KeiRo::Base::Coord2 > newPolygonElements;
-            vector< unsigned int > newPolygonIDElements;
-            vector< KeiRo::Base::Coord2 > &polygonElements = (*_polygonVecPtr)[i].elements();
-            newPolygonElements.push_back( polygonElements[0] );
-            for( unsigned int j = 0; j < polygonElements.size(); j++ ) {
-	
-	            KeiRo::Base::Coord2 &coordA = polygonElements[j];
-	            KeiRo::Base::Coord2 &coordB = polygonElements[(j + 1) % polygonElements.size()];
-	            KeiRo::Base::Coord2 unitBA = (coordA - coordB) / (coordA - coordB).norm();
-	            KeiRo::Base::Coord2 a = coordA + _min_point_distance * unitBA;
-	            KeiRo::Base::Coord2 b = coordB - _min_point_distance * unitBA;
-
-                // draw grid graph edges
-                map< double, KeiRo::Base::Coord2 > intersectionMap;
-                BGL_FORALL_EDGES( ed, gridG, Graph::GridGraph ) {
-
-                    Graph::GridGraph::vertex_descriptor vdS = source( ed, gridG );
-                    Graph::GridGraph::vertex_descriptor vdT = target( ed, gridG );
-                    KeiRo::Base::Coord2 &coordC = *gridG[ vdS ].coordPtr;
-                    KeiRo::Base::Coord2 &coordD = *gridG[ vdT ].coordPtr;
-                    KeiRo::Base::Coord2 unitDC = (coordC-coordD)/(coordC-coordD).norm();
-
-                    KeiRo::Base::Coord2 c = coordC + _min_point_distance * unitDC;
-                    KeiRo::Base::Coord2 d = coordD - _min_point_distance * unitDC;
-                    KeiRo::Base::Coord2 intersection;
-                    if( isIntersected( a, b, c, d, intersection ) == true ){
-
-                        // add intermediate sample points
-                        double distance = ( intersection-coordA ).norm();
-
-                        if( !( ( distance < _min_point_distance ) ||
-                            ( ( intersection-coordB ).norm() < _min_point_distance ) ) ) {
-                            intersectionMap.insert( pair< double, KeiRo::Base::Coord2 >( distance, intersection ) );
-                        }
-#ifdef COMPRESSION_DEBUG
-                        else{
-                            cerr << "skip... " << endl;
-                        }
-                        cerr << "eid = " << gridG[ed].id << endl;
-                        cerr << "distance to A = " << distance << endl;
-                        cerr << "distance to B = " << ( intersection-coordB ).norm() << endl;
-
-                        cerr << "isIntersected = " << true << endl;
-                        cerr << setprecision(50) << " coordC = " << coordC;
-                        cerr << setprecision(50) << " coordD = " << coordD;
-                        cerr << setprecision(50) << "intersection = " << intersection;
-                        if( distanceBetween( coordC, intersection ) < 1e-5 ){
-                            cerr << "coordC == intersection" << endl;
-                        }
-                        if( distanceBetween( coordD, intersection ) < 1e-5 ){
-                            cerr << "coordD == intersection" << endl;
-                        }
-                        cerr << endl;
-#endif // COMPRESSION_DEBUG
-                    }
-                }
-
-                // add intersected nodes
-                if( intersectionMap.size() > 0 ){
-                    map< double, KeiRo::Base::Coord2 >::iterator it = intersectionMap.begin();
-                    newPolygonElements.push_back( it->second );
-                    map< double, KeiRo::Base::Coord2 >::iterator itPrev = it;
-                    it++;
-                    for( ; it != intersectionMap.end(); it++ ){
-
-                        if( ( itPrev->second - it->second ).norm() > _min_point_distance ){
-                            newPolygonElements.push_back( it->second );
-                        }
-                        itPrev = it;
-                    }
-                }
-
-#ifdef COMPRESSION_DEBUG
-                cerr << "list = " << intersectionMap.size() << endl;
-                cerr << "A: " << coordA;
-                map< double, KeiRo::Base::Coord2 >::iterator it = intersectionMap.begin();
-                cerr << it->second;
-                newPolygonElements.push_back( it->second );
-                map< double, KeiRo::Base::Coord2 >::iterator itPrev = it;
-                it++;
-                for( ; it != intersectionMap.end(); it++ ){
-                    if( ( itPrev->second - it->second ).norm() > _min_point_distance ){
-                        cerr << "( itPrev->second - it->second ).norm() = " << ( itPrev->second - it->second ).norm()
-                             << ", " << it->second;
-                    }
-                    itPrev = it;
-                }
-                cerr << "B: " << coordB;
-                cerr << endl;
-#endif // COMPRESSION_DEBUG
-
-                if( (j+1)%polygonElements.size() != 0 ){
-                    newPolygonElements.push_back( polygonElements[(j+1)%polygonElements.size()] );
-                }
-            }
-
-            (*_polygonVecPtr)[i].elements() = newPolygonElements;
-            (*_polygonVecPtr)[i].fixedElements() = newPolygonElements;
-        }
-    }
-
-    //
-    //  Compression::createCompression --	create compression from polygons and polylines
-    //
-    //  Inputs
-    //	none
-    //
-    //  Outputs
-    //	none
-    //
-    void CompressionGrid::createCompression( bool isOn )
-    {
-		if( isOn ){
-	        createCompressedGridJoints();
-	        createCompressedJoints();
-		}
-		else{
-			createCompressedSamples();
-		}
-    }
-
-    //------------------------------------------------------------------------------
-    //	Friend functions
-    //------------------------------------------------------------------------------
-
-
-    //------------------------------------------------------------------------------
-    //	I/O functions
-    //------------------------------------------------------------------------------
-
-
-
-
Index: Graph/src/TreeDirectedGraph.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// TreeDirectedGraph.h\r\n//\t: header file for tree graph\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Sun Feb 09 23:16:12 2020\r\n//\r\n//******************************************************************************\r\n\r\n#ifndef _Graph_TreeDirectedGraph_H\r\n#define _Graph_TreeDirectedGraph_H\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <string>\r\n#include <iostream>\r\n#include <fstream>\r\n#include <vector>\r\n#include <map>\r\n#include <algorithm>\r\n#include <ctime>\r\n#include <cstdlib>\r\n\r\nusing namespace std;\r\n\r\n#include <boost/config.hpp>\r\n#include <boost/graph/graph_traits.hpp>\r\n#include <boost/graph/adjacency_list.hpp>\r\n#include <boost/graph/iteration_macros.hpp>\r\n\r\nusing namespace boost;\r\n\r\n#include \"Coord2.h\"\r\n#include \"TreeGraphProperty.h\"\r\n#include \"TreeVertexProperty.h\"\r\n#include \"TreeEdgeProperty.h\"\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Macros\r\n//------------------------------------------------------------------------------\r\n\r\nnamespace Graph {\r\n\r\n    typedef adjacency_list< listS, listS, bidirectionalS,\r\n            TreeVertexProperty, TreeEdgeProperty,\r\n            TreeGraphProperty >  TreeDirectedGraph;\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tSpecial functions\r\n    //------------------------------------------------------------------------------\r\n    void printGraph( const TreeDirectedGraph & g );\r\n    void clearGraph( TreeDirectedGraph & g );\r\n\r\n} // namespace Graph\r\n\r\n#endif  // _Graph_TreeDirectedGraph_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Graph/src/TreeDirectedGraph.h b/Graph/src/TreeDirectedGraph.h
--- a/Graph/src/TreeDirectedGraph.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Graph/src/TreeDirectedGraph.h	(date 1729410604730)
@@ -1,59 +1,0 @@
-//******************************************************************************
-// TreeDirectedGraph.h
-//	: header file for tree graph
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Sun Feb 09 23:16:12 2020
-//
-//******************************************************************************
-
-#ifndef _Graph_TreeDirectedGraph_H
-#define _Graph_TreeDirectedGraph_H
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <string>
-#include <iostream>
-#include <fstream>
-#include <vector>
-#include <map>
-#include <algorithm>
-#include <ctime>
-#include <cstdlib>
-
-using namespace std;
-
-#include <boost/config.hpp>
-#include <boost/graph/graph_traits.hpp>
-#include <boost/graph/adjacency_list.hpp>
-#include <boost/graph/iteration_macros.hpp>
-
-using namespace boost;
-
-#include "Coord2.h"
-#include "TreeGraphProperty.h"
-#include "TreeVertexProperty.h"
-#include "TreeEdgeProperty.h"
-
-//------------------------------------------------------------------------------
-//	Defining Macros
-//------------------------------------------------------------------------------
-
-namespace Graph {
-
-    typedef adjacency_list< listS, listS, bidirectionalS,
-            TreeVertexProperty, TreeEdgeProperty,
-            TreeGraphProperty >  TreeDirectedGraph;
-
-    //------------------------------------------------------------------------------
-    //	Special functions
-    //------------------------------------------------------------------------------
-    void printGraph( const TreeDirectedGraph & g );
-    void clearGraph( TreeDirectedGraph & g );
-
-} // namespace Graph
-
-#endif  // _Graph_TreeDirectedGraph_H
Index: Composite/src/Contour2.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// Contour2.cc\r\n//\t: program file for 2D simpleContour\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Sun Sep 16 15:02:45 2012\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <iostream>\r\n#include <iomanip>\r\n#include <cctype>\r\n#include <cmath>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\n#include \"Contour2.h\"\r\n\r\n//------------------------------------------------------------------------------\r\n//\tMacro Definitions\r\n//------------------------------------------------------------------------------\r\n\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tProtected Functions\r\n//------------------------------------------------------------------------------\r\n//\r\n//  Contour2::_init --\tinitialization\r\n//\r\n//  Inputs\r\n//  __elements\r\n//\r\n//  Outputs\r\n//  none\r\n//\r\nvoid Contour2::_init( unsigned int __id, vector< KeiRo::Base::Polygon2 > __polygons ) {\r\n\t_id = __id;\r\n\t_polygons = __polygons;\r\n\t\r\n\t// detect non-simple polygon and remove overlapped vertices\r\n\tfor( unsigned int i = 0; i < _polygons.size(); i++ ) {\r\n\t\tCGAL::Polygon_2< K > polygon;\r\n\t\tKeiRo::Base::Polygon2 &p = _polygons[ i ];\r\n\t\tfor( unsigned int j = 0; j < p.elements().size(); j++ ) {\r\n\t\t\tif( ( p.elements()[ j ] - p.elements()[ ( j + 1 ) % ( int ) p.elements().size() ] ).norm() > 0.5 )\r\n\t\t\t\tpolygon.push_back( K::Point_2( p.elements()[ j ].x(), p.elements()[ j ].y() ) );\r\n\t\t}\r\n\t\t\r\n\t\tp.elements().clear();\r\n\t\tfor( unsigned int j = 0; j < polygon.size(); j++ ) {\r\n\t\t\tp.elements().push_back( KeiRo::Base::Coord2( CGAL::to_double( polygon[ j ].x() ),\r\n\t\t\t                                CGAL::to_double( polygon[ j ].y() ) ) );\r\n\t\t}\r\n\t\t\r\n\t\tbool isSimple = polygon.is_simple();\r\n\t\t\r\n\t\tif( polygon.is_simple() == false ) {\r\n\t\t\tcerr << \"i = \" << i << \" isSimple = \" << polygon.is_simple() << endl;\r\n\t\t\tcerr << p << endl;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n//\r\n//  Contour2::_clear --\tclear elements\r\n//\r\n//  Inputs\r\n//\r\n//\r\n//  Outputs\r\n//  none\r\n//\r\nvoid Contour2::_clear( void ) {\r\n\t_polygons.clear();\r\n\t_fineContour.clear();\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n//\tPublic functions\r\n//------------------------------------------------------------------------------\r\n\r\n//------------------------------------------------------------------------------\r\n//\tConstructors\r\n//------------------------------------------------------------------------------\r\n//\r\n//  Contour2::Contour2 -- default constructor\r\n//\r\n//  Inputs\r\n//  none\r\n//\r\n//  Outputs\r\n//  none\r\n//\r\nContour2::Contour2() {\r\n\t_fineContour.clear();\r\n}\r\n\r\n//\r\n//  Contour2::Contour2 -- constructor\r\n//\r\n//  Inputs\r\n//  __elements\r\n//\r\n//  Outputs\r\n//  none\r\n//\r\nContour2::Contour2( vector< KeiRo::Base::Polygon2 > __polygons ) {\r\n\t_polygons = __polygons;\r\n}\r\n\r\n//\r\n//  Contour2::Contour2 -- copy constructor\r\n//\r\n//  Inputs\r\n//  polygon\r\n//\r\n//  Outputs\r\n//  none\r\n//\r\nContour2::Contour2( const Contour2 &v ) {\r\n\t_id = v._id;\r\n\t_contour = v._contour;\r\n\t_polygons = v._polygons;\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tAssignment operators\r\n//------------------------------------------------------------------------------\r\n\r\n//\r\n//  Contour2::operator = --\tassignment\r\n//\r\n//  Inputs\r\n//\tv\t: 2D coordinates\r\n//\r\n//  Outputs\r\n//\treference to this object\r\n//\r\nContour2 &Contour2::operator=( const Contour2 &p ) {\r\n\tif( this != &p ) {\r\n\t\t_id = p._id;\r\n\t\t_contour = p._contour;\r\n\t\t_polygons = p._polygons;\r\n\t}\r\n\treturn *this;\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n//\tSpecial functions\r\n//------------------------------------------------------------------------------\r\nbool Contour2::findVertexInComplex( const KeiRo::Base::Coord2 &coord, Graph::BaseUndirectedGraph &complex,\r\n                                    Graph::BaseUndirectedGraph::vertex_descriptor &target ) {\r\n\tbool isFound = false;\r\n\t\r\n\tBGL_FORALL_VERTICES( vd, complex, Graph::BaseUndirectedGraph ) {\r\n\t\t\t//cerr << \" vd \" << *complex[vd].coordPtr << endl;\r\n\t\t\tif( ( coord - *complex[ vd ].coordPtr ).norm() < MIN_VERTEX_DISTANCE ) {\r\n\t\t\t\ttarget = vd;\r\n\t\t\t\tisFound = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t//cerr << \"isFound = \" << isFound << endl;\r\n\treturn isFound;\r\n}\r\n\r\ndouble Contour2::randomCentroid( void ) {\r\n\t\r\n\tint num = 30;\r\n\tdouble radius = 20.0;\r\n\tif( _contour.elements().size() == 0 ) return 1.0;\r\n\t\r\n\tKeiRo::Base::Coord2 c = _contour.centroid();\r\n\twhile( inContour( c ) == false ) {\r\n\t\tint size = _contour.elements().size();\r\n\t\tint idA = rand() % size;\r\n\t\tint idB = ( idA + 1 ) % size;\r\n\t\tint idC = ( idA + 2 ) % size;\r\n\t\tc = (_contour.elements()[ idA ] + _contour.elements()[ idB ] + _contour.elements()[ idC ])/3.0;\r\n\t}\r\n\tdouble min = minDistToPolygon( c );\r\n\tfor( int i = 0; i < num; i++ ) {\r\n\t\t\r\n\t\tKeiRo::Base::Coord2 coord( 0.0, 0.0 );\r\n\t\tcerr << \"HERE3\" << endl;\r\n\t\tcoord.x() = c.x() + radius * ( 2.0 * rand() / ( double ) RAND_MAX - 1.0 );\r\n\t\tcoord.y() = c.y() + radius * ( 2.0 * rand() / ( double ) RAND_MAX - 1.0 );\r\n\t\tdouble minB = minDistToPolygon( coord );\r\n\t\tif( min < minB && inContour( coord ) ){\r\n\t\t\tc = coord;\r\n\t\t\tmin = minB;\r\n\t\t}\r\n\t}\r\n\t\r\n\t_contour.centroid() = c;\r\n\t\r\n\treturn MAX2( 1.0, min );\r\n}\r\n\r\n//\r\n//  Contour2::minDistToPolygon --    find the minimum distance of a vertex to the polygon boundary\r\n//\r\n//  Inputs\r\n//  none\r\n//\r\n//  Outputs\r\n//  none\r\n//\r\ndouble Contour2::minDistToPolygon( const KeiRo::Base::Coord2 &coord ) {\r\n\t\r\n\tdouble minDist = INFINITY;\r\n\t\r\n\tfor( unsigned int i = 0; i < _contour.elements().size(); i++ ) {\r\n\t\t\r\n\t\tKeiRo::Base::Coord2 &coordM = _contour.elements()[ i ];\r\n\t\tKeiRo::Base::Coord2 &coordN = _contour.elements()[ ( i + 1 ) % ( int ) _contour.elements().size() ];\r\n\t\tKeiRo::Base::Coord2 mnVec = coordN - coordM;\r\n\t\tKeiRo::Base::Coord2 cmVec = coord - coordM;\r\n\t\tdouble D = ( mnVec * cmVec ) / mnVec.squaredNorm();\r\n\t\tKeiRo::Base::Coord2 coordD = coordM + D * mnVec;\r\n\t\t\r\n\t\tif( KeiRo::Base::Line2::isOnLine( coordD, coordM, coordN ) ) {\r\n\t\t\t\r\n\t\t\tdouble dist = ( coord - coordD ).norm();\r\n\t\t\tif( dist < minDist ) minDist = dist;\r\n\t\t}\r\n\t\tdouble dist = (coordM - coord).norm();\r\n\t\tif( dist < minDist ) {\r\n\t\t\tminDist = dist;\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn minDist;\r\n}\r\n\r\nvoid Contour2::createContour( void ) {\r\n\t\r\n\t// copy cells to a graph\r\n\tGraph::BaseUndirectedGraph complex;\r\n\tunsigned int vid = 0;\r\n\tunsigned int eid = 0;\r\n\tfor( unsigned int j = 0; j < _polygons.size(); j++ ) {\r\n\t\t\r\n\t\tKeiRo::Base::Polygon2 &p = _polygons[ j ];\r\n\t\tvector< Graph::BaseUndirectedGraph::vertex_descriptor > vdVec;\r\n\t\t\r\n\t\t// add vertices\r\n\t\tfor( unsigned int k = 0; k < p.elements().size(); k++ ) {\r\n\t\t\tGraph::BaseUndirectedGraph::vertex_descriptor vd = NULL;\r\n\t\t\t\r\n\t\t\tbool isFound = findVertexInComplex( p.elements()[ k ], complex, vd );\r\n\t\t\tif( isFound == true ) {\r\n\t\t\t\tvdVec.push_back( vd );\r\n\t\t\t\t//cerr << k << \" found = \" << *complex[ vd ].coordPtr;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvd = add_vertex( complex );\r\n\t\t\t\tcomplex[ vd ].id = vid;\r\n\t\t\t\tcomplex[ vd ].coordPtr = new KeiRo::Base::Coord2( p.elements()[ k ].x(), p.elements()[ k ].y() );\r\n\t\t\t\tvdVec.push_back( vd );\r\n\t\t\t\tvid++;\r\n\t\t\t\t//cerr << k << \" new = \" << *complex[ vd ].coordPtr;\r\n\t\t\t}\r\n\t\t\t//cerr << \"( \" << complex[ vd ].id << \" ) = \" << *complex[ vd ].coordPtr << endl;\r\n\t\t}\r\n\t\t\r\n\t\t// add edges\r\n\t\tfor( unsigned int k = 1; k < vdVec.size() + 1; k++ ) {\r\n\t\t\t\r\n\t\t\tGraph::BaseUndirectedGraph::vertex_descriptor vdS = vdVec[ k - 1 ];\r\n\t\t\tGraph::BaseUndirectedGraph::vertex_descriptor vdT = vdVec[ k % ( int ) vdVec.size() ];\r\n\t\t\t\r\n\t\t\tbool isFound = false;\r\n\t\t\tGraph::BaseUndirectedGraph::edge_descriptor oldED;\r\n\t\t\ttie( oldED, isFound ) = edge( vdS, vdT, complex );\r\n\t\t\t\r\n\t\t\tif( isFound == true ) {\r\n\t\t\t\tcomplex[ oldED ].weight += 1;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t\r\n\t\t\t\tpair< Graph::BaseUndirectedGraph::edge_descriptor, unsigned int > foreE = add_edge( vdS, vdT, complex );\r\n\t\t\t\tGraph::BaseUndirectedGraph::edge_descriptor foreED = foreE.first;\r\n\t\t\t\tcomplex[ foreED ].id = eid;\r\n\t\t\t\tcomplex[ foreED ].weight = 0;\r\n\t\t\t\teid++;\r\n\t\t\t}\r\n\t\t\t// cerr << \"( \" << complex[ vdS ].id << \", \" << complex[ vdT ].id << \" ) \" << endl;\r\n\t\t}\r\n\t\t// cerr << endl;\r\n\t}\r\n\r\n#ifdef DEBUG\r\n\tprintGraph( complex );\r\n#endif // DEBUG\r\n\t\r\n\t// remove inner edges\r\n\tvector< Graph::BaseUndirectedGraph::edge_descriptor > edVec;\r\n\tBGL_FORALL_EDGES( ed, complex, Graph::BaseUndirectedGraph ) {\r\n\t\t\tif( complex[ ed ].weight > 0 ) {\r\n\t\t\t\tedVec.push_back( ed );\r\n\t\t\t\t//cerr << \"w = \" << complex[ed].weight << endl;\r\n\t\t\t}\r\n\t\t}\r\n\r\n#ifdef DEBUG\r\n\tcerr << \"bnV = \" << num_vertices( complex ) << \" \";\r\n\tcerr << \"bnE = \" << num_edges( complex ) << endl;\r\n#endif // DEBUG\r\n\t\r\n\tfor( unsigned int j = 0; j < edVec.size(); j++ ) {\r\n\t\tremove_edge( edVec[ j ], complex );\r\n\t}\r\n\t// reorder edge id\r\n\teid = 0;\r\n\tBGL_FORALL_EDGES( ed, complex, Graph::BaseUndirectedGraph ) {\r\n\t\t\tcomplex[ ed ].id = eid;\r\n\t\t\tcomplex[ ed ].visit = false;\r\n\t\t\teid++;\r\n\t\t}\r\n\t\t\r\n#ifdef DEBUG\r\n\tprintGraph( complex );\r\n#endif // DEBUG\r\n\t\r\n\t// find the vertex with degree > 0\r\n#ifdef DEBUG\r\n\tcerr << \"nV = \" << num_vertices( complex ) << \" \";\r\n\tcerr << \"nE = \" << num_edges( complex ) << endl;\r\n#endif // DEBUG\r\n\tGraph::BaseUndirectedGraph::vertex_descriptor vdS;\r\n\tBGL_FORALL_VERTICES( vd, complex, Graph::BaseUndirectedGraph ) {\r\n#ifdef DEBUG\r\n\t\t\tif ( true ){\r\n\t\t\t\tcerr << \" degree = \" << out_degree( vd, complex );\r\n\t\t\t}\r\n#endif // DEBUG\r\n\t\t\tif( out_degree( vd, complex ) > 0 ) {\r\n\t\t\t\tvdS = vd;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t// find the simpleContour\r\n\tGraph::BaseUndirectedGraph::out_edge_iterator eo, eo_end;\r\n\tGraph::BaseUndirectedGraph::vertex_descriptor vdC = vdS;\r\n\t//cerr << \"idC = \" << complex[vdC].id << \" \";\r\n\t\r\n\tKeiRo::Base::Polygon2 polygon;\r\n\tpolygon.elements().push_back( KeiRo::Base::Coord2( complex[ vdS ].coordPtr->x(), complex[ vdS ].coordPtr->y() ) );\r\n\twhile( true ) {\r\n\t\t\r\n\t\tGraph::BaseUndirectedGraph::vertex_descriptor vdT = NULL;\r\n\t\tfor( tie( eo, eo_end ) = out_edges( vdC, complex ); eo != eo_end; eo++ ) {\r\n\t\t\t\r\n\t\t\tGraph::BaseUndirectedGraph::edge_descriptor ed = *eo;\r\n\t\t\tif( complex[ ed ].visit == false ) {\r\n\t\t\t\tvdT = target( ed, complex );\r\n\t\t\t\tcomplex[ ed ].visit = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t//cerr << \"(\" << complex[source( ed, complex )].id << \",\" << complex[target( ed, complex )].id << \")\" << endl;\r\n\t\t}\r\n\t\t\r\n\t\tif( vdS == vdT ) break;\r\n\t\telse\r\n\t\t\tassert( vdT != NULL );\r\n\t\t//cerr << complex[vdT].id << \" \";\r\n\t\tpolygon.elements().push_back( KeiRo::Base::Coord2( complex[ vdT ].coordPtr->x(), complex[ vdT ].coordPtr->y() ) );\r\n\t\tvdC = vdT;\r\n\t}\r\n\t\r\n\t// simplify polygon\r\n\t//cerr << \"size = \" << polygon.elements().size() << endl;\r\n\tfor( unsigned int i = 0; i < polygon.elements().size(); i++ ) {\r\n\t\t\r\n\t\tKeiRo::Base::Coord2 prev;\r\n\t\tif( i == 0 ) prev = polygon.elements()[ polygon.elements().size() - 1 ];\r\n\t\telse prev = polygon.elements()[ i - 1 ];\r\n\t\t\r\n\t\tKeiRo::Base::Coord2 curr = polygon.elements()[ i ];\r\n\t\tKeiRo::Base::Coord2 next = polygon.elements()[ ( i + 1 ) % ( int ) polygon.elements().size() ];\r\n\t\tKeiRo::Base::Coord2 vecA = prev - curr;\r\n\t\tKeiRo::Base::Coord2 vecB = next - curr;\r\n\r\n#ifdef DEBUG\r\n\t\tcerr << i << \": \" << (i-1)%polygon.elements().size() << endl;\r\n\t\tcerr << \"prev = \" << prev;\r\n\t\tcerr << \"next = \" << next;\r\n\t\tcerr << \"curr = \" << curr;\r\n\t\tcerr << \"vecA = \" << vecA;\r\n\t\tcerr << \"vecB = \" << vecB;\r\n#endif // DEBUG\r\n\t\t\r\n\t\tdouble cosTheta = vecA * vecB / ( vecA.norm() * vecB.norm() );\r\n\t\tif( fabs( M_PI - acos( cosTheta ) ) > 0.1 ) {\r\n\t\t\t//cerr << \"acos = \" << acos( cosTheta ) << endl;\r\n\t\t\t\r\n\t\t\t//Coord2 &prev = polygon.elements()[ (i-1+polygon.elements().size())%polygon.elements().size() ];\r\n\t\t\t//if( (prev-polygon.elements()[i]).norm() > 1 )\r\n\t\t\t_contour.elements().push_back( polygon.elements()[ i ] );\r\n\t\t}\r\n\t}\r\n\t\r\n\t//cerr << \"(ori)::_contour = \" << _contour << endl;\r\n\t_contour.cleanPolygon();\r\n\t_contour.updateCentroid();\r\n\t_contour.updateOrientation();\r\n\t//cerr << \"simpleContour = \" << _contour << endl;\r\n\r\n\r\n#ifdef DEBUG\r\n\tcerr << \"centroid = \" << polygon.centroid() << endl;\r\n\tcerr << \"p[\" << i << \"] = \" << polygon << endl;\r\n\tcerr << \"simpleContour = \" << _contour << endl;\r\n#endif // DEBUG\r\n}\r\n\r\nbool Contour2::inContour( KeiRo::Base::Coord2 &coord ) {\r\n\treturn _contour.inPolygon( coord );\r\n}\r\n\r\nvoid Contour2::_initChaikinCurve( double unit = 50 ) {\r\n\t// initialization\r\n\t_fineContour.elements().clear();\r\n\t\r\n\t// store initial the path\r\n\tKeiRo::Base::Polygon2 &contour = _contour;\r\n\t\r\n\t// cerr << \"simpleContour.elements().size() = \" << simpleContour.elements().size() << endl;\r\n\tif( contour.elements().size() > 0 )\r\n\t\t_fineContour.elements().push_back( contour.elements()[ 0 ] );\r\n\tfor( unsigned int j = 1; j <= contour.elements().size(); j++ ) {\r\n\t\t\r\n\t\tKeiRo::Base::Coord2 diff = ( contour.elements()[ j % contour.elements().size() ] - contour.elements()[ j - 1 ] );\r\n\t\t// cerr << \"dist = \" << diff.norm() << endl;\r\n\t\tif( diff.norm() > unit ) {\r\n\t\t\t\r\n\t\t\tint num = floor( diff.norm() / unit );\r\n\t\t\tdouble interval = diff.norm() / ( double ) num;\r\n\t\t\t\r\n\t\t\tfor( int k = 1; k < num; k++ ) {\r\n\t\t\t\t// cerr << \"here\" << endl;\r\n\t\t\t\tKeiRo::Base::Coord2 c = contour.elements()[ j - 1 ] + ( double ) k * interval * diff / diff.norm();\r\n\t\t\t\t// cerr << \"here \" << c;\r\n\t\t\t\t_fineContour.elements().push_back( c );\r\n\t\t\t}\r\n\t\t}\r\n\t\tif( j < contour.elements().size() )\r\n\t\t\t_fineContour.elements().push_back( contour.elements()[ j ] );\r\n\t}\r\n}\r\n\r\nvoid Contour2::computeChaikinCurve( int num = 5, double unit = 100 ) {\r\n\t_initChaikinCurve( unit );\r\n\t\r\n\tdouble interval = 4.0;\r\n\tfor( int k = 0; k < num; k++ ) {\r\n\t\t\r\n\t\tvector< KeiRo::Base::Coord2 > core;\r\n\t\tfor( unsigned int j = 0; j < _fineContour.elements().size(); j++ ) {\r\n\t\t\tcore.push_back( _fineContour.elements()[ j ] );\r\n\t\t}\r\n\t\t\r\n\t\t// compute Chaikin Curve\r\n\t\t_fineContour.clear();\r\n\t\tfor( unsigned int j = 0; j < core.size(); j++ ) {\r\n\t\t\t\r\n\t\t\tKeiRo::Base::Coord2 &p1 = core[ j ];\r\n\t\t\tKeiRo::Base::Coord2 &p2 = core[ ( j + 1 ) % core.size() ];\r\n\t\t\tKeiRo::Base::Coord2 q = ( 1.0 - 1.0 / interval ) * p1 + ( 1.0 / interval ) * p2;\r\n\t\t\tKeiRo::Base::Coord2 r = ( 1.0 / interval ) * p1 + ( 1.0 - 1.0 / interval ) * p2;\r\n\t\t\t\r\n\t\t\t_fineContour.elements().push_back( q );\r\n\t\t\t_fineContour.elements().push_back( r );\r\n\t\t}\r\n\t}\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n//\tFriend functions\r\n//------------------------------------------------------------------------------\r\n\r\n//------------------------------------------------------------------------------\r\n//\tI/O functions\r\n//------------------------------------------------------------------------------\r\n//\r\n//  operator << --\toutput\r\n//\r\n//  Inputs\r\n//\ts\t: reference to output stream\r\n//\tv\t: 2D coordinates\r\n//\r\n//  Outputs\r\n//\treference to output stream\r\n//\r\nostream &operator<<( ostream &stream, const Contour2 &obj ) {\r\n\tint i;        // loop counter\r\n\t// set the output formatting\r\n\t//stream << setiosflags( ios::showpoint );\r\n\t//stream << setprecision( 8 );\r\n\t//int width = 16;\r\n\t// print out the elements\r\n\tfor( i = 0; i < obj._contour.elements().size(); i++ ) {\r\n\t\t//stream << setw( width ) << obj._element[ i ];\r\n\t\tstream << setw( 4 ) << obj._contour.elements()[ i ];\r\n\t\tif( i != 1 ) stream << \"\\t\";\r\n\t}\r\n\tstream << endl;\r\n\t\r\n\treturn stream;\r\n}\r\n\r\n\r\n//\r\n//  operator >> --\tinput\r\n//\r\n//  Inputs\r\n//\ts\t: reference to input stream\r\n//\tv\t: 2D coordinates\r\n//\r\n//  Outputs\r\n//\treference to input stream\r\n//\r\nistream &operator>>( istream &stream, Contour2 &obj ) {\r\n\tint i;        // loop counter\r\n\t// reading the elements\r\n\tfor( i = 0; i < obj._contour.elements().size(); i++ )\r\n\t\tstream >> obj._contour.elements()[ i ];\r\n\treturn stream;\r\n}\r\n\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Composite/src/Contour2.cpp b/Composite/src/Contour2.cpp
--- a/Composite/src/Contour2.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Composite/src/Contour2.cpp	(date 1729410604750)
@@ -1,543 +1,0 @@
-//******************************************************************************
-// Contour2.cc
-//	: program file for 2D simpleContour
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Sun Sep 16 15:02:45 2012
-//
-//******************************************************************************
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <iostream>
-#include <iomanip>
-#include <cctype>
-#include <cmath>
-#include <algorithm>
-
-using namespace std;
-
-#include "Contour2.h"
-
-//------------------------------------------------------------------------------
-//	Macro Definitions
-//------------------------------------------------------------------------------
-
-
-
-//------------------------------------------------------------------------------
-//	Protected Functions
-//------------------------------------------------------------------------------
-//
-//  Contour2::_init --	initialization
-//
-//  Inputs
-//  __elements
-//
-//  Outputs
-//  none
-//
-void Contour2::_init( unsigned int __id, vector< KeiRo::Base::Polygon2 > __polygons ) {
-	_id = __id;
-	_polygons = __polygons;
-	
-	// detect non-simple polygon and remove overlapped vertices
-	for( unsigned int i = 0; i < _polygons.size(); i++ ) {
-		CGAL::Polygon_2< K > polygon;
-		KeiRo::Base::Polygon2 &p = _polygons[ i ];
-		for( unsigned int j = 0; j < p.elements().size(); j++ ) {
-			if( ( p.elements()[ j ] - p.elements()[ ( j + 1 ) % ( int ) p.elements().size() ] ).norm() > 0.5 )
-				polygon.push_back( K::Point_2( p.elements()[ j ].x(), p.elements()[ j ].y() ) );
-		}
-		
-		p.elements().clear();
-		for( unsigned int j = 0; j < polygon.size(); j++ ) {
-			p.elements().push_back( KeiRo::Base::Coord2( CGAL::to_double( polygon[ j ].x() ),
-			                                CGAL::to_double( polygon[ j ].y() ) ) );
-		}
-		
-		bool isSimple = polygon.is_simple();
-		
-		if( polygon.is_simple() == false ) {
-			cerr << "i = " << i << " isSimple = " << polygon.is_simple() << endl;
-			cerr << p << endl;
-		}
-	}
-}
-
-//
-//  Contour2::_clear --	clear elements
-//
-//  Inputs
-//
-//
-//  Outputs
-//  none
-//
-void Contour2::_clear( void ) {
-	_polygons.clear();
-	_fineContour.clear();
-}
-
-//------------------------------------------------------------------------------
-//	Public functions
-//------------------------------------------------------------------------------
-
-//------------------------------------------------------------------------------
-//	Constructors
-//------------------------------------------------------------------------------
-//
-//  Contour2::Contour2 -- default constructor
-//
-//  Inputs
-//  none
-//
-//  Outputs
-//  none
-//
-Contour2::Contour2() {
-	_fineContour.clear();
-}
-
-//
-//  Contour2::Contour2 -- constructor
-//
-//  Inputs
-//  __elements
-//
-//  Outputs
-//  none
-//
-Contour2::Contour2( vector< KeiRo::Base::Polygon2 > __polygons ) {
-	_polygons = __polygons;
-}
-
-//
-//  Contour2::Contour2 -- copy constructor
-//
-//  Inputs
-//  polygon
-//
-//  Outputs
-//  none
-//
-Contour2::Contour2( const Contour2 &v ) {
-	_id = v._id;
-	_contour = v._contour;
-	_polygons = v._polygons;
-}
-
-
-//------------------------------------------------------------------------------
-//	Assignment operators
-//------------------------------------------------------------------------------
-
-//
-//  Contour2::operator = --	assignment
-//
-//  Inputs
-//	v	: 2D coordinates
-//
-//  Outputs
-//	reference to this object
-//
-Contour2 &Contour2::operator=( const Contour2 &p ) {
-	if( this != &p ) {
-		_id = p._id;
-		_contour = p._contour;
-		_polygons = p._polygons;
-	}
-	return *this;
-}
-
-//------------------------------------------------------------------------------
-//	Special functions
-//------------------------------------------------------------------------------
-bool Contour2::findVertexInComplex( const KeiRo::Base::Coord2 &coord, Graph::BaseUndirectedGraph &complex,
-                                    Graph::BaseUndirectedGraph::vertex_descriptor &target ) {
-	bool isFound = false;
-	
-	BGL_FORALL_VERTICES( vd, complex, Graph::BaseUndirectedGraph ) {
-			//cerr << " vd " << *complex[vd].coordPtr << endl;
-			if( ( coord - *complex[ vd ].coordPtr ).norm() < MIN_VERTEX_DISTANCE ) {
-				target = vd;
-				isFound = true;
-			}
-		}
-	
-	//cerr << "isFound = " << isFound << endl;
-	return isFound;
-}
-
-double Contour2::randomCentroid( void ) {
-	
-	int num = 30;
-	double radius = 20.0;
-	if( _contour.elements().size() == 0 ) return 1.0;
-	
-	KeiRo::Base::Coord2 c = _contour.centroid();
-	while( inContour( c ) == false ) {
-		int size = _contour.elements().size();
-		int idA = rand() % size;
-		int idB = ( idA + 1 ) % size;
-		int idC = ( idA + 2 ) % size;
-		c = (_contour.elements()[ idA ] + _contour.elements()[ idB ] + _contour.elements()[ idC ])/3.0;
-	}
-	double min = minDistToPolygon( c );
-	for( int i = 0; i < num; i++ ) {
-		
-		KeiRo::Base::Coord2 coord( 0.0, 0.0 );
-		cerr << "HERE3" << endl;
-		coord.x() = c.x() + radius * ( 2.0 * rand() / ( double ) RAND_MAX - 1.0 );
-		coord.y() = c.y() + radius * ( 2.0 * rand() / ( double ) RAND_MAX - 1.0 );
-		double minB = minDistToPolygon( coord );
-		if( min < minB && inContour( coord ) ){
-			c = coord;
-			min = minB;
-		}
-	}
-	
-	_contour.centroid() = c;
-	
-	return MAX2( 1.0, min );
-}
-
-//
-//  Contour2::minDistToPolygon --    find the minimum distance of a vertex to the polygon boundary
-//
-//  Inputs
-//  none
-//
-//  Outputs
-//  none
-//
-double Contour2::minDistToPolygon( const KeiRo::Base::Coord2 &coord ) {
-	
-	double minDist = INFINITY;
-	
-	for( unsigned int i = 0; i < _contour.elements().size(); i++ ) {
-		
-		KeiRo::Base::Coord2 &coordM = _contour.elements()[ i ];
-		KeiRo::Base::Coord2 &coordN = _contour.elements()[ ( i + 1 ) % ( int ) _contour.elements().size() ];
-		KeiRo::Base::Coord2 mnVec = coordN - coordM;
-		KeiRo::Base::Coord2 cmVec = coord - coordM;
-		double D = ( mnVec * cmVec ) / mnVec.squaredNorm();
-		KeiRo::Base::Coord2 coordD = coordM + D * mnVec;
-		
-		if( KeiRo::Base::Line2::isOnLine( coordD, coordM, coordN ) ) {
-			
-			double dist = ( coord - coordD ).norm();
-			if( dist < minDist ) minDist = dist;
-		}
-		double dist = (coordM - coord).norm();
-		if( dist < minDist ) {
-			minDist = dist;
-		}
-	}
-	
-	return minDist;
-}
-
-void Contour2::createContour( void ) {
-	
-	// copy cells to a graph
-	Graph::BaseUndirectedGraph complex;
-	unsigned int vid = 0;
-	unsigned int eid = 0;
-	for( unsigned int j = 0; j < _polygons.size(); j++ ) {
-		
-		KeiRo::Base::Polygon2 &p = _polygons[ j ];
-		vector< Graph::BaseUndirectedGraph::vertex_descriptor > vdVec;
-		
-		// add vertices
-		for( unsigned int k = 0; k < p.elements().size(); k++ ) {
-			Graph::BaseUndirectedGraph::vertex_descriptor vd = NULL;
-			
-			bool isFound = findVertexInComplex( p.elements()[ k ], complex, vd );
-			if( isFound == true ) {
-				vdVec.push_back( vd );
-				//cerr << k << " found = " << *complex[ vd ].coordPtr;
-			}
-			else {
-				vd = add_vertex( complex );
-				complex[ vd ].id = vid;
-				complex[ vd ].coordPtr = new KeiRo::Base::Coord2( p.elements()[ k ].x(), p.elements()[ k ].y() );
-				vdVec.push_back( vd );
-				vid++;
-				//cerr << k << " new = " << *complex[ vd ].coordPtr;
-			}
-			//cerr << "( " << complex[ vd ].id << " ) = " << *complex[ vd ].coordPtr << endl;
-		}
-		
-		// add edges
-		for( unsigned int k = 1; k < vdVec.size() + 1; k++ ) {
-			
-			Graph::BaseUndirectedGraph::vertex_descriptor vdS = vdVec[ k - 1 ];
-			Graph::BaseUndirectedGraph::vertex_descriptor vdT = vdVec[ k % ( int ) vdVec.size() ];
-			
-			bool isFound = false;
-			Graph::BaseUndirectedGraph::edge_descriptor oldED;
-			tie( oldED, isFound ) = edge( vdS, vdT, complex );
-			
-			if( isFound == true ) {
-				complex[ oldED ].weight += 1;
-			}
-			else {
-				
-				pair< Graph::BaseUndirectedGraph::edge_descriptor, unsigned int > foreE = add_edge( vdS, vdT, complex );
-				Graph::BaseUndirectedGraph::edge_descriptor foreED = foreE.first;
-				complex[ foreED ].id = eid;
-				complex[ foreED ].weight = 0;
-				eid++;
-			}
-			// cerr << "( " << complex[ vdS ].id << ", " << complex[ vdT ].id << " ) " << endl;
-		}
-		// cerr << endl;
-	}
-
-#ifdef DEBUG
-	printGraph( complex );
-#endif // DEBUG
-	
-	// remove inner edges
-	vector< Graph::BaseUndirectedGraph::edge_descriptor > edVec;
-	BGL_FORALL_EDGES( ed, complex, Graph::BaseUndirectedGraph ) {
-			if( complex[ ed ].weight > 0 ) {
-				edVec.push_back( ed );
-				//cerr << "w = " << complex[ed].weight << endl;
-			}
-		}
-
-#ifdef DEBUG
-	cerr << "bnV = " << num_vertices( complex ) << " ";
-	cerr << "bnE = " << num_edges( complex ) << endl;
-#endif // DEBUG
-	
-	for( unsigned int j = 0; j < edVec.size(); j++ ) {
-		remove_edge( edVec[ j ], complex );
-	}
-	// reorder edge id
-	eid = 0;
-	BGL_FORALL_EDGES( ed, complex, Graph::BaseUndirectedGraph ) {
-			complex[ ed ].id = eid;
-			complex[ ed ].visit = false;
-			eid++;
-		}
-		
-#ifdef DEBUG
-	printGraph( complex );
-#endif // DEBUG
-	
-	// find the vertex with degree > 0
-#ifdef DEBUG
-	cerr << "nV = " << num_vertices( complex ) << " ";
-	cerr << "nE = " << num_edges( complex ) << endl;
-#endif // DEBUG
-	Graph::BaseUndirectedGraph::vertex_descriptor vdS;
-	BGL_FORALL_VERTICES( vd, complex, Graph::BaseUndirectedGraph ) {
-#ifdef DEBUG
-			if ( true ){
-				cerr << " degree = " << out_degree( vd, complex );
-			}
-#endif // DEBUG
-			if( out_degree( vd, complex ) > 0 ) {
-				vdS = vd;
-				break;
-			}
-		}
-	
-	// find the simpleContour
-	Graph::BaseUndirectedGraph::out_edge_iterator eo, eo_end;
-	Graph::BaseUndirectedGraph::vertex_descriptor vdC = vdS;
-	//cerr << "idC = " << complex[vdC].id << " ";
-	
-	KeiRo::Base::Polygon2 polygon;
-	polygon.elements().push_back( KeiRo::Base::Coord2( complex[ vdS ].coordPtr->x(), complex[ vdS ].coordPtr->y() ) );
-	while( true ) {
-		
-		Graph::BaseUndirectedGraph::vertex_descriptor vdT = NULL;
-		for( tie( eo, eo_end ) = out_edges( vdC, complex ); eo != eo_end; eo++ ) {
-			
-			Graph::BaseUndirectedGraph::edge_descriptor ed = *eo;
-			if( complex[ ed ].visit == false ) {
-				vdT = target( ed, complex );
-				complex[ ed ].visit = true;
-				break;
-			}
-			//cerr << "(" << complex[source( ed, complex )].id << "," << complex[target( ed, complex )].id << ")" << endl;
-		}
-		
-		if( vdS == vdT ) break;
-		else
-			assert( vdT != NULL );
-		//cerr << complex[vdT].id << " ";
-		polygon.elements().push_back( KeiRo::Base::Coord2( complex[ vdT ].coordPtr->x(), complex[ vdT ].coordPtr->y() ) );
-		vdC = vdT;
-	}
-	
-	// simplify polygon
-	//cerr << "size = " << polygon.elements().size() << endl;
-	for( unsigned int i = 0; i < polygon.elements().size(); i++ ) {
-		
-		KeiRo::Base::Coord2 prev;
-		if( i == 0 ) prev = polygon.elements()[ polygon.elements().size() - 1 ];
-		else prev = polygon.elements()[ i - 1 ];
-		
-		KeiRo::Base::Coord2 curr = polygon.elements()[ i ];
-		KeiRo::Base::Coord2 next = polygon.elements()[ ( i + 1 ) % ( int ) polygon.elements().size() ];
-		KeiRo::Base::Coord2 vecA = prev - curr;
-		KeiRo::Base::Coord2 vecB = next - curr;
-
-#ifdef DEBUG
-		cerr << i << ": " << (i-1)%polygon.elements().size() << endl;
-		cerr << "prev = " << prev;
-		cerr << "next = " << next;
-		cerr << "curr = " << curr;
-		cerr << "vecA = " << vecA;
-		cerr << "vecB = " << vecB;
-#endif // DEBUG
-		
-		double cosTheta = vecA * vecB / ( vecA.norm() * vecB.norm() );
-		if( fabs( M_PI - acos( cosTheta ) ) > 0.1 ) {
-			//cerr << "acos = " << acos( cosTheta ) << endl;
-			
-			//Coord2 &prev = polygon.elements()[ (i-1+polygon.elements().size())%polygon.elements().size() ];
-			//if( (prev-polygon.elements()[i]).norm() > 1 )
-			_contour.elements().push_back( polygon.elements()[ i ] );
-		}
-	}
-	
-	//cerr << "(ori)::_contour = " << _contour << endl;
-	_contour.cleanPolygon();
-	_contour.updateCentroid();
-	_contour.updateOrientation();
-	//cerr << "simpleContour = " << _contour << endl;
-
-
-#ifdef DEBUG
-	cerr << "centroid = " << polygon.centroid() << endl;
-	cerr << "p[" << i << "] = " << polygon << endl;
-	cerr << "simpleContour = " << _contour << endl;
-#endif // DEBUG
-}
-
-bool Contour2::inContour( KeiRo::Base::Coord2 &coord ) {
-	return _contour.inPolygon( coord );
-}
-
-void Contour2::_initChaikinCurve( double unit = 50 ) {
-	// initialization
-	_fineContour.elements().clear();
-	
-	// store initial the path
-	KeiRo::Base::Polygon2 &contour = _contour;
-	
-	// cerr << "simpleContour.elements().size() = " << simpleContour.elements().size() << endl;
-	if( contour.elements().size() > 0 )
-		_fineContour.elements().push_back( contour.elements()[ 0 ] );
-	for( unsigned int j = 1; j <= contour.elements().size(); j++ ) {
-		
-		KeiRo::Base::Coord2 diff = ( contour.elements()[ j % contour.elements().size() ] - contour.elements()[ j - 1 ] );
-		// cerr << "dist = " << diff.norm() << endl;
-		if( diff.norm() > unit ) {
-			
-			int num = floor( diff.norm() / unit );
-			double interval = diff.norm() / ( double ) num;
-			
-			for( int k = 1; k < num; k++ ) {
-				// cerr << "here" << endl;
-				KeiRo::Base::Coord2 c = contour.elements()[ j - 1 ] + ( double ) k * interval * diff / diff.norm();
-				// cerr << "here " << c;
-				_fineContour.elements().push_back( c );
-			}
-		}
-		if( j < contour.elements().size() )
-			_fineContour.elements().push_back( contour.elements()[ j ] );
-	}
-}
-
-void Contour2::computeChaikinCurve( int num = 5, double unit = 100 ) {
-	_initChaikinCurve( unit );
-	
-	double interval = 4.0;
-	for( int k = 0; k < num; k++ ) {
-		
-		vector< KeiRo::Base::Coord2 > core;
-		for( unsigned int j = 0; j < _fineContour.elements().size(); j++ ) {
-			core.push_back( _fineContour.elements()[ j ] );
-		}
-		
-		// compute Chaikin Curve
-		_fineContour.clear();
-		for( unsigned int j = 0; j < core.size(); j++ ) {
-			
-			KeiRo::Base::Coord2 &p1 = core[ j ];
-			KeiRo::Base::Coord2 &p2 = core[ ( j + 1 ) % core.size() ];
-			KeiRo::Base::Coord2 q = ( 1.0 - 1.0 / interval ) * p1 + ( 1.0 / interval ) * p2;
-			KeiRo::Base::Coord2 r = ( 1.0 / interval ) * p1 + ( 1.0 - 1.0 / interval ) * p2;
-			
-			_fineContour.elements().push_back( q );
-			_fineContour.elements().push_back( r );
-		}
-	}
-}
-
-//------------------------------------------------------------------------------
-//	Friend functions
-//------------------------------------------------------------------------------
-
-//------------------------------------------------------------------------------
-//	I/O functions
-//------------------------------------------------------------------------------
-//
-//  operator << --	output
-//
-//  Inputs
-//	s	: reference to output stream
-//	v	: 2D coordinates
-//
-//  Outputs
-//	reference to output stream
-//
-ostream &operator<<( ostream &stream, const Contour2 &obj ) {
-	int i;        // loop counter
-	// set the output formatting
-	//stream << setiosflags( ios::showpoint );
-	//stream << setprecision( 8 );
-	//int width = 16;
-	// print out the elements
-	for( i = 0; i < obj._contour.elements().size(); i++ ) {
-		//stream << setw( width ) << obj._element[ i ];
-		stream << setw( 4 ) << obj._contour.elements()[ i ];
-		if( i != 1 ) stream << "\t";
-	}
-	stream << endl;
-	
-	return stream;
-}
-
-
-//
-//  operator >> --	input
-//
-//  Inputs
-//	s	: reference to input stream
-//	v	: 2D coordinates
-//
-//  Outputs
-//	reference to input stream
-//
-istream &operator>>( istream &stream, Contour2 &obj ) {
-	int i;        // loop counter
-	// reading the elements
-	for( i = 0; i < obj._contour.elements().size(); i++ )
-		stream >> obj._contour.elements()[ i ];
-	return stream;
-}
-
-
-
-
Index: Graph/src/PropertyGraph.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#ifndef _PropertyGraph_H\r\n#define _PropertyGraph_H\r\n\r\n\r\n#include <boost/config.hpp>\r\n#include <boost/graph/graph_traits.hpp>\r\n#include <boost/graph/adjacency_list.hpp>\r\n#include <boost/property_map/property_map.hpp>\r\n#include <boost/graph/graphml.hpp>\r\n\r\nusing namespace boost;\r\n\r\nnamespace Graph {\r\n\t\r\n\ttypedef adjacency_list< vecS, vecS, directedS,\r\n\tproperty< vertex_index_t, int >,\r\n\tproperty< edge_weight_t, int > > DirectedPropertyGraph;\r\n\r\n\ttypedef adjacency_list< listS, vecS, undirectedS,\r\n\tproperty< vertex_index_t, int >,\r\n\tproperty< edge_index_t, int >,\r\n\tproperty< edge_weight_t, double > > PropertyGraph;\r\n\r\n\t// define the storage type for the planar embedding\r\n\ttypedef vector< std::vector< graph_traits< PropertyGraph >::edge_descriptor > > embedding_storage_t;\r\n\ttypedef boost::iterator_property_map < embedding_storage_t::iterator, property_map< PropertyGraph, vertex_index_t >::type > embedding_t;\r\n\r\n\ttypedef property_map< PropertyGraph, vertex_index_t >::type VertexIndexMap;\r\n\ttypedef property_map< PropertyGraph, edge_index_t >::type EdgeIndexMap;\r\n\t\r\n\t//typedef property_map< PropertyGraph, edge_weight_t >::type EdgeWeightMap;\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n//\tCustomized BaseGraph Functions\r\n//------------------------------------------------------------------------------\r\n\r\n#endif  // _PropertyGraph_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Graph/src/PropertyGraph.h b/Graph/src/PropertyGraph.h
--- a/Graph/src/PropertyGraph.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Graph/src/PropertyGraph.h	(date 1729410604760)
@@ -1,38 +1,0 @@
-#ifndef _PropertyGraph_H
-#define _PropertyGraph_H
-
-
-#include <boost/config.hpp>
-#include <boost/graph/graph_traits.hpp>
-#include <boost/graph/adjacency_list.hpp>
-#include <boost/property_map/property_map.hpp>
-#include <boost/graph/graphml.hpp>
-
-using namespace boost;
-
-namespace Graph {
-	
-	typedef adjacency_list< vecS, vecS, directedS,
-	property< vertex_index_t, int >,
-	property< edge_weight_t, int > > DirectedPropertyGraph;
-
-	typedef adjacency_list< listS, vecS, undirectedS,
-	property< vertex_index_t, int >,
-	property< edge_index_t, int >,
-	property< edge_weight_t, double > > PropertyGraph;
-
-	// define the storage type for the planar embedding
-	typedef vector< std::vector< graph_traits< PropertyGraph >::edge_descriptor > > embedding_storage_t;
-	typedef boost::iterator_property_map < embedding_storage_t::iterator, property_map< PropertyGraph, vertex_index_t >::type > embedding_t;
-
-	typedef property_map< PropertyGraph, vertex_index_t >::type VertexIndexMap;
-	typedef property_map< PropertyGraph, edge_index_t >::type EdgeIndexMap;
-	
-	//typedef property_map< PropertyGraph, edge_weight_t >::type EdgeWeightMap;
-}
-
-//------------------------------------------------------------------------------
-//	Customized BaseGraph Functions
-//------------------------------------------------------------------------------
-
-#endif  // _PropertyGraph_H
Index: CMakeLists.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>cmake_minimum_required( VERSION 3.8 )\r\nPROJECT( KeiRo )\r\nset( Target_Name KeiRo )\r\nset(CMAKE_MACOSX_RPATH OFF)\r\n\r\n#----------------------------------------------------------------------\r\n# cmake setting\r\n#----------------------------------------------------------------------\r\nmessage( \"CMAKE_BINARY_DIR: \" ${CMAKE_BINARY_DIR} )\r\nmessage( \"CMAKE_SOURCE_DIR: \" ${CMAKE_SOURCE_DIR} )\r\n## set output folder\r\n## set(CMAKE_INCLUDE_CURRENT_DIR ON)\r\n#set( CMAKE_RUNTIME_OUTPUT_DIRECTORY \"${CMAKE_BINARY_DIR}/bin\" )\r\n#set( CMAKE_LIBRARY_OUTPUT_DIRECTORY \"${CMAKE_BINARY_DIR}/bin\" )\r\n#set( CMAKE_ARCHIVE_OUTPUT_DIRECTORY \"${CMAKE_BINARY_DIR}/bin\" )\r\n##set( SEPARATE_BUILD ON)\r\n\r\n# basic library configuration\r\nadd_subdirectory( Base )\r\nadd_subdirectory( Graph )\r\nadd_subdirectory( Optimization )\r\nadd_subdirectory( Composite )\r\nadd_subdirectory( Geometry )\r\nadd_subdirectory( FileIO )\r\nadd_subdirectory( UI )\r\n\r\n# target binary configuration\r\nif(EXISTS \"${CMAKE_SOURCE_DIR}/Metabopolis\")\r\n    add_subdirectory( Metabopolis )\r\n    message( \"The system will build Metabopolis\" )\r\nendif()\r\nif(EXISTS \"${CMAKE_SOURCE_DIR}/Harmony\")\r\n#    add_subdirectory( Harmony )\r\n    message( \"The system will build Harmony\" )\r\nendif()\r\nif(EXISTS \"${CMAKE_SOURCE_DIR}/ResponsiveLens\")\r\n    add_subdirectory( ResponsiveLens )\r\n    message( \"The system will build ResponsiveLens\" )\r\nendif()\r\n#if(EXISTS \"${CMAKE_SOURCE_DIR}/Test\")\r\n#    add_subdirectory( Test )\r\n#    message( \"The system will build Test\" )\r\n#endif()\r\n\r\n# Copy directories\r\nfile(COPY ${CMAKE_SOURCE_DIR}/config/ DESTINATION ${CMAKE_BINARY_DIR}/config/)\r\nfile(COPY ${CMAKE_SOURCE_DIR}/data/ DESTINATION ${CMAKE_BINARY_DIR}/data/)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/CMakeLists.txt b/CMakeLists.txt
--- a/CMakeLists.txt	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/CMakeLists.txt	(date 1729410604770)
@@ -1,47 +1,0 @@
-cmake_minimum_required( VERSION 3.8 )
-PROJECT( KeiRo )
-set( Target_Name KeiRo )
-set(CMAKE_MACOSX_RPATH OFF)
-
-#----------------------------------------------------------------------
-# cmake setting
-#----------------------------------------------------------------------
-message( "CMAKE_BINARY_DIR: " ${CMAKE_BINARY_DIR} )
-message( "CMAKE_SOURCE_DIR: " ${CMAKE_SOURCE_DIR} )
-## set output folder
-## set(CMAKE_INCLUDE_CURRENT_DIR ON)
-#set( CMAKE_RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/bin" )
-#set( CMAKE_LIBRARY_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/bin" )
-#set( CMAKE_ARCHIVE_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/bin" )
-##set( SEPARATE_BUILD ON)
-
-# basic library configuration
-add_subdirectory( Base )
-add_subdirectory( Graph )
-add_subdirectory( Optimization )
-add_subdirectory( Composite )
-add_subdirectory( Geometry )
-add_subdirectory( FileIO )
-add_subdirectory( UI )
-
-# target binary configuration
-if(EXISTS "${CMAKE_SOURCE_DIR}/Metabopolis")
-    add_subdirectory( Metabopolis )
-    message( "The system will build Metabopolis" )
-endif()
-if(EXISTS "${CMAKE_SOURCE_DIR}/Harmony")
-#    add_subdirectory( Harmony )
-    message( "The system will build Harmony" )
-endif()
-if(EXISTS "${CMAKE_SOURCE_DIR}/ResponsiveLens")
-    add_subdirectory( ResponsiveLens )
-    message( "The system will build ResponsiveLens" )
-endif()
-#if(EXISTS "${CMAKE_SOURCE_DIR}/Test")
-#    add_subdirectory( Test )
-#    message( "The system will build Test" )
-#endif()
-
-# Copy directories
-file(COPY ${CMAKE_SOURCE_DIR}/config/ DESTINATION ${CMAKE_BINARY_DIR}/config/)
-file(COPY ${CMAKE_SOURCE_DIR}/data/ DESTINATION ${CMAKE_BINARY_DIR}/data/)
Index: UI/src/GraphicsPolygonItem.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// GraphicsPolygonItem.cpp\r\n//\t: program file for polygon items\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Jun 19 02:36:37 2019\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include \"GraphicsPolygonItem.h\"\r\n\r\n\r\nnamespace Ui {\r\nnamespace Vector {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPrivate functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tProtected functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  GraphicsPolygonItem::init -- initialization\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void GraphicsPolygonItem::_init( void )\r\n    {\r\n\t    GraphicsBase::_init();\r\n    }\r\n\t\r\n\tQVariant polygonInterpolator(const QPolygonF &start, const QPolygonF &end, qreal progress)\r\n\t{\r\n//    \tcerr << \"progress = \" << progress << endl;\r\n//\t\tcerr << \"0 x = \" << end[0].x() << \" y = \" << end[0].y() << endl;\r\n//\t\tcerr << \"1 x = \" << end[1].x() << \" y = \" << end[1].y() << endl;\r\n\t\tQPolygonF poly;\r\n\t\tfor( unsigned int i = 0; i < start.size(); i++ ){\r\n\t\t\tQPointF p;\r\n\t\t\tp.setX( progress * end[i].x() + (1.0-progress) * start[i].x() );\r\n\t\t\tp.setY( progress * end[i].y() + (1.0-progress) * start[i].y() );\r\n\t\t\tpoly.append( p );\r\n\t\t}\r\n\r\n//\t\tcerr << \"size = \" << poly.size() << endl;\r\n\t\treturn poly;\r\n\t}\r\n\t\r\n    //------------------------------------------------------------------------------\r\n    //\tPublic functions\r\n    //------------------------------------------------------------------------------\r\n    //------------------------------------------------------------------------------\r\n    //\tConstructors & Destructors\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  GraphicsPolygonItem::GraphicsPolygonItem -- constructor\r\n    //\r\n    //  Inputs\r\n    //  parent: parent object\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    GraphicsPolygonItem::GraphicsPolygonItem( QGraphicsItem *parent )\r\n    {\r\n\t    qRegisterAnimationInterpolator< QPolygonF >( polygonInterpolator );\r\n    \t\r\n        setFlag( QGraphicsItem::ItemIsSelectable );\r\n//        setFlag( QGraphicsItem::ItemIsMovable );\r\n//        setFlag( QGraphicsItem::ItemSendsGeometryChanges );\r\n        //setAcceptDrops( true );\r\n\r\n        //pen().setJoinStyle( Qt::MiterJoin );\r\n        pen().setJoinStyle( Qt::RoundJoin );\r\n    }\r\n    \r\n    //\r\n    //  GraphicsPolygonItem::boundingRect -- find bounding box\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  reference to the bounding box\r\n    //\r\n    QRectF GraphicsPolygonItem::boundingRect( void ) const\r\n    {\r\n#ifdef GRAPHICSPOLYGONITEM_DEBUG\r\n        cerr << \"id = \" << _id\r\n             << setw(10 )<< \" bx = \" << polygon().boundingRect().x()\r\n             << setw(10 )<< \" by = \" << polygon().boundingRect().y()\r\n             << setw(10 )<< \" bw = \" << polygon().boundingRect().width()\r\n             << setw(10 )<< \" bh = \" << polygon().boundingRect().height()\r\n             << endl;\r\n#endif // GRAPHICSPOLYGONITEM_DEBUG\r\n        return polygon().boundingRect();\r\n    }\r\n\r\n    //\r\n    //  GraphicsPolygonItem::paint -- paint scene\r\n    //\r\n    //  Inputs\r\n    //  painter: Qpainter\r\n    //  option: QStyleOptionGraphicsItem\r\n    //  widget: QWidget\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void GraphicsPolygonItem::paint( QPainter *painter, const QStyleOptionGraphicsItem *option,\r\n                                     QWidget *widget )\r\n    {\r\n        QFontMetrics metrics( _font );\r\n        double sx = metrics.width( _text );\r\n        double sy = 0.5*metrics.height();\r\n\r\n        // draw boundary\r\n        painter->setRenderHints( QPainter::Antialiasing );\r\n        painter->setPen( pen() );\r\n        painter->setBrush( brush() );\r\n\t    painter->drawPolygon( polygon() );\r\n\r\n\t    double minX = INFINITY, maxX = -INFINITY;\r\n\t    double minY = INFINITY, maxY = -INFINITY;\r\n\t    for( unsigned int i = 0; i < polygon().size(); i++ ){\r\n\t\t\tif( minX > polygon()[i].x() ) minX = polygon()[i].x();\r\n\t\t    if( maxX < polygon()[i].x() ) maxX = polygon()[i].x();\r\n\t\t    if( minY > polygon()[i].y() ) minY = polygon()[i].y();\r\n\t\t    if( maxY < polygon()[i].y() ) maxY = polygon()[i].y();\r\n\t    }\r\n\t    \r\n\t    QPointF p( 0.5*(minX+maxX), 0.5*(minY+maxY) );\r\n        if( _textOn == true ){\r\n\r\n            painter->setPen( _textpen );\r\n\t        painter->setFont( _font );\r\n#ifdef SKIP\r\n            for( unsigned int i = 0; i < p.size(); i++ ){\r\n                painter->drawText( p.at(i).x()+5, p.at(i).y()-5, QString::fromStdString( to_string( _id ) ) );\r\n            }\r\n#endif // SKIP\r\n\r\n\t        painter->drawText( p.x() - 0.5 * sx, p.y() + 0.5 * sy, _text );\r\n//            painter->drawText(\r\n//                    _bbox.x() + 0.5 * _bbox.width() - 0.5 * sx,\r\n//                    -_bbox.y() - 0.5 * _bbox.height() + 0.5 * sy,\r\n//                    _text\r\n//                    );\r\n        }\r\n\r\n        //cerr << \"paint x = \" << pos().x() << \" y = \" << pos().y() << endl;\r\n        // Qt function\r\n        //if ( option->state & QStyle::State_Selected )\r\n        //\tqt_graphicsItem_highlightSelected( this, painter, option );\r\n    }\r\n\r\n    //\r\n    //  GraphicsPolygonItem::type -- find type\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  reference to the type of the object\r\n    //\r\n    int GraphicsPolygonItem::type( void ) const\r\n    {\r\n        return 0; //GRAPHICS_POLYGON+QGraphicsItem::UserType;\r\n    }\r\n\r\n} // namespace Vector\r\n} // namespace Ui
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/UI/src/GraphicsPolygonItem.cpp b/UI/src/GraphicsPolygonItem.cpp
--- a/UI/src/GraphicsPolygonItem.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/UI/src/GraphicsPolygonItem.cpp	(date 1729410604780)
@@ -1,182 +1,0 @@
-//******************************************************************************
-// GraphicsPolygonItem.cpp
-//	: program file for polygon items
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Jun 19 02:36:37 2019
-//
-//******************************************************************************
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include "GraphicsPolygonItem.h"
-
-
-namespace Ui {
-namespace Vector {
-
-    //------------------------------------------------------------------------------
-    //	Private functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Protected functions
-    //------------------------------------------------------------------------------
-    //
-    //  GraphicsPolygonItem::init -- initialization
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    //
-    void GraphicsPolygonItem::_init( void )
-    {
-	    GraphicsBase::_init();
-    }
-	
-	QVariant polygonInterpolator(const QPolygonF &start, const QPolygonF &end, qreal progress)
-	{
-//    	cerr << "progress = " << progress << endl;
-//		cerr << "0 x = " << end[0].x() << " y = " << end[0].y() << endl;
-//		cerr << "1 x = " << end[1].x() << " y = " << end[1].y() << endl;
-		QPolygonF poly;
-		for( unsigned int i = 0; i < start.size(); i++ ){
-			QPointF p;
-			p.setX( progress * end[i].x() + (1.0-progress) * start[i].x() );
-			p.setY( progress * end[i].y() + (1.0-progress) * start[i].y() );
-			poly.append( p );
-		}
-
-//		cerr << "size = " << poly.size() << endl;
-		return poly;
-	}
-	
-    //------------------------------------------------------------------------------
-    //	Public functions
-    //------------------------------------------------------------------------------
-    //------------------------------------------------------------------------------
-    //	Constructors & Destructors
-    //------------------------------------------------------------------------------
-    //
-    //  GraphicsPolygonItem::GraphicsPolygonItem -- constructor
-    //
-    //  Inputs
-    //  parent: parent object
-    //
-    //  Outputs
-    //  none
-    //
-    GraphicsPolygonItem::GraphicsPolygonItem( QGraphicsItem *parent )
-    {
-	    qRegisterAnimationInterpolator< QPolygonF >( polygonInterpolator );
-    	
-        setFlag( QGraphicsItem::ItemIsSelectable );
-//        setFlag( QGraphicsItem::ItemIsMovable );
-//        setFlag( QGraphicsItem::ItemSendsGeometryChanges );
-        //setAcceptDrops( true );
-
-        //pen().setJoinStyle( Qt::MiterJoin );
-        pen().setJoinStyle( Qt::RoundJoin );
-    }
-    
-    //
-    //  GraphicsPolygonItem::boundingRect -- find bounding box
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  reference to the bounding box
-    //
-    QRectF GraphicsPolygonItem::boundingRect( void ) const
-    {
-#ifdef GRAPHICSPOLYGONITEM_DEBUG
-        cerr << "id = " << _id
-             << setw(10 )<< " bx = " << polygon().boundingRect().x()
-             << setw(10 )<< " by = " << polygon().boundingRect().y()
-             << setw(10 )<< " bw = " << polygon().boundingRect().width()
-             << setw(10 )<< " bh = " << polygon().boundingRect().height()
-             << endl;
-#endif // GRAPHICSPOLYGONITEM_DEBUG
-        return polygon().boundingRect();
-    }
-
-    //
-    //  GraphicsPolygonItem::paint -- paint scene
-    //
-    //  Inputs
-    //  painter: Qpainter
-    //  option: QStyleOptionGraphicsItem
-    //  widget: QWidget
-    //
-    //  Outputs
-    //  none
-    //
-    void GraphicsPolygonItem::paint( QPainter *painter, const QStyleOptionGraphicsItem *option,
-                                     QWidget *widget )
-    {
-        QFontMetrics metrics( _font );
-        double sx = metrics.width( _text );
-        double sy = 0.5*metrics.height();
-
-        // draw boundary
-        painter->setRenderHints( QPainter::Antialiasing );
-        painter->setPen( pen() );
-        painter->setBrush( brush() );
-	    painter->drawPolygon( polygon() );
-
-	    double minX = INFINITY, maxX = -INFINITY;
-	    double minY = INFINITY, maxY = -INFINITY;
-	    for( unsigned int i = 0; i < polygon().size(); i++ ){
-			if( minX > polygon()[i].x() ) minX = polygon()[i].x();
-		    if( maxX < polygon()[i].x() ) maxX = polygon()[i].x();
-		    if( minY > polygon()[i].y() ) minY = polygon()[i].y();
-		    if( maxY < polygon()[i].y() ) maxY = polygon()[i].y();
-	    }
-	    
-	    QPointF p( 0.5*(minX+maxX), 0.5*(minY+maxY) );
-        if( _textOn == true ){
-
-            painter->setPen( _textpen );
-	        painter->setFont( _font );
-#ifdef SKIP
-            for( unsigned int i = 0; i < p.size(); i++ ){
-                painter->drawText( p.at(i).x()+5, p.at(i).y()-5, QString::fromStdString( to_string( _id ) ) );
-            }
-#endif // SKIP
-
-	        painter->drawText( p.x() - 0.5 * sx, p.y() + 0.5 * sy, _text );
-//            painter->drawText(
-//                    _bbox.x() + 0.5 * _bbox.width() - 0.5 * sx,
-//                    -_bbox.y() - 0.5 * _bbox.height() + 0.5 * sy,
-//                    _text
-//                    );
-        }
-
-        //cerr << "paint x = " << pos().x() << " y = " << pos().y() << endl;
-        // Qt function
-        //if ( option->state & QStyle::State_Selected )
-        //	qt_graphicsItem_highlightSelected( this, painter, option );
-    }
-
-    //
-    //  GraphicsPolygonItem::type -- find type
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  reference to the type of the object
-    //
-    int GraphicsPolygonItem::type( void ) const
-    {
-        return 0; //GRAPHICS_POLYGON+QGraphicsItem::UserType;
-    }
-
-} // namespace Vector
-} // namespace Ui
\ No newline at end of file
Index: UI/src/GraphicsView.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// GraphicsView.cpp\r\n//\t: program file for graphics view\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Jun 19 02:36:37 2019\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include \"GraphicsCellItem.h\"\r\n#include \"GraphicsPathItem.h\"\r\n#include \"GraphicsView.h\"\r\n\r\n#define _USE_MATH_DEFINES\r\n#include <math.h>\r\n\r\nnamespace Ui {\r\n\t\t\r\n\t//------------------------------------------------------------------------------\r\n\t//\tPrivate functions\r\n\t//------------------------------------------------------------------------------\r\n\t\r\n\t//------------------------------------------------------------------------------\r\n\t//\tProtected functions\r\n\t//------------------------------------------------------------------------------\r\n\t\r\n\t//------------------------------------------------------------------------------\r\n\t//\tPublic functions\r\n\t//------------------------------------------------------------------------------\r\n\t\r\n\t//------------------------------------------------------------------------------\r\n\t//\tConstructors & Destructors\r\n\t//------------------------------------------------------------------------------\r\n\t//\r\n\t//  GraphicsView::GraphicsView -- constructor\r\n\t//\r\n\t//  Inputs\r\n\t//  none\r\n\t//\r\n\t//  Outputs\r\n\t//  none\r\n\t//\r\n\tGraphicsView::GraphicsView( QWidget *parent )\r\n\t\t\t: QGraphicsView( parent ) {\r\n\t\t\r\n\t\t//------------------------------------------------------------------------------\r\n\t\t// configuration file\r\n\t\t//------------------------------------------------------------------------------\r\n//\t\t\tstring configFilePath = qApp->applicationDirPath().toStdString() + \"/../config/MainWindow.conf\";\r\n//\t\t\tBase::Config conf( configFilePath );\r\n\t\t_basePtr = nullptr;\r\n\t\t\r\n\t\tsetGeometry( QRect( 0, 0,\r\n\t\t                    KeiRo::Base::Common::getMainwidgetWidth(), KeiRo::Base::Common::getMainwidgetHeight() ) );\r\n\t\tsetMinimumSize(QSize( KeiRo::Base::Common::getMainwidgetWidth(), KeiRo::Base::Common::getMainwidgetHeight() ) );\r\n\t\t\r\n\t\t_scenePtr = new QGraphicsScene;\r\n        _scenePtr->setSceneRect( -KeiRo::Base::Common::getMainwidgetWidth() / 2.0, -KeiRo::Base::Common::getMainwidgetHeight() / 2.0,\r\n                                 KeiRo::Base::Common::getMainwidgetWidth(), KeiRo::Base::Common::getMainwidgetHeight() );  // x, y, w, h\r\n                                 \r\n#ifdef DEBUG\r\n\t\tcerr << \"w = \" << width() << \", h = \" << height() << endl;\r\n\t\tcerr << \"mainwidget_width = \" << KeiRo::Base::Common::getMainwidgetWidth() << endl;\r\n\t\tcerr << \"mainwidget_height = \" << KeiRo::Base::Common::getMainwidgetHeight() << endl;\r\n\t\tcerr << \"dockwidget_width = \" << KeiRo::Base::Common::getDockWidgetWidth() << endl;\r\n#endif // DEBUG\r\n\t\tthis->setScene( _scenePtr );\r\n\t}\r\n\t\r\n\r\n\t//------------------------------------------------------------------------------\r\n\t//\tEvent handlers\r\n\t//------------------------------------------------------------------------------\r\n\tvoid GraphicsView::simulateKey( Qt::Key key ) {\r\n\r\n\t\t// press the key\r\n\t\tQKeyEvent eventP( QEvent::KeyPress, key, Qt::NoModifier );\r\n\t\tQApplication::sendEvent( this, &eventP );\r\n\t\t// release the key\r\n\t\tQKeyEvent eventR( QEvent::KeyRelease, key, Qt::NoModifier );\r\n\t\tQApplication::sendEvent( this, &eventR );\r\n\t}\r\n/*\r\n\t//\r\n\t//  GraphicsView::keyPressEvent -- key press event\r\n\t//\r\n\t//  Inputs\r\n\t//  event: key event\r\n\t//\r\n\t//  Outputs\r\n\t//  none\r\n\t//\r\n\tvoid GraphicsView::keyPressEvent( QKeyEvent *event )\r\n\t{\r\n\t\tswitch( event->key() ) {\r\n\r\n            case Qt::Key_L: {\r\n                break;\r\n            }\r\n            default: {\r\n                // QWidget::keyPressEvent( event );\r\n                // QGraphicsView::keyPressEvent( event );\r\n                break;\r\n            }\r\n\t\t}\r\n\t\t\r\n\t\tQGraphicsView::keyPressEvent( event );\r\n\t\tupdateSceneItems();\r\n\t}\r\n\t\r\n\t//\r\n\t//  GraphicsView::mousePressEvent -- mouse press event\r\n\t//\r\n\t//  Inputs\r\n\t//  event: mouse event\r\n\t//\r\n\t//  Outputs\r\n\t//  none\r\n\t//\r\n\tvoid GraphicsView::mousePressEvent( QMouseEvent *event ) {\r\n\r\n\t\tQPointF coord = mapToScene( event->pos() );\r\n\t\t// centerOn( coord.x(), coord.y() );\r\n\t\t\r\n\t\t//QPainterPath selectionArea;\r\n\t\tdouble square = 10.0;\r\n//\t\t\t_selectionArea.clear();\r\n//\t\t\t_selectionArea.addPolygon( mapToScene(\r\n//\t\t\t\t\tQRect( event->pos().x() - square / 2.0, event->pos().y() - square / 2.0, square, square ) ) );\r\n//\t\t\t_selectionArea.closeSubpath();\r\n//\r\n//\t\t\t_scenePtr->setSelectionArea( _selectionArea, this->rubberBandSelectionMode() ); //, viewportTransform() );\r\n\t\t\r\n\t\tswitch( event->buttons() ) {\r\n\t\t\r\n\t\tcase Qt::RightButton:\r\n\t\t\tbreak;\r\n\t\tcase Qt::LeftButton:\r\n\t\t\tbreak;\r\n\t\tcase Qt::MiddleButton:\r\n\t\t\tbreak;\r\n\t\tdefault: {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tQGraphicsView::mousePressEvent( event );\r\n\r\n#ifdef GRAPHICSVIEW_DEBUG\r\n\t\tcerr << \"mouse pressing...\" << endl\r\n\t\t\t << \" x = \" << event->pos().x() << \" y = \" << event->pos().y() << endl\r\n\t\t\t << \" sx = \" << coord.x() << \" sy = \" << coord.y() << endl;\r\n\t\tcerr << \"_right_button_pressed = \" << _right_button_pressed << endl\r\n\t\t\t << \"_left_button_pressed = \" << _left_button_pressed << endl\r\n\t\t\t << \"_middle_button_pressed = \" << _middle_button_pressed << endl;\r\n#endif // GRAPHICSVIEW_DEBUG\r\n\t}\r\n\t\r\n\t//\r\n\t//  GraphicsView::mouseMoveEvent -- mouse move event\r\n\t//\r\n\t//  Inputs\r\n\t//  event: mouse event\r\n\t//\r\n\t//  Outputs\r\n\t//  none\r\n\t//\r\n\tvoid GraphicsView::mouseMoveEvent( QMouseEvent *event ) {\r\n//\t\t\t_cursor = QPoint( event->pos().x() - Base::Common::getMainwidgetWidth() / 2,\r\n//\t\t\t                  -( event->pos().y() - Base::Common::getMainwidgetHeight() / 2 ) );\r\n\t\tdouble norm = QLineF( _cursor, _oldCursor ).length();\r\n\t\t\r\n\t\t// static int test = 0;\r\n\t\t\r\n\t\tif( norm > 1.0 * _min_point_distance ) {\r\n\t\t\tsimulateKey( Qt::Key_Z );\r\n\r\n#ifdef GRAPHICSVIEW_DEBUG\r\n\t\t\t// sleep( 3 );\r\n\t\t\ttest = test+1;\r\n\t\t\tcerr << \"#######################\" << endl;\r\n\t\t\tcerr << \"norm = \" << norm << endl;\r\n\t\t\tcerr << \"Moving mouse ... \" << endl;\r\n\t\t\tcerr << test << \", className = \" << className() << endl;\r\n\t\t\tcerr << \"_oldCursor = \" << _oldCursor.x() << \", \" << _oldCursor.y() << endl;\r\n\t\t\tcerr << \"_cursor = \" << _cursor.x() << \", \" << _cursor.y() << endl;\r\n\t\t\tcerr << \"norm = \" << norm << endl;\r\n#endif // GRAPHICSVIEW_DEBUG\r\n\t\t\t_oldCursor = _cursor;\r\n\t\t}\r\n\t\tQGraphicsView::mouseMoveEvent( event );\r\n\t}\r\n\t\r\n\t//\r\n\t//  GraphicsView::mouseReleaseEvent -- mouse release event\r\n\t//\r\n\t//  Inputs\r\n\t//  event: mouse event\r\n\t//\r\n\t//  Outputs\r\n\t//  none\r\n\t//\r\n\tvoid GraphicsView::mouseReleaseEvent( QMouseEvent *event ) {\r\n\t\t_right_button_pressed = false;\r\n\t\t_left_button_pressed = false;\r\n\t\t_middle_button_pressed = false;\r\n\t\t\r\n\t\tQGraphicsView::mouseReleaseEvent( event );\r\n\r\n#ifdef GRAPHICSVIEW_DEBUG\r\n\t\tcerr << \"Releasing mouse ...\" << endl;\r\n\t\tcerr << \"_right_button_pressed = \" << _right_button_pressed << endl\r\n\t\t\t << \"_left_button_pressed = \" << _left_button_pressed << endl\r\n\t\t\t << \"_middle_button_pressed = \" << _middle_button_pressed << endl;\r\n#endif // GRAPHICSVIEW_DEBUG\r\n\t}\r\n*/\r\n\t\r\n\t//\r\n\t//  GraphicsView::exportPNG -- export png\r\n\t//\r\n\t//  Inputs\r\n\t//  x, y, w, h: center, width, height\r\n\t//\r\n\t//  Outputs\r\n\t//  none\r\n\t//\r\n\tvoid GraphicsView::exportPNG( double x, double y, double w, double h )\r\n\t{\r\n\t\t// Take file path and name that will create\r\n\t\t//QString newPath = QFileDialog::getSaveFileName(this, trUtf8(\"Save SVG\"),\r\n\t\t//                                               path, tr(\"SVG files (*.svg)\"));\r\n\t\tstatic int id = 0;\r\n\t\tostringstream ss;\r\n\t\tss << setw( 8 ) << std::setfill( '0' ) << id;\r\n\t\tstring s2( ss.str() );\r\n\t\tQString idStr = QString::fromStdString( s2 );\r\n\t\t// cerr << \"s2 = \" << s2 << endl;\r\n\t\t\r\n\t\t// create tmp folder for stable treemap command\r\n\t\tQString filePath = qApp->applicationDirPath() + QString( \"/tmp\" );\r\n\t\t\r\n\t\t// create the temporary folder\r\n\t\tQString exportFolder = filePath + QString( \"/png/\" );\r\n\t\t\r\n\t\tif( !QDir( exportFolder ).exists() ){\r\n\t\t\tQDir().mkdir( exportFolder );\r\n\t\t\tcerr << \"create a png folder!\" << endl;\r\n\t\t}\r\n\t\t\r\n\t\tQString newPath = exportFolder + idStr + QString( QLatin1String( \".png\" ) );\r\n\t\t_scenePtr->setSceneRect( x, y, w, h );  // x, y, w, h\r\n\t\t\r\n\t\tif( newPath.isEmpty() ) return;\r\n\t\t\r\n\t\tQImage screenshot( w, h, QImage::Format_RGB32 ); // maximum 32767x32767\r\n\t\t\r\n\t\t//int dpm = 300 / 0.0254; // ~300 DPI\r\n\t\t//screenshot.setDotsPerMeterX( dpm );\r\n\t\t//screenshot.setDotsPerMeterY( dpm );\r\n\t\t\r\n\t\tQPainter painter( &screenshot );\r\n\t\tpainter.setRenderHint( QPainter::Antialiasing );\r\n\t\tpainter.fillRect( 0, 0, w, h, Qt::white );\r\n\t\t_scenePtr->render( &painter );\r\n\t\tscreenshot.save( newPath );\r\n\t\t\r\n\t\tid++;\r\n\t}\r\n\t\r\n\t//\r\n\t//  GraphicsView::exportSVG -- export svg\r\n\t//\r\n\t//  Inputs\r\n\t//  x, y, w, h: center, width, height\r\n\t//\r\n\t//  Outputs\r\n\t//  none\r\n\t//\r\n\tvoid GraphicsView::exportSVG( double x, double y, double w, double h ) {\r\n\t\r\n//\t\t\t// Take file path and name that will create\r\n//\t\t\t//QString newPath = QFileDialog::getSaveFileName(this, trUtf8(\"Save SVG\"),\r\n//\t\t\t//                                               path, tr(\"SVG files (*.svg)\"));\r\n//\t\t\tstatic int id = 0;\r\n//\t\t\tostringstream ss;\r\n//\t\t\tss << setw( 8 ) << std::setfill( '0' ) << id;\r\n//\t\t\tstring s2( ss.str() );\r\n//\t\t\tQString idStr = QString::fromStdString( s2 );\r\n//\t\t\t// cerr << \"s2 = \" << s2 << endl;\r\n//\t\t\tQString newPath =\r\n//\t\t\t\t\tQString( QLatin1String( \"../svg/pathway-\" ) ) + idStr + QString( QLatin1String( \".svg\" ) );\r\n//\t\t\t_scenePtr->setSceneRect( x, y, w, h );  // x, y, w, h\r\n//\r\n//\t\t\tif( newPath.isEmpty() ) return;\r\n//\r\n//\t\t\tQSvgGenerator generator;            // Create a file generator object\r\n//\t\t\tgenerator.setFileName( newPath );    // We set the path to the file where to save vector graphics\r\n//\t\t\tgenerator.setSize(\r\n//\t\t\t\t\tQSize( w, h ) );  // Set the dimensions of the working area of the document in millimeters\r\n//\t\t\tgenerator.setViewBox( QRect( 0, 0, w, h ) ); // Set the work area in the coordinates\r\n//\t\t\tgenerator.setTitle( trUtf8( \"SVG Example\" ) );                                // The title document\r\n//\t\t\tgenerator.setDescription( trUtf8( \"File created by SVG Example\" ) );\r\n//\r\n//\t\t\tQPainter painter;\r\n//\t\t\tpainter.begin( &generator );\r\n//\t\t\t_scenePtr->render( &painter );\r\n//\t\t\tpainter.end();\r\n//\r\n//\t\t\tid++;\r\n\t}\r\n\t\t\r\n} // namespace Ui
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/UI/src/GraphicsView.cpp b/UI/src/GraphicsView.cpp
--- a/UI/src/GraphicsView.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/UI/src/GraphicsView.cpp	(date 1729410604790)
@@ -1,318 +1,0 @@
-//******************************************************************************
-// GraphicsView.cpp
-//	: program file for graphics view
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Jun 19 02:36:37 2019
-//
-//******************************************************************************
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include "GraphicsCellItem.h"
-#include "GraphicsPathItem.h"
-#include "GraphicsView.h"
-
-#define _USE_MATH_DEFINES
-#include <math.h>
-
-namespace Ui {
-		
-	//------------------------------------------------------------------------------
-	//	Private functions
-	//------------------------------------------------------------------------------
-	
-	//------------------------------------------------------------------------------
-	//	Protected functions
-	//------------------------------------------------------------------------------
-	
-	//------------------------------------------------------------------------------
-	//	Public functions
-	//------------------------------------------------------------------------------
-	
-	//------------------------------------------------------------------------------
-	//	Constructors & Destructors
-	//------------------------------------------------------------------------------
-	//
-	//  GraphicsView::GraphicsView -- constructor
-	//
-	//  Inputs
-	//  none
-	//
-	//  Outputs
-	//  none
-	//
-	GraphicsView::GraphicsView( QWidget *parent )
-			: QGraphicsView( parent ) {
-		
-		//------------------------------------------------------------------------------
-		// configuration file
-		//------------------------------------------------------------------------------
-//			string configFilePath = qApp->applicationDirPath().toStdString() + "/../config/MainWindow.conf";
-//			Base::Config conf( configFilePath );
-		_basePtr = nullptr;
-		
-		setGeometry( QRect( 0, 0,
-		                    KeiRo::Base::Common::getMainwidgetWidth(), KeiRo::Base::Common::getMainwidgetHeight() ) );
-		setMinimumSize(QSize( KeiRo::Base::Common::getMainwidgetWidth(), KeiRo::Base::Common::getMainwidgetHeight() ) );
-		
-		_scenePtr = new QGraphicsScene;
-        _scenePtr->setSceneRect( -KeiRo::Base::Common::getMainwidgetWidth() / 2.0, -KeiRo::Base::Common::getMainwidgetHeight() / 2.0,
-                                 KeiRo::Base::Common::getMainwidgetWidth(), KeiRo::Base::Common::getMainwidgetHeight() );  // x, y, w, h
-                                 
-#ifdef DEBUG
-		cerr << "w = " << width() << ", h = " << height() << endl;
-		cerr << "mainwidget_width = " << KeiRo::Base::Common::getMainwidgetWidth() << endl;
-		cerr << "mainwidget_height = " << KeiRo::Base::Common::getMainwidgetHeight() << endl;
-		cerr << "dockwidget_width = " << KeiRo::Base::Common::getDockWidgetWidth() << endl;
-#endif // DEBUG
-		this->setScene( _scenePtr );
-	}
-	
-
-	//------------------------------------------------------------------------------
-	//	Event handlers
-	//------------------------------------------------------------------------------
-	void GraphicsView::simulateKey( Qt::Key key ) {
-
-		// press the key
-		QKeyEvent eventP( QEvent::KeyPress, key, Qt::NoModifier );
-		QApplication::sendEvent( this, &eventP );
-		// release the key
-		QKeyEvent eventR( QEvent::KeyRelease, key, Qt::NoModifier );
-		QApplication::sendEvent( this, &eventR );
-	}
-/*
-	//
-	//  GraphicsView::keyPressEvent -- key press event
-	//
-	//  Inputs
-	//  event: key event
-	//
-	//  Outputs
-	//  none
-	//
-	void GraphicsView::keyPressEvent( QKeyEvent *event )
-	{
-		switch( event->key() ) {
-
-            case Qt::Key_L: {
-                break;
-            }
-            default: {
-                // QWidget::keyPressEvent( event );
-                // QGraphicsView::keyPressEvent( event );
-                break;
-            }
-		}
-		
-		QGraphicsView::keyPressEvent( event );
-		updateSceneItems();
-	}
-	
-	//
-	//  GraphicsView::mousePressEvent -- mouse press event
-	//
-	//  Inputs
-	//  event: mouse event
-	//
-	//  Outputs
-	//  none
-	//
-	void GraphicsView::mousePressEvent( QMouseEvent *event ) {
-
-		QPointF coord = mapToScene( event->pos() );
-		// centerOn( coord.x(), coord.y() );
-		
-		//QPainterPath selectionArea;
-		double square = 10.0;
-//			_selectionArea.clear();
-//			_selectionArea.addPolygon( mapToScene(
-//					QRect( event->pos().x() - square / 2.0, event->pos().y() - square / 2.0, square, square ) ) );
-//			_selectionArea.closeSubpath();
-//
-//			_scenePtr->setSelectionArea( _selectionArea, this->rubberBandSelectionMode() ); //, viewportTransform() );
-		
-		switch( event->buttons() ) {
-		
-		case Qt::RightButton:
-			break;
-		case Qt::LeftButton:
-			break;
-		case Qt::MiddleButton:
-			break;
-		default: {
-			break;
-		}
-		}
-		
-		QGraphicsView::mousePressEvent( event );
-
-#ifdef GRAPHICSVIEW_DEBUG
-		cerr << "mouse pressing..." << endl
-			 << " x = " << event->pos().x() << " y = " << event->pos().y() << endl
-			 << " sx = " << coord.x() << " sy = " << coord.y() << endl;
-		cerr << "_right_button_pressed = " << _right_button_pressed << endl
-			 << "_left_button_pressed = " << _left_button_pressed << endl
-			 << "_middle_button_pressed = " << _middle_button_pressed << endl;
-#endif // GRAPHICSVIEW_DEBUG
-	}
-	
-	//
-	//  GraphicsView::mouseMoveEvent -- mouse move event
-	//
-	//  Inputs
-	//  event: mouse event
-	//
-	//  Outputs
-	//  none
-	//
-	void GraphicsView::mouseMoveEvent( QMouseEvent *event ) {
-//			_cursor = QPoint( event->pos().x() - Base::Common::getMainwidgetWidth() / 2,
-//			                  -( event->pos().y() - Base::Common::getMainwidgetHeight() / 2 ) );
-		double norm = QLineF( _cursor, _oldCursor ).length();
-		
-		// static int test = 0;
-		
-		if( norm > 1.0 * _min_point_distance ) {
-			simulateKey( Qt::Key_Z );
-
-#ifdef GRAPHICSVIEW_DEBUG
-			// sleep( 3 );
-			test = test+1;
-			cerr << "#######################" << endl;
-			cerr << "norm = " << norm << endl;
-			cerr << "Moving mouse ... " << endl;
-			cerr << test << ", className = " << className() << endl;
-			cerr << "_oldCursor = " << _oldCursor.x() << ", " << _oldCursor.y() << endl;
-			cerr << "_cursor = " << _cursor.x() << ", " << _cursor.y() << endl;
-			cerr << "norm = " << norm << endl;
-#endif // GRAPHICSVIEW_DEBUG
-			_oldCursor = _cursor;
-		}
-		QGraphicsView::mouseMoveEvent( event );
-	}
-	
-	//
-	//  GraphicsView::mouseReleaseEvent -- mouse release event
-	//
-	//  Inputs
-	//  event: mouse event
-	//
-	//  Outputs
-	//  none
-	//
-	void GraphicsView::mouseReleaseEvent( QMouseEvent *event ) {
-		_right_button_pressed = false;
-		_left_button_pressed = false;
-		_middle_button_pressed = false;
-		
-		QGraphicsView::mouseReleaseEvent( event );
-
-#ifdef GRAPHICSVIEW_DEBUG
-		cerr << "Releasing mouse ..." << endl;
-		cerr << "_right_button_pressed = " << _right_button_pressed << endl
-			 << "_left_button_pressed = " << _left_button_pressed << endl
-			 << "_middle_button_pressed = " << _middle_button_pressed << endl;
-#endif // GRAPHICSVIEW_DEBUG
-	}
-*/
-	
-	//
-	//  GraphicsView::exportPNG -- export png
-	//
-	//  Inputs
-	//  x, y, w, h: center, width, height
-	//
-	//  Outputs
-	//  none
-	//
-	void GraphicsView::exportPNG( double x, double y, double w, double h )
-	{
-		// Take file path and name that will create
-		//QString newPath = QFileDialog::getSaveFileName(this, trUtf8("Save SVG"),
-		//                                               path, tr("SVG files (*.svg)"));
-		static int id = 0;
-		ostringstream ss;
-		ss << setw( 8 ) << std::setfill( '0' ) << id;
-		string s2( ss.str() );
-		QString idStr = QString::fromStdString( s2 );
-		// cerr << "s2 = " << s2 << endl;
-		
-		// create tmp folder for stable treemap command
-		QString filePath = qApp->applicationDirPath() + QString( "/tmp" );
-		
-		// create the temporary folder
-		QString exportFolder = filePath + QString( "/png/" );
-		
-		if( !QDir( exportFolder ).exists() ){
-			QDir().mkdir( exportFolder );
-			cerr << "create a png folder!" << endl;
-		}
-		
-		QString newPath = exportFolder + idStr + QString( QLatin1String( ".png" ) );
-		_scenePtr->setSceneRect( x, y, w, h );  // x, y, w, h
-		
-		if( newPath.isEmpty() ) return;
-		
-		QImage screenshot( w, h, QImage::Format_RGB32 ); // maximum 32767x32767
-		
-		//int dpm = 300 / 0.0254; // ~300 DPI
-		//screenshot.setDotsPerMeterX( dpm );
-		//screenshot.setDotsPerMeterY( dpm );
-		
-		QPainter painter( &screenshot );
-		painter.setRenderHint( QPainter::Antialiasing );
-		painter.fillRect( 0, 0, w, h, Qt::white );
-		_scenePtr->render( &painter );
-		screenshot.save( newPath );
-		
-		id++;
-	}
-	
-	//
-	//  GraphicsView::exportSVG -- export svg
-	//
-	//  Inputs
-	//  x, y, w, h: center, width, height
-	//
-	//  Outputs
-	//  none
-	//
-	void GraphicsView::exportSVG( double x, double y, double w, double h ) {
-	
-//			// Take file path and name that will create
-//			//QString newPath = QFileDialog::getSaveFileName(this, trUtf8("Save SVG"),
-//			//                                               path, tr("SVG files (*.svg)"));
-//			static int id = 0;
-//			ostringstream ss;
-//			ss << setw( 8 ) << std::setfill( '0' ) << id;
-//			string s2( ss.str() );
-//			QString idStr = QString::fromStdString( s2 );
-//			// cerr << "s2 = " << s2 << endl;
-//			QString newPath =
-//					QString( QLatin1String( "../svg/pathway-" ) ) + idStr + QString( QLatin1String( ".svg" ) );
-//			_scenePtr->setSceneRect( x, y, w, h );  // x, y, w, h
-//
-//			if( newPath.isEmpty() ) return;
-//
-//			QSvgGenerator generator;            // Create a file generator object
-//			generator.setFileName( newPath );    // We set the path to the file where to save vector graphics
-//			generator.setSize(
-//					QSize( w, h ) );  // Set the dimensions of the working area of the document in millimeters
-//			generator.setViewBox( QRect( 0, 0, w, h ) ); // Set the work area in the coordinates
-//			generator.setTitle( trUtf8( "SVG Example" ) );                                // The title document
-//			generator.setDescription( trUtf8( "File created by SVG Example" ) );
-//
-//			QPainter painter;
-//			painter.begin( &generator );
-//			_scenePtr->render( &painter );
-//			painter.end();
-//
-//			id++;
-	}
-		
-} // namespace Ui
\ No newline at end of file
Index: README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># KeiRo\r\n\r\n`KeiRo` is a package for generating biological pathway diagrams, which contain the following features:\r\n\r\n- `Harmony` is a harmonized layout algorithm for biological pathways.\r\n- `Lens` is a lens technique for exploring diagrams semantically.\r\n- `Metabopolis` is a new layout algorithm for biological pathways, which has been\r\ndeveloped by [Hsiang-Yun Wu][yw], [Martin Nöllenburg][mn], and [Ivan Viola][iv],\r\nin the group [Research Unit of Computer Graphics][rucg] at [TU Wien][tuwien] in\r\nVienna, Austria. The c++ library was developed by [Hsiang-Yun Wu][yw].\r\n\r\n## How to cite?\r\n\r\n- Hsiang-Yun Wu, Martin Nöllenburg, Filipa L. Sousa, and Ivan Viola, Metabopolis:\r\n  Scalable Network Layout for Biological Pathway Diagrams in Urban Map Style, BMC\r\n  Bioinformatics, Vol. 20, No. 1, p. 187, 2019.\r\n  [[Paper][bmc-paper]] [[Video][bmc-video]]\r\n\r\n## Installing\r\n\r\n### Prerequisites\r\n\r\n- [cmake 3.10+][cmake]\r\n- [qt 5.13][qt5]\r\n- [Boost Graph Library 1.71][boost]\r\n- [libsbml 5.17][sbml]\r\n- [libSBGN 2.0][sbgn]\r\n- [Eigen3 3.3][eigen]\r\n- [CGAL 4 4.14.3][cgal]\r\n\r\n### Build\r\n\r\nClone the KeiRo repository into a directory `KeiRo`.\r\n\r\n```\r\n$ git clone KeiRo\r\n$ cd KeiRo\r\n$ mkdir build\r\n$ cd build\r\n$ cmake ../\r\n$ make\r\n```\r\n\r\n## Using KeiRo\r\n\r\n```\r\n$ ./KeiRo\r\n```\r\n\r\n### Tested environment\r\n\r\n- Ubuntu 16.04 LTS\r\n- Mac OS 10.12\r\n\r\n\r\n## Acknowledgement\r\n\r\nThe project leading to this submission has received funding from the European Union\r\nHorizon 2020 research and innovation programme under the Marie Sklodowska-Curie\r\ngrant agreement [No. 747985][msca] and from the Vienna Science and Technology Fund (WWTF)\r\nthrough project [VRG11-010][vrg11].\r\n\r\n[cmake]: https://cmake.org/\r\n[qt5]: https://www.qt.io/\r\n[boost]: https://www.boost.org/\r\n[sbml]: https://sbml.org/\r\n[sbgn]: https://github.com/fbergmann/libSBGN2/\r\n[eigen]: http://eigen.tuxfamily.org/\r\n[cgal]: https://www.cgal.org/\r\n\r\n[rucg]: https://www.cg.tuwien.ac.at/\r\n[tuwien]: https://www.tuwien.ac.at/\r\n[yw]: https://www.cg.tuwien.ac.at/staff/HsiangYunWu.html\r\n[mn]: https://www.ac.tuwien.ac.at/people/noellenburg/\r\n[iv]: https://www.cg.tuwien.ac.at/staff/IvanViola.html\r\n[msca]: https://www.cg.tuwien.ac.at/research/projects/BioNetIllustration/\r\n[vrg11]: https://www.cg.tuwien.ac.at/research/projects/illvisation/\r\n\r\n<!-- Metabopolis -->\r\n[bmc-paper]: https://doi.org/10.1016/j.visinf.2018.12.006\r\n[bmc-video]: https://www.youtube.com/watch?v=AhWCIGTxqAg\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/README.md b/README.md
--- a/README.md	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/README.md	(date 1729410604800)
@@ -1,81 +1,0 @@
-# KeiRo
-
-`KeiRo` is a package for generating biological pathway diagrams, which contain the following features:
-
-- `Harmony` is a harmonized layout algorithm for biological pathways.
-- `Lens` is a lens technique for exploring diagrams semantically.
-- `Metabopolis` is a new layout algorithm for biological pathways, which has been
-developed by [Hsiang-Yun Wu][yw], [Martin Nöllenburg][mn], and [Ivan Viola][iv],
-in the group [Research Unit of Computer Graphics][rucg] at [TU Wien][tuwien] in
-Vienna, Austria. The c++ library was developed by [Hsiang-Yun Wu][yw].
-
-## How to cite?
-
-- Hsiang-Yun Wu, Martin Nöllenburg, Filipa L. Sousa, and Ivan Viola, Metabopolis:
-  Scalable Network Layout for Biological Pathway Diagrams in Urban Map Style, BMC
-  Bioinformatics, Vol. 20, No. 1, p. 187, 2019.
-  [[Paper][bmc-paper]] [[Video][bmc-video]]
-
-## Installing
-
-### Prerequisites
-
-- [cmake 3.10+][cmake]
-- [qt 5.13][qt5]
-- [Boost Graph Library 1.71][boost]
-- [libsbml 5.17][sbml]
-- [libSBGN 2.0][sbgn]
-- [Eigen3 3.3][eigen]
-- [CGAL 4 4.14.3][cgal]
-
-### Build
-
-Clone the KeiRo repository into a directory `KeiRo`.
-
-```
-$ git clone KeiRo
-$ cd KeiRo
-$ mkdir build
-$ cd build
-$ cmake ../
-$ make
-```
-
-## Using KeiRo
-
-```
-$ ./KeiRo
-```
-
-### Tested environment
-
-- Ubuntu 16.04 LTS
-- Mac OS 10.12
-
-
-## Acknowledgement
-
-The project leading to this submission has received funding from the European Union
-Horizon 2020 research and innovation programme under the Marie Sklodowska-Curie
-grant agreement [No. 747985][msca] and from the Vienna Science and Technology Fund (WWTF)
-through project [VRG11-010][vrg11].
-
-[cmake]: https://cmake.org/
-[qt5]: https://www.qt.io/
-[boost]: https://www.boost.org/
-[sbml]: https://sbml.org/
-[sbgn]: https://github.com/fbergmann/libSBGN2/
-[eigen]: http://eigen.tuxfamily.org/
-[cgal]: https://www.cgal.org/
-
-[rucg]: https://www.cg.tuwien.ac.at/
-[tuwien]: https://www.tuwien.ac.at/
-[yw]: https://www.cg.tuwien.ac.at/staff/HsiangYunWu.html
-[mn]: https://www.ac.tuwien.ac.at/people/noellenburg/
-[iv]: https://www.cg.tuwien.ac.at/staff/IvanViola.html
-[msca]: https://www.cg.tuwien.ac.at/research/projects/BioNetIllustration/
-[vrg11]: https://www.cg.tuwien.ac.at/research/projects/illvisation/
-
-<!-- Metabopolis -->
-[bmc-paper]: https://doi.org/10.1016/j.visinf.2018.12.006
-[bmc-video]: https://www.youtube.com/watch?v=AhWCIGTxqAg
Index: UI/src/GraphicsEdgeItem.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// GraphicsEdgeItem.cpp\r\n//\t: program file for edge items\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Jun 19 02:36:37 2019\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include \"GraphicsEdgeItem.h\"\r\n\r\n\r\nnamespace Ui {\r\nnamespace Vector {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPrivate functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tProtected functions\r\n    //------------------------------------------------------------------------------\r\n\t//\r\n\t//  GraphicsEdgeItem::init -- initialization\r\n\t//\r\n\t//  Inputs\r\n\t//  none\r\n\t//\r\n\t//  Outputs\r\n\t//  none\r\n\t//\r\n\tvoid GraphicsEdgeItem::_init( void )\r\n\t{\r\n\t\tGraphicsBase::_init();\r\n\t}\r\n\t\r\n\tQVariant pathInterpolator(const QLineF &start, const QLineF &end, qreal progress )\r\n\t{\r\n//    \tcerr << \"progress = \" << progress << endl;\r\n//\t\tcerr << \"0 x = \" << end[0].x() << \" y = \" << end[0].y() << endl;\r\n//\t\tcerr << \"1 x = \" << end[1].x() << \" y = \" << end[1].y() << endl;\r\n//\t\tQLineF line;\r\n//\t\tfor( unsigned int i = 0; i < start.size(); i++ ){\r\n\t\tQPointF p1, p2;\r\n\t\t\r\n\t\tp1.setX( progress * end.p1().x() + (1.0-progress) * start.p1().x() );\r\n\t\tp1.setY( progress * end.p1().y() + (1.0-progress) * start.p1().y() );\r\n\t\tp2.setX( progress * end.p2().x() + (1.0-progress) * start.p2().x() );\r\n\t\tp2.setY( progress * end.p2().y() + (1.0-progress) * start.p2().y() );\r\n//\t\tline = QLineF( p1, p2 );\r\n//\t\t\tpoly.append( p );\r\n//\t\t}\r\n\r\n//\t\tcerr << \"size = \" << poly.size() << endl;\r\n\t\treturn  QLineF( p1, p2 );\r\n\t}\r\n\t\r\n    //------------------------------------------------------------------------------\r\n    //\tPublic functions\r\n    //------------------------------------------------------------------------------\r\n    //------------------------------------------------------------------------------\r\n    //\tConstructors & Destructors\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  GraphicsBallItem::GraphicsBallItem -- constructor\r\n    //\r\n    //  Inputs\r\n    //  parent: parent object\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    GraphicsEdgeItem::GraphicsEdgeItem( QGraphicsItem *parent )\r\n    {\r\n\t    qRegisterAnimationInterpolator< QLineF >( pathInterpolator );\r\n\t\r\n\t    //setFlag( QGraphicsItem::ItemIsSelectable );\r\n        //setFlag( QGraphicsItem::ItemIsMovable );\r\n        //setFlag( QGraphicsItem::ItemSendsGeometryChanges );\r\n        //setAcceptDrops( true );\r\n\r\n//        pen().setJoinStyle( Qt::MiterJoin );\r\n        pen().setJoinStyle( Qt::RoundJoin );\r\n\t\r\n\t    GraphicsBase::_init();\r\n    }\r\n\r\n    //\r\n    //  GraphicsEdgeItem::GraphicsEdgeItem -- copy constructor\r\n    //\r\n    //  Inputs\r\n    //  parent: parent object\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    GraphicsEdgeItem::GraphicsEdgeItem( const QLineF &line, QGraphicsItem *parent )\r\n    {\r\n        setLine( line );\r\n    }\r\n\r\n    //\r\n    //  GraphicsEdgeItem::boundingRect -- find bounding box\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  reference to the bounding box\r\n    //\r\n//    QRectF GraphicsEdgeItem::boundingRect( void ) const\r\n//    {\r\n//        return line().controlPointRect();\r\n//    }\r\n\r\n    //\r\n    //  GraphicsEdgeItem::paint -- paint the object\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void GraphicsEdgeItem::paint( QPainter *painter, const QStyleOptionGraphicsItem *option,\r\n                                  QWidget *widget )\r\n    {\r\n        // draw boundary\r\n        painter->setRenderHints( QPainter::Antialiasing );\r\n        painter->setPen( pen() );\r\n//        painter->setBrush( brush() );\r\n//        painter->drawPath( path() );\r\n        painter->drawLine( line() );\r\n\r\n        // draw text\r\n//        if( _textOn == true ){\r\n//            painter->setPen( _textpen );\r\n//            painter->setFont( _font );\r\n//            painter->drawText( path().boundingRect().x()+0.5*( path().boundingRect().width() ),\r\n//                               path().boundingRect().y()+0.5*( path().boundingRect().height() ),\r\n//                               _text );\r\n//        }\r\n\r\n        //cerr << \"paint x = \" << pos().x() << \" y = \" << pos().y() << endl;\r\n\r\n        // Qt function\r\n        //if ( option->state & QStyle::State_Selected )\r\n        //\tqt_graphicsItem_highlightSelected( this, painter, option );\r\n    }\r\n\r\n    //\r\n    //  GraphicsEdgeItem::paint -- find the object type\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  reference to the object type\r\n    //\r\n    int GraphicsEdgeItem::type( void ) const\r\n    {\r\n        return 0; // GRAPHICS_EDGE+QGraphicsItem::UserType;\r\n    }\r\n\r\n\r\n} // namespace Vector\r\n} // namespace Ui
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/UI/src/GraphicsEdgeItem.cpp b/UI/src/GraphicsEdgeItem.cpp
--- a/UI/src/GraphicsEdgeItem.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/UI/src/GraphicsEdgeItem.cpp	(date 1729410604810)
@@ -1,172 +1,0 @@
-//******************************************************************************
-// GraphicsEdgeItem.cpp
-//	: program file for edge items
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Jun 19 02:36:37 2019
-//
-//******************************************************************************
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include "GraphicsEdgeItem.h"
-
-
-namespace Ui {
-namespace Vector {
-
-    //------------------------------------------------------------------------------
-    //	Private functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Protected functions
-    //------------------------------------------------------------------------------
-	//
-	//  GraphicsEdgeItem::init -- initialization
-	//
-	//  Inputs
-	//  none
-	//
-	//  Outputs
-	//  none
-	//
-	void GraphicsEdgeItem::_init( void )
-	{
-		GraphicsBase::_init();
-	}
-	
-	QVariant pathInterpolator(const QLineF &start, const QLineF &end, qreal progress )
-	{
-//    	cerr << "progress = " << progress << endl;
-//		cerr << "0 x = " << end[0].x() << " y = " << end[0].y() << endl;
-//		cerr << "1 x = " << end[1].x() << " y = " << end[1].y() << endl;
-//		QLineF line;
-//		for( unsigned int i = 0; i < start.size(); i++ ){
-		QPointF p1, p2;
-		
-		p1.setX( progress * end.p1().x() + (1.0-progress) * start.p1().x() );
-		p1.setY( progress * end.p1().y() + (1.0-progress) * start.p1().y() );
-		p2.setX( progress * end.p2().x() + (1.0-progress) * start.p2().x() );
-		p2.setY( progress * end.p2().y() + (1.0-progress) * start.p2().y() );
-//		line = QLineF( p1, p2 );
-//			poly.append( p );
-//		}
-
-//		cerr << "size = " << poly.size() << endl;
-		return  QLineF( p1, p2 );
-	}
-	
-    //------------------------------------------------------------------------------
-    //	Public functions
-    //------------------------------------------------------------------------------
-    //------------------------------------------------------------------------------
-    //	Constructors & Destructors
-    //------------------------------------------------------------------------------
-    //
-    //  GraphicsBallItem::GraphicsBallItem -- constructor
-    //
-    //  Inputs
-    //  parent: parent object
-    //
-    //  Outputs
-    //  none
-    //
-    GraphicsEdgeItem::GraphicsEdgeItem( QGraphicsItem *parent )
-    {
-	    qRegisterAnimationInterpolator< QLineF >( pathInterpolator );
-	
-	    //setFlag( QGraphicsItem::ItemIsSelectable );
-        //setFlag( QGraphicsItem::ItemIsMovable );
-        //setFlag( QGraphicsItem::ItemSendsGeometryChanges );
-        //setAcceptDrops( true );
-
-//        pen().setJoinStyle( Qt::MiterJoin );
-        pen().setJoinStyle( Qt::RoundJoin );
-	
-	    GraphicsBase::_init();
-    }
-
-    //
-    //  GraphicsEdgeItem::GraphicsEdgeItem -- copy constructor
-    //
-    //  Inputs
-    //  parent: parent object
-    //
-    //  Outputs
-    //  none
-    //
-    GraphicsEdgeItem::GraphicsEdgeItem( const QLineF &line, QGraphicsItem *parent )
-    {
-        setLine( line );
-    }
-
-    //
-    //  GraphicsEdgeItem::boundingRect -- find bounding box
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  reference to the bounding box
-    //
-//    QRectF GraphicsEdgeItem::boundingRect( void ) const
-//    {
-//        return line().controlPointRect();
-//    }
-
-    //
-    //  GraphicsEdgeItem::paint -- paint the object
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    //
-    void GraphicsEdgeItem::paint( QPainter *painter, const QStyleOptionGraphicsItem *option,
-                                  QWidget *widget )
-    {
-        // draw boundary
-        painter->setRenderHints( QPainter::Antialiasing );
-        painter->setPen( pen() );
-//        painter->setBrush( brush() );
-//        painter->drawPath( path() );
-        painter->drawLine( line() );
-
-        // draw text
-//        if( _textOn == true ){
-//            painter->setPen( _textpen );
-//            painter->setFont( _font );
-//            painter->drawText( path().boundingRect().x()+0.5*( path().boundingRect().width() ),
-//                               path().boundingRect().y()+0.5*( path().boundingRect().height() ),
-//                               _text );
-//        }
-
-        //cerr << "paint x = " << pos().x() << " y = " << pos().y() << endl;
-
-        // Qt function
-        //if ( option->state & QStyle::State_Selected )
-        //	qt_graphicsItem_highlightSelected( this, painter, option );
-    }
-
-    //
-    //  GraphicsEdgeItem::paint -- find the object type
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  reference to the object type
-    //
-    int GraphicsEdgeItem::type( void ) const
-    {
-        return 0; // GRAPHICS_EDGE+QGraphicsItem::UserType;
-    }
-
-
-} // namespace Vector
-} // namespace Ui
\ No newline at end of file
Index: UI/src/GraphicsPathItem.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// GraphicsEdgeItem.cpp\r\n//\t: program file for edge items\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Jun 19 02:36:37 2019\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include \"GraphicsPathItem.h\"\r\n\r\n\r\nnamespace Ui {\r\nnamespace Vector {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPrivate functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tProtected functions\r\n    //------------------------------------------------------------------------------\r\n\t//\r\n\t//  GraphicsEdgeItem::init -- initialization\r\n\t//\r\n\t//  Inputs\r\n\t//  none\r\n\t//\r\n\t//  Outputs\r\n\t//  none\r\n\t//\r\n\tvoid GraphicsPathItem::_init( void )\r\n\t{\r\n\t\tGraphicsBase::_init();\r\n\t}\r\n\t\r\n\t\r\n    //------------------------------------------------------------------------------\r\n    //\tPublic functions\r\n    //------------------------------------------------------------------------------\r\n    //------------------------------------------------------------------------------\r\n    //\tConstructors & Destructors\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  GraphicsBallItem::GraphicsBallItem -- constructor\r\n    //\r\n    //  Inputs\r\n    //  parent: parent object\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    GraphicsPathItem::GraphicsPathItem( QGraphicsItem *parent )\r\n    {\r\n\t    //setFlag( QGraphicsItem::ItemIsSelectable );\r\n        //setFlag( QGraphicsItem::ItemIsMovable );\r\n        //setFlag( QGraphicsItem::ItemSendsGeometryChanges );\r\n        //setAcceptDrops( true );\r\n\r\n        //pen().setJoinStyle( Qt::MiterJoin );\r\n        pen().setJoinStyle( Qt::RoundJoin );\r\n\t\r\n\t    GraphicsBase::_init();\r\n    }\r\n\r\n    //\r\n    //  GraphicsEdgeItem::GraphicsEdgeItem -- copy constructor\r\n    //\r\n    //  Inputs\r\n    //  parent: parent object\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    GraphicsPathItem::GraphicsPathItem( const QPainterPath &path, QGraphicsItem *parent )\r\n    {\r\n        if ( !path.isEmpty() ) setPath( path );\r\n    }\r\n\r\n    //\r\n    //  GraphicsEdgeItem::boundingRect -- find bounding box\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  reference to the bounding box\r\n    //\r\n    QRectF GraphicsPathItem::boundingRect( void ) const\r\n    {\r\n        return path().controlPointRect();\r\n    }\r\n\r\n    //\r\n    //  GraphicsEdgeItem::paint -- paint the object\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void GraphicsPathItem::paint( QPainter *painter, const QStyleOptionGraphicsItem *option,\r\n                                  QWidget *widget )\r\n    {\r\n        // draw boundary\r\n        painter->setRenderHints( QPainter::Antialiasing );\r\n        painter->setPen( pen() );\r\n        painter->setBrush( brush() );\r\n        painter->drawPath( path() );\r\n\r\n        // draw text\r\n        if( _textOn == true ){\r\n            painter->setPen( _textpen );\r\n            painter->setFont( _font );\r\n            painter->drawText( path().boundingRect().x()+0.5*( path().boundingRect().width() ),\r\n                               path().boundingRect().y()+0.5*( path().boundingRect().height() ),\r\n                               _text );\r\n        }\r\n\r\n        //cerr << \"paint x = \" << pos().x() << \" y = \" << pos().y() << endl;\r\n\r\n        // Qt function\r\n        //if ( option->state & QStyle::State_Selected )\r\n        //\tqt_graphicsItem_highlightSelected( this, painter, option );\r\n    }\r\n\r\n    //\r\n    //  GraphicsEdgeItem::paint -- find the object type\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  reference to the object type\r\n    //\r\n    int GraphicsPathItem::type( void ) const\r\n    {\r\n        return 0; // GRAPHICS_EDGE+QGraphicsItem::UserType;\r\n    }\r\n\r\n\r\n} // namespace Vector\r\n} // namespace Ui
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/UI/src/GraphicsPathItem.cpp b/UI/src/GraphicsPathItem.cpp
--- a/UI/src/GraphicsPathItem.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/UI/src/GraphicsPathItem.cpp	(date 1729410604830)
@@ -1,149 +1,0 @@
-//******************************************************************************
-// GraphicsEdgeItem.cpp
-//	: program file for edge items
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Jun 19 02:36:37 2019
-//
-//******************************************************************************
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include "GraphicsPathItem.h"
-
-
-namespace Ui {
-namespace Vector {
-
-    //------------------------------------------------------------------------------
-    //	Private functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Protected functions
-    //------------------------------------------------------------------------------
-	//
-	//  GraphicsEdgeItem::init -- initialization
-	//
-	//  Inputs
-	//  none
-	//
-	//  Outputs
-	//  none
-	//
-	void GraphicsPathItem::_init( void )
-	{
-		GraphicsBase::_init();
-	}
-	
-	
-    //------------------------------------------------------------------------------
-    //	Public functions
-    //------------------------------------------------------------------------------
-    //------------------------------------------------------------------------------
-    //	Constructors & Destructors
-    //------------------------------------------------------------------------------
-    //
-    //  GraphicsBallItem::GraphicsBallItem -- constructor
-    //
-    //  Inputs
-    //  parent: parent object
-    //
-    //  Outputs
-    //  none
-    //
-    GraphicsPathItem::GraphicsPathItem( QGraphicsItem *parent )
-    {
-	    //setFlag( QGraphicsItem::ItemIsSelectable );
-        //setFlag( QGraphicsItem::ItemIsMovable );
-        //setFlag( QGraphicsItem::ItemSendsGeometryChanges );
-        //setAcceptDrops( true );
-
-        //pen().setJoinStyle( Qt::MiterJoin );
-        pen().setJoinStyle( Qt::RoundJoin );
-	
-	    GraphicsBase::_init();
-    }
-
-    //
-    //  GraphicsEdgeItem::GraphicsEdgeItem -- copy constructor
-    //
-    //  Inputs
-    //  parent: parent object
-    //
-    //  Outputs
-    //  none
-    //
-    GraphicsPathItem::GraphicsPathItem( const QPainterPath &path, QGraphicsItem *parent )
-    {
-        if ( !path.isEmpty() ) setPath( path );
-    }
-
-    //
-    //  GraphicsEdgeItem::boundingRect -- find bounding box
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  reference to the bounding box
-    //
-    QRectF GraphicsPathItem::boundingRect( void ) const
-    {
-        return path().controlPointRect();
-    }
-
-    //
-    //  GraphicsEdgeItem::paint -- paint the object
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    //
-    void GraphicsPathItem::paint( QPainter *painter, const QStyleOptionGraphicsItem *option,
-                                  QWidget *widget )
-    {
-        // draw boundary
-        painter->setRenderHints( QPainter::Antialiasing );
-        painter->setPen( pen() );
-        painter->setBrush( brush() );
-        painter->drawPath( path() );
-
-        // draw text
-        if( _textOn == true ){
-            painter->setPen( _textpen );
-            painter->setFont( _font );
-            painter->drawText( path().boundingRect().x()+0.5*( path().boundingRect().width() ),
-                               path().boundingRect().y()+0.5*( path().boundingRect().height() ),
-                               _text );
-        }
-
-        //cerr << "paint x = " << pos().x() << " y = " << pos().y() << endl;
-
-        // Qt function
-        //if ( option->state & QStyle::State_Selected )
-        //	qt_graphicsItem_highlightSelected( this, painter, option );
-    }
-
-    //
-    //  GraphicsEdgeItem::paint -- find the object type
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  reference to the object type
-    //
-    int GraphicsPathItem::type( void ) const
-    {
-        return 0; // GRAPHICS_EDGE+QGraphicsItem::UserType;
-    }
-
-
-} // namespace Vector
-} // namespace Ui
\ No newline at end of file
Index: download.sh
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>git clone ssh://eyeviz/Users/yun/gitroot/tools/Harmony.git\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/download.sh b/download.sh
--- a/download.sh	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/download.sh	(date 1729410604840)
@@ -1,1 +1,0 @@
-git clone ssh://eyeviz/Users/yun/gitroot/tools/Harmony.git
Index: UI/src/GraphicsVertexItem.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// GraphicsVertexItem.cpp\r\n//\t: program file for vertex items\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Jun 19 02:36:37 2019\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include \"GraphicsVertexItem.h\"\r\n\r\nnamespace Ui {\r\nnamespace Vector {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPrivate functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tProtected functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  GraphicsVertexItem::init -- initialization\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void GraphicsVertexItem::_init( void ) {\r\n\t\r\n\t    GraphicsBase::_init();\r\n\t    _radius = 10;\r\n\t    _isSimple = false;\r\n    }\r\n    \r\n    //------------------------------------------------------------------------------\r\n    //\tPublic functions\r\n    //------------------------------------------------------------------------------\r\n    //------------------------------------------------------------------------------\r\n    //\tConstructors & Destructors\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  GraphicsVertexItem::GraphicsVertexItem -- constructor\r\n    //\r\n    //  Inputs\r\n    //  parent: parent object\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    GraphicsVertexItem::GraphicsVertexItem( QGraphicsItem *parent )\r\n    {\r\n        //setFlag( QGraphicsItem::ItemIsSelectable );\r\n        //setFlag( QGraphicsItem::ItemIsMovable );\r\n        //setFlag( QGraphicsItem::ItemSendsGeometryChanges );\r\n        //setAcceptDrops( true );\r\n\r\n\t    _init();\r\n    }\r\n\r\n    //\r\n    //  GraphicsVertexItem::GraphicsVertexItem -- parameterized constructor\r\n    //\r\n    //  Inputs\r\n    //  parent: parent object\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    GraphicsVertexItem::GraphicsVertexItem( qreal x, qreal y, qreal w, qreal h, QGraphicsItem *parent )\r\n    {\r\n        setRect( QRectF( x, y, w, h ) );\r\n    }\r\n\r\n    //\r\n    //  GraphicsVertexItem::GraphicsVertexItem -- copy constructor\r\n    //\r\n    //  Inputs\r\n    //  parent: parent object\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    GraphicsVertexItem::GraphicsVertexItem( const QRectF &rect, QGraphicsItem *parent )\r\n    {\r\n        setRect( rect );\r\n    }\r\n    \r\n\r\n    //\r\n    //  GraphicsVertexItem::boundingRect -- find bounding box\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  reference to the bounding box\r\n    //\r\n    QRectF GraphicsVertexItem::boundingRect( void ) const\r\n    {\r\n        return rect();\r\n    }\r\n\r\n    //\r\n    //  GraphicsVertexItem::paint -- paint the object\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void GraphicsVertexItem::paint( QPainter *painter, const QStyleOptionGraphicsItem *option,\r\n                                    QWidget *widget )\r\n    {\r\n\t    painter->setRenderHints( QPainter::Antialiasing );\r\n\t    painter->setPen( pen() );\r\n\t    painter->setBrush( brush() );\r\n\r\n\t    QRectF fineRect( rect() );\r\n    \tQFontMetrics fm( _font );\r\n\t    double sx = fm.width( _text );\r\n\t    double sy = 0.5*fm.height();\r\n\t    \r\n    \tif( _isSimple == true ){\r\n\t\t\r\n\t\t    double sx = _radius, sy = _radius;\r\n\t\t\r\n\t\t    fineRect.setX( rect().x() - 0.5 * sx );\r\n\t\t    fineRect.setY( rect().y() - 0.5 * sy );\r\n//\t\t    fineRect.setX( rect().x() - 0.5 * sx );\r\n//\t\t    fineRect.setY( rect().y() - 0.5 * sy );\r\n\t\t    fineRect.setWidth( sx );\r\n\t\t    fineRect.setHeight( sy );\r\n\t\t    _sourceRect = fineRect;\r\n\t\t    painter->drawEllipse( _sourceRect );\r\n    \t}\r\n    \telse{\r\n\r\n\t\t    fineRect.setX( rect().x() );\r\n\t\t    fineRect.setY( rect().y() );\r\n\t\t    fineRect.setWidth( rect().width() );\r\n\t\t    fineRect.setHeight( rect().height() );\r\n\t\t    _sourceRect = fineRect;\r\n    \t\t\r\n\t\t    painter->drawRoundedRect( _sourceRect, _radius, _radius, Qt::AbsoluteSize );\r\n    \t}\r\n    \t\r\n        if( _textOn == true ) {\r\n\t        \r\n\t        painter->setFont( _font );\r\n\t        painter->setPen( _textpen );\r\n\t        painter->drawText(\r\n\t\t\t        _sourceRect.x() + 0.5 * _sourceRect.width() - 0.5 * sx,\r\n\t\t\t        _sourceRect.y() + 0.5 * _sourceRect.height() + 0.5 * sy,\r\n\t\t\t        _text\r\n\t        );\r\n        }\r\n\r\n        // Qt function\r\n        //if ( option->state & QStyle::State_Selected )\r\n        //\tqt_graphicsItem_highlightSelected( this, painter, option );\r\n        // cerr << \"painting ball...\" << endl;\r\n    }\r\n\r\n    //\r\n    //  GraphicsVertexItem::type -- find type\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  reference to the type of the object\r\n    //\r\n    int GraphicsVertexItem::type( void ) const\r\n    {\r\n        return 0; //GRAPHICS_VERTEX+QGraphicsItem::UserType;\r\n    }\r\n\r\n} // namespace Vector\r\n} // namespace Ui
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/UI/src/GraphicsVertexItem.cpp b/UI/src/GraphicsVertexItem.cpp
--- a/UI/src/GraphicsVertexItem.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/UI/src/GraphicsVertexItem.cpp	(date 1729410604850)
@@ -1,188 +1,0 @@
-//******************************************************************************
-// GraphicsVertexItem.cpp
-//	: program file for vertex items
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Jun 19 02:36:37 2019
-//
-//******************************************************************************
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include "GraphicsVertexItem.h"
-
-namespace Ui {
-namespace Vector {
-
-    //------------------------------------------------------------------------------
-    //	Private functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Protected functions
-    //------------------------------------------------------------------------------
-    //
-    //  GraphicsVertexItem::init -- initialization
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    //
-    void GraphicsVertexItem::_init( void ) {
-	
-	    GraphicsBase::_init();
-	    _radius = 10;
-	    _isSimple = false;
-    }
-    
-    //------------------------------------------------------------------------------
-    //	Public functions
-    //------------------------------------------------------------------------------
-    //------------------------------------------------------------------------------
-    //	Constructors & Destructors
-    //------------------------------------------------------------------------------
-    //
-    //  GraphicsVertexItem::GraphicsVertexItem -- constructor
-    //
-    //  Inputs
-    //  parent: parent object
-    //
-    //  Outputs
-    //  none
-    //
-    GraphicsVertexItem::GraphicsVertexItem( QGraphicsItem *parent )
-    {
-        //setFlag( QGraphicsItem::ItemIsSelectable );
-        //setFlag( QGraphicsItem::ItemIsMovable );
-        //setFlag( QGraphicsItem::ItemSendsGeometryChanges );
-        //setAcceptDrops( true );
-
-	    _init();
-    }
-
-    //
-    //  GraphicsVertexItem::GraphicsVertexItem -- parameterized constructor
-    //
-    //  Inputs
-    //  parent: parent object
-    //
-    //  Outputs
-    //  none
-    //
-    GraphicsVertexItem::GraphicsVertexItem( qreal x, qreal y, qreal w, qreal h, QGraphicsItem *parent )
-    {
-        setRect( QRectF( x, y, w, h ) );
-    }
-
-    //
-    //  GraphicsVertexItem::GraphicsVertexItem -- copy constructor
-    //
-    //  Inputs
-    //  parent: parent object
-    //
-    //  Outputs
-    //  none
-    //
-    GraphicsVertexItem::GraphicsVertexItem( const QRectF &rect, QGraphicsItem *parent )
-    {
-        setRect( rect );
-    }
-    
-
-    //
-    //  GraphicsVertexItem::boundingRect -- find bounding box
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  reference to the bounding box
-    //
-    QRectF GraphicsVertexItem::boundingRect( void ) const
-    {
-        return rect();
-    }
-
-    //
-    //  GraphicsVertexItem::paint -- paint the object
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    //
-    void GraphicsVertexItem::paint( QPainter *painter, const QStyleOptionGraphicsItem *option,
-                                    QWidget *widget )
-    {
-	    painter->setRenderHints( QPainter::Antialiasing );
-	    painter->setPen( pen() );
-	    painter->setBrush( brush() );
-
-	    QRectF fineRect( rect() );
-    	QFontMetrics fm( _font );
-	    double sx = fm.width( _text );
-	    double sy = 0.5*fm.height();
-	    
-    	if( _isSimple == true ){
-		
-		    double sx = _radius, sy = _radius;
-		
-		    fineRect.setX( rect().x() - 0.5 * sx );
-		    fineRect.setY( rect().y() - 0.5 * sy );
-//		    fineRect.setX( rect().x() - 0.5 * sx );
-//		    fineRect.setY( rect().y() - 0.5 * sy );
-		    fineRect.setWidth( sx );
-		    fineRect.setHeight( sy );
-		    _sourceRect = fineRect;
-		    painter->drawEllipse( _sourceRect );
-    	}
-    	else{
-
-		    fineRect.setX( rect().x() );
-		    fineRect.setY( rect().y() );
-		    fineRect.setWidth( rect().width() );
-		    fineRect.setHeight( rect().height() );
-		    _sourceRect = fineRect;
-    		
-		    painter->drawRoundedRect( _sourceRect, _radius, _radius, Qt::AbsoluteSize );
-    	}
-    	
-        if( _textOn == true ) {
-	        
-	        painter->setFont( _font );
-	        painter->setPen( _textpen );
-	        painter->drawText(
-			        _sourceRect.x() + 0.5 * _sourceRect.width() - 0.5 * sx,
-			        _sourceRect.y() + 0.5 * _sourceRect.height() + 0.5 * sy,
-			        _text
-	        );
-        }
-
-        // Qt function
-        //if ( option->state & QStyle::State_Selected )
-        //	qt_graphicsItem_highlightSelected( this, painter, option );
-        // cerr << "painting ball..." << endl;
-    }
-
-    //
-    //  GraphicsVertexItem::type -- find type
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  reference to the type of the object
-    //
-    int GraphicsVertexItem::type( void ) const
-    {
-        return 0; //GRAPHICS_VERTEX+QGraphicsItem::UserType;
-    }
-
-} // namespace Vector
-} // namespace Ui
\ No newline at end of file
Index: UI/src/GraphicsBase.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// GraphicsBase.h\r\n//\t: header file for base items\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: The Dec 20 10:48:37 2020\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include \"GraphicsBase.h\"\r\n\r\nnamespace Ui {\r\nnamespace Vector {\r\n\t//------------------------------------------------------------------------------\r\n\t//\tPrivate functions\r\n\t//------------------------------------------------------------------------------\r\n\t\r\n\t//------------------------------------------------------------------------------\r\n\t//\tProtected functions\r\n\t//------------------------------------------------------------------------------\r\n\t//\r\n\t//  GraphicsBase::_init -- initialization\r\n\t//\r\n\t//  Inputs\r\n\t//  none\r\n\t//\r\n\t//  Outputs\r\n\t//  none\r\n\t//\r\n\tvoid GraphicsBase::_init( void ) {\r\n\r\n\t\t_id             = 0;\r\n\t\t_weight         = 1.0;\r\n\t\t_name           = \"NULL\";\r\n\r\n\t\t_text           = \"NULL\";\r\n\t\t_textOn         = false;\r\n\t\t_font           = QFont( \"Arial\", 12, QFont::Normal, false );\r\n\t\t_textpen        = QPen( QColor( 100, 100, 100, 255 ), 3 );\r\n\t}\r\n\t\r\n\t//------------------------------------------------------------------------------\r\n\t//\tPublic functions\r\n\t//------------------------------------------------------------------------------\r\n\t//------------------------------------------------------------------------------\r\n\t//\tConstructors & Destructors\r\n\t//------------------------------------------------------------------------------\r\n\t//\r\n\t//  GraphicsBase::GraphicsBase -- copy constructor\r\n\t//\r\n\t//  Inputs\r\n\t//  parent: parent object\r\n\t//\r\n\t//  Outputs\r\n\t//  none\r\n\t//\r\n\tGraphicsBase::GraphicsBase( GraphicsBase &o ) {\r\n\t\t\r\n\t\t_id             = o._id;\r\n\t\t_weight         = o._weight;\r\n\t\t_name           = o._name;\r\n\r\n\t\t_text           = o._text;\r\n\t\t_textOn         = o._textOn;\r\n\t\t_font           = o._font;\r\n\t\t_textpen        = o._textpen;\r\n\t}\r\n\t\r\n}\r\n} // namespace Ui\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/UI/src/GraphicsBase.cpp b/UI/src/GraphicsBase.cpp
--- a/UI/src/GraphicsBase.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/UI/src/GraphicsBase.cpp	(date 1729410604860)
@@ -1,75 +1,0 @@
-//******************************************************************************
-// GraphicsBase.h
-//	: header file for base items
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: The Dec 20 10:48:37 2020
-//
-//******************************************************************************
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include "GraphicsBase.h"
-
-namespace Ui {
-namespace Vector {
-	//------------------------------------------------------------------------------
-	//	Private functions
-	//------------------------------------------------------------------------------
-	
-	//------------------------------------------------------------------------------
-	//	Protected functions
-	//------------------------------------------------------------------------------
-	//
-	//  GraphicsBase::_init -- initialization
-	//
-	//  Inputs
-	//  none
-	//
-	//  Outputs
-	//  none
-	//
-	void GraphicsBase::_init( void ) {
-
-		_id             = 0;
-		_weight         = 1.0;
-		_name           = "NULL";
-
-		_text           = "NULL";
-		_textOn         = false;
-		_font           = QFont( "Arial", 12, QFont::Normal, false );
-		_textpen        = QPen( QColor( 100, 100, 100, 255 ), 3 );
-	}
-	
-	//------------------------------------------------------------------------------
-	//	Public functions
-	//------------------------------------------------------------------------------
-	//------------------------------------------------------------------------------
-	//	Constructors & Destructors
-	//------------------------------------------------------------------------------
-	//
-	//  GraphicsBase::GraphicsBase -- copy constructor
-	//
-	//  Inputs
-	//  parent: parent object
-	//
-	//  Outputs
-	//  none
-	//
-	GraphicsBase::GraphicsBase( GraphicsBase &o ) {
-		
-		_id             = o._id;
-		_weight         = o._weight;
-		_name           = o._name;
-
-		_text           = o._text;
-		_textOn         = o._textOn;
-		_font           = o._font;
-		_textpen        = o._textpen;
-	}
-	
-}
-} // namespace Ui
Index: UI/src/MainWindow.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// MainWindow.cpp\r\n//\t: program file for main window\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Jun 19 02:36:37 2019\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n\r\n#include \"MainWindow.h\"\r\n\r\nnamespace Ui {\r\n\t\r\n\t//------------------------------------------------------------------------------\r\n    //\tPrivate functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  MainWindow::_createActions -- create actions\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void MainWindow::_createActions()\r\n    {\r\n        QMenu *fileMenu = menuBar()->addMenu(tr(\"&File\"));\r\n\r\n        // tool box setting\r\n        QToolBar *fileToolBar = addToolBar(tr(\"File\"));\r\n        fileToolBar->setIconSize(QSize(25, 25));\r\n        fileToolBar->setFixedHeight(50);\r\n\t\r\n\t    //------------------------------------------------------------------------------\r\n\t    //\ttool box\r\n\t    //------------------------------------------------------------------------------\r\n\t    const QIcon newIcon = QIcon::fromTheme(\"\", QIcon(\":/icons/app.png\"));\r\n        QAction *newFileAct = new QAction(newIcon, tr(\"&Open\"), this );\r\n        newFileAct->setShortcuts( QKeySequence::New) ;\r\n        newFileAct->setStatusTip(tr(\"Open a new file\"));\r\n        connect( newFileAct, &QAction::triggered, this, &MainWindow::newFile );\r\n        fileMenu->addAction( newFileAct );\r\n        fileToolBar->addAction( newFileAct );\r\n\r\n#ifdef SKIP\r\n        const QIcon saveIcon = QIcon::fromTheme(\"\", QIcon(\":/icons/save.png\"));\r\n        //const QIcon saveIcon = QIcon::fromTheme(\"document-save\", QIcon(\":/icons/save.png\"));\r\n        QAction *saveAct = new QAction( saveIcon, tr(\"&Save...\"), this );\r\n        saveAct->setShortcuts( QKeySequence::Save);\r\n        saveAct->setStatusTip(tr(\"Save the current form letter\") );\r\n        connect( saveAct, &QAction::triggered, this, &MainWindow::save );\r\n        fileMenu->addAction( saveAct );\r\n        fileToolBar->addAction( saveAct );\r\n\r\n        const QIcon printIcon = QIcon::fromTheme( \"\", QIcon(\":/icons/print.png\") );\r\n        //const QIcon printIcon = QIcon::fromTheme(\"document-print\", QIcon(\":/icons/print.png\"));\r\n        QAction *printAct = new QAction(printIcon, tr(\"&Print...\"), this);\r\n        printAct->setShortcuts(QKeySequence::Print);\r\n        printAct->setStatusTip(tr(\"Print the current form letter\") );\r\n        connect( printAct, &QAction::triggered, this, &MainWindow::print);\r\n        fileMenu->addAction( printAct );\r\n        fileToolBar->addAction( printAct );\r\n#endif // SKIP\r\n\r\n\t    //------------------------------------------------------------------------------\r\n\t    //\tfile menu\r\n\t    //------------------------------------------------------------------------------\r\n\r\n        fileMenu->addSeparator();\r\n\r\n        QAction *quitAct = fileMenu->addAction( tr(\"&Quit\"), this, &QWidget::close );\r\n        quitAct->setShortcuts(QKeySequence::Quit);\r\n        quitAct->setStatusTip(tr(\"Quit the application\"));\r\n\r\n        QMenu *editMenu = menuBar()->addMenu(tr(\"&Edit\"));\r\n        QToolBar *editToolBar = addToolBar(tr(\"Edit\"));\r\n        editToolBar->setIconSize(QSize(25, 25));\r\n        editToolBar->setFixedHeight(50);\r\n\r\n#ifdef SKIP\r\n        const QIcon undoIcon = QIcon::fromTheme(\"\", QIcon(\":/icons/undo.png\"));\r\n        //const QIcon undoIcon = QIcon::fromTheme(\"edit-undo\", QIcon(\":/icons/undo.png\"));\r\n        QAction *undoAct = new QAction(undoIcon, tr(\"&Undo\"), this);\r\n        undoAct->setShortcuts(QKeySequence::Undo);\r\n        undoAct->setStatusTip(tr(\"Undo the last editing action\"));\r\n        connect(undoAct, &QAction::triggered, this, &MainWindow::undo);\r\n        editMenu->addAction(undoAct);\r\n        editToolBar->addAction(undoAct);\r\n#endif // SKIP\r\n        \r\n        menuBar()->addSeparator();\r\n\r\n        _viewMenu = menuBar()->addMenu(tr(\"&View\"));\r\n        menuBar()->addSeparator();\r\n\r\n        QMenu *helpMenu = menuBar()->addMenu(tr(\"&Help\"));\r\n\r\n        QAction *aboutAct = helpMenu->addAction(tr(\"&About\"), this, &MainWindow::about );\r\n        aboutAct->setStatusTip(tr(\"Show the application's About box\"));\r\n\r\n        QAction *aboutQtAct = helpMenu->addAction(tr(\"About &Qt\"), qApp, &QApplication::aboutQt );\r\n        aboutQtAct->setStatusTip(tr(\"Show the Qt library's About box\"));\r\n\t\t\r\n\t\tconnect( _mainGV, SIGNAL( dataInitialized() ), this, SLOT( _initAllDocks() ) );\r\n        connect( _mainGV, SIGNAL( dataChanged() ), this, SLOT( _updateAllDocks() ) );\r\n    }\r\n\r\n    //\r\n    //  MainWindow::_createStatusBar -- create status bar\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none-'['-]\r\n    //\r\n    void MainWindow::_createStatusBar()\r\n    {\r\n        statusBar()->showMessage(tr(\"Ready\"));\r\n    }\r\n\r\n    //\r\n    //  MainWindow::_createDockWindows -- create dock windows\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n//    void MainWindow::_createDockWindows( void )\r\n//    {\r\n//\t    _settingsDock = new QDockWidget(tr(\"Setting\"), this );\r\n//        _settingsDock->setAllowedAreas( Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);\r\n//\r\n//\t    _setting = new QWidget( _settingsDock );\r\n//        _setting->setGeometry( QRect(0,0,KeiRo::Base::Common::getDockWidgetWidth(),\r\n//\t\t\t\t\t\t\t\t\t KeiRo::Base::Common::getMainwidgetHeight()/2.0 ) );\r\n//        _setting->setMinimumSize( QSize( KeiRo::Base::Common::getDockWidgetWidth(),\r\n//\t\t\t\t\t\t\t\t\t\t KeiRo::Base::Common::getMainwidgetHeight()/3.0 ) );\r\n////\t    _setting->setMaximumSize( QSize( KeiRo::Base::Common::getDockWidgetWidth(),\r\n////\t                                     KeiRo::Base::Common::getMainwidgetHeight()/3.0 ) );\r\n////        _setting->setMouseTracking( false );\r\n//        _settingsDock->setWidget( _setting );\r\n//        addDockWidget(Qt::RightDockWidgetArea, _settingsDock );\r\n//        _viewMenu->addAction(_settingsDock->toggleViewAction() );\r\n//\r\n//\r\n//\t    _interactionDock = new QDockWidget(tr(\"Interaction\"), this );\r\n//\t    _interactionDock->setAllowedAreas( Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);\r\n//\r\n//        _interaction = new QWidget( _interactionDock );\r\n//        _interaction->setGeometry( QRect(0,0,KeiRo::Base::Common::getDockWidgetWidth(),\r\n//\t\t\t\t\t\t\t\t\t\t KeiRo::Base::Common::getDockWidgetWidth()*KeiRo::Base::Common::getMainwidgetHeight()/KeiRo::Base::Common::getMainwidgetWidth() ) );\r\n//        _interaction->setMinimumSize( QSize( KeiRo::Base::Common::getDockWidgetWidth(),\r\n//\t\t\t\t\t\t\t\t\t\t\t KeiRo::Base::Common::getDockWidgetWidth()*KeiRo::Base::Common::getMainwidgetHeight()/KeiRo::Base::Common::getMainwidgetWidth() ) );\r\n////        _interaction->setMouseTracking( false );\r\n//\r\n//\t    _interactionDock->setWidget( _interaction );\r\n//        addDockWidget(Qt::RightDockWidgetArea, _interactionDock );\r\n//        _viewMenu->addAction( _interactionDock->toggleViewAction() );\r\n//\r\n//\t    //    connect(setting, &QWidget::windowIconChanged, this, &MainWindow::updateSetting );\r\n//\t    //    connect(interaction, &QWidget::windowIconChanged, this, &MainWindow::updateInteraction );\r\n//    }\r\n\r\n    void MainWindow::setSettings(QWidget* settingsWidget) \r\n    {\r\n    }\r\n\t\r\n\tvoid MainWindow::setInteraction(QWidget* interactionWidget)\r\n\t{\r\n\t}\r\n\t\r\n    //------------------------------------------------------------------------------\r\n    //\tProtected functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  MainWindow::initSetting -- init setting\r\n    //\r\n    //  Inputs\r\n    //  setting: text string\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void MainWindow::_initSetting( const QString &setting )\r\n    {\r\n//    \t_setting->initSceneItems();\r\n\t    if( setting.isEmpty() ) return;\r\n    }\r\n\t\r\n\t//\r\n\t//  MainWindow::initInteraction -- init interaction\r\n\t//\r\n\t//  Inputs\r\n\t//  interaction: text string\r\n\t//\r\n\t//  Outputs\r\n\t//  none\r\n\t//\r\n\tvoid MainWindow::_initInteraction( const QString &interaction )\r\n\t{\r\n\t\t_interaction->initSceneItems();\r\n\t\tif( interaction.isEmpty() ) return;\r\n\t}\r\n\t\r\n\t//\r\n\t//  MainWindow::_initAllDocks -- init all dock widgets\r\n\t//\r\n\t//  Inputs\r\n\t//  none\r\n\t//\r\n\t//  Outputs\r\n\t//  none\r\n\t//\r\n\tvoid MainWindow::_initAllDocks( void )\r\n\t{\r\n\t\t_initSetting( \"\" );\r\n\t\t_initInteraction( \"\" );\r\n//\t\tcerr << \"init docks...\" << endl;\r\n\t}\r\n\t\r\n\t//\r\n    //  MainWindow::updateSetting -- update setting\r\n    //\r\n    //  Inputs\r\n    //  setting: text string\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void MainWindow::_updateSetting( const QString &setting )\r\n    {\r\n//    \t_setting->updateSceneItems();\r\n        if( setting.isEmpty() ) return;\r\n    }\r\n\r\n    //\r\n    //  MainWindow::updateInteraction -- update interaction\r\n    //\r\n    //  Inputs\r\n    //  interaction: text string\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void MainWindow::_updateInteraction( const QString &interaction )\r\n    {\r\n        _interaction->updateSceneItems();\r\n        if( interaction.isEmpty() ) return;\r\n    }\r\n\r\n    //\r\n    //  MainWindow::_updateAllDocks -- update all dock widgets\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void MainWindow::_updateAllDocks( void )\r\n    {\r\n        _updateSetting( \"\" );\r\n        _updateInteraction( \"\" );\r\n//        cerr << \"update docks...\" << endl;\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPublic functions\r\n    //------------------------------------------------------------------------------\r\n    //------------------------------------------------------------------------------\r\n    //\tConstructors & Destructors\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  MainWindow::MainWindow -- constructor\r\n    //\r\n    //  Inputs\r\n    //  parent: parent widget\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    MainWindow::MainWindow( QWidget *parent )\r\n        : QMainWindow( parent )\r\n    {\r\n\t    //------------------------------------------------------------------------------\r\n\t    // initialization\r\n\t    //------------------------------------------------------------------------------\r\n\t    _basePtr = nullptr;\r\n\t    \r\n\t    // setup timer\r\n\t    _timerptr = new QTimer( this );\r\n\t    connect( _timerptr, SIGNAL( timeout() ), this, SLOT( exportPNG() ) );\r\n\t    _timerptr->start( 500 );\r\n\t    \r\n\t    //------------------------------------------------------------------------------\r\n        // clear stored images\r\n        //------------------------------------------------------------------------------\r\n        QString path = \"../../svg/\";\r\n        QDir dir( path );\r\n        dir.setNameFilters( QStringList() << \"*.*\" );\r\n        dir.setFilter( QDir::Files );\r\n        for( const QString &dirFile: dir.entryList() ) {\r\n            dir.remove( dirFile );\r\n        }\r\n\r\n        //------------------------------------------------------------------------------\r\n        // configuration file\r\n        //------------------------------------------------------------------------------\r\n        string configFilePath = qApp->applicationDirPath().toStdString() + \"/../config/MainWindow.conf\";\r\n        KeiRo::Base::Config conf( configFilePath );\r\n\r\n        int icon_width = 0,\r\n            icon_height = 0;\r\n\r\n        if ( conf.has( \"mainwidget_width\" ) ){\r\n            string parammainwidgetWidth = conf.gets( \"mainwidget_width\" );\r\n            KeiRo::Base::Common::setMainwidgetWidth( stoi( parammainwidgetWidth ) );\r\n        }\r\n        if ( conf.has( \"mainwidget_height\" ) ){\r\n            string parammainwidgetHeight = conf.gets( \"mainwidget_height\" );\r\n\t        KeiRo::Base::Common::setMainwidgetHeight( stoi( parammainwidgetHeight ) );\r\n        }\r\n        if ( conf.has( \"dockwidget_width\" ) ){\r\n            string paramDockWidgetWidth = conf.gets( \"dockwidget_width\" );\r\n\t        KeiRo::Base::Common::setDockWidgetWidth( stoi( paramDockWidgetWidth ) );\r\n       }\r\n        if ( conf.has( \"menubar_height\" ) ){\r\n            string paramMenuBarHeight = conf.gets( \"menubar_height\" );\r\n\t        KeiRo::Base::Common::setMenubarHeight( stoi( paramMenuBarHeight ) );\r\n        }\r\n        if ( conf.has( \"icon_width\" ) ){\r\n            string paramIconWidth = conf.gets( \"icon_width\" );\r\n            icon_width = stoi( paramIconWidth );\r\n        }\r\n        if ( conf.has( \"icon_height\" ) ){\r\n            string paramIconHeight = conf.gets( \"icon_height\" );\r\n            icon_height = stoi( paramIconHeight );\r\n        }\r\n\r\n        setGeometry( QRect( 50, 50,\r\n\t\t\t\t\t\t\tKeiRo::Base::Common::getMainwidgetWidth()+KeiRo::Base::Common::getDockWidgetWidth(),\r\n\t\t\t\t\t\t\tKeiRo::Base::Common::getMainwidgetHeight() + KeiRo::Base::Common::getMenubarHeight() ) );\r\n\t    setMinimumSize(QSize( KeiRo::Base::Common::getMainwidgetWidth()+KeiRo::Base::Common::getDockWidgetWidth(),\r\n\t\t\t\t\t\t   KeiRo::Base::Common::getMainwidgetHeight() + KeiRo::Base::Common::getMenubarHeight()\r\n\t\t\t\t\t\t   + icon_height ) );\r\n\t    \r\n#ifdef DEBUG\r\n        cerr << \"mainwidget_width = \" << KeiRo::Base::Common::getMainwidgetWidth() << endl;\r\n        cerr << \"mainwidget_height = \" << KeiRo::Base::Common::getMainwidgetHeight() << endl;\r\n        cerr << \"dockwidget_width = \" << KeiRo::Base::Common::getDockWidgetWidth() << endl;\r\n        cerr << \"menubar_height = \" << KeiRo::Base::Common::getMenubarHeight() << endl;\r\n        cerr << \"icon_width = \" << icon_width << endl;\r\n        cerr << \"icon_height = \" << icon_height << endl;\r\n\t    cerr << \"win_width = \" << width() << \" win_height = \" << height() << endl;\r\n#endif // DEBUG\r\n    }\r\n    \r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tEvent handlers\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tSpecial functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  MainWindow::newFile -- open new file\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void MainWindow::newFile( void )\r\n    {\r\n        _mainGV->simulateKey( Qt::Key_L );\r\n    }\r\n\t\r\n\t//\r\n\t//  MainWindow::exportPNG -- export main window as png\r\n\t//\r\n\t//  Inputs\r\n\t//  none\r\n\t//\r\n\t//  Outputs\r\n\t//  none\r\n\t//\r\n\tvoid MainWindow::exportPNG( void )\r\n\t{\r\n    \tdouble ww = KeiRo::Base::Common::getMainwidgetWidth();\r\n\t\tdouble wh = KeiRo::Base::Common::getMainwidgetHeight();\r\n\r\n    \t_mainGV->exportPNG( -0.5*ww, -0.5*wh, ww, wh );\r\n\t}\r\n\t\r\n    //\r\n    //  MainWindow::print -- print\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void MainWindow::print( void )\r\n    {\r\n    }\r\n\r\n    //\r\n    //  MainWindow::undo -- undo\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void MainWindow::undo( void )\r\n    {\r\n    }\r\n\r\n    //\r\n    //  MainWindow::save -- save\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void MainWindow::save( void )\r\n    {\r\n    #ifdef REVISE\r\n        QMimeDatabase mimeDatabase;\r\n        QString fileName = QFileDialog::getSaveFileName(this,\r\n                            tr(\"Choose a file name\"), \".\",\r\n                            mimeDatabase.mimeTypeForName(\"text/html\").filterString());\r\n        if (fileName.isEmpty())\r\n            return;\r\n        QFile file(fileName);\r\n        if (!file.open(QFile::WriteOnly | QFile::Text)) {\r\n            QMessageBox::warning(this, tr(\"Dock Widgets\"),\r\n                                 tr(\"Cannot write file %1:\\n%2.\")\r\n                                 .arg(QDir::toNativeSeparators(fileName), file.errorString()));\r\n            return;\r\n        }\r\n\r\n        QTextStream out(&file);\r\n        QApplication::setOverrideCursor(Qt::WaitCursor);\r\n        out << textEdit->toHtml();\r\n        QApplication::restoreOverrideCursor();\r\n\r\n        statusBar()->showMessage(tr(\"Saved '%1'\").arg(fileName), 2000);\r\n    #endif // REVISE\r\n    }\r\n\r\n    //\r\n    //  MainWindow::about -- about\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void MainWindow::about( void )\r\n    {\r\n       QMessageBox::about(this, tr(\"About KeiRo\"),\r\n                tr( \"Map-based biological pathway diagram\"));\r\n    }\r\n\t\r\n} // namespace Ui
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/UI/src/MainWindow.cpp b/UI/src/MainWindow.cpp
--- a/UI/src/MainWindow.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/UI/src/MainWindow.cpp	(date 1729410604880)
@@ -1,483 +1,0 @@
-//******************************************************************************
-// MainWindow.cpp
-//	: program file for main window
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Jun 19 02:36:37 2019
-//
-//******************************************************************************
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-
-#include "MainWindow.h"
-
-namespace Ui {
-	
-	//------------------------------------------------------------------------------
-    //	Private functions
-    //------------------------------------------------------------------------------
-    //
-    //  MainWindow::_createActions -- create actions
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    //
-    void MainWindow::_createActions()
-    {
-        QMenu *fileMenu = menuBar()->addMenu(tr("&File"));
-
-        // tool box setting
-        QToolBar *fileToolBar = addToolBar(tr("File"));
-        fileToolBar->setIconSize(QSize(25, 25));
-        fileToolBar->setFixedHeight(50);
-	
-	    //------------------------------------------------------------------------------
-	    //	tool box
-	    //------------------------------------------------------------------------------
-	    const QIcon newIcon = QIcon::fromTheme("", QIcon(":/icons/app.png"));
-        QAction *newFileAct = new QAction(newIcon, tr("&Open"), this );
-        newFileAct->setShortcuts( QKeySequence::New) ;
-        newFileAct->setStatusTip(tr("Open a new file"));
-        connect( newFileAct, &QAction::triggered, this, &MainWindow::newFile );
-        fileMenu->addAction( newFileAct );
-        fileToolBar->addAction( newFileAct );
-
-#ifdef SKIP
-        const QIcon saveIcon = QIcon::fromTheme("", QIcon(":/icons/save.png"));
-        //const QIcon saveIcon = QIcon::fromTheme("document-save", QIcon(":/icons/save.png"));
-        QAction *saveAct = new QAction( saveIcon, tr("&Save..."), this );
-        saveAct->setShortcuts( QKeySequence::Save);
-        saveAct->setStatusTip(tr("Save the current form letter") );
-        connect( saveAct, &QAction::triggered, this, &MainWindow::save );
-        fileMenu->addAction( saveAct );
-        fileToolBar->addAction( saveAct );
-
-        const QIcon printIcon = QIcon::fromTheme( "", QIcon(":/icons/print.png") );
-        //const QIcon printIcon = QIcon::fromTheme("document-print", QIcon(":/icons/print.png"));
-        QAction *printAct = new QAction(printIcon, tr("&Print..."), this);
-        printAct->setShortcuts(QKeySequence::Print);
-        printAct->setStatusTip(tr("Print the current form letter") );
-        connect( printAct, &QAction::triggered, this, &MainWindow::print);
-        fileMenu->addAction( printAct );
-        fileToolBar->addAction( printAct );
-#endif // SKIP
-
-	    //------------------------------------------------------------------------------
-	    //	file menu
-	    //------------------------------------------------------------------------------
-
-        fileMenu->addSeparator();
-
-        QAction *quitAct = fileMenu->addAction( tr("&Quit"), this, &QWidget::close );
-        quitAct->setShortcuts(QKeySequence::Quit);
-        quitAct->setStatusTip(tr("Quit the application"));
-
-        QMenu *editMenu = menuBar()->addMenu(tr("&Edit"));
-        QToolBar *editToolBar = addToolBar(tr("Edit"));
-        editToolBar->setIconSize(QSize(25, 25));
-        editToolBar->setFixedHeight(50);
-
-#ifdef SKIP
-        const QIcon undoIcon = QIcon::fromTheme("", QIcon(":/icons/undo.png"));
-        //const QIcon undoIcon = QIcon::fromTheme("edit-undo", QIcon(":/icons/undo.png"));
-        QAction *undoAct = new QAction(undoIcon, tr("&Undo"), this);
-        undoAct->setShortcuts(QKeySequence::Undo);
-        undoAct->setStatusTip(tr("Undo the last editing action"));
-        connect(undoAct, &QAction::triggered, this, &MainWindow::undo);
-        editMenu->addAction(undoAct);
-        editToolBar->addAction(undoAct);
-#endif // SKIP
-        
-        menuBar()->addSeparator();
-
-        _viewMenu = menuBar()->addMenu(tr("&View"));
-        menuBar()->addSeparator();
-
-        QMenu *helpMenu = menuBar()->addMenu(tr("&Help"));
-
-        QAction *aboutAct = helpMenu->addAction(tr("&About"), this, &MainWindow::about );
-        aboutAct->setStatusTip(tr("Show the application's About box"));
-
-        QAction *aboutQtAct = helpMenu->addAction(tr("About &Qt"), qApp, &QApplication::aboutQt );
-        aboutQtAct->setStatusTip(tr("Show the Qt library's About box"));
-		
-		connect( _mainGV, SIGNAL( dataInitialized() ), this, SLOT( _initAllDocks() ) );
-        connect( _mainGV, SIGNAL( dataChanged() ), this, SLOT( _updateAllDocks() ) );
-    }
-
-    //
-    //  MainWindow::_createStatusBar -- create status bar
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none-'['-]
-    //
-    void MainWindow::_createStatusBar()
-    {
-        statusBar()->showMessage(tr("Ready"));
-    }
-
-    //
-    //  MainWindow::_createDockWindows -- create dock windows
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    //
-//    void MainWindow::_createDockWindows( void )
-//    {
-//	    _settingsDock = new QDockWidget(tr("Setting"), this );
-//        _settingsDock->setAllowedAreas( Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);
-//
-//	    _setting = new QWidget( _settingsDock );
-//        _setting->setGeometry( QRect(0,0,KeiRo::Base::Common::getDockWidgetWidth(),
-//									 KeiRo::Base::Common::getMainwidgetHeight()/2.0 ) );
-//        _setting->setMinimumSize( QSize( KeiRo::Base::Common::getDockWidgetWidth(),
-//										 KeiRo::Base::Common::getMainwidgetHeight()/3.0 ) );
-////	    _setting->setMaximumSize( QSize( KeiRo::Base::Common::getDockWidgetWidth(),
-////	                                     KeiRo::Base::Common::getMainwidgetHeight()/3.0 ) );
-////        _setting->setMouseTracking( false );
-//        _settingsDock->setWidget( _setting );
-//        addDockWidget(Qt::RightDockWidgetArea, _settingsDock );
-//        _viewMenu->addAction(_settingsDock->toggleViewAction() );
-//
-//
-//	    _interactionDock = new QDockWidget(tr("Interaction"), this );
-//	    _interactionDock->setAllowedAreas( Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);
-//
-//        _interaction = new QWidget( _interactionDock );
-//        _interaction->setGeometry( QRect(0,0,KeiRo::Base::Common::getDockWidgetWidth(),
-//										 KeiRo::Base::Common::getDockWidgetWidth()*KeiRo::Base::Common::getMainwidgetHeight()/KeiRo::Base::Common::getMainwidgetWidth() ) );
-//        _interaction->setMinimumSize( QSize( KeiRo::Base::Common::getDockWidgetWidth(),
-//											 KeiRo::Base::Common::getDockWidgetWidth()*KeiRo::Base::Common::getMainwidgetHeight()/KeiRo::Base::Common::getMainwidgetWidth() ) );
-////        _interaction->setMouseTracking( false );
-//
-//	    _interactionDock->setWidget( _interaction );
-//        addDockWidget(Qt::RightDockWidgetArea, _interactionDock );
-//        _viewMenu->addAction( _interactionDock->toggleViewAction() );
-//
-//	    //    connect(setting, &QWidget::windowIconChanged, this, &MainWindow::updateSetting );
-//	    //    connect(interaction, &QWidget::windowIconChanged, this, &MainWindow::updateInteraction );
-//    }
-
-    void MainWindow::setSettings(QWidget* settingsWidget) 
-    {
-    }
-	
-	void MainWindow::setInteraction(QWidget* interactionWidget)
-	{
-	}
-	
-    //------------------------------------------------------------------------------
-    //	Protected functions
-    //------------------------------------------------------------------------------
-    //
-    //  MainWindow::initSetting -- init setting
-    //
-    //  Inputs
-    //  setting: text string
-    //
-    //  Outputs
-    //  none
-    //
-    void MainWindow::_initSetting( const QString &setting )
-    {
-//    	_setting->initSceneItems();
-	    if( setting.isEmpty() ) return;
-    }
-	
-	//
-	//  MainWindow::initInteraction -- init interaction
-	//
-	//  Inputs
-	//  interaction: text string
-	//
-	//  Outputs
-	//  none
-	//
-	void MainWindow::_initInteraction( const QString &interaction )
-	{
-		_interaction->initSceneItems();
-		if( interaction.isEmpty() ) return;
-	}
-	
-	//
-	//  MainWindow::_initAllDocks -- init all dock widgets
-	//
-	//  Inputs
-	//  none
-	//
-	//  Outputs
-	//  none
-	//
-	void MainWindow::_initAllDocks( void )
-	{
-		_initSetting( "" );
-		_initInteraction( "" );
-//		cerr << "init docks..." << endl;
-	}
-	
-	//
-    //  MainWindow::updateSetting -- update setting
-    //
-    //  Inputs
-    //  setting: text string
-    //
-    //  Outputs
-    //  none
-    //
-    void MainWindow::_updateSetting( const QString &setting )
-    {
-//    	_setting->updateSceneItems();
-        if( setting.isEmpty() ) return;
-    }
-
-    //
-    //  MainWindow::updateInteraction -- update interaction
-    //
-    //  Inputs
-    //  interaction: text string
-    //
-    //  Outputs
-    //  none
-    //
-    void MainWindow::_updateInteraction( const QString &interaction )
-    {
-        _interaction->updateSceneItems();
-        if( interaction.isEmpty() ) return;
-    }
-
-    //
-    //  MainWindow::_updateAllDocks -- update all dock widgets
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    //
-    void MainWindow::_updateAllDocks( void )
-    {
-        _updateSetting( "" );
-        _updateInteraction( "" );
-//        cerr << "update docks..." << endl;
-    }
-
-    //------------------------------------------------------------------------------
-    //	Public functions
-    //------------------------------------------------------------------------------
-    //------------------------------------------------------------------------------
-    //	Constructors & Destructors
-    //------------------------------------------------------------------------------
-    //
-    //  MainWindow::MainWindow -- constructor
-    //
-    //  Inputs
-    //  parent: parent widget
-    //
-    //  Outputs
-    //  none
-    //
-    MainWindow::MainWindow( QWidget *parent )
-        : QMainWindow( parent )
-    {
-	    //------------------------------------------------------------------------------
-	    // initialization
-	    //------------------------------------------------------------------------------
-	    _basePtr = nullptr;
-	    
-	    // setup timer
-	    _timerptr = new QTimer( this );
-	    connect( _timerptr, SIGNAL( timeout() ), this, SLOT( exportPNG() ) );
-	    _timerptr->start( 500 );
-	    
-	    //------------------------------------------------------------------------------
-        // clear stored images
-        //------------------------------------------------------------------------------
-        QString path = "../../svg/";
-        QDir dir( path );
-        dir.setNameFilters( QStringList() << "*.*" );
-        dir.setFilter( QDir::Files );
-        for( const QString &dirFile: dir.entryList() ) {
-            dir.remove( dirFile );
-        }
-
-        //------------------------------------------------------------------------------
-        // configuration file
-        //------------------------------------------------------------------------------
-        string configFilePath = qApp->applicationDirPath().toStdString() + "/../config/MainWindow.conf";
-        KeiRo::Base::Config conf( configFilePath );
-
-        int icon_width = 0,
-            icon_height = 0;
-
-        if ( conf.has( "mainwidget_width" ) ){
-            string parammainwidgetWidth = conf.gets( "mainwidget_width" );
-            KeiRo::Base::Common::setMainwidgetWidth( stoi( parammainwidgetWidth ) );
-        }
-        if ( conf.has( "mainwidget_height" ) ){
-            string parammainwidgetHeight = conf.gets( "mainwidget_height" );
-	        KeiRo::Base::Common::setMainwidgetHeight( stoi( parammainwidgetHeight ) );
-        }
-        if ( conf.has( "dockwidget_width" ) ){
-            string paramDockWidgetWidth = conf.gets( "dockwidget_width" );
-	        KeiRo::Base::Common::setDockWidgetWidth( stoi( paramDockWidgetWidth ) );
-       }
-        if ( conf.has( "menubar_height" ) ){
-            string paramMenuBarHeight = conf.gets( "menubar_height" );
-	        KeiRo::Base::Common::setMenubarHeight( stoi( paramMenuBarHeight ) );
-        }
-        if ( conf.has( "icon_width" ) ){
-            string paramIconWidth = conf.gets( "icon_width" );
-            icon_width = stoi( paramIconWidth );
-        }
-        if ( conf.has( "icon_height" ) ){
-            string paramIconHeight = conf.gets( "icon_height" );
-            icon_height = stoi( paramIconHeight );
-        }
-
-        setGeometry( QRect( 50, 50,
-							KeiRo::Base::Common::getMainwidgetWidth()+KeiRo::Base::Common::getDockWidgetWidth(),
-							KeiRo::Base::Common::getMainwidgetHeight() + KeiRo::Base::Common::getMenubarHeight() ) );
-	    setMinimumSize(QSize( KeiRo::Base::Common::getMainwidgetWidth()+KeiRo::Base::Common::getDockWidgetWidth(),
-						   KeiRo::Base::Common::getMainwidgetHeight() + KeiRo::Base::Common::getMenubarHeight()
-						   + icon_height ) );
-	    
-#ifdef DEBUG
-        cerr << "mainwidget_width = " << KeiRo::Base::Common::getMainwidgetWidth() << endl;
-        cerr << "mainwidget_height = " << KeiRo::Base::Common::getMainwidgetHeight() << endl;
-        cerr << "dockwidget_width = " << KeiRo::Base::Common::getDockWidgetWidth() << endl;
-        cerr << "menubar_height = " << KeiRo::Base::Common::getMenubarHeight() << endl;
-        cerr << "icon_width = " << icon_width << endl;
-        cerr << "icon_height = " << icon_height << endl;
-	    cerr << "win_width = " << width() << " win_height = " << height() << endl;
-#endif // DEBUG
-    }
-    
-
-    //------------------------------------------------------------------------------
-    //	Event handlers
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Special functions
-    //------------------------------------------------------------------------------
-    //
-    //  MainWindow::newFile -- open new file
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    //
-    void MainWindow::newFile( void )
-    {
-        _mainGV->simulateKey( Qt::Key_L );
-    }
-	
-	//
-	//  MainWindow::exportPNG -- export main window as png
-	//
-	//  Inputs
-	//  none
-	//
-	//  Outputs
-	//  none
-	//
-	void MainWindow::exportPNG( void )
-	{
-    	double ww = KeiRo::Base::Common::getMainwidgetWidth();
-		double wh = KeiRo::Base::Common::getMainwidgetHeight();
-
-    	_mainGV->exportPNG( -0.5*ww, -0.5*wh, ww, wh );
-	}
-	
-    //
-    //  MainWindow::print -- print
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    //
-    void MainWindow::print( void )
-    {
-    }
-
-    //
-    //  MainWindow::undo -- undo
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    //
-    void MainWindow::undo( void )
-    {
-    }
-
-    //
-    //  MainWindow::save -- save
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    //
-    void MainWindow::save( void )
-    {
-    #ifdef REVISE
-        QMimeDatabase mimeDatabase;
-        QString fileName = QFileDialog::getSaveFileName(this,
-                            tr("Choose a file name"), ".",
-                            mimeDatabase.mimeTypeForName("text/html").filterString());
-        if (fileName.isEmpty())
-            return;
-        QFile file(fileName);
-        if (!file.open(QFile::WriteOnly | QFile::Text)) {
-            QMessageBox::warning(this, tr("Dock Widgets"),
-                                 tr("Cannot write file %1:\n%2.")
-                                 .arg(QDir::toNativeSeparators(fileName), file.errorString()));
-            return;
-        }
-
-        QTextStream out(&file);
-        QApplication::setOverrideCursor(Qt::WaitCursor);
-        out << textEdit->toHtml();
-        QApplication::restoreOverrideCursor();
-
-        statusBar()->showMessage(tr("Saved '%1'").arg(fileName), 2000);
-    #endif // REVISE
-    }
-
-    //
-    //  MainWindow::about -- about
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    //
-    void MainWindow::about( void )
-    {
-       QMessageBox::about(this, tr("About KeiRo"),
-                tr( "Map-based biological pathway diagram"));
-    }
-	
-} // namespace Ui
\ No newline at end of file
Index: Base/src/Timer.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// Timer.h\r\n//\t: header file for color schemes\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Jun 19 02:36:37 2019\r\n//\r\n//******************************************************************************\r\n\r\n#ifndef _Base_Timer_H\r\n#define _Base_Timer_H\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <chrono>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Macros\r\n//------------------------------------------------------------------------------\r\n\r\nnamespace Base {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tDefining Classes\r\n    //------------------------------------------------------------------------------\r\n    template< typename T >\r\n    class Timer {\r\n\r\n    private:\r\n\r\n        string _unit;\r\n        chrono::steady_clock::time_point _begin;\r\n        chrono::steady_clock::time_point _end;\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tSpecial functions\r\n        //------------------------------------------------------------------------------\r\n\r\n    public:\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tConstructors & Destructors\r\n        //------------------------------------------------------------------------------\r\n        // default constructor\r\n        Timer( void ) {}\r\n        // copy constructor\r\n        Timer( const string & s ) {\r\n            _unit = s;\r\n        }\r\n        // destructor\r\n        ~Timer( void ){}\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tAssignment operators\r\n        //------------------------------------------------------------------------------\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tReference to elements\r\n        //------------------------------------------------------------------------------\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tSpecial functions\r\n        //------------------------------------------------------------------------------\r\n        void begin( void ) {\r\n            _begin = chrono::steady_clock::now();\r\n        }\r\n        void end( void ) {\r\n            _end = chrono::steady_clock::now();\r\n        }\r\n        void elapsed( void ) {\r\n\r\n            // chrono::nanoseconds, ns, 1e9\r\n            // chrono::microseconds, µs, 1e6\r\n            // chrono::milliseconds, ms, 1e3\r\n            // chrono::seconds, sec, 1\r\n            cerr << \"Computation Time: \" << chrono::duration_cast< T >( _end-_begin ).count()\r\n                 << \" in \" << _unit << endl;\r\n        }\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tFriend functions\r\n        //------------------------------------------------------------------------------\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tI/O functions\r\n        //------------------------------------------------------------------------------\r\n        // output\r\n        friend ostream &\toperator << ( ostream & s, const Timer & t );\r\n        // input\r\n        friend istream &\toperator >> ( istream & s, Timer & t );\r\n        // class name\r\n        virtual const char * className( void ) const { return \"Timer\"; }\r\n\r\n    };\r\n\r\n} // namespace Base\r\n\r\n#endif // _Base_Timer_H
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Base/src/Timer.h b/Base/src/Timer.h
--- a/Base/src/Timer.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Base/src/Timer.h	(date 1729410604890)
@@ -1,104 +1,0 @@
-//******************************************************************************
-// Timer.h
-//	: header file for color schemes
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Jun 19 02:36:37 2019
-//
-//******************************************************************************
-
-#ifndef _Base_Timer_H
-#define _Base_Timer_H
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <chrono>
-#include <iostream>
-
-using namespace std;
-
-//------------------------------------------------------------------------------
-//	Defining Macros
-//------------------------------------------------------------------------------
-
-namespace Base {
-
-    //------------------------------------------------------------------------------
-    //	Defining Classes
-    //------------------------------------------------------------------------------
-    template< typename T >
-    class Timer {
-
-    private:
-
-        string _unit;
-        chrono::steady_clock::time_point _begin;
-        chrono::steady_clock::time_point _end;
-
-        //------------------------------------------------------------------------------
-        //	Special functions
-        //------------------------------------------------------------------------------
-
-    public:
-
-        //------------------------------------------------------------------------------
-        //	Constructors & Destructors
-        //------------------------------------------------------------------------------
-        // default constructor
-        Timer( void ) {}
-        // copy constructor
-        Timer( const string & s ) {
-            _unit = s;
-        }
-        // destructor
-        ~Timer( void ){}
-
-        //------------------------------------------------------------------------------
-        //	Assignment operators
-        //------------------------------------------------------------------------------
-
-        //------------------------------------------------------------------------------
-        //	Reference to elements
-        //------------------------------------------------------------------------------
-
-        //------------------------------------------------------------------------------
-        //	Special functions
-        //------------------------------------------------------------------------------
-        void begin( void ) {
-            _begin = chrono::steady_clock::now();
-        }
-        void end( void ) {
-            _end = chrono::steady_clock::now();
-        }
-        void elapsed( void ) {
-
-            // chrono::nanoseconds, ns, 1e9
-            // chrono::microseconds, µs, 1e6
-            // chrono::milliseconds, ms, 1e3
-            // chrono::seconds, sec, 1
-            cerr << "Computation Time: " << chrono::duration_cast< T >( _end-_begin ).count()
-                 << " in " << _unit << endl;
-        }
-
-        //------------------------------------------------------------------------------
-        //	Friend functions
-        //------------------------------------------------------------------------------
-
-        //------------------------------------------------------------------------------
-        //	I/O functions
-        //------------------------------------------------------------------------------
-        // output
-        friend ostream &	operator << ( ostream & s, const Timer & t );
-        // input
-        friend istream &	operator >> ( istream & s, Timer & t );
-        // class name
-        virtual const char * className( void ) const { return "Timer"; }
-
-    };
-
-} // namespace Base
-
-#endif // _Base_Timer_H
\ No newline at end of file
Index: UI/src/GraphicsCellItem.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// GraphicsCellItem.cpp\r\n//\t: program file for vertex items\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Jun 19 02:36:37 2019\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include \"GraphicsCellItem.h\"\r\n\r\nnamespace Ui {\r\n\tnamespace Vector {\r\n\t\t\r\n\t\t//------------------------------------------------------------------------------\r\n\t\t//\tPrivate functions\r\n\t\t//------------------------------------------------------------------------------\r\n\t\t\r\n\t\t//------------------------------------------------------------------------------\r\n\t\t//\tProtected functions\r\n\t\t//------------------------------------------------------------------------------\r\n\t\t//\r\n\t\t//  GraphicsCellItem::init -- initialization\r\n\t\t//\r\n\t\t//  Inputs\r\n\t\t//  none\r\n\t\t//\r\n\t\t//  Outputs\r\n\t\t//  none\r\n\t\t//\r\n\t\tvoid GraphicsCellItem::_init( void ) {\r\n\t\t\t\r\n\t\t\tGraphicsBase::_init();\r\n\t\t}\r\n\t\t\r\n\t\t//------------------------------------------------------------------------------\r\n\t\t//\tPublic functions\r\n\t\t//------------------------------------------------------------------------------\r\n\t\t//------------------------------------------------------------------------------\r\n\t\t//\tConstructors & Destructors\r\n\t\t//------------------------------------------------------------------------------\r\n\t\t//\r\n\t\t//  GraphicsCellItem::GraphicsCellItem -- constructor\r\n\t\t//\r\n\t\t//  Inputs\r\n\t\t//  parent: parent object\r\n\t\t//\r\n\t\t//  Outputs\r\n\t\t//  none\r\n\t\t//\r\n\t\tGraphicsCellItem::GraphicsCellItem( QGraphicsItem *parent )\r\n\t\t{\r\n\t\t\t//setFlag( QGraphicsItem::ItemIsSelectable );\r\n\t\t\t//setFlag( QGraphicsItem::ItemIsMovable );\r\n\t\t\t//setFlag( QGraphicsItem::ItemSendsGeometryChanges );\r\n\t\t\t//setAcceptDrops( true );\r\n\t\t\t\r\n\t\t\t_init();\r\n\t\t}\r\n\t\t\r\n\t\t//\r\n\t\t//  GraphicsCellItem::GraphicsCellItem -- parameterized constructor\r\n\t\t//\r\n\t\t//  Inputs\r\n\t\t//  parent: parent object\r\n\t\t//\r\n\t\t//  Outputs\r\n\t\t//  none\r\n\t\t//\r\n\t\tGraphicsCellItem::GraphicsCellItem( qreal x, qreal y, qreal w, qreal h, QGraphicsItem *parent )\r\n\t\t{\r\n\t\t\tsetRect( QRectF( x, y, w, h ) );\r\n\t\t}\r\n\t\t\r\n\t\t//\r\n\t\t//  GraphicsCellItem::GraphicsCellItem -- copy constructor\r\n\t\t//\r\n\t\t//  Inputs\r\n\t\t//  parent: parent object\r\n\t\t//\r\n\t\t//  Outputs\r\n\t\t//  none\r\n\t\t//\r\n\t\tGraphicsCellItem::GraphicsCellItem( const QRectF &rect, QGraphicsItem *parent )\r\n\t\t{\r\n\t\t\tsetRect( rect );\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\t//\r\n\t\t//  GraphicsCellItem::boundingRect -- find bounding box\r\n\t\t//\r\n\t\t//  Inputs\r\n\t\t//  none\r\n\t\t//\r\n\t\t//  Outputs\r\n\t\t//  reference to the bounding box\r\n\t\t//\r\n\t\tQRectF GraphicsCellItem::boundingRect( void ) const\r\n\t\t{\r\n\t\t\treturn rect();\r\n\t\t}\r\n\t\t\r\n\t\t//\r\n\t\t//  GraphicsCellItem::paint -- paint the object\r\n\t\t//\r\n\t\t//  Inputs\r\n\t\t//  none\r\n\t\t//\r\n\t\t//  Outputs\r\n\t\t//  none\r\n\t\t//\r\n\t\tvoid GraphicsCellItem::paint( QPainter *painter, const QStyleOptionGraphicsItem *option,\r\n\t\t                                QWidget *widget )\r\n\t\t{\r\n\t\t\tQ_UNUSED(option)\r\n\t\t\tQ_UNUSED(widget)\r\n\t\t\t\r\n\t\t\tpainter->setRenderHints( QPainter::Antialiasing );\r\n\t\t\tpainter->setPen( pen() );\r\n\t\t\tpainter->setBrush( brush() );\r\n\t\t\t//painter->drawRect( _sourceRect );\r\n\t\t\tint padding = 3;\r\n\t\t\tpainter->drawRoundedRect( _sourceRect, padding, padding);\r\n\t\t\t\r\n\t\t\tif( _textOn == true ) {\r\n\t\t\t\tQFontMetrics fm( _font );\r\n\t\t\t\tdouble sx = fm.width( _text );\r\n\t\t\t\tdouble sy = 0.5*fm.height();\r\n\r\n\t\t\t\tpainter->setFont( _font );\r\n\t\t\t\tpainter->setPen( _textpen );\r\n\r\n\t\t\t\tpainter->drawText(\r\n\t\t\t\t    _sourceRect.x() + 0.5 * _sourceRect.width() - 0.5 * sx,\r\n\t\t\t\t    _sourceRect.y() + 0.5 * _sourceRect.height() + 0.5 * sy,\r\n\t\t\t\t    _text\r\n\t\t\t\t);\r\n\t\t\t\t//cerr << \"id = \" << _id << endl;\r\n\t\t\t\t//painter->drawText( rect().x()+10, rect().y()-10, QString::fromStdString( to_string( _id ) ) );\r\n\t\t\t\t//painter->drawText( rect().x()+0.5*( rect().width() ),\r\n\t\t\t\t                   //rect().y()+0.5*( rect().height() ), _text ); // (x ,y) must be left-upper corner\r\n\t\t\t\t//painter->drawText( fineRect.x()+0.5*( fineRect.width()-sx ) - 0.5*MIN_NEIGHBOR_DISTANCE,\r\n\t\t\t\t//                   fineRect.y()+0.5*( fineRect.height()+0.5*sy ) + MIN_NEIGHBOR_DISTANCE, _name );\r\n\t\t\t\t\r\n\t\t\t\t//cerr << \"paint x = \" << pos().x() << \" y = \" << pos().y() << endl;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Qt function\r\n\t\t\t//if ( option->state & QStyle::State_Selected )\r\n\t\t\t//\tqt_graphicsItem_highlightSelected( this, painter, option );\r\n\t\t\t// cerr << \"painting ball...\" << endl;\r\n\t\t}\r\n\t\t\r\n\t\t//\r\n\t\t//  GraphicsCellItem::type -- find type\r\n\t\t//\r\n\t\t//  Inputs\r\n\t\t//  none\r\n\t\t//\r\n\t\t//  Outputs\r\n\t\t//  reference to the type of the object\r\n\t\t//\r\n\t\tint GraphicsCellItem::type( void ) const\r\n\t\t{\r\n\t\t\treturn 0; //GRAPHICS_VERTEX+QGraphicsItem::UserType;\r\n\t\t}\r\n\t\r\n\t} // namespace Vector\r\n} // namespace Ui
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/UI/src/GraphicsCellItem.cpp b/UI/src/GraphicsCellItem.cpp
--- a/UI/src/GraphicsCellItem.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/UI/src/GraphicsCellItem.cpp	(date 1729410604900)
@@ -1,175 +1,0 @@
-//******************************************************************************
-// GraphicsCellItem.cpp
-//	: program file for vertex items
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Jun 19 02:36:37 2019
-//
-//******************************************************************************
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include "GraphicsCellItem.h"
-
-namespace Ui {
-	namespace Vector {
-		
-		//------------------------------------------------------------------------------
-		//	Private functions
-		//------------------------------------------------------------------------------
-		
-		//------------------------------------------------------------------------------
-		//	Protected functions
-		//------------------------------------------------------------------------------
-		//
-		//  GraphicsCellItem::init -- initialization
-		//
-		//  Inputs
-		//  none
-		//
-		//  Outputs
-		//  none
-		//
-		void GraphicsCellItem::_init( void ) {
-			
-			GraphicsBase::_init();
-		}
-		
-		//------------------------------------------------------------------------------
-		//	Public functions
-		//------------------------------------------------------------------------------
-		//------------------------------------------------------------------------------
-		//	Constructors & Destructors
-		//------------------------------------------------------------------------------
-		//
-		//  GraphicsCellItem::GraphicsCellItem -- constructor
-		//
-		//  Inputs
-		//  parent: parent object
-		//
-		//  Outputs
-		//  none
-		//
-		GraphicsCellItem::GraphicsCellItem( QGraphicsItem *parent )
-		{
-			//setFlag( QGraphicsItem::ItemIsSelectable );
-			//setFlag( QGraphicsItem::ItemIsMovable );
-			//setFlag( QGraphicsItem::ItemSendsGeometryChanges );
-			//setAcceptDrops( true );
-			
-			_init();
-		}
-		
-		//
-		//  GraphicsCellItem::GraphicsCellItem -- parameterized constructor
-		//
-		//  Inputs
-		//  parent: parent object
-		//
-		//  Outputs
-		//  none
-		//
-		GraphicsCellItem::GraphicsCellItem( qreal x, qreal y, qreal w, qreal h, QGraphicsItem *parent )
-		{
-			setRect( QRectF( x, y, w, h ) );
-		}
-		
-		//
-		//  GraphicsCellItem::GraphicsCellItem -- copy constructor
-		//
-		//  Inputs
-		//  parent: parent object
-		//
-		//  Outputs
-		//  none
-		//
-		GraphicsCellItem::GraphicsCellItem( const QRectF &rect, QGraphicsItem *parent )
-		{
-			setRect( rect );
-		}
-		
-		
-		//
-		//  GraphicsCellItem::boundingRect -- find bounding box
-		//
-		//  Inputs
-		//  none
-		//
-		//  Outputs
-		//  reference to the bounding box
-		//
-		QRectF GraphicsCellItem::boundingRect( void ) const
-		{
-			return rect();
-		}
-		
-		//
-		//  GraphicsCellItem::paint -- paint the object
-		//
-		//  Inputs
-		//  none
-		//
-		//  Outputs
-		//  none
-		//
-		void GraphicsCellItem::paint( QPainter *painter, const QStyleOptionGraphicsItem *option,
-		                                QWidget *widget )
-		{
-			Q_UNUSED(option)
-			Q_UNUSED(widget)
-			
-			painter->setRenderHints( QPainter::Antialiasing );
-			painter->setPen( pen() );
-			painter->setBrush( brush() );
-			//painter->drawRect( _sourceRect );
-			int padding = 3;
-			painter->drawRoundedRect( _sourceRect, padding, padding);
-			
-			if( _textOn == true ) {
-				QFontMetrics fm( _font );
-				double sx = fm.width( _text );
-				double sy = 0.5*fm.height();
-
-				painter->setFont( _font );
-				painter->setPen( _textpen );
-
-				painter->drawText(
-				    _sourceRect.x() + 0.5 * _sourceRect.width() - 0.5 * sx,
-				    _sourceRect.y() + 0.5 * _sourceRect.height() + 0.5 * sy,
-				    _text
-				);
-				//cerr << "id = " << _id << endl;
-				//painter->drawText( rect().x()+10, rect().y()-10, QString::fromStdString( to_string( _id ) ) );
-				//painter->drawText( rect().x()+0.5*( rect().width() ),
-				                   //rect().y()+0.5*( rect().height() ), _text ); // (x ,y) must be left-upper corner
-				//painter->drawText( fineRect.x()+0.5*( fineRect.width()-sx ) - 0.5*MIN_NEIGHBOR_DISTANCE,
-				//                   fineRect.y()+0.5*( fineRect.height()+0.5*sy ) + MIN_NEIGHBOR_DISTANCE, _name );
-				
-				//cerr << "paint x = " << pos().x() << " y = " << pos().y() << endl;
-			}
-			
-			// Qt function
-			//if ( option->state & QStyle::State_Selected )
-			//	qt_graphicsItem_highlightSelected( this, painter, option );
-			// cerr << "painting ball..." << endl;
-		}
-		
-		//
-		//  GraphicsCellItem::type -- find type
-		//
-		//  Inputs
-		//  none
-		//
-		//  Outputs
-		//  reference to the type of the object
-		//
-		int GraphicsCellItem::type( void ) const
-		{
-			return 0; //GRAPHICS_VERTEX+QGraphicsItem::UserType;
-		}
-	
-	} // namespace Vector
-} // namespace Ui
\ No newline at end of file
Index: Optimization/src/LaplacianOptimization.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// LalacianMatrix.cpp\r\n//  : program file for the boundary network\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//              Date: Mon Dec 10 04:28:26 2012\r\n//\r\n//==============================================================================\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <iostream>\r\n#include <fstream>\r\n#include <cmath>\r\n\r\nusing namespace std;\r\n\r\n#include \"LaplacianOptimization.h\"\r\n\r\n//------------------------------------------------------------------------------\r\n//\tProtected functions\r\n//------------------------------------------------------------------------------\r\n//\r\n//  LaplacianOptimization::_reset --        reset the class\r\n//\r\n//  Inputs\r\n//      none\r\n//\r\n//  Outputs\r\n//      none\r\n//\r\nvoid LaplacianOptimization::_reset( void ) {\r\n\t\r\n\t_optType = LEAST_SQUARE;\r\n\t\r\n\t_nVars = 0;\r\n\t_nConstrs = 0;\r\n\t_iteration = 0;\r\n}\r\n\r\n//\r\n//  LaplacianOptimization::_LeastSquare --        optimization\r\n//\r\n//  Inputs\r\n//      none\r\n//\r\n//  Outputs\r\n//      err:\r\n//\r\ndouble LaplacianOptimization::_LeastSquare( void ) {\r\n\t\r\n\tdouble mse = 0.0;\r\n\tunsigned int iter = _iteration;\r\n\tfor( int i = 0; i < iter; i++ ) {\r\n\t\t\r\n\t\tEigen::VectorXd last_var = _var;\r\n\r\n#ifdef  DEBUG_TIME\r\n\t\tclock_t start_time = 0;\r\n\t\tfloat time1 = 0, time2 = 0, time3 = 0, time4 = 0;\r\n\t\tstart_time = clock();\r\n#endif  // DEBUG_TIME\r\n\t\t\r\n\t\t// ### optimization ###\r\n\t\t_var = ( ( _coef.transpose() * _coef ) ).inverse() * _coef.transpose() * _output;\r\n#ifdef  DEBUG_TIME\r\n\t\ttime1 = clock() - start_time;\r\n\t\tstart_time = clock();\r\n#endif  // DEBUG_TIME\r\n\t\t\r\n\t\t// ### retrieve the result ###\r\n\t\tretrieve();\r\n#ifdef  DEBUG_TIME\r\n\t\ttime2 = clock() - start_time;\r\n\t\tstart_time = clock();\r\n#endif  // DEBUG_TIME\r\n\t\t\r\n\t\t// ### update coefficient matrix ###\r\n\t\t_updateCoefs();\r\n#ifdef  DEBUG_TIME\r\n\t\ttime3 = clock() - start_time;\r\n\t\tstart_time = clock();\r\n#endif  // DEBUG_TIME\r\n\t\t\r\n\t\t// ### update target values ###\r\n\t\t_updateOutputs();\r\n#ifdef  DEBUG_TIME\r\n\t\ttime4 = clock() - start_time;\r\n#endif  // DEBUG_TIME\r\n\t\t\r\n\t\t// node movement\r\n\t\tEigen::VectorXd err = last_var - _var;\r\n\t\tmse = err.adjoint() * err;\r\n\t\t\r\n\t\tif( ( i + 1 ) % 100 == 0 )\r\n\t\t\tcerr << setprecision( 10 ) << \"Loop(\" << i << \") mse = \" << mse << endl;\r\n#ifdef  DEBUG_TIME\r\n\t\tcerr << \"time1 = \" << time1 << \" time2 = \" << time2 << \" time3 = \" << time3 << \" time4 = \" << time4 << endl;\r\n#endif  // DEBUG_TIME\r\n\t\tif( ( mse ) < 5.0e-4 ) break;\r\n\t}\r\n\r\n#ifdef  DEBUG\r\n\tcerr << \"_var:\" << endl;\r\n\tcerr << _var << endl;\r\n#endif  // DEBUG\r\n\treturn mse;\r\n}\r\n\r\n//\r\n//  LaplacianOptimization::_ConjugateGradient --        optimization\r\n//\r\n//  Inputs\r\n//      none\r\n//\r\n//  Outputs\r\n//      err\r\n//\r\ndouble LaplacianOptimization::_ConjugateGradient( void ) {\r\n\r\n\tunsigned int iter = _iteration;\r\n\t\r\n\t// initialization, prepareBoundary the square matrix\r\n\tEigen::MatrixXd A;\r\n\tEigen::VectorXd b, Ap;\r\n\tA = _coef.transpose() * _coef;\r\n\tb = _coef.transpose() * _output;\r\n\r\n\t// initialization\r\n\tEigen::VectorXd err = b - A * _var;\r\n\tEigen::VectorXd p = err;\r\n\tdouble rsold = err.adjoint() * err;\r\n\r\n\t// main algorithm\r\n\t// cerr << \"iter = \" << iter << endl;\r\n\tfor( int i = 0; i < iter; i++ ) {\r\n\r\n\t\t// cerr << \"i = \" << i << endl;\r\n\t\t// prepareBoundary the square matrix\r\n\t\tA = _coef.transpose() * _coef;\r\n\t\tb = _coef.transpose() * _output;\r\n\t\tAp = A * p;\r\n\r\n\t\tdouble alpha = ( double ) ( p.transpose() * err ) / ( double ) ( p.transpose() * Ap );\r\n\t\t_var = _var + alpha * p;\r\n\t\terr = b - A * _var;\r\n\r\n\t\tif( sqrt( err.adjoint() * err ) < 1e-10 ) {\r\n\t\t\tcerr << \"sqrterror(\" << i << \") = \" << sqrt( err.adjoint() * err ) << endl;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tdouble beta = -1.0 * ( double ) ( err.transpose() * Ap ) / ( double ) ( p.transpose() * Ap );\r\n\t\t\tp = err + beta * p;\r\n\t\t}\r\n\r\n\t\t// update\r\n\t\tretrieve();\r\n\t\t_updateCoefs();\r\n\t\t_updateOutputs();\r\n\t}\r\n\r\n\t// cerr << \"sqrterror = \" << sqrt( err.adjoint() * err ) << endl;\r\n\treturn sqrt( err.adjoint() * err );\r\n}\r\n\r\n//\r\n//  LaplacianOptimization::clear --        memory management\r\n//\r\n//  Inputs\r\n//      none\r\n//\r\n//  Outputs\r\n//      none\r\n//\r\nvoid LaplacianOptimization::clear( void ) {\r\n\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n//\tPublic functions\r\n//------------------------------------------------------------------------------\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDestructor\r\n//------------------------------------------------------------------------------\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Optimization/src/LaplacianOptimization.cpp b/Optimization/src/LaplacianOptimization.cpp
--- a/Optimization/src/LaplacianOptimization.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Optimization/src/LaplacianOptimization.cpp	(date 1729410604920)
@@ -1,189 +1,0 @@
-// LalacianMatrix.cpp
-//  : program file for the boundary network
-//
-//------------------------------------------------------------------------------
-//
-//              Date: Mon Dec 10 04:28:26 2012
-//
-//==============================================================================
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <iostream>
-#include <fstream>
-#include <cmath>
-
-using namespace std;
-
-#include "LaplacianOptimization.h"
-
-//------------------------------------------------------------------------------
-//	Protected functions
-//------------------------------------------------------------------------------
-//
-//  LaplacianOptimization::_reset --        reset the class
-//
-//  Inputs
-//      none
-//
-//  Outputs
-//      none
-//
-void LaplacianOptimization::_reset( void ) {
-	
-	_optType = LEAST_SQUARE;
-	
-	_nVars = 0;
-	_nConstrs = 0;
-	_iteration = 0;
-}
-
-//
-//  LaplacianOptimization::_LeastSquare --        optimization
-//
-//  Inputs
-//      none
-//
-//  Outputs
-//      err:
-//
-double LaplacianOptimization::_LeastSquare( void ) {
-	
-	double mse = 0.0;
-	unsigned int iter = _iteration;
-	for( int i = 0; i < iter; i++ ) {
-		
-		Eigen::VectorXd last_var = _var;
-
-#ifdef  DEBUG_TIME
-		clock_t start_time = 0;
-		float time1 = 0, time2 = 0, time3 = 0, time4 = 0;
-		start_time = clock();
-#endif  // DEBUG_TIME
-		
-		// ### optimization ###
-		_var = ( ( _coef.transpose() * _coef ) ).inverse() * _coef.transpose() * _output;
-#ifdef  DEBUG_TIME
-		time1 = clock() - start_time;
-		start_time = clock();
-#endif  // DEBUG_TIME
-		
-		// ### retrieve the result ###
-		retrieve();
-#ifdef  DEBUG_TIME
-		time2 = clock() - start_time;
-		start_time = clock();
-#endif  // DEBUG_TIME
-		
-		// ### update coefficient matrix ###
-		_updateCoefs();
-#ifdef  DEBUG_TIME
-		time3 = clock() - start_time;
-		start_time = clock();
-#endif  // DEBUG_TIME
-		
-		// ### update target values ###
-		_updateOutputs();
-#ifdef  DEBUG_TIME
-		time4 = clock() - start_time;
-#endif  // DEBUG_TIME
-		
-		// node movement
-		Eigen::VectorXd err = last_var - _var;
-		mse = err.adjoint() * err;
-		
-		if( ( i + 1 ) % 100 == 0 )
-			cerr << setprecision( 10 ) << "Loop(" << i << ") mse = " << mse << endl;
-#ifdef  DEBUG_TIME
-		cerr << "time1 = " << time1 << " time2 = " << time2 << " time3 = " << time3 << " time4 = " << time4 << endl;
-#endif  // DEBUG_TIME
-		if( ( mse ) < 5.0e-4 ) break;
-	}
-
-#ifdef  DEBUG
-	cerr << "_var:" << endl;
-	cerr << _var << endl;
-#endif  // DEBUG
-	return mse;
-}
-
-//
-//  LaplacianOptimization::_ConjugateGradient --        optimization
-//
-//  Inputs
-//      none
-//
-//  Outputs
-//      err
-//
-double LaplacianOptimization::_ConjugateGradient( void ) {
-
-	unsigned int iter = _iteration;
-	
-	// initialization, prepareBoundary the square matrix
-	Eigen::MatrixXd A;
-	Eigen::VectorXd b, Ap;
-	A = _coef.transpose() * _coef;
-	b = _coef.transpose() * _output;
-
-	// initialization
-	Eigen::VectorXd err = b - A * _var;
-	Eigen::VectorXd p = err;
-	double rsold = err.adjoint() * err;
-
-	// main algorithm
-	// cerr << "iter = " << iter << endl;
-	for( int i = 0; i < iter; i++ ) {
-
-		// cerr << "i = " << i << endl;
-		// prepareBoundary the square matrix
-		A = _coef.transpose() * _coef;
-		b = _coef.transpose() * _output;
-		Ap = A * p;
-
-		double alpha = ( double ) ( p.transpose() * err ) / ( double ) ( p.transpose() * Ap );
-		_var = _var + alpha * p;
-		err = b - A * _var;
-
-		if( sqrt( err.adjoint() * err ) < 1e-10 ) {
-			cerr << "sqrterror(" << i << ") = " << sqrt( err.adjoint() * err ) << endl;
-			break;
-		}
-		else {
-			double beta = -1.0 * ( double ) ( err.transpose() * Ap ) / ( double ) ( p.transpose() * Ap );
-			p = err + beta * p;
-		}
-
-		// update
-		retrieve();
-		_updateCoefs();
-		_updateOutputs();
-	}
-
-	// cerr << "sqrterror = " << sqrt( err.adjoint() * err ) << endl;
-	return sqrt( err.adjoint() * err );
-}
-
-//
-//  LaplacianOptimization::clear --        memory management
-//
-//  Inputs
-//      none
-//
-//  Outputs
-//      none
-//
-void LaplacianOptimization::clear( void ) {
-
-}
-
-//------------------------------------------------------------------------------
-//	Public functions
-//------------------------------------------------------------------------------
-
-
-//------------------------------------------------------------------------------
-//	Destructor
-//------------------------------------------------------------------------------
Index: Optimization/src/Schematization.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Orthogonal.cpp\r\n//  : program file for the boundary network\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//              Date: Mon Dec 10 04:28:26 2012\r\n//\r\n//==============================================================================\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <iostream>\r\n#include <fstream>\r\n#include <cassert>\r\n#include <cmath>\r\n\r\nusing namespace std;\r\n\r\n#include <qapplication.h>\r\n#include \"Schematization.h\"\r\n\r\n//template function bodies need to ALL be in the header files\r\n//template class Schematization< Graph::SchematicGraph >;\r\n\r\n//------------------------------------------------------------------------------\r\n//\tProtected functions\r\n//------------------------------------------------------------------------------\r\n\r\n//------------------------------------------------------------------------------\r\n//\tPublic functions\r\n//------------------------------------------------------------------------------\r\n//\r\n//  Schematization::clear --        memory management\r\n//\r\n//  Inputs\r\n//      none\r\n//\r\n//  Outputs\r\n//      none\r\n//\r\ntemplate <typename GraphType>\r\nvoid Schematization<GraphType>::clear( void ) {\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n//\tPublic functions\r\n//------------------------------------------------------------------------------\r\n//\r\n//  Schematization::Orthogonal -- copy constructor\r\n//\r\n//  Inputs\r\n//  obj : object of this class\r\n//\r\n//  Outputs\r\n//  none\r\n//\r\ntemplate <typename GraphType>\r\nSchematization<GraphType>::Schematization( const Schematization<GraphType> &obj ) {\r\n\r\n\t_optType = obj._opttype;\r\n\r\n\t_graph = obj._graph;\r\n\t_half_width = obj._half_width;      // window_width\r\n\t_half_height = obj._half_height;    // window_height\r\n\r\n\t_nVars = obj._nVars;\r\n\t_nConstrs = obj._nConstrs;\r\n\t_w_schematization = obj._w_Orthogonal;\r\n\t_w_position = obj._w_position;\r\n\t_w_fixposition = obj._w_fixposition;\r\n\t_w_boundary = obj._w_boundary;\r\n\t_w_crossing = obj._w_crossing;\r\n\t//_d_Alpha = obj._d_Alpha;\r\n\t_d_Beta = obj._d_Beta;\r\n\t_theta = obj._theta;\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDestructor\r\n//------------------------------------------------------------------------------\r\n//\r\n//  Schematization::~Orthogonal --    destructor\r\n//\r\n//  Inputs\r\n//  none\r\n//\r\n//  Outputs\r\n//  none\r\n//\r\ntemplate <typename GraphType>\r\nSchematization<GraphType>::~Schematization<GraphType>( void ) {\r\n}\r\n\r\n// end of header file\r\n// Do not add any stuff under this line.\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Optimization/src/Schematization.cpp b/Optimization/src/Schematization.cpp
--- a/Optimization/src/Schematization.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Optimization/src/Schematization.cpp	(date 1729410604930)
@@ -1,99 +1,0 @@
-// Orthogonal.cpp
-//  : program file for the boundary network
-//
-//------------------------------------------------------------------------------
-//
-//              Date: Mon Dec 10 04:28:26 2012
-//
-//==============================================================================
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <iostream>
-#include <fstream>
-#include <cassert>
-#include <cmath>
-
-using namespace std;
-
-#include <qapplication.h>
-#include "Schematization.h"
-
-//template function bodies need to ALL be in the header files
-//template class Schematization< Graph::SchematicGraph >;
-
-//------------------------------------------------------------------------------
-//	Protected functions
-//------------------------------------------------------------------------------
-
-//------------------------------------------------------------------------------
-//	Public functions
-//------------------------------------------------------------------------------
-//
-//  Schematization::clear --        memory management
-//
-//  Inputs
-//      none
-//
-//  Outputs
-//      none
-//
-template <typename GraphType>
-void Schematization<GraphType>::clear( void ) {
-}
-
-//------------------------------------------------------------------------------
-//	Public functions
-//------------------------------------------------------------------------------
-//
-//  Schematization::Orthogonal -- copy constructor
-//
-//  Inputs
-//  obj : object of this class
-//
-//  Outputs
-//  none
-//
-template <typename GraphType>
-Schematization<GraphType>::Schematization( const Schematization<GraphType> &obj ) {
-
-	_optType = obj._opttype;
-
-	_graph = obj._graph;
-	_half_width = obj._half_width;      // window_width
-	_half_height = obj._half_height;    // window_height
-
-	_nVars = obj._nVars;
-	_nConstrs = obj._nConstrs;
-	_w_schematization = obj._w_Orthogonal;
-	_w_position = obj._w_position;
-	_w_fixposition = obj._w_fixposition;
-	_w_boundary = obj._w_boundary;
-	_w_crossing = obj._w_crossing;
-	//_d_Alpha = obj._d_Alpha;
-	_d_Beta = obj._d_Beta;
-	_theta = obj._theta;
-}
-
-
-//------------------------------------------------------------------------------
-//	Destructor
-//------------------------------------------------------------------------------
-//
-//  Schematization::~Orthogonal --    destructor
-//
-//  Inputs
-//  none
-//
-//  Outputs
-//  none
-//
-template <typename GraphType>
-Schematization<GraphType>::~Schematization<GraphType>( void ) {
-}
-
-// end of header file
-// Do not add any stuff under this line.
-
Index: Base/src/Coord2.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// Coord2.cc\r\n//\t: program file for 2D coordinatse\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Sun Sep 16 15:02:45 2012\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <iostream>\r\n#include <iomanip>\r\n#include <cctype>\r\n#include <cmath>\r\n#include <algorithm>\r\nusing namespace std;\r\n\r\n#include \"Common.h\"\r\n#include \"Coord2.h\"\r\n\r\nnamespace KeiRo {\r\nnamespace Base {\r\n\r\n//------------------------------------------------------------------------------\r\n//\tMacro Definitions\r\n//------------------------------------------------------------------------------\r\n\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tProtected Functions\r\n//------------------------------------------------------------------------------\r\n\r\n//\r\n//  Coord2::_init --\t\u001B$B$9$Y$F$NMWAG$r%<%m$K$9$k\u001B(B\r\n//\r\n//  \u001B$B0z?t\u001B(B\r\n//\t\u001B$B$J$7\u001B(B\r\n//\r\n//  \u001B$BJV$jCM\u001B(B\r\n//\t\u001B$B$J$7\u001B(B\r\n//\r\nvoid Coord2::_init( void )\r\n{\r\n\t_oldElement[ 0 ] = _oldElement[ 1 ] = 0.0;\r\n    _element[ 0 ] = _element[ 1 ] = 0.0;\r\n    _inLocalMove = false;\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n//\tPublic functions\r\n//------------------------------------------------------------------------------\r\n\r\n//------------------------------------------------------------------------------\r\n//\tConstuructors\r\n//------------------------------------------------------------------------------\r\n\r\n//\r\n//  Coord2::Coord2 --\t\u001B$B%3%s%9%H%i%/%?\u001B(B(\u001B$B%G%U%)%k%H\u001B(B)\r\n//\r\n//  \u001B$B0z?t\u001B(B\r\n//\t\u001B$B$J$7\u001B(B\r\n//\r\n//  \u001B$BJV$jCM\u001B(B\r\n//\t\u001B$B$J$7\u001B(B\r\n//\r\nCoord2::Coord2()\r\n{\r\n    _init();\r\n}\r\n\r\n\r\n//\r\n//  Coord2::Coord2 --\t\u001B$B:BI8$rF~NO\u001B(B\r\n//\r\n//  \u001B$B0z?t\u001B(B\r\n//\tx, y :\t2\u001B$B<!85:BI8\u001B(B\r\n//\r\n//  \u001B$BJV$jCM\u001B(B\r\n//\t\u001B$B$J$7\u001B(B\r\n//\r\nCoord2::Coord2( const double x, const double y )\r\n{\r\n\t_oldElement[ 0 ] = _element[ 0 ]\t= x;\r\n\t_oldElement[ 1 ] = _element[ 1 ]\t= y;\r\n\t_inLocalMove = false;\r\n}\r\n\r\n//\r\n//  Coord2::Coord2 --\t\u001B$B%3%T!<!&%3%s%9%H%i%/%?\u001B(B\r\n//\r\n//  \u001B$B0z?t\u001B(B\r\n//\tv\t: 2\u001B$B<!85%Y%/%H%k!&%*%V%8%'%/%H\u001B(B\r\n//\r\n//  \u001B$BJV$jCM\u001B(B\r\n//\t\u001B$B$J$7\u001B(B\r\n//\r\nCoord2::Coord2( const Coord2 & v )\r\n{\r\n\t_oldElement[ 0 ]\t= v._oldElement[ 0 ];\r\n\t_oldElement[ 1 ]\t= v._oldElement[ 1 ];\r\n    _element[ 0 ]\t= v._element[ 0 ];\r\n    _element[ 1 ]\t= v._element[ 1 ];\r\n    _inLocalMove = false;\r\n }\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tAssignment opereators\r\n//------------------------------------------------------------------------------\r\n\r\n//\r\n//  Coord2::operator = --\tassignment\r\n//\r\n//  Inputs\r\n//\tv\t: 2D coordinates\r\n//\r\n//  Outputs\r\n//\treference to this object\r\n//\r\nCoord2 & Coord2::operator = ( const Coord2 & v )\r\n{\r\n    if ( this != &v ) {\r\n\t    _oldElement[ 0 ]\t= v._oldElement[ 0 ];\r\n\t    _oldElement[ 1 ]\t= v._oldElement[ 1 ];\r\n\t\t_element[ 0 ]\t= v._element[ 0 ];\r\n\t\t_element[ 1 ]\t= v._element[ 1 ];\r\n    }\r\n    return *this;\r\n}\r\n\r\n\r\n//\r\n//  Coord2::operator += --\taddition + assignment\r\n//\r\n//  Inputs\r\n//\tv\t: 2D coordinates\r\n//\r\n//  Outputs\r\n//\treference to this object\r\n//\r\nCoord2 & Coord2::operator += ( const Coord2 & v )\r\n{\r\n    _element[ 0 ]\t+= v._element[ 0 ];\r\n    _element[ 1 ]\t+= v._element[ 1 ];\r\n    return *this;\r\n}\r\n\r\n\r\n//\r\n//  Coord2::operator -= --\tsubtraction + assignment\r\n//\r\n//  Inputs\r\n//\tv\t: 2D coordinates\r\n//\r\n//  Outputs\r\n//\treference to this object\r\n//\r\nCoord2 & Coord2::operator -= ( const Coord2 & v )\r\n{\r\n    _element[ 0 ]\t-= v._element[ 0 ];\r\n    _element[ 1 ]\t-= v._element[ 1 ];\r\n    return *this;\r\n}\r\n\r\n\r\n//\r\n//  Coord2::operator -= --\tscalar product + assignment\r\n//\r\n//  Inputs\r\n//\td\t: scalar value\r\n//\r\n//  Outputs\r\n//\treference to this object\r\n//\r\nCoord2 & Coord2::operator *= ( const double d )\r\n{\r\n    _element[ 0 ]\t*= d;\r\n    _element[ 1 ]\t*= d;\r\n    return *this;\r\n}\r\n\r\n\r\n//\r\n//  Coord2::operator /= --\tscalar division\u001B$B>&\u001B(B + assignment\r\n//\r\n//  Inputs\r\n//\td\t: scalar value\r\n//\r\n//  Outputs\r\n//\treference to this object\r\n//\r\nCoord2 & Coord2::operator /= ( const double d )\r\n{\r\n    double d_inv = 1./d;\r\n    _element[ 0 ]\t\t*= d_inv;\r\n    _element[ 1 ]\t\t*= d_inv;\r\n    return *this;\r\n}\r\n\r\n\r\n//\r\n//  Coord2::operator [] --\treference to an element\r\n//\r\n//  Inputs\r\n//\ti\t: index of the coordinate\r\n//\r\n//  Outputs\r\n//\tthe corresponding coordinate\r\n//\r\nconst double & Coord2::operator [] ( int i ) const\r\n{\r\n#ifdef VEC2_INDEX_CHECK\r\n    const char theName[] = \"Coord2::operator [] : \";\r\n    if ( ( i < 0 ) || ( i > 1 ) ) {\r\n\tcerr << theName << \" index = \" << i << endl;\r\n\tassert( ( 0 <= i ) && ( i <= 1 ) );\r\n    }\r\n#endif\t// VEC2_INDEX_CHECK\r\n    return _element[ i ];\r\n}\r\n\r\n\r\n//\r\n//  Coord2::operator [] --\treference to an element\r\n//\r\n//  Inputs\r\n//\ti\t: index of the coordinate\r\n//\r\n//  Outputs\r\n//\tthe corresponding coordinate\r\n//\r\ndouble & Coord2::operator [] ( int i )\r\n{\r\n#ifdef VEC2_INDEX_CHECK\r\n    const char theName[] = \"Coord2::operator [] : \";\r\n    if ( ( i < 0 ) || ( i > 1 ) ) {\r\n\tcerr << theName << \" index = \" << i << endl;\r\n\tassert( ( 0 <= i ) && ( i <= 1 ) );\r\n    }\r\n#endif\t// VEC2_INDEX_CHECK\r\n    return _element[ i ];\r\n}\r\n\r\n\r\n//\r\n//  Coord2::set --\tset all the coordinates\r\n//\r\n//  Inputs\r\n//\tx, y\t: x and y coordinates\r\n//\r\n//  Returns\r\n//\tnone\r\n//\r\nvoid Coord2::set( const double x, const double y )\r\n{\r\n    _element[ 0 ]\t= x;\r\n    _element[ 1 ]\t= y;\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\t\u001B$B%Y%/%H%kFCM-$N4X?t\u001B(B\r\n//\tSpecial functions\r\n//------------------------------------------------------------------------------\r\n\r\n//\r\n//  Coord2::norm --\treturn the norm of the vector\r\n//\r\n//  Inputs\r\n//\tnone\r\n//\r\n//  Outputs\r\n//\tnorm of this vector\r\n//\r\ndouble Coord2::norm( void ) const\r\n{\r\n    return sqrt( squaredNorm() );\r\n}\r\n\r\n\r\n//\r\n//  Coord2::squaredNorm --\treturn the squared norm of the vector\r\n//\r\n//  Inputs\r\n//\tnone\r\n//\r\n//  Outputs\r\n//\tsquared norm of this vector\r\n//\r\ndouble Coord2::squaredNorm( void ) const\r\n{\r\n    return ( _element[ 0 ]*_element[ 0 ] + _element[ 1 ]*_element[ 1 ] );\r\n}\r\n\r\n\r\n//\r\n//  Coord2::normalize --\tnormalize the vector\r\n//\r\n//  Inputs\r\n//\tnone\r\n//\r\n//  Returns\r\n//\treference to this object (after normalization)\r\n//\r\nCoord2 & Coord2::normalize( void )\r\n    // division-by-zero should be cared by the caller side\r\n{\r\n    double l = norm();\r\n    *this /= l;\r\n    return *this;\r\n}\r\n\r\n\r\n//\r\n//  Coord2::unit --\tcompute the unit vector\r\n//\r\n//  Inputs\r\n//\tnone\r\n//\r\n//  Outputs\r\n//\treturn the unit vector\r\n//\r\nCoord2 Coord2::unit( void ) const\r\n    // division-by-zero should be cared by the caller side\r\n{\r\n    Coord2 ret( *this );\r\n    ret.normalize();\r\n    return ret;\r\n}\r\n\r\n//\r\n//  Coord2::updateOldElement --\tupdate old elements\r\n//\r\n//  Inputs\r\n//\tnone\r\n//\r\n//  Outputs\r\n//\tnone\r\n//\r\nvoid Coord2::updateOldElement( void )\r\n{\r\n\t_oldElement[0] = _element[0];\r\n\t_oldElement[1] = _element[1];\r\n\tresetInLocalMove();\r\n}\r\n\r\nvoid Coord2::updateIntermediateElement( const double x, const double y )\r\n{\r\n    _intermediateElement[ 0 ]\t= x;\r\n    _intermediateElement[ 1 ]\t= y;\r\n    _inLocalMove = true;\r\n}\r\n\r\nvoid Coord2::resetInLocalMove( void )\r\n{\r\n    _inLocalMove = false;\r\n}\r\n\r\n\r\n//\r\n//  Coord2::manhattan --\treturn the Manhattan norm of the vector\r\n//\r\n//  Inputs\r\n//\tnone\r\n//\r\n//  Outputs\r\n//\tManhattan norm\r\n//\r\ndouble Coord2::manhattan( void ) const\r\n{\r\n    return ( fabs( _element[ 0 ] ) + fabs( _element[ 1 ] ) );\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIntersection check\r\n//------------------------------------------------------------------------------\r\n\r\n//\r\n//  Coord2::cross --\tcross product\r\n//\r\n//  Inputs\r\n//\ta, b\t: two input vectors\r\n//\r\n//  Outputs\r\n//\tcross product\r\n//\r\ndouble crossProd( const Coord2 & a, const Coord2 & b )\r\n{\r\n    return ( a.x() * b.y() - b.x() * a.y() );\r\n}\r\n\r\n\r\n//\r\n//  Coord2::doubleArea --\treturn the twice of the triangle area\r\n//\r\n//  Inputs\r\n//\ta, b, c :\tcoordinate of the three corner points\r\n//\r\n//  Outputs\r\n//\ttwice of the area\r\n//\r\ndouble doubleArea( const Coord2 & a, const Coord2 & b, const Coord2 & c )\r\n{\r\n    return crossProd( ( a - b ), ( a - c ) );\r\n}\r\n\r\n\r\n//\r\n//  isSeparate --\treturn true if the bounding boxes spanned by \"a-b\" and\r\n//\t\t\t\"c-d\" has no overlap.\r\n//\r\n//  Inputs\r\n//\ta, b, c :\tcoordinate of the three points\r\n//\r\n//  Outputs\r\n//\tboolean value\r\n//\r\nbool isSeparate( const Coord2 & a, const Coord2 & b, const Coord2 & c, const Coord2 & d )\r\n{\r\n    double xminAB = min( a.x(), b.x() );\r\n    double xmaxAB = max( a.x(), b.x() );\r\n    double yminAB = min( a.y(), b.y() );\r\n    double ymaxAB = max( a.y(), b.y() );\r\n    double xminCD = min( c.x(), d.x() );\r\n    double xmaxCD = max( c.x(), d.x() );\r\n    double yminCD = min( c.y(), d.y() );\r\n    double ymaxCD = max( c.y(), d.y() );\r\n\r\n    if ( xmaxCD < xminAB ) return true;\r\n    if ( xmaxAB < xminCD ) return true;\r\n    if ( ymaxCD < yminAB ) return true;\r\n    if ( ymaxAB < yminCD ) return true;\r\n\r\n    return false;\r\n}\r\n\r\n\r\nbool isCollinear ( const Coord2 & a, const Coord2 & b, const Coord2 & c )\r\n{\r\n    return ( fabs( doubleArea( a, b, c ) ) < 1.0e-8 );\r\n}\r\n\r\nbool isLeft( const Coord2 & a, const Coord2 & b, const Coord2 & c )\r\n{\r\n    return ( doubleArea( a, b, c ) > 1.0e-8 );\r\n}\r\n\r\nbool isCCW( const Coord2 & a, const Coord2 & b, const Coord2 & c )\r\n{\r\n    return isLeft( a, b, c );\r\n}\r\n\r\nbool isLeftOn( const Coord2 & a, const Coord2 & b, const Coord2 & c )\r\n{\r\n    return ( doubleArea( a, b, c ) > -USER_EPS );\r\n}\r\n\r\n\r\n// \r\n//\r\n//  Coord2::isIntersected -\tFind intersection between the segments ab and cd. \r\n//\t\t\t\tIf they are intersected, p will be the\r\n//\t\t\t\tinterecting point and s and t are internal\r\n//\t\t\t\tratios for the two segments, respectively. \r\n//\r\n//  Inputs\r\n//\tnone\r\n//\r\n//  Outputs\r\n//\tboolean value acoording to the intersection between two line segments\r\n//\r\nbool isIntersected( const Coord2 & a, const Coord2 & b, const Coord2 & c, const Coord2 & d ) \r\n{\r\n    if ( isSeparate( a, b, c, d ) ) return false;\r\n\r\n    if ( isCollinear( a, b, c ) ||\r\n\t isCollinear( a, b, d ) ||\r\n\t isCollinear( c, d, a ) ||\r\n\t isCollinear( c, d, a ) ) return false;\r\n\r\n    return ( ( doubleArea( a, b, c ) * doubleArea( a, b, d ) < 0.0 ) &&\r\n\t     ( doubleArea( c, d, a ) * doubleArea( c, d, b ) < 0.0 ) ); \r\n}\r\n\r\n\r\n// \r\n//\r\n//  Coord2::isIntersected -\tFind intersection between the segments ab and cd. \r\n//\t\t\t\tIf they are intersected, p will be the\r\n//\t\t\t\tinterecting point and s and t are internal\r\n//\t\t\t\tratios for the two segments, respectively. \r\n//\r\n//  Inputs\r\n//\tintersection\t: intersection point\r\n//\r\n//  Outputs\r\n//\tboolean value acoording to the intersection between two line segments\r\n//\r\nbool isIntersected( const Coord2 & a, const Coord2 & b, const Coord2 & c, const Coord2 & d,\r\n\t\t    Coord2 & intersection ) \r\n{\r\n#ifdef DEBUG\r\n    cerr << \" a = \" << a.x << \" , \" << a.y << endl;\r\n    cerr << \" b = \" << b.x << \" , \" << b.y << endl;\r\n    cerr << \" c = \" << c.x << \" , \" << c.y << endl;\r\n    cerr << \" d = \" << d.x << \" , \" << d.y << endl;\r\n#endif\t// DEBUG\r\n\r\n    double denominator =\r\n        ( double )a.x() * ( double )( d.y() - c.y() ) +\r\n        ( double )b.x() * ( double )( c.y() - d.y() ) +\r\n        ( double )d.x() * ( double )( b.y() - a.y() ) +\r\n        ( double )c.x() * ( double )( a.y() - b.y() );\r\n\r\n    // If denominator vanishes, the two segments are parallel to each other\r\n    // In that case, return false\r\n    if ( fabs( denominator ) < USER_EPS ) return false;\r\n\r\n    double s =  (\r\n\t\t ( double )a.x() * ( double )( d.y() - c.y() ) +\r\n\t\t ( double )c.x() * ( double )( a.y() - d.y() ) +\r\n\t\t ( double )d.x() * ( double )( c.y() - a.y() )\r\n\t\t ) / denominator;\r\n    double t = -( \r\n\t\t ( double )a.x() * ( double )( c.y() - b.y() ) +\r\n\t\t ( double )b.x() * ( double )( a.y() - c.y() ) +\r\n\t\t ( double )c.x() * ( double )( b.y() - a.y() )\r\n\t\t  ) / denominator;\r\n\r\n#ifdef DEBUG\r\n    cerr << \" deno = \" << denominator << \" s = \" << s << \" t = \" << t << endl;\r\n#endif  // DEBUG\r\n\r\n    // If the intersecting point exists within the segments, return true\r\n    if ( ( -USER_EPS <= s ) && ( s <= 1.0 + USER_EPS ) &&\r\n         ( -USER_EPS <= t ) && ( t <= 1.0 + USER_EPS ) ) {\r\n#ifdef NONEED\r\n        s = MIN2( 1.0, MAX2( 0.0, s ) );\r\n        t = MIN2( 1.0, MAX2( 0.0, t ) );\r\n#endif\t// NONEED\r\n#ifdef DEBUG\r\n\tcerr << \" True\" << endl;\r\n#endif\t// DEBUG\r\n\tintersection.setX( ( double )a.x() + s * ( double )( b.x() - a.x() ) );\r\n\tintersection.setY( ( double )a.y() + s * ( double )( b.y() - a.y() ) );\r\n        return true;\r\n    }\r\n    else {\r\n#ifdef DEBUG\r\n\tcerr << \" False\" << endl;\r\n#endif\t// DEBUG\r\n        return false;\r\n    }\r\n}\r\n\r\n\r\n// \r\n//\r\n//  Coord2::isIntersected -\tFind intersection between the segments ab and cd. \r\n//\t\t\t\tIf they are intersected, p will be the\r\n//\t\t\t\tinterecting point and s and t are internal\r\n//\t\t\t\tratios for the two segments, respectively. \r\n//\r\n//  Inputs\r\n//\tnone\r\n//\r\n//  Outputs\r\n//\tboolean value acoording to the intersection between two line segments\r\n//\r\nbool doConflict( const Coord2 & a, const Coord2 & b, const Coord2 & c, const Coord2 & d ) \r\n{\r\n    const double gap = 0.01;\r\n    Coord2 cc =   (1.0+gap) * c - gap * d;\r\n    Coord2 dd =  -gap * c + (1.0+gap) * d;\r\n\r\n    if ( isSeparate( a, b, cc, dd ) ) return false;\r\n\r\n    if ( isCollinear( a, b, cc ) ||\r\n\t isCollinear( a, b, dd ) ||\r\n\t isCollinear( cc, dd, a ) ||\r\n\t isCollinear( cc, dd, a ) ) return false;\r\n\r\n    return ( ( doubleArea( a, b, cc ) * doubleArea( a, b, dd ) < 0.0 ) &&\r\n\t     ( doubleArea( cc, dd, a ) * doubleArea( cc, dd, b ) < 0.0 ) ); \r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tFriend functions\r\n//------------------------------------------------------------------------------\r\n\r\n//\r\n//  operator - --\tsign change\r\n//\r\n//  Inputs\r\n//\ta\t: 2D coordinates\r\n//\r\n//  Outputs\r\n//\t2D coordinates in the opposite direction\r\n//\r\nCoord2 operator - ( const Coord2 & a )\r\n{\r\n    return Coord2( -a._element[ 0 ], -a._element[ 1 ] );\r\n}\r\n\r\n\r\n//\r\n//  operator + --\taddition\r\n//\r\n//  Inputs\r\n//\ta, b\t: 2D coordinates\r\n//\r\n//  Outputs\r\n//\taddition of the two 2D coordinates\r\n//\r\nCoord2 operator + ( const Coord2 & a, const Coord2 & b )\r\n{\r\n    return Coord2( a._element[ 0 ] + b._element[ 0 ],\r\n\t\t   a._element[ 1 ] + b._element[ 1 ] );\r\n}\r\n\r\n\r\n//\r\n//  operator - --\tdifference\r\n//\r\n//  Inputs\r\n//\ta, b\t: 2D coordinates\r\n//\r\n//  Outputs\r\n//\tdifference of the two 2D coordinates\r\n//\r\nCoord2 operator - ( const Coord2 & a, const Coord2 & b )\r\n{\r\n    return Coord2( a._element[ 0 ] - b._element[ 0 ],\r\n\t\t   a._element[ 1 ] - b._element[ 1 ] );\r\n}\r\n\r\n\r\n//\r\n//  operator * --\tscalar product\r\n//\r\n//  Inputs\r\n//\td\t: scalar value\r\n//\ta\t: 2D coordinates\r\n//\r\n//  Outputs\r\n//\tscalar product \r\n//\r\nCoord2 operator * ( const double d, const Coord2 & a )\r\n{\r\n    return Coord2( d * a._element[ 0 ], d * a._element[ 1 ] );\r\n}\r\n\r\n\r\n//\r\n//  operator * --\tinner product\r\n//\r\n//  Inputs\r\n//\ta, b\t: 2D coordinates\r\n//\r\n//  Outputs\r\n//\tinner product\r\n//\r\ndouble operator * ( const Coord2 & a, const Coord2 & b )\r\n{\r\n    return ( a._element[ 0 ] * b._element[ 0 ] +\r\n\t     a._element[ 1 ] * b._element[ 1 ] );\r\n}\r\n\r\n\r\n//\r\n//  operator / --\tscalar division\r\n//\r\n//  Inputs\r\n//\ta\t: 2D coordinates\r\n//\td\t: scalar value\r\n//\r\n//  Outputs\r\n//\tscalar division\r\n//\r\nCoord2 operator / ( const Coord2 & a, const double d )\r\n{\r\n    double d_inv = 1./d;\r\n    return Coord2( a._element[ 0 ] * d_inv, a._element[ 1 ] * d_inv );\r\n}\r\n\r\n\r\n//\r\n//  operator == --\tequivalence\r\n//\r\n//  Inputs\r\n//\ta, b\t: 2D coordinates\r\n//\r\n//  Outputs\r\n//\tboolean value\r\n//\r\nint operator == ( const Coord2 & a, const Coord2 & b )\r\n{\r\n    return ( ( a._element[ 0 ] == b._element[ 0 ] ) &&\r\n\t     ( a._element[ 1 ] == b._element[ 1 ] ) );\r\n}\r\n\r\n\r\n//\r\n//  operator < --\tcomparison (less than)\r\n//\r\n//  Inputs\r\n//\ta, b\t: 2D coordinates\r\n//\r\n//  Outputs\r\n//\tboolean value\r\n//\r\nint operator < ( const Coord2 & a, const Coord2 & b )\r\n{\r\n    if ( a._element[ 0 ] < b._element[ 0 ] ) return true;\r\n    else if ( a._element[ 0 ] > b._element[ 0 ] ) return false;\r\n    else {\r\n\tif ( a._element[ 1 ] < b._element[ 1 ] ) return true;\r\n\telse if ( a._element[ 1 ] > b._element[ 1 ] ) return false;\r\n\telse return false;\r\n    }\r\n}\r\n\r\n\r\n//\r\n//  operator > --\tcomparison (more than)\r\n//\r\n//  Inputs\r\n//\ta, b\t: 2D coordinates\r\n//\r\n//  Outputs\r\n//\tboolean value\r\n//\r\nint operator > ( const Coord2 & a, const Coord2 & b )\r\n{\r\n    if ( a._element[ 0 ] > b._element[ 0 ] ) return true;\r\n    else if ( a._element[ 0 ] < b._element[ 0 ] ) return false;\r\n    else {\r\n\tif ( a._element[ 1 ] > b._element[ 1 ] ) return true;\r\n\telse if ( a._element[ 1 ] < b._element[ 1 ] ) return false;\r\n\telse return false;\r\n    }\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tI/O functions\r\n//------------------------------------------------------------------------------\r\n\r\n//\r\n//  operator << --\toutput\r\n//\r\n//  Inputs\r\n//\ts\t: reference to output stream\r\n//\tv\t: 2D coordinates\r\n//\r\n//  Outputs\r\n//\treference to output stream\r\n//\r\nostream & operator << ( ostream & stream, const Coord2 & obj )\r\n{\r\n    int i;\t\t// loop counter\r\n    // set the output formatting\r\n    //stream << setiosflags( ios::showpoint );\r\n    //stream << setprecision( 8 );\r\n    //int width = 16;\r\n    // print out the elements\r\n    for ( i = 0; i < 2; i++ ) {\r\n\t//stream << setw( width ) << obj._element[ i ];\r\n\tstream << setw( 4 ) << obj._element[ i ];\r\n\tif ( i != 1 ) stream << \"\\t\";\r\n    }\r\n    stream << endl;\r\n\r\n    return stream;\r\n}\r\n\r\n\r\n//\r\n//  operator >> --\tinput\r\n//\r\n//  Inputs\r\n//\ts\t: reference to input stream\r\n//\tv\t: 2D coordinates\r\n//\r\n//  Outputs\r\n//\treference to input stream\r\n//\r\nistream & operator >> ( istream & stream, Coord2 & obj )\r\n{\r\n    int i;\t\t// loop counter\r\n    // reading the elements\r\n    for ( i = 0; i < 2; i++ )\r\n\tstream >> obj._element[ i ];\r\n    return stream;\r\n}\r\n\r\n\r\n} // namespace Base\r\n} // namespace KeiRo\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Base/src/Coord2.cpp b/Base/src/Coord2.cpp
--- a/Base/src/Coord2.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Base/src/Coord2.cpp	(date 1729410604950)
@@ -1,806 +1,0 @@
-//******************************************************************************
-// Coord2.cc
-//	: program file for 2D coordinatse
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Sun Sep 16 15:02:45 2012
-//
-//******************************************************************************
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <iostream>
-#include <iomanip>
-#include <cctype>
-#include <cmath>
-#include <algorithm>
-using namespace std;
-
-#include "Common.h"
-#include "Coord2.h"
-
-namespace KeiRo {
-namespace Base {
-
-//------------------------------------------------------------------------------
-//	Macro Definitions
-//------------------------------------------------------------------------------
-
-
-
-//------------------------------------------------------------------------------
-//	Protected Functions
-//------------------------------------------------------------------------------
-
-//
-//  Coord2::_init --	$B$9$Y$F$NMWAG$r%<%m$K$9$k(B
-//
-//  $B0z?t(B
-//	$B$J$7(B
-//
-//  $BJV$jCM(B
-//	$B$J$7(B
-//
-void Coord2::_init( void )
-{
-	_oldElement[ 0 ] = _oldElement[ 1 ] = 0.0;
-    _element[ 0 ] = _element[ 1 ] = 0.0;
-    _inLocalMove = false;
-}
-
-//------------------------------------------------------------------------------
-//	Public functions
-//------------------------------------------------------------------------------
-
-//------------------------------------------------------------------------------
-//	Constuructors
-//------------------------------------------------------------------------------
-
-//
-//  Coord2::Coord2 --	$B%3%s%9%H%i%/%?(B($B%G%U%)%k%H(B)
-//
-//  $B0z?t(B
-//	$B$J$7(B
-//
-//  $BJV$jCM(B
-//	$B$J$7(B
-//
-Coord2::Coord2()
-{
-    _init();
-}
-
-
-//
-//  Coord2::Coord2 --	$B:BI8$rF~NO(B
-//
-//  $B0z?t(B
-//	x, y :	2$B<!85:BI8(B
-//
-//  $BJV$jCM(B
-//	$B$J$7(B
-//
-Coord2::Coord2( const double x, const double y )
-{
-	_oldElement[ 0 ] = _element[ 0 ]	= x;
-	_oldElement[ 1 ] = _element[ 1 ]	= y;
-	_inLocalMove = false;
-}
-
-//
-//  Coord2::Coord2 --	$B%3%T!<!&%3%s%9%H%i%/%?(B
-//
-//  $B0z?t(B
-//	v	: 2$B<!85%Y%/%H%k!&%*%V%8%'%/%H(B
-//
-//  $BJV$jCM(B
-//	$B$J$7(B
-//
-Coord2::Coord2( const Coord2 & v )
-{
-	_oldElement[ 0 ]	= v._oldElement[ 0 ];
-	_oldElement[ 1 ]	= v._oldElement[ 1 ];
-    _element[ 0 ]	= v._element[ 0 ];
-    _element[ 1 ]	= v._element[ 1 ];
-    _inLocalMove = false;
- }
-
-
-//------------------------------------------------------------------------------
-//	Assignment opereators
-//------------------------------------------------------------------------------
-
-//
-//  Coord2::operator = --	assignment
-//
-//  Inputs
-//	v	: 2D coordinates
-//
-//  Outputs
-//	reference to this object
-//
-Coord2 & Coord2::operator = ( const Coord2 & v )
-{
-    if ( this != &v ) {
-	    _oldElement[ 0 ]	= v._oldElement[ 0 ];
-	    _oldElement[ 1 ]	= v._oldElement[ 1 ];
-		_element[ 0 ]	= v._element[ 0 ];
-		_element[ 1 ]	= v._element[ 1 ];
-    }
-    return *this;
-}
-
-
-//
-//  Coord2::operator += --	addition + assignment
-//
-//  Inputs
-//	v	: 2D coordinates
-//
-//  Outputs
-//	reference to this object
-//
-Coord2 & Coord2::operator += ( const Coord2 & v )
-{
-    _element[ 0 ]	+= v._element[ 0 ];
-    _element[ 1 ]	+= v._element[ 1 ];
-    return *this;
-}
-
-
-//
-//  Coord2::operator -= --	subtraction + assignment
-//
-//  Inputs
-//	v	: 2D coordinates
-//
-//  Outputs
-//	reference to this object
-//
-Coord2 & Coord2::operator -= ( const Coord2 & v )
-{
-    _element[ 0 ]	-= v._element[ 0 ];
-    _element[ 1 ]	-= v._element[ 1 ];
-    return *this;
-}
-
-
-//
-//  Coord2::operator -= --	scalar product + assignment
-//
-//  Inputs
-//	d	: scalar value
-//
-//  Outputs
-//	reference to this object
-//
-Coord2 & Coord2::operator *= ( const double d )
-{
-    _element[ 0 ]	*= d;
-    _element[ 1 ]	*= d;
-    return *this;
-}
-
-
-//
-//  Coord2::operator /= --	scalar division$B>&(B + assignment
-//
-//  Inputs
-//	d	: scalar value
-//
-//  Outputs
-//	reference to this object
-//
-Coord2 & Coord2::operator /= ( const double d )
-{
-    double d_inv = 1./d;
-    _element[ 0 ]		*= d_inv;
-    _element[ 1 ]		*= d_inv;
-    return *this;
-}
-
-
-//
-//  Coord2::operator [] --	reference to an element
-//
-//  Inputs
-//	i	: index of the coordinate
-//
-//  Outputs
-//	the corresponding coordinate
-//
-const double & Coord2::operator [] ( int i ) const
-{
-#ifdef VEC2_INDEX_CHECK
-    const char theName[] = "Coord2::operator [] : ";
-    if ( ( i < 0 ) || ( i > 1 ) ) {
-	cerr << theName << " index = " << i << endl;
-	assert( ( 0 <= i ) && ( i <= 1 ) );
-    }
-#endif	// VEC2_INDEX_CHECK
-    return _element[ i ];
-}
-
-
-//
-//  Coord2::operator [] --	reference to an element
-//
-//  Inputs
-//	i	: index of the coordinate
-//
-//  Outputs
-//	the corresponding coordinate
-//
-double & Coord2::operator [] ( int i )
-{
-#ifdef VEC2_INDEX_CHECK
-    const char theName[] = "Coord2::operator [] : ";
-    if ( ( i < 0 ) || ( i > 1 ) ) {
-	cerr << theName << " index = " << i << endl;
-	assert( ( 0 <= i ) && ( i <= 1 ) );
-    }
-#endif	// VEC2_INDEX_CHECK
-    return _element[ i ];
-}
-
-
-//
-//  Coord2::set --	set all the coordinates
-//
-//  Inputs
-//	x, y	: x and y coordinates
-//
-//  Returns
-//	none
-//
-void Coord2::set( const double x, const double y )
-{
-    _element[ 0 ]	= x;
-    _element[ 1 ]	= y;
-}
-
-
-//------------------------------------------------------------------------------
-//	$B%Y%/%H%kFCM-$N4X?t(B
-//	Special functions
-//------------------------------------------------------------------------------
-
-//
-//  Coord2::norm --	return the norm of the vector
-//
-//  Inputs
-//	none
-//
-//  Outputs
-//	norm of this vector
-//
-double Coord2::norm( void ) const
-{
-    return sqrt( squaredNorm() );
-}
-
-
-//
-//  Coord2::squaredNorm --	return the squared norm of the vector
-//
-//  Inputs
-//	none
-//
-//  Outputs
-//	squared norm of this vector
-//
-double Coord2::squaredNorm( void ) const
-{
-    return ( _element[ 0 ]*_element[ 0 ] + _element[ 1 ]*_element[ 1 ] );
-}
-
-
-//
-//  Coord2::normalize --	normalize the vector
-//
-//  Inputs
-//	none
-//
-//  Returns
-//	reference to this object (after normalization)
-//
-Coord2 & Coord2::normalize( void )
-    // division-by-zero should be cared by the caller side
-{
-    double l = norm();
-    *this /= l;
-    return *this;
-}
-
-
-//
-//  Coord2::unit --	compute the unit vector
-//
-//  Inputs
-//	none
-//
-//  Outputs
-//	return the unit vector
-//
-Coord2 Coord2::unit( void ) const
-    // division-by-zero should be cared by the caller side
-{
-    Coord2 ret( *this );
-    ret.normalize();
-    return ret;
-}
-
-//
-//  Coord2::updateOldElement --	update old elements
-//
-//  Inputs
-//	none
-//
-//  Outputs
-//	none
-//
-void Coord2::updateOldElement( void )
-{
-	_oldElement[0] = _element[0];
-	_oldElement[1] = _element[1];
-	resetInLocalMove();
-}
-
-void Coord2::updateIntermediateElement( const double x, const double y )
-{
-    _intermediateElement[ 0 ]	= x;
-    _intermediateElement[ 1 ]	= y;
-    _inLocalMove = true;
-}
-
-void Coord2::resetInLocalMove( void )
-{
-    _inLocalMove = false;
-}
-
-
-//
-//  Coord2::manhattan --	return the Manhattan norm of the vector
-//
-//  Inputs
-//	none
-//
-//  Outputs
-//	Manhattan norm
-//
-double Coord2::manhattan( void ) const
-{
-    return ( fabs( _element[ 0 ] ) + fabs( _element[ 1 ] ) );
-}
-
-//------------------------------------------------------------------------------
-//	Intersection check
-//------------------------------------------------------------------------------
-
-//
-//  Coord2::cross --	cross product
-//
-//  Inputs
-//	a, b	: two input vectors
-//
-//  Outputs
-//	cross product
-//
-double crossProd( const Coord2 & a, const Coord2 & b )
-{
-    return ( a.x() * b.y() - b.x() * a.y() );
-}
-
-
-//
-//  Coord2::doubleArea --	return the twice of the triangle area
-//
-//  Inputs
-//	a, b, c :	coordinate of the three corner points
-//
-//  Outputs
-//	twice of the area
-//
-double doubleArea( const Coord2 & a, const Coord2 & b, const Coord2 & c )
-{
-    return crossProd( ( a - b ), ( a - c ) );
-}
-
-
-//
-//  isSeparate --	return true if the bounding boxes spanned by "a-b" and
-//			"c-d" has no overlap.
-//
-//  Inputs
-//	a, b, c :	coordinate of the three points
-//
-//  Outputs
-//	boolean value
-//
-bool isSeparate( const Coord2 & a, const Coord2 & b, const Coord2 & c, const Coord2 & d )
-{
-    double xminAB = min( a.x(), b.x() );
-    double xmaxAB = max( a.x(), b.x() );
-    double yminAB = min( a.y(), b.y() );
-    double ymaxAB = max( a.y(), b.y() );
-    double xminCD = min( c.x(), d.x() );
-    double xmaxCD = max( c.x(), d.x() );
-    double yminCD = min( c.y(), d.y() );
-    double ymaxCD = max( c.y(), d.y() );
-
-    if ( xmaxCD < xminAB ) return true;
-    if ( xmaxAB < xminCD ) return true;
-    if ( ymaxCD < yminAB ) return true;
-    if ( ymaxAB < yminCD ) return true;
-
-    return false;
-}
-
-
-bool isCollinear ( const Coord2 & a, const Coord2 & b, const Coord2 & c )
-{
-    return ( fabs( doubleArea( a, b, c ) ) < 1.0e-8 );
-}
-
-bool isLeft( const Coord2 & a, const Coord2 & b, const Coord2 & c )
-{
-    return ( doubleArea( a, b, c ) > 1.0e-8 );
-}
-
-bool isCCW( const Coord2 & a, const Coord2 & b, const Coord2 & c )
-{
-    return isLeft( a, b, c );
-}
-
-bool isLeftOn( const Coord2 & a, const Coord2 & b, const Coord2 & c )
-{
-    return ( doubleArea( a, b, c ) > -USER_EPS );
-}
-
-
-// 
-//
-//  Coord2::isIntersected -	Find intersection between the segments ab and cd. 
-//				If they are intersected, p will be the
-//				interecting point and s and t are internal
-//				ratios for the two segments, respectively. 
-//
-//  Inputs
-//	none
-//
-//  Outputs
-//	boolean value acoording to the intersection between two line segments
-//
-bool isIntersected( const Coord2 & a, const Coord2 & b, const Coord2 & c, const Coord2 & d ) 
-{
-    if ( isSeparate( a, b, c, d ) ) return false;
-
-    if ( isCollinear( a, b, c ) ||
-	 isCollinear( a, b, d ) ||
-	 isCollinear( c, d, a ) ||
-	 isCollinear( c, d, a ) ) return false;
-
-    return ( ( doubleArea( a, b, c ) * doubleArea( a, b, d ) < 0.0 ) &&
-	     ( doubleArea( c, d, a ) * doubleArea( c, d, b ) < 0.0 ) ); 
-}
-
-
-// 
-//
-//  Coord2::isIntersected -	Find intersection between the segments ab and cd. 
-//				If they are intersected, p will be the
-//				interecting point and s and t are internal
-//				ratios for the two segments, respectively. 
-//
-//  Inputs
-//	intersection	: intersection point
-//
-//  Outputs
-//	boolean value acoording to the intersection between two line segments
-//
-bool isIntersected( const Coord2 & a, const Coord2 & b, const Coord2 & c, const Coord2 & d,
-		    Coord2 & intersection ) 
-{
-#ifdef DEBUG
-    cerr << " a = " << a.x << " , " << a.y << endl;
-    cerr << " b = " << b.x << " , " << b.y << endl;
-    cerr << " c = " << c.x << " , " << c.y << endl;
-    cerr << " d = " << d.x << " , " << d.y << endl;
-#endif	// DEBUG
-
-    double denominator =
-        ( double )a.x() * ( double )( d.y() - c.y() ) +
-        ( double )b.x() * ( double )( c.y() - d.y() ) +
-        ( double )d.x() * ( double )( b.y() - a.y() ) +
-        ( double )c.x() * ( double )( a.y() - b.y() );
-
-    // If denominator vanishes, the two segments are parallel to each other
-    // In that case, return false
-    if ( fabs( denominator ) < USER_EPS ) return false;
-
-    double s =  (
-		 ( double )a.x() * ( double )( d.y() - c.y() ) +
-		 ( double )c.x() * ( double )( a.y() - d.y() ) +
-		 ( double )d.x() * ( double )( c.y() - a.y() )
-		 ) / denominator;
-    double t = -( 
-		 ( double )a.x() * ( double )( c.y() - b.y() ) +
-		 ( double )b.x() * ( double )( a.y() - c.y() ) +
-		 ( double )c.x() * ( double )( b.y() - a.y() )
-		  ) / denominator;
-
-#ifdef DEBUG
-    cerr << " deno = " << denominator << " s = " << s << " t = " << t << endl;
-#endif  // DEBUG
-
-    // If the intersecting point exists within the segments, return true
-    if ( ( -USER_EPS <= s ) && ( s <= 1.0 + USER_EPS ) &&
-         ( -USER_EPS <= t ) && ( t <= 1.0 + USER_EPS ) ) {
-#ifdef NONEED
-        s = MIN2( 1.0, MAX2( 0.0, s ) );
-        t = MIN2( 1.0, MAX2( 0.0, t ) );
-#endif	// NONEED
-#ifdef DEBUG
-	cerr << " True" << endl;
-#endif	// DEBUG
-	intersection.setX( ( double )a.x() + s * ( double )( b.x() - a.x() ) );
-	intersection.setY( ( double )a.y() + s * ( double )( b.y() - a.y() ) );
-        return true;
-    }
-    else {
-#ifdef DEBUG
-	cerr << " False" << endl;
-#endif	// DEBUG
-        return false;
-    }
-}
-
-
-// 
-//
-//  Coord2::isIntersected -	Find intersection between the segments ab and cd. 
-//				If they are intersected, p will be the
-//				interecting point and s and t are internal
-//				ratios for the two segments, respectively. 
-//
-//  Inputs
-//	none
-//
-//  Outputs
-//	boolean value acoording to the intersection between two line segments
-//
-bool doConflict( const Coord2 & a, const Coord2 & b, const Coord2 & c, const Coord2 & d ) 
-{
-    const double gap = 0.01;
-    Coord2 cc =   (1.0+gap) * c - gap * d;
-    Coord2 dd =  -gap * c + (1.0+gap) * d;
-
-    if ( isSeparate( a, b, cc, dd ) ) return false;
-
-    if ( isCollinear( a, b, cc ) ||
-	 isCollinear( a, b, dd ) ||
-	 isCollinear( cc, dd, a ) ||
-	 isCollinear( cc, dd, a ) ) return false;
-
-    return ( ( doubleArea( a, b, cc ) * doubleArea( a, b, dd ) < 0.0 ) &&
-	     ( doubleArea( cc, dd, a ) * doubleArea( cc, dd, b ) < 0.0 ) ); 
-}
-
-
-//------------------------------------------------------------------------------
-//	Friend functions
-//------------------------------------------------------------------------------
-
-//
-//  operator - --	sign change
-//
-//  Inputs
-//	a	: 2D coordinates
-//
-//  Outputs
-//	2D coordinates in the opposite direction
-//
-Coord2 operator - ( const Coord2 & a )
-{
-    return Coord2( -a._element[ 0 ], -a._element[ 1 ] );
-}
-
-
-//
-//  operator + --	addition
-//
-//  Inputs
-//	a, b	: 2D coordinates
-//
-//  Outputs
-//	addition of the two 2D coordinates
-//
-Coord2 operator + ( const Coord2 & a, const Coord2 & b )
-{
-    return Coord2( a._element[ 0 ] + b._element[ 0 ],
-		   a._element[ 1 ] + b._element[ 1 ] );
-}
-
-
-//
-//  operator - --	difference
-//
-//  Inputs
-//	a, b	: 2D coordinates
-//
-//  Outputs
-//	difference of the two 2D coordinates
-//
-Coord2 operator - ( const Coord2 & a, const Coord2 & b )
-{
-    return Coord2( a._element[ 0 ] - b._element[ 0 ],
-		   a._element[ 1 ] - b._element[ 1 ] );
-}
-
-
-//
-//  operator * --	scalar product
-//
-//  Inputs
-//	d	: scalar value
-//	a	: 2D coordinates
-//
-//  Outputs
-//	scalar product 
-//
-Coord2 operator * ( const double d, const Coord2 & a )
-{
-    return Coord2( d * a._element[ 0 ], d * a._element[ 1 ] );
-}
-
-
-//
-//  operator * --	inner product
-//
-//  Inputs
-//	a, b	: 2D coordinates
-//
-//  Outputs
-//	inner product
-//
-double operator * ( const Coord2 & a, const Coord2 & b )
-{
-    return ( a._element[ 0 ] * b._element[ 0 ] +
-	     a._element[ 1 ] * b._element[ 1 ] );
-}
-
-
-//
-//  operator / --	scalar division
-//
-//  Inputs
-//	a	: 2D coordinates
-//	d	: scalar value
-//
-//  Outputs
-//	scalar division
-//
-Coord2 operator / ( const Coord2 & a, const double d )
-{
-    double d_inv = 1./d;
-    return Coord2( a._element[ 0 ] * d_inv, a._element[ 1 ] * d_inv );
-}
-
-
-//
-//  operator == --	equivalence
-//
-//  Inputs
-//	a, b	: 2D coordinates
-//
-//  Outputs
-//	boolean value
-//
-int operator == ( const Coord2 & a, const Coord2 & b )
-{
-    return ( ( a._element[ 0 ] == b._element[ 0 ] ) &&
-	     ( a._element[ 1 ] == b._element[ 1 ] ) );
-}
-
-
-//
-//  operator < --	comparison (less than)
-//
-//  Inputs
-//	a, b	: 2D coordinates
-//
-//  Outputs
-//	boolean value
-//
-int operator < ( const Coord2 & a, const Coord2 & b )
-{
-    if ( a._element[ 0 ] < b._element[ 0 ] ) return true;
-    else if ( a._element[ 0 ] > b._element[ 0 ] ) return false;
-    else {
-	if ( a._element[ 1 ] < b._element[ 1 ] ) return true;
-	else if ( a._element[ 1 ] > b._element[ 1 ] ) return false;
-	else return false;
-    }
-}
-
-
-//
-//  operator > --	comparison (more than)
-//
-//  Inputs
-//	a, b	: 2D coordinates
-//
-//  Outputs
-//	boolean value
-//
-int operator > ( const Coord2 & a, const Coord2 & b )
-{
-    if ( a._element[ 0 ] > b._element[ 0 ] ) return true;
-    else if ( a._element[ 0 ] < b._element[ 0 ] ) return false;
-    else {
-	if ( a._element[ 1 ] > b._element[ 1 ] ) return true;
-	else if ( a._element[ 1 ] < b._element[ 1 ] ) return false;
-	else return false;
-    }
-}
-
-
-//------------------------------------------------------------------------------
-//	I/O functions
-//------------------------------------------------------------------------------
-
-//
-//  operator << --	output
-//
-//  Inputs
-//	s	: reference to output stream
-//	v	: 2D coordinates
-//
-//  Outputs
-//	reference to output stream
-//
-ostream & operator << ( ostream & stream, const Coord2 & obj )
-{
-    int i;		// loop counter
-    // set the output formatting
-    //stream << setiosflags( ios::showpoint );
-    //stream << setprecision( 8 );
-    //int width = 16;
-    // print out the elements
-    for ( i = 0; i < 2; i++ ) {
-	//stream << setw( width ) << obj._element[ i ];
-	stream << setw( 4 ) << obj._element[ i ];
-	if ( i != 1 ) stream << "\t";
-    }
-    stream << endl;
-
-    return stream;
-}
-
-
-//
-//  operator >> --	input
-//
-//  Inputs
-//	s	: reference to input stream
-//	v	: 2D coordinates
-//
-//  Outputs
-//	reference to input stream
-//
-istream & operator >> ( istream & stream, Coord2 & obj )
-{
-    int i;		// loop counter
-    // reading the elements
-    for ( i = 0; i < 2; i++ )
-	stream >> obj._element[ i ];
-    return stream;
-}
-
-
-} // namespace Base
-} // namespace KeiRo
-
Index: Base/src/Common.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// Config.cpp\r\n//\t: program file for system configuration\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Sun Aug 16 15:02:45 2020\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include \"Common.h\"\r\n\r\nusing namespace std;\r\n\r\nnamespace KeiRo {\r\nnamespace Base {\r\n\t\r\n\tdouble Common::_mainwidget_width = 800;\r\n\tdouble Common::_mainwidget_height = 600;\r\n\tdouble Common::_maincontent_width = 800;\r\n\tdouble Common::_maincontent_height = 600;\r\n\tdouble Common::_dockwidget_width = 60;\r\n\tdouble Common::_menubar_height = 60;\r\n\tunsigned int Common::_font_size = 12;\r\n\tstring Common::_batch_str = \"0\";\r\n\t\r\n\t//------------------------------------------------------------------------------\r\n\t//\tPrivate Functions\r\n\t//------------------------------------------------------------------------------\r\n\t\r\n\t//------------------------------------------------------------------------------\r\n\t//\tProtected Functions\r\n\t//------------------------------------------------------------------------------\r\n\t\r\n\t//------------------------------------------------------------------------------\r\n\t//\tPublic functions\r\n\t//------------------------------------------------------------------------------\r\n\t//  Common::_stringToDouble -- convert string to double\r\n\t//\r\n\t//  Inputs\r\n\t//      string\r\n\t//\r\n\t//  Outputs\r\n\t//  double\r\n\t//\r\n\tdouble Common::stringToDouble( const std::string str )\r\n\t{\r\n\t\tstringstream ss( str );\r\n\t\tdouble val = 0;\r\n\t\tss >> val;\r\n\t\t\r\n\t\treturn val;\r\n\t}\r\n\t\r\n\t\r\n\tconst double &Common::getMainwidgetWidth() {\r\n\t\treturn _mainwidget_width;\r\n\t}\r\n\t\r\n\tvoid Common::setMainwidgetWidth( double mainwidgetWidth ) {\r\n\t\t_mainwidget_width = mainwidgetWidth;\r\n\t}\r\n\t\r\n\tdouble & Common::mainwidgetWidth( void ) {\r\n\t\treturn _mainwidget_width;\r\n\t}\r\n\t\r\n\tconst double &Common::getMainwidgetHeight() {\r\n\t\treturn _mainwidget_height;\r\n\t}\r\n\t\r\n\tvoid Common::setMainwidgetHeight( double mainwidgetHeight ) {\r\n\t\t_mainwidget_height = mainwidgetHeight;\r\n\t}\r\n\t\r\n\tdouble & Common::mainwidgetHeight( void ) {\r\n\t\treturn _mainwidget_height;\r\n\t}\r\n\t\r\n\tconst double &Common::getMaincontentWidth() {\r\n\t\treturn _maincontent_width;\r\n\t}\r\n\t\r\n\tvoid Common::setMaincontentWidth( double maincontentWidth ) {\r\n\t\t_maincontent_width = maincontentWidth;\r\n\t}\r\n\t\r\n\tdouble & Common::maincontentWidth( void ) {\r\n\t\treturn _maincontent_width;\r\n\t}\r\n\t\r\n\tconst double &Common::getMaincontentHeight() {\r\n\t\treturn _maincontent_height;\r\n\t}\r\n\t\r\n\tvoid Common::setMaincontentHeight( double maincontentHeight ) {\r\n\t\t_maincontent_height = maincontentHeight;\r\n\t}\r\n\t\r\n\tdouble & Common::maincontentHeight( void ) {\r\n\t\treturn _maincontent_height;\r\n\t}\r\n\t\r\n\tconst double Common::getDockWidgetWidth() {\r\n\t\treturn _dockwidget_width;\r\n\t}\r\n\t\r\n\tvoid Common::setDockWidgetWidth( double dockwidgetWidth ) {\r\n\t\t_dockwidget_width = dockwidgetWidth;\r\n\t}\r\n\t\r\n\tconst double Common::getMenubarHeight() {\r\n\t\treturn _menubar_height;\r\n\t}\r\n\t\r\n\tvoid Common::setMenubarHeight( double menubarHeight ) {\r\n\t\t_menubar_height = menubarHeight;\r\n\t}\r\n\t\r\n\tconst unsigned int Common::getFontSize() {\r\n\t\treturn _font_size;\r\n\t}\r\n\t\r\n\tvoid Common::setFontSize( unsigned int fontSize ) {\r\n\t\t_font_size = fontSize;\r\n\t}\r\n\t\r\n\tconst std::string &Common::getBatchStr( void ) {\r\n\t\treturn _batch_str;\r\n\t}\r\n\t\r\n\tvoid Common::setBatchStr( const std::string &batchStr ) {\r\n\t\t_batch_str = batchStr;\r\n\t}\r\n\t\r\n} // namespace Base\r\n} // namespace KeiRo\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Base/src/Common.cpp b/Base/src/Common.cpp
--- a/Base/src/Common.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Base/src/Common.cpp	(date 1729410604960)
@@ -1,141 +1,0 @@
-//******************************************************************************
-// Config.cpp
-//	: program file for system configuration
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Sun Aug 16 15:02:45 2020
-//
-//******************************************************************************
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include "Common.h"
-
-using namespace std;
-
-namespace KeiRo {
-namespace Base {
-	
-	double Common::_mainwidget_width = 800;
-	double Common::_mainwidget_height = 600;
-	double Common::_maincontent_width = 800;
-	double Common::_maincontent_height = 600;
-	double Common::_dockwidget_width = 60;
-	double Common::_menubar_height = 60;
-	unsigned int Common::_font_size = 12;
-	string Common::_batch_str = "0";
-	
-	//------------------------------------------------------------------------------
-	//	Private Functions
-	//------------------------------------------------------------------------------
-	
-	//------------------------------------------------------------------------------
-	//	Protected Functions
-	//------------------------------------------------------------------------------
-	
-	//------------------------------------------------------------------------------
-	//	Public functions
-	//------------------------------------------------------------------------------
-	//  Common::_stringToDouble -- convert string to double
-	//
-	//  Inputs
-	//      string
-	//
-	//  Outputs
-	//  double
-	//
-	double Common::stringToDouble( const std::string str )
-	{
-		stringstream ss( str );
-		double val = 0;
-		ss >> val;
-		
-		return val;
-	}
-	
-	
-	const double &Common::getMainwidgetWidth() {
-		return _mainwidget_width;
-	}
-	
-	void Common::setMainwidgetWidth( double mainwidgetWidth ) {
-		_mainwidget_width = mainwidgetWidth;
-	}
-	
-	double & Common::mainwidgetWidth( void ) {
-		return _mainwidget_width;
-	}
-	
-	const double &Common::getMainwidgetHeight() {
-		return _mainwidget_height;
-	}
-	
-	void Common::setMainwidgetHeight( double mainwidgetHeight ) {
-		_mainwidget_height = mainwidgetHeight;
-	}
-	
-	double & Common::mainwidgetHeight( void ) {
-		return _mainwidget_height;
-	}
-	
-	const double &Common::getMaincontentWidth() {
-		return _maincontent_width;
-	}
-	
-	void Common::setMaincontentWidth( double maincontentWidth ) {
-		_maincontent_width = maincontentWidth;
-	}
-	
-	double & Common::maincontentWidth( void ) {
-		return _maincontent_width;
-	}
-	
-	const double &Common::getMaincontentHeight() {
-		return _maincontent_height;
-	}
-	
-	void Common::setMaincontentHeight( double maincontentHeight ) {
-		_maincontent_height = maincontentHeight;
-	}
-	
-	double & Common::maincontentHeight( void ) {
-		return _maincontent_height;
-	}
-	
-	const double Common::getDockWidgetWidth() {
-		return _dockwidget_width;
-	}
-	
-	void Common::setDockWidgetWidth( double dockwidgetWidth ) {
-		_dockwidget_width = dockwidgetWidth;
-	}
-	
-	const double Common::getMenubarHeight() {
-		return _menubar_height;
-	}
-	
-	void Common::setMenubarHeight( double menubarHeight ) {
-		_menubar_height = menubarHeight;
-	}
-	
-	const unsigned int Common::getFontSize() {
-		return _font_size;
-	}
-	
-	void Common::setFontSize( unsigned int fontSize ) {
-		_font_size = fontSize;
-	}
-	
-	const std::string &Common::getBatchStr( void ) {
-		return _batch_str;
-	}
-	
-	void Common::setBatchStr( const std::string &batchStr ) {
-		_batch_str = batchStr;
-	}
-	
-} // namespace Base
-} // namespace KeiRo
Index: UI/src/GraphicsPolygonItem.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// GraphicsPolygonItem.h\r\n//\t: header file for polygon items\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Jun 19 02:36:37 2019\r\n//\r\n//******************************************************************************\r\n\r\n#ifndef Ui_Vector_GraphicsPolygonItem_H\r\n#define Ui_Vector_GraphicsPolygonItem_H\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <iostream>\r\n#include <iomanip>\r\n#include <fstream>\r\n#include <map>\r\n#include <list>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <cmath>\r\n#include <ctime>\r\n#include <cstdlib>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\n#include <QtWidgets/QGraphicsScene>\r\n#include <QtWidgets/QGraphicsItem>\r\n//#include <QtGui/QPainter>\r\n//#include <QtCore/QString>\r\n//#include <QtWidgets/QGraphicsSceneMouseEvent>\r\n#include <QPropertyAnimation>\r\n\r\n#ifndef Q_MOC_RUN\r\n#include \"GraphicsBase.h\"\r\n#endif // Q_MOC_RUN\r\n\r\nnamespace Ui {\r\nnamespace Vector {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tClass definition\r\n    //------------------------------------------------------------------------------\r\n    class GraphicsPolygonItem : public QObject, public QGraphicsPolygonItem, public GraphicsBase {\r\n\r\n\t    Q_OBJECT\r\n\t    Q_PROPERTY( QPolygonF polygon READ getPolygon WRITE setPolygon )\r\n\t    Q_INTERFACES( QGraphicsItem )\r\n\t    \r\n    private:\r\n\r\n        QRect           _bbox;\r\n\t    unsigned long   _attributeID;\r\n\t    QBrush          _defaultBrush;\r\n\t    QPen            _defaultPen;\r\n\r\n    protected:\r\n    \t\r\n\t    //------------------------------------------------------------------------------\r\n\t    //\tSpecial functions\r\n\t    //------------------------------------------------------------------------------\r\n\t    void            _init( void );\r\n\t    \r\n    public:\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tConstructors & Destructors\r\n        //------------------------------------------------------------------------------\r\n        // default constructor\r\n        explicit GraphicsPolygonItem( QGraphicsItem *parent = Q_NULLPTR );\r\n        // copy constructor\r\n        explicit GraphicsPolygonItem( QPolygonF &polygon, QGraphicsItem *parent = Q_NULLPTR ) {}\r\n        // destructor\r\n        ~GraphicsPolygonItem( void ) {}\r\n\r\n        // source from the qt library\r\n        //QPainterPath path() const;\r\n        //void setPath(const QPainterPath &path);\r\n\r\n        //QPainterPath shape() const Q_DECL_OVERRIDE;\r\n        //bool contains(const QPointF &point) const Q_DECL_OVERRIDE;\r\n\r\n        //------------------------------------------------------------------------------\r\n        //      Reimplementation\r\n        //------------------------------------------------------------------------------\r\n        QRectF boundingRect() const Q_DECL_OVERRIDE;\r\n        int type( void ) const Q_DECL_OVERRIDE;\r\n\r\n        void paint( QPainter *painter, const QStyleOptionGraphicsItem *option,\r\n                    QWidget *widget = Q_NULLPTR ) Q_DECL_OVERRIDE;\r\n\r\n        //------------------------------------------------------------------------------\r\n        //      Reference to elements\r\n        //------------------------------------------------------------------------------\r\n\r\n        QRect &\t                bbox( void )        { return _bbox; }\r\n        const QRect &\t        bbox( void ) const\t{ return _bbox; }\r\n\t\r\n\t    unsigned long &\t        attributeID( void )         { return _attributeID; }\r\n\t    const unsigned long &\tattributeID( void ) const\t{ return _attributeID; }\r\n\t\r\n\t    QBrush &\t            defaultBrush( void )        { return _defaultBrush; }\r\n\t    const QBrush &\t        defaultBrush( void ) const\t{ return _defaultBrush; }\r\n\t    void                    settoDefaultBrush( void ) \t{ this->setBrush( _defaultBrush ); }\r\n\t\r\n\t    QPen &\t                defaultPen( void )          { return _defaultPen; }\r\n\t    const QPen &\t        defaultPen( void ) const\t{ return _defaultPen; }\r\n\t    void                    settoDefaultPen( void ) \t{ this->setPen( _defaultPen ); }\r\n\r\n\t    QPolygonF               getPolygon() const {\r\n            return polygon();\r\n        }\r\n\t    \r\n\t    //------------------------------------------------------------------------------\r\n\t    //\tSpecial functions\r\n\t    //------------------------------------------------------------------------------\r\n\t    void init( void ) { _init(); }\r\n    };\r\n\r\n} // namespace Vector\r\n} // namespace Ui\r\n\r\n#endif // Ui_Vector_GraphicsPolygonItem_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/UI/src/GraphicsPolygonItem.h b/UI/src/GraphicsPolygonItem.h
--- a/UI/src/GraphicsPolygonItem.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/UI/src/GraphicsPolygonItem.h	(date 1729410605020)
@@ -1,128 +1,0 @@
-//******************************************************************************
-// GraphicsPolygonItem.h
-//	: header file for polygon items
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Jun 19 02:36:37 2019
-//
-//******************************************************************************
-
-#ifndef Ui_Vector_GraphicsPolygonItem_H
-#define Ui_Vector_GraphicsPolygonItem_H
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <iostream>
-#include <iomanip>
-#include <fstream>
-#include <map>
-#include <list>
-#include <vector>
-#include <algorithm>
-#include <cmath>
-#include <ctime>
-#include <cstdlib>
-#include <string>
-
-using namespace std;
-
-#include <QtWidgets/QGraphicsScene>
-#include <QtWidgets/QGraphicsItem>
-//#include <QtGui/QPainter>
-//#include <QtCore/QString>
-//#include <QtWidgets/QGraphicsSceneMouseEvent>
-#include <QPropertyAnimation>
-
-#ifndef Q_MOC_RUN
-#include "GraphicsBase.h"
-#endif // Q_MOC_RUN
-
-namespace Ui {
-namespace Vector {
-
-    //------------------------------------------------------------------------------
-    //	Class definition
-    //------------------------------------------------------------------------------
-    class GraphicsPolygonItem : public QObject, public QGraphicsPolygonItem, public GraphicsBase {
-
-	    Q_OBJECT
-	    Q_PROPERTY( QPolygonF polygon READ getPolygon WRITE setPolygon )
-	    Q_INTERFACES( QGraphicsItem )
-	    
-    private:
-
-        QRect           _bbox;
-	    unsigned long   _attributeID;
-	    QBrush          _defaultBrush;
-	    QPen            _defaultPen;
-
-    protected:
-    	
-	    //------------------------------------------------------------------------------
-	    //	Special functions
-	    //------------------------------------------------------------------------------
-	    void            _init( void );
-	    
-    public:
-
-        //------------------------------------------------------------------------------
-        //	Constructors & Destructors
-        //------------------------------------------------------------------------------
-        // default constructor
-        explicit GraphicsPolygonItem( QGraphicsItem *parent = Q_NULLPTR );
-        // copy constructor
-        explicit GraphicsPolygonItem( QPolygonF &polygon, QGraphicsItem *parent = Q_NULLPTR ) {}
-        // destructor
-        ~GraphicsPolygonItem( void ) {}
-
-        // source from the qt library
-        //QPainterPath path() const;
-        //void setPath(const QPainterPath &path);
-
-        //QPainterPath shape() const Q_DECL_OVERRIDE;
-        //bool contains(const QPointF &point) const Q_DECL_OVERRIDE;
-
-        //------------------------------------------------------------------------------
-        //      Reimplementation
-        //------------------------------------------------------------------------------
-        QRectF boundingRect() const Q_DECL_OVERRIDE;
-        int type( void ) const Q_DECL_OVERRIDE;
-
-        void paint( QPainter *painter, const QStyleOptionGraphicsItem *option,
-                    QWidget *widget = Q_NULLPTR ) Q_DECL_OVERRIDE;
-
-        //------------------------------------------------------------------------------
-        //      Reference to elements
-        //------------------------------------------------------------------------------
-
-        QRect &	                bbox( void )        { return _bbox; }
-        const QRect &	        bbox( void ) const	{ return _bbox; }
-	
-	    unsigned long &	        attributeID( void )         { return _attributeID; }
-	    const unsigned long &	attributeID( void ) const	{ return _attributeID; }
-	
-	    QBrush &	            defaultBrush( void )        { return _defaultBrush; }
-	    const QBrush &	        defaultBrush( void ) const	{ return _defaultBrush; }
-	    void                    settoDefaultBrush( void ) 	{ this->setBrush( _defaultBrush ); }
-	
-	    QPen &	                defaultPen( void )          { return _defaultPen; }
-	    const QPen &	        defaultPen( void ) const	{ return _defaultPen; }
-	    void                    settoDefaultPen( void ) 	{ this->setPen( _defaultPen ); }
-
-	    QPolygonF               getPolygon() const {
-            return polygon();
-        }
-	    
-	    //------------------------------------------------------------------------------
-	    //	Special functions
-	    //------------------------------------------------------------------------------
-	    void init( void ) { _init(); }
-    };
-
-} // namespace Vector
-} // namespace Ui
-
-#endif // Ui_Vector_GraphicsPolygonItem_H
Index: Base/src/Rectangle2.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// Rectangle2.cpp\r\n//\t: program file for 2D Rectangle2 coordinates\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Dec 27 23:15:32 2011\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <iostream>\r\n#include <iomanip>\r\n#include <cctype>\r\n#include <cmath>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\n#include \"Rectangle2.h\"\r\n\r\nnamespace KeiRo {\r\nnamespace Base {\r\n\t\t\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tProtected Functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  Rectangle2::init -- initialization\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void Rectangle2::_init( void )\r\n    {\r\n        _clear();\r\n    }\r\n\r\n    //\r\n    //  Polygon2::_clear --\tclear elements\r\n    //\r\n    //  Inputs\r\n    //\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void Rectangle2::_clear( void )\r\n    {\r\n    \t_leftBottom.zero();\r\n    \t_oldLeftBottom.zero();\r\n\t\t_fixedLeftBottom.zero();\r\n    \t_width = _oldWidth = _fixedWidth = _height = _oldHeight = _fixedHeight = 0.0;\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPublic functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tConstructors & Destructors\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  Rectangle2::Rectangle2 -- default constructor\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    Rectangle2::Rectangle2()\r\n    {\r\n        _init();\r\n        \r\n        //Object::Object();\r\n    }\r\n\r\n    //\r\n    //  Rectangle2::Rectangle2 -- parameterized constructor\r\n    //\r\n    //  Inputs\r\n    //  __elements\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    Rectangle2::Rectangle2( double x, double y, double w, double h )\r\n    {\r\n\t    _leftBottom.x()     = x;\r\n\t    _leftBottom.y()     = y;\r\n\t    _width              = w;\r\n\t    _height             = h;\r\n\t\r\n\t    _fixedLeftBottom.x()  = x;\r\n\t    _fixedLeftBottom.y()  = y;\r\n\t    _fixedWidth           = w;\r\n\t    _fixedHeight          = h;\r\n\t\t\r\n\t    _oldLeftBottom.x()  = x;\r\n\t    _oldLeftBottom.y()  = y;\r\n\t    _oldWidth           = w;\r\n\t    _oldHeight          = h;\r\n\t    \r\n\t    _intermediateLeftBottom.x()= x;\r\n\t    _intermediateLeftBottom.y()= y;\r\n\t    _intermediateWidth\t\t= w;\r\n\t    _intermediateHeight\t= h;\r\n\t    \r\n\t    _unshrunkLeftBottom.x()\t= x;\r\n\t    _unshrunkLeftBottom.y()\t= y;\r\n\t    _unshrunkWidth\t\t= w;\r\n\t    _unshrunkHeight\t\t= h;\r\n\t    \r\n\t    _inLocalMove\t\t= false;\r\n    }\r\n\r\n    //\r\n    //  Polygon2::Polygon2 -- copy constructor\r\n    //\r\n    //  Inputs\r\n    //  polygon\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    Rectangle2::Rectangle2( const Rectangle2 & v )\r\n    {\r\n        _id                 = v._id;\r\n        _gid                = v._gid;\r\n        _name               = v._name;\r\n\t\r\n\t    _leftBottom         = v._leftBottom;\r\n        _width              = v._width;\r\n        _height             = v._height;\r\n\t\r\n\t    _fixedLeftBottom    = v._fixedLeftBottom;\r\n\t    _fixedWidth         = v._fixedWidth;\r\n\t    _fixedHeight        = v._fixedHeight;\r\n\t\t\r\n\t    _oldLeftBottom      = v._oldLeftBottom;\r\n\t    _oldWidth           = v._oldWidth;\r\n\t    _oldHeight          = v._oldHeight;\r\n\t    \r\n\t    _intermediateLeftBottom\t= v._intermediateLeftBottom;\r\n\t    _intermediateWidth\t\t= v._intermediateWidth;\r\n\t    _intermediateHeight\t= v._intermediateHeight;\r\n\t    \r\n\t    _unshrunkLeftBottom\t= v._unshrunkLeftBottom;\r\n\t    _unshrunkWidth\t\t= v._unshrunkWidth;\r\n\t    _unshrunkHeight\t\t= v._unshrunkHeight;\r\n\t    \r\n\t    _inLocalMove\t\t= false;\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tAssignment operators\r\n    //------------------------------------------------------------------------------\r\n\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tSpecial functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  Polygon2::isInside -- check if the vertex inside the rectangle\r\n    //\r\n    //  Inputs\r\n    //  Coord2 c\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    bool Rectangle2::isInside( Coord2 c )\r\n    {\r\n    \tif ( ( _leftBottom.x() < c.x()) && ( c.x() < _leftBottom.x() + _width) &&\r\n\t         ( _leftBottom.y() < c.y()) && ( c.y() < _leftBottom.y() + _height) )\r\n    \t\treturn true;\r\n    \treturn false;\r\n    }\r\n\t\r\n\t//\r\n\t//  Polygon2::isOverlap -- check if the two rectangle overlapped\r\n\t//\r\n\t//  Inputs\r\n\t//  Rectangle2 r\r\n\t//\r\n\t//  Outputs\r\n\t//  none\r\n\t//\r\n\tbool Rectangle2::isOverlap( Rectangle2 r, double &area )\r\n\t{\r\n    \tarea = 0.0;\r\n    \t\r\n    \tCoord2 ci = _leftBottom + Coord2( 0.5*_width, 0.5*_height );\r\n\t\tCoord2 cj = r._leftBottom + Coord2( 0.5*r._width, 0.5*r._height );\r\n    \tdouble w = MAX2( 0.0, MIN2( 0.5*(_width+r._width)-fabs(ci.x()-cj.x()), MIN2( _width, r._width )) );\r\n    \tdouble h = MAX2( 0.0, MIN2( 0.5*(_height+r._height)-fabs(ci.y()-cj.y()), MIN2( _height, r._height )) );\r\n\t\tarea = w*h;\r\n\r\n\t\tif( area > 0.0 ) return true;\r\n\t\telse return false;\r\n\t}\r\n\t\r\n\t//\r\n\t//  Polygon2::isOverlap -- check if the two rectangle overlapped\r\n\t//\r\n\t//  Inputs\r\n\t//  Rectangle2 r\r\n\t//\r\n\t//  Outputs\r\n\t//  none\r\n\t//\r\n\tCoord2 Rectangle2::projectedOnBoundary( Coord2 c )\r\n\t{\r\n\t\tCoord2 projectedC;\r\n\t\tCoord2 diff = c - _leftBottom;\r\n\t\t\r\n\t\tif( isInside( c ) == false ){\r\n\t\t\tcerr << \"sth is wrong here... \" << __LINE__ << \" in file \" << __FILE__ << endl;\r\n\t\t}\r\n\t\t\r\n\t\tdouble left = fabs( diff.x() );\r\n\t\tdouble right = _width - fabs( diff.x() );\r\n\t\tdouble bottom = fabs( diff.y() );\r\n\t\tdouble top = _height - fabs( diff.y() );\r\n\t\t\r\n\t\tif( left < right && left < bottom && left < top ){\r\n\t\t\tprojectedC.x() = _leftBottom.x();\r\n\t\t\tprojectedC.y() = c.y();\r\n\t\t}\r\n\t\tif( right < left && right < bottom && right < top ){\r\n\t\t\tprojectedC.x() = _leftBottom.x() + _width;\r\n\t\t\tprojectedC.y() = c.y();\r\n\t\t}\r\n\t\tif( bottom < left && bottom < right && bottom < top ){\r\n\t\t\tprojectedC.x() = c.x();\r\n\t\t\tprojectedC.y() = _leftBottom.y();\r\n\t\t}\r\n\t\tif( top < left && top < right && top < bottom ){\r\n\t\t\tprojectedC.x() = c.x();\r\n\t\t\tprojectedC.y() = _leftBottom.y() + _height;\r\n\t\t}\r\n#ifdef DEBUG\r\n\t\tcerr << \"c = \" << c\r\n\t\t\t << \"lb = \" << _leftBottom\r\n\t\t\t << \"w = \" << _width << \",h = \" << _height << endl\r\n\t\t\t << \"projC = \" << projectedC << endl;\r\n#endif // DEBUG\r\n\t\treturn projectedC;\r\n\t}\r\n\t\r\n\tvoid Rectangle2::updateOldElement( void )\r\n\t{\r\n\t\t_oldLeftBottom  = _leftBottom;\r\n\t\t_oldWidth       = _width;\r\n\t\t_oldHeight      = _height;\r\n\t\tresetInLocalMove();\r\n\t}\r\n\t\r\n\tvoid Rectangle2::updateIntermediateElement( Coord2 & c, double width, double height )\r\n\t{\r\n\t\t// if already in local move, restrict intermediate element to intersection\r\n\t\tif(_inLocalMove) {\r\n\t\t\t// first fix horizontal measurements\r\n\t\t\tif( c.x() + width < _intermediateLeftBottom.x() + _intermediateWidth ) {\r\n\t\t\t// right side of new box is left of right side of old box\r\n\t\t\t\tif( c.x() < _intermediateLeftBottom.x() ) {\r\n\t\t\t\t// left side of new box is left of left side of old box\r\n\t\t\t\t\t_intermediateWidth = width - (_intermediateLeftBottom.x() - c.x());\r\n\t\t\t\t\t\r\n\t\t\t\t} else { // left side of new box is right of left side of old box\r\n\t\t\t\t\t_intermediateLeftBottom.x() = c.x();\r\n\t\t\t\t\t_intermediateWidth = width;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t// right side of new box is right of right side of old box\r\n\t\t\t\tif( c.x() >= _intermediateLeftBottom.x() ) {\r\n\t\t\t\t// left side of new box is right of left side of old box\r\n\t\t\t\t\t_intermediateWidth = _intermediateWidth - (c.x() - _intermediateLeftBottom.x());\r\n\t\t\t\t\t_intermediateLeftBottom.x() = c.x();\r\n\t\t\t\t\r\n\t\t\t\t} // no 'else' because then the old box is completely inside new box \r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// then fix vertical measurements\r\n\t\t\tif( c.y() + height < _intermediateLeftBottom.y() + _intermediateHeight ) {\r\n\t\t\t// top side of new box is below of top side of old box\r\n\t\t\t\tif( c.y() < _intermediateLeftBottom.y() ) {\r\n\t\t\t\t// bottom side of new box is below the bottom side of old box\r\n\t\t\t\t\t_intermediateHeight = height - (_intermediateLeftBottom.y() - c.y());\r\n\t\t\t\t\t\r\n\t\t\t\t} else { // bottom side of new box is above the bottom side of old box\r\n\t\t\t\t\t_intermediateLeftBottom.y() = c.y();\r\n\t\t\t\t\t_intermediateHeight = height;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t// top side of new box is above the top side of old box\r\n\t\t\t\tif( c.y() >= _intermediateLeftBottom.y() ) {\r\n\t\t\t\t// bottom side of new box is above the bottom side of old box\r\n\t\t\t\t\t_intermediateHeight = _intermediateHeight - (c.y() - _intermediateLeftBottom.y());\r\n\t\t\t\t\t_intermediateLeftBottom.y() = c.y();\r\n\t\t\t\t\r\n\t\t\t\t} // no 'else' because then the old box is completely inside new box \r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t} else { // otherwise simply set intermediate values\r\n\t\t\t_intermediateLeftBottom  = c;\r\n\t\t\t_intermediateWidth       = width;\r\n\t\t\t_intermediateHeight      = height;\r\n\t\t\t_inLocalMove = true;\r\n\t\t}\r\n\t}\r\n\t\r\n\tvoid Rectangle2::updateUnshrunkElement( Coord2 & c, double width, double height )\r\n\t{\r\n\t\t_unshrunkLeftBottom\t= c;\r\n\t\t_unshrunkWidth\t\t= width;\r\n\t\t_unshrunkHeight\t= height;\r\n\t}\r\n\t\r\n\tvoid Rectangle2::resetInLocalMove( void )\r\n\t{\r\n\t\t_inLocalMove = false;\r\n\t}\r\n\t\r\n\tvoid Rectangle2::updateFixedElement( void )\r\n\t{\r\n\t\t_fixedLeftBottom  = _leftBottom;\r\n\t\t_fixedWidth       = _width;\r\n\t\t_fixedHeight      = _height;\r\n\t}\r\n\t\r\n    //------------------------------------------------------------------------------\r\n    //\tFriend functions\r\n    //------------------------------------------------------------------------------\r\n\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tI/O functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  operator << --\toutput\r\n    //\r\n    //  Inputs\r\n    //\ts\t: reference to output stream\r\n    //\tv\t: 2D coordinates\r\n    //\r\n    //  Outputs\r\n    //\treference to output stream\r\n    //\r\n    ostream & operator << ( ostream & stream, const Rectangle2 & obj )\r\n    {\r\n        // set the output formatting\r\n        stream << setiosflags( ios::showpoint );\r\n        stream << setprecision( 8 );\r\n\r\n        int width = 8;\r\n        // print out the elements\r\n        stream << setw( width ) << \"x = \" << obj._leftBottom.x() << \", y = \" << obj._leftBottom.y() << \", \";\r\n\t    stream << setw( width ) << \"w = \" << obj._width << \", h = \" << obj._height << endl;\r\n\t    stream << setw( width ) << \"ox = \" << obj._oldLeftBottom.x() << \", oy = \" << obj._oldLeftBottom.y() << \", \";\r\n\t    stream << setw( width ) << \"ow = \" << obj._oldWidth << \", oh = \" << obj._oldHeight << endl;\r\n//        stream << endl;\r\n\r\n        return stream;\r\n    }\r\n\r\n\r\n    //\r\n    //  operator >> --\tinput\r\n    //\r\n    //  Inputs\r\n    //\ts\t: reference to input stream\r\n    //\tv\t: 2D coordinates\r\n    //\r\n    //  Outputs\r\n    //\treference to input stream\r\n    //\r\n    istream & operator >> ( istream & stream, Rectangle2 & obj )\r\n    {\r\n        return stream;\r\n    }\r\n\r\n\r\n} // namespace Base\r\n} // namespace KeiRo\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Base/src/Rectangle2.cpp b/Base/src/Rectangle2.cpp
--- a/Base/src/Rectangle2.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Base/src/Rectangle2.cpp	(date 1729410605040)
@@ -1,396 +1,0 @@
-//******************************************************************************
-// Rectangle2.cpp
-//	: program file for 2D Rectangle2 coordinates
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Dec 27 23:15:32 2011
-//
-//******************************************************************************
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <iostream>
-#include <iomanip>
-#include <cctype>
-#include <cmath>
-#include <algorithm>
-
-using namespace std;
-
-#include "Rectangle2.h"
-
-namespace KeiRo {
-namespace Base {
-		
-
-    //------------------------------------------------------------------------------
-    //	Protected Functions
-    //------------------------------------------------------------------------------
-    //
-    //  Rectangle2::init -- initialization
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    //
-    void Rectangle2::_init( void )
-    {
-        _clear();
-    }
-
-    //
-    //  Polygon2::_clear --	clear elements
-    //
-    //  Inputs
-    //
-    //
-    //  Outputs
-    //  none
-    //
-    void Rectangle2::_clear( void )
-    {
-    	_leftBottom.zero();
-    	_oldLeftBottom.zero();
-		_fixedLeftBottom.zero();
-    	_width = _oldWidth = _fixedWidth = _height = _oldHeight = _fixedHeight = 0.0;
-    }
-
-    //------------------------------------------------------------------------------
-    //	Public functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Constructors & Destructors
-    //------------------------------------------------------------------------------
-    //
-    //  Rectangle2::Rectangle2 -- default constructor
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    Rectangle2::Rectangle2()
-    {
-        _init();
-        
-        //Object::Object();
-    }
-
-    //
-    //  Rectangle2::Rectangle2 -- parameterized constructor
-    //
-    //  Inputs
-    //  __elements
-    //
-    //  Outputs
-    //  none
-    //
-    Rectangle2::Rectangle2( double x, double y, double w, double h )
-    {
-	    _leftBottom.x()     = x;
-	    _leftBottom.y()     = y;
-	    _width              = w;
-	    _height             = h;
-	
-	    _fixedLeftBottom.x()  = x;
-	    _fixedLeftBottom.y()  = y;
-	    _fixedWidth           = w;
-	    _fixedHeight          = h;
-		
-	    _oldLeftBottom.x()  = x;
-	    _oldLeftBottom.y()  = y;
-	    _oldWidth           = w;
-	    _oldHeight          = h;
-	    
-	    _intermediateLeftBottom.x()= x;
-	    _intermediateLeftBottom.y()= y;
-	    _intermediateWidth		= w;
-	    _intermediateHeight	= h;
-	    
-	    _unshrunkLeftBottom.x()	= x;
-	    _unshrunkLeftBottom.y()	= y;
-	    _unshrunkWidth		= w;
-	    _unshrunkHeight		= h;
-	    
-	    _inLocalMove		= false;
-    }
-
-    //
-    //  Polygon2::Polygon2 -- copy constructor
-    //
-    //  Inputs
-    //  polygon
-    //
-    //  Outputs
-    //  none
-    //
-    Rectangle2::Rectangle2( const Rectangle2 & v )
-    {
-        _id                 = v._id;
-        _gid                = v._gid;
-        _name               = v._name;
-	
-	    _leftBottom         = v._leftBottom;
-        _width              = v._width;
-        _height             = v._height;
-	
-	    _fixedLeftBottom    = v._fixedLeftBottom;
-	    _fixedWidth         = v._fixedWidth;
-	    _fixedHeight        = v._fixedHeight;
-		
-	    _oldLeftBottom      = v._oldLeftBottom;
-	    _oldWidth           = v._oldWidth;
-	    _oldHeight          = v._oldHeight;
-	    
-	    _intermediateLeftBottom	= v._intermediateLeftBottom;
-	    _intermediateWidth		= v._intermediateWidth;
-	    _intermediateHeight	= v._intermediateHeight;
-	    
-	    _unshrunkLeftBottom	= v._unshrunkLeftBottom;
-	    _unshrunkWidth		= v._unshrunkWidth;
-	    _unshrunkHeight		= v._unshrunkHeight;
-	    
-	    _inLocalMove		= false;
-    }
-
-    //------------------------------------------------------------------------------
-    //	Assignment operators
-    //------------------------------------------------------------------------------
-
-
-    //------------------------------------------------------------------------------
-    //	Special functions
-    //------------------------------------------------------------------------------
-    //
-    //  Polygon2::isInside -- check if the vertex inside the rectangle
-    //
-    //  Inputs
-    //  Coord2 c
-    //
-    //  Outputs
-    //  none
-    //
-    bool Rectangle2::isInside( Coord2 c )
-    {
-    	if ( ( _leftBottom.x() < c.x()) && ( c.x() < _leftBottom.x() + _width) &&
-	         ( _leftBottom.y() < c.y()) && ( c.y() < _leftBottom.y() + _height) )
-    		return true;
-    	return false;
-    }
-	
-	//
-	//  Polygon2::isOverlap -- check if the two rectangle overlapped
-	//
-	//  Inputs
-	//  Rectangle2 r
-	//
-	//  Outputs
-	//  none
-	//
-	bool Rectangle2::isOverlap( Rectangle2 r, double &area )
-	{
-    	area = 0.0;
-    	
-    	Coord2 ci = _leftBottom + Coord2( 0.5*_width, 0.5*_height );
-		Coord2 cj = r._leftBottom + Coord2( 0.5*r._width, 0.5*r._height );
-    	double w = MAX2( 0.0, MIN2( 0.5*(_width+r._width)-fabs(ci.x()-cj.x()), MIN2( _width, r._width )) );
-    	double h = MAX2( 0.0, MIN2( 0.5*(_height+r._height)-fabs(ci.y()-cj.y()), MIN2( _height, r._height )) );
-		area = w*h;
-
-		if( area > 0.0 ) return true;
-		else return false;
-	}
-	
-	//
-	//  Polygon2::isOverlap -- check if the two rectangle overlapped
-	//
-	//  Inputs
-	//  Rectangle2 r
-	//
-	//  Outputs
-	//  none
-	//
-	Coord2 Rectangle2::projectedOnBoundary( Coord2 c )
-	{
-		Coord2 projectedC;
-		Coord2 diff = c - _leftBottom;
-		
-		if( isInside( c ) == false ){
-			cerr << "sth is wrong here... " << __LINE__ << " in file " << __FILE__ << endl;
-		}
-		
-		double left = fabs( diff.x() );
-		double right = _width - fabs( diff.x() );
-		double bottom = fabs( diff.y() );
-		double top = _height - fabs( diff.y() );
-		
-		if( left < right && left < bottom && left < top ){
-			projectedC.x() = _leftBottom.x();
-			projectedC.y() = c.y();
-		}
-		if( right < left && right < bottom && right < top ){
-			projectedC.x() = _leftBottom.x() + _width;
-			projectedC.y() = c.y();
-		}
-		if( bottom < left && bottom < right && bottom < top ){
-			projectedC.x() = c.x();
-			projectedC.y() = _leftBottom.y();
-		}
-		if( top < left && top < right && top < bottom ){
-			projectedC.x() = c.x();
-			projectedC.y() = _leftBottom.y() + _height;
-		}
-#ifdef DEBUG
-		cerr << "c = " << c
-			 << "lb = " << _leftBottom
-			 << "w = " << _width << ",h = " << _height << endl
-			 << "projC = " << projectedC << endl;
-#endif // DEBUG
-		return projectedC;
-	}
-	
-	void Rectangle2::updateOldElement( void )
-	{
-		_oldLeftBottom  = _leftBottom;
-		_oldWidth       = _width;
-		_oldHeight      = _height;
-		resetInLocalMove();
-	}
-	
-	void Rectangle2::updateIntermediateElement( Coord2 & c, double width, double height )
-	{
-		// if already in local move, restrict intermediate element to intersection
-		if(_inLocalMove) {
-			// first fix horizontal measurements
-			if( c.x() + width < _intermediateLeftBottom.x() + _intermediateWidth ) {
-			// right side of new box is left of right side of old box
-				if( c.x() < _intermediateLeftBottom.x() ) {
-				// left side of new box is left of left side of old box
-					_intermediateWidth = width - (_intermediateLeftBottom.x() - c.x());
-					
-				} else { // left side of new box is right of left side of old box
-					_intermediateLeftBottom.x() = c.x();
-					_intermediateWidth = width;
-				}
-				
-			} else {
-			// right side of new box is right of right side of old box
-				if( c.x() >= _intermediateLeftBottom.x() ) {
-				// left side of new box is right of left side of old box
-					_intermediateWidth = _intermediateWidth - (c.x() - _intermediateLeftBottom.x());
-					_intermediateLeftBottom.x() = c.x();
-				
-				} // no 'else' because then the old box is completely inside new box 
-				
-			}
-			
-			// then fix vertical measurements
-			if( c.y() + height < _intermediateLeftBottom.y() + _intermediateHeight ) {
-			// top side of new box is below of top side of old box
-				if( c.y() < _intermediateLeftBottom.y() ) {
-				// bottom side of new box is below the bottom side of old box
-					_intermediateHeight = height - (_intermediateLeftBottom.y() - c.y());
-					
-				} else { // bottom side of new box is above the bottom side of old box
-					_intermediateLeftBottom.y() = c.y();
-					_intermediateHeight = height;
-				}
-				
-			} else {
-			// top side of new box is above the top side of old box
-				if( c.y() >= _intermediateLeftBottom.y() ) {
-				// bottom side of new box is above the bottom side of old box
-					_intermediateHeight = _intermediateHeight - (c.y() - _intermediateLeftBottom.y());
-					_intermediateLeftBottom.y() = c.y();
-				
-				} // no 'else' because then the old box is completely inside new box 
-				
-			}
-			
-		} else { // otherwise simply set intermediate values
-			_intermediateLeftBottom  = c;
-			_intermediateWidth       = width;
-			_intermediateHeight      = height;
-			_inLocalMove = true;
-		}
-	}
-	
-	void Rectangle2::updateUnshrunkElement( Coord2 & c, double width, double height )
-	{
-		_unshrunkLeftBottom	= c;
-		_unshrunkWidth		= width;
-		_unshrunkHeight	= height;
-	}
-	
-	void Rectangle2::resetInLocalMove( void )
-	{
-		_inLocalMove = false;
-	}
-	
-	void Rectangle2::updateFixedElement( void )
-	{
-		_fixedLeftBottom  = _leftBottom;
-		_fixedWidth       = _width;
-		_fixedHeight      = _height;
-	}
-	
-    //------------------------------------------------------------------------------
-    //	Friend functions
-    //------------------------------------------------------------------------------
-
-
-    //------------------------------------------------------------------------------
-    //	I/O functions
-    //------------------------------------------------------------------------------
-    //
-    //  operator << --	output
-    //
-    //  Inputs
-    //	s	: reference to output stream
-    //	v	: 2D coordinates
-    //
-    //  Outputs
-    //	reference to output stream
-    //
-    ostream & operator << ( ostream & stream, const Rectangle2 & obj )
-    {
-        // set the output formatting
-        stream << setiosflags( ios::showpoint );
-        stream << setprecision( 8 );
-
-        int width = 8;
-        // print out the elements
-        stream << setw( width ) << "x = " << obj._leftBottom.x() << ", y = " << obj._leftBottom.y() << ", ";
-	    stream << setw( width ) << "w = " << obj._width << ", h = " << obj._height << endl;
-	    stream << setw( width ) << "ox = " << obj._oldLeftBottom.x() << ", oy = " << obj._oldLeftBottom.y() << ", ";
-	    stream << setw( width ) << "ow = " << obj._oldWidth << ", oh = " << obj._oldHeight << endl;
-//        stream << endl;
-
-        return stream;
-    }
-
-
-    //
-    //  operator >> --	input
-    //
-    //  Inputs
-    //	s	: reference to input stream
-    //	v	: 2D coordinates
-    //
-    //  Outputs
-    //	reference to input stream
-    //
-    istream & operator >> ( istream & stream, Rectangle2 & obj )
-    {
-        return stream;
-    }
-
-
-} // namespace Base
-} // namespace KeiRo
Index: Base/src/Config.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// Config.cpp\r\n//\t: program file for system configuration\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Sun Sep 16 15:02:45 2019\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include \"Config.h\"\r\n\r\nusing namespace std;\r\n\r\nnamespace KeiRo {\r\nnamespace Base {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPrivate Functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tProtected Functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPublic functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  Config::getlf --\tstring to double\r\n    //\r\n    //  Inputs\r\n    //\tkey\t: text string\r\n    //\r\n    //  Outputs\r\n    //\tthe corresponding value\r\n    //\r\n    double Config::getlf( const string& key ) const {\r\n\r\n        map< string, string >::const_iterator it = m_map.find( key );\r\n\r\n        if( it == m_map.end() )\r\n        {\r\n            cerr << \"[ERR] \" << key << \" is not a defined option.\" << endl;\r\n            return 0.0;\r\n        }\r\n\r\n        return atof( it->second.c_str() );\r\n    }\r\n\r\n    //\r\n    //  Config::getf --\tstring to float\r\n    //\r\n    //  Inputs\r\n    //\tkey\t: text string\r\n    //\r\n    //  Outputs\r\n    //\tthe corresponding value\r\n    //\r\n    float Config::getf( const string& key ) const\r\n    {\r\n        map< string, string >::const_iterator it = m_map.find( key );\r\n\r\n        if( it == m_map.end() )\r\n        {\r\n            cerr << \"[ERR] \" << key << \" is not a defined option.\" << endl;\r\n            return 0.0f;\r\n        }\r\n\r\n        return atof( it->second.c_str() );\r\n    }\r\n\r\n    //\r\n    //  Config::geti --\tstring to integer\r\n    //\r\n    //  Inputs\r\n    //\tkey\t: text string\r\n    //\r\n    //  Outputs\r\n    //\tthe corresponding value\r\n    //\r\n    int Config::geti( const string& key ) const\r\n    {\r\n        map< string, string >::const_iterator it = m_map.find(key);\r\n\r\n        if( it == m_map.end() )\r\n        {\r\n            cerr << \"[ERR] \" << key << \" is not a defined option.\" << endl;\r\n            return 0;\r\n        }\r\n\r\n        return atoi( it->second.c_str() );\r\n    }\r\n\r\n    //\r\n    //  Config::gets --\tstring to string\r\n    //\r\n    //  Inputs\r\n    //\tkey\t: text string\r\n    //\r\n    //  Outputs\r\n    //\tthe corresponding value\r\n    //\r\n    string Config::gets( const string& key ) const\r\n    {\r\n        map< string, string>::const_iterator it = m_map.find( key );\r\n\r\n        if( it == m_map.end() )\r\n        {\r\n            cerr << \"[ERR] \" << key << \" is not a defined option.\" << endl;\r\n            return string( \"\" );\r\n        }\r\n\r\n        return it->second;\r\n    }\r\n\r\n    //\r\n    //  Config::has --\tcheck if in the list\r\n    //\r\n    //  Inputs\r\n    //\tkey\t: text string\r\n    //\r\n    //  Outputs\r\n    //\tyes/no\r\n    //\r\n    bool Config::has( const string& key ) const\r\n    {\r\n        if( m_map.find( key ) == m_map.end() )\r\n        {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    //\r\n    //  Config::split --\tseparate by \" \"\r\n    //\r\n    //  Inputs\r\n    //\tin\t: text string\r\n    //\tout\t: text string vector\r\n    //\r\n    //  Outputs\r\n    //\tnone\r\n    //\r\n    void Config::split( const string& in, vector< string >& out )\r\n    {\r\n        out.clear();\r\n        out.resize(2);\r\n\r\n        string::size_type sp_st  = in.find( \" \", 0 );\r\n        string::size_type sp_ed  = sp_st;\r\n\r\n        if( sp_st == string::npos ) return;\r\n\r\n        while( true ){\r\n            if( in.at( ++sp_ed ) != ' ' )\r\n            {\r\n                break;\r\n            }\r\n        }\r\n\r\n        out[0] = in.substr( 1, sp_st - 1 );\r\n        out[1] = in.substr( sp_ed, in.length() );\r\n\r\n    }\r\n\r\n    //\r\n    //  Config::loadConfigFile --\tload file\r\n    //\r\n    //  Inputs\r\n    //\tfilename\t: text string\r\n    //\r\n    //  Outputs\r\n    //\tnone\r\n    //\r\n    void Config::loadConfigFile( const string& filename )\r\n    {\r\n        ifstream ifs( filename.c_str(), ios::in );\r\n        if( ifs.fail() )\r\n        {\r\n            cerr << \"[ERR] file open error \" << filename << endl;\r\n            return;\r\n        }\r\n\r\n        string buf;\r\n\r\n        while( getline( ifs, buf ) )\r\n        {\r\n            if( buf.length() == 0   ) continue;\r\n            if( buf.at(0)    != ':' ) continue;\r\n\r\n            vector< string > vbuf;\r\n            split( buf, vbuf );\r\n    #ifdef  DEBUG\r\n            cerr << \"buf = \" << buf << endl;\r\n                        for( int i = 0; i < vbuf.size(); i++ ){\r\n                            cerr << \"vbuf[\" << i << \"] = \" << vbuf[i] << endl;\r\n                        }\r\n    #endif  // DEBUG\r\n            m_map.insert( make_pair(vbuf[0], vbuf[1]) );\r\n        }\r\n    }\r\n\r\n} // namespace Base\r\n} // namespace KeiRo\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Base/src/Config.cpp b/Base/src/Config.cpp
--- a/Base/src/Config.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Base/src/Config.cpp	(date 1729410605050)
@@ -1,210 +1,0 @@
-//******************************************************************************
-// Config.cpp
-//	: program file for system configuration
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Sun Sep 16 15:02:45 2019
-//
-//******************************************************************************
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include "Config.h"
-
-using namespace std;
-
-namespace KeiRo {
-namespace Base {
-
-    //------------------------------------------------------------------------------
-    //	Private Functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Protected Functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Public functions
-    //------------------------------------------------------------------------------
-    //
-    //  Config::getlf --	string to double
-    //
-    //  Inputs
-    //	key	: text string
-    //
-    //  Outputs
-    //	the corresponding value
-    //
-    double Config::getlf( const string& key ) const {
-
-        map< string, string >::const_iterator it = m_map.find( key );
-
-        if( it == m_map.end() )
-        {
-            cerr << "[ERR] " << key << " is not a defined option." << endl;
-            return 0.0;
-        }
-
-        return atof( it->second.c_str() );
-    }
-
-    //
-    //  Config::getf --	string to float
-    //
-    //  Inputs
-    //	key	: text string
-    //
-    //  Outputs
-    //	the corresponding value
-    //
-    float Config::getf( const string& key ) const
-    {
-        map< string, string >::const_iterator it = m_map.find( key );
-
-        if( it == m_map.end() )
-        {
-            cerr << "[ERR] " << key << " is not a defined option." << endl;
-            return 0.0f;
-        }
-
-        return atof( it->second.c_str() );
-    }
-
-    //
-    //  Config::geti --	string to integer
-    //
-    //  Inputs
-    //	key	: text string
-    //
-    //  Outputs
-    //	the corresponding value
-    //
-    int Config::geti( const string& key ) const
-    {
-        map< string, string >::const_iterator it = m_map.find(key);
-
-        if( it == m_map.end() )
-        {
-            cerr << "[ERR] " << key << " is not a defined option." << endl;
-            return 0;
-        }
-
-        return atoi( it->second.c_str() );
-    }
-
-    //
-    //  Config::gets --	string to string
-    //
-    //  Inputs
-    //	key	: text string
-    //
-    //  Outputs
-    //	the corresponding value
-    //
-    string Config::gets( const string& key ) const
-    {
-        map< string, string>::const_iterator it = m_map.find( key );
-
-        if( it == m_map.end() )
-        {
-            cerr << "[ERR] " << key << " is not a defined option." << endl;
-            return string( "" );
-        }
-
-        return it->second;
-    }
-
-    //
-    //  Config::has --	check if in the list
-    //
-    //  Inputs
-    //	key	: text string
-    //
-    //  Outputs
-    //	yes/no
-    //
-    bool Config::has( const string& key ) const
-    {
-        if( m_map.find( key ) == m_map.end() )
-        {
-            return false;
-        }
-
-        return true;
-    }
-
-    //
-    //  Config::split --	separate by " "
-    //
-    //  Inputs
-    //	in	: text string
-    //	out	: text string vector
-    //
-    //  Outputs
-    //	none
-    //
-    void Config::split( const string& in, vector< string >& out )
-    {
-        out.clear();
-        out.resize(2);
-
-        string::size_type sp_st  = in.find( " ", 0 );
-        string::size_type sp_ed  = sp_st;
-
-        if( sp_st == string::npos ) return;
-
-        while( true ){
-            if( in.at( ++sp_ed ) != ' ' )
-            {
-                break;
-            }
-        }
-
-        out[0] = in.substr( 1, sp_st - 1 );
-        out[1] = in.substr( sp_ed, in.length() );
-
-    }
-
-    //
-    //  Config::loadConfigFile --	load file
-    //
-    //  Inputs
-    //	filename	: text string
-    //
-    //  Outputs
-    //	none
-    //
-    void Config::loadConfigFile( const string& filename )
-    {
-        ifstream ifs( filename.c_str(), ios::in );
-        if( ifs.fail() )
-        {
-            cerr << "[ERR] file open error " << filename << endl;
-            return;
-        }
-
-        string buf;
-
-        while( getline( ifs, buf ) )
-        {
-            if( buf.length() == 0   ) continue;
-            if( buf.at(0)    != ':' ) continue;
-
-            vector< string > vbuf;
-            split( buf, vbuf );
-    #ifdef  DEBUG
-            cerr << "buf = " << buf << endl;
-                        for( int i = 0; i < vbuf.size(); i++ ){
-                            cerr << "vbuf[" << i << "] = " << vbuf[i] << endl;
-                        }
-    #endif  // DEBUG
-            m_map.insert( make_pair(vbuf[0], vbuf[1]) );
-        }
-    }
-
-} // namespace Base
-} // namespace KeiRo
Index: Base/src/Object.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// Object.cpp\r\n//\t: program file for object\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Sun Mar 9 6:02:45 2019\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include \"Object.h\"\r\n#include \"Common.h\"\r\n\r\nnamespace KeiRo {\r\nnamespace Base {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPrivate Functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tProtected Functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  Polygon2::_init --\tinitialization\r\n    //\r\n    //  Inputs\r\n    //  __elements\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void Object::_init( void )\r\n    {\r\n        _clear();\r\n\r\n        _id             = 0;\r\n        _gid            = 0;\r\n        _name           = \"unknown\";\r\n        _label          = \"unknown\";\r\n        _isVisible          = true;\r\n\t    _isTextVisible      = true;\r\n        _parentFileID.first = _parentFileID.second = 0;\r\n        _parentPolygonID = 0;\r\n\t\r\n\t    _stroke.resize( 4 );\r\n\t    _stroke[0] = _stroke[1] = _stroke[2] = 0;\r\n\t    _stroke[3] = 255;\r\n\t    _strokeWidth = 1.0;\r\n\r\n\t    _fill.resize( 4 );\r\n\t    _fill[0] = _fill[1] = _fill[2] = 100;\r\n\t    _fill[3] = 255;\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPublic functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  Object::Object -- default constructor\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    Object::Object()\r\n    {\r\n        _init();\r\n    }\r\n\r\n    //\r\n    //  Object::Object -- copy constructor\r\n    //\r\n    //  Inputs\r\n    //  object\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    Object::Object( const Object & v )\r\n    {\r\n        _id                     = v._id;\r\n        _gid                    = v._gid;\r\n        _name                   = v._name;\r\n\t    _label                  = v._label;\r\n        _isVisible              = v._isVisible;\r\n\t    _isTextVisible          = v._isTextVisible;\r\n        _parentFileID.first     = v._parentFileID.first;\r\n        _parentFileID.second    = v._parentFileID.second;\r\n        _parentPolygonID        = v._parentPolygonID;\r\n\t\r\n\t    _stroke                 = v._stroke;\r\n\t    _strokeWidth            = v._strokeWidth;\r\n\t\r\n\t    _fill                   = v._fill;\r\n    }\r\n\t\r\n} // namespace Base\r\n} // namespace KeiRo\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Base/src/Object.cpp b/Base/src/Object.cpp
--- a/Base/src/Object.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Base/src/Object.cpp	(date 1729410605070)
@@ -1,105 +1,0 @@
-//******************************************************************************
-// Object.cpp
-//	: program file for object
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Sun Mar 9 6:02:45 2019
-//
-//******************************************************************************
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include "Object.h"
-#include "Common.h"
-
-namespace KeiRo {
-namespace Base {
-
-    //------------------------------------------------------------------------------
-    //	Private Functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Protected Functions
-    //------------------------------------------------------------------------------
-    //
-    //  Polygon2::_init --	initialization
-    //
-    //  Inputs
-    //  __elements
-    //
-    //  Outputs
-    //  none
-    //
-    void Object::_init( void )
-    {
-        _clear();
-
-        _id             = 0;
-        _gid            = 0;
-        _name           = "unknown";
-        _label          = "unknown";
-        _isVisible          = true;
-	    _isTextVisible      = true;
-        _parentFileID.first = _parentFileID.second = 0;
-        _parentPolygonID = 0;
-	
-	    _stroke.resize( 4 );
-	    _stroke[0] = _stroke[1] = _stroke[2] = 0;
-	    _stroke[3] = 255;
-	    _strokeWidth = 1.0;
-
-	    _fill.resize( 4 );
-	    _fill[0] = _fill[1] = _fill[2] = 100;
-	    _fill[3] = 255;
-    }
-
-    //------------------------------------------------------------------------------
-    //	Public functions
-    //------------------------------------------------------------------------------
-    //
-    //  Object::Object -- default constructor
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    //
-    Object::Object()
-    {
-        _init();
-    }
-
-    //
-    //  Object::Object -- copy constructor
-    //
-    //  Inputs
-    //  object
-    //
-    //  Outputs
-    //  none
-    //
-    Object::Object( const Object & v )
-    {
-        _id                     = v._id;
-        _gid                    = v._gid;
-        _name                   = v._name;
-	    _label                  = v._label;
-        _isVisible              = v._isVisible;
-	    _isTextVisible          = v._isTextVisible;
-        _parentFileID.first     = v._parentFileID.first;
-        _parentFileID.second    = v._parentFileID.second;
-        _parentPolygonID        = v._parentPolygonID;
-	
-	    _stroke                 = v._stroke;
-	    _strokeWidth            = v._strokeWidth;
-	
-	    _fill                   = v._fill;
-    }
-	
-} // namespace Base
-} // namespace KeiRo
Index: Base/src/Base.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//==============================================================================\r\n// Base.cc\r\n//\t: program file for Base class\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\t\t\t\tDate: Sun Aug 12 22:01:14 2020\r\n//\r\n//==============================================================================\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include \"Base.h\"\r\n\r\nnamespace KeiRo {\r\nnamespace Base {\r\n\r\n} // namespace Base\r\n} // namespace KeiRo\r\n\r\n// end of header file\r\n// Do not add any stuff under this line.\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Base/src/Base.cpp b/Base/src/Base.cpp
--- a/Base/src/Base.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Base/src/Base.cpp	(date 1729410605080)
@@ -1,24 +1,0 @@
-//==============================================================================
-// Base.cc
-//	: program file for Base class
-//
-//------------------------------------------------------------------------------
-//
-//				Date: Sun Aug 12 22:01:14 2020
-//
-//==============================================================================
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include "Base.h"
-
-namespace KeiRo {
-namespace Base {
-
-} // namespace Base
-} // namespace KeiRo
-
-// end of header file
-// Do not add any stuff under this line.
Index: Base/src/Line2.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// Line2.cpp\r\n//\t: program file for 2D Line2 coordinates\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Dec 27 23:15:32 2011\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <iostream>\r\n#include <iomanip>\r\n#include <cctype>\r\n#include <cmath>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\n#include \"Line2.h\"\r\n\r\nnamespace KeiRo {\r\nnamespace Base {\r\n\t\t\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tProtected Functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  Line2::init -- initialization\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void Line2::_init( void )\r\n    {\r\n        _clear();\r\n    }\r\n\r\n    //\r\n    //  Polygon2::_clear --\tclear elements\r\n    //\r\n    //  Inputs\r\n    //\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void Line2::_clear( void )\r\n    {\r\n        _elements.clear();\r\n        _fixedElements.clear();\r\n        _idElements.clear();\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPublic functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tConstructors & Destructors\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  Line2::Line2 -- default constructor\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    Line2::Line2()\r\n    {\r\n        _init();\r\n\t\r\n//\t    _stroke.resize( 4 );\r\n//\t    _stroke[0] = _stroke[1] = _stroke[2] = 0;\r\n//\t    _stroke[3] = 255;\r\n//\t    _strokeWidth = 1.0;\r\n//\t    _strokeOpacity = 1.0;\r\n//\r\n//\t    _fill.resize( 4 );\r\n//\t    _fill[0] = _fill[1] = _fill[2] = 100;\r\n//\t    _fill[3] = 255;\r\n//\t    _fillOpacity = 1.0;\r\n\r\n//        _stroke.resize( 4 );\r\n//        _stroke[0] = _stroke[1] = _stroke[2] = 0;\r\n//        _stroke[3] = 255;\r\n//        _fill.resize( 4 );\r\n//        _fill[0] = _fill[1] = _fill[2] = _fill[3] = 0;\r\n        //Object::Object();\r\n    }\r\n\r\n    //\r\n    //  Line2::Line2 -- parameterized constructor\r\n    //\r\n    //  Inputs\r\n    //  __elements\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    Line2::Line2( vector< Coord2 > __elements )\r\n    {\r\n        _elements           = __elements;\r\n\t    _oldElements        = _elements;\r\n        _fixedElements      = _elements;\r\n\t\t\r\n        _idElements.clear();\r\n    }\r\n\r\n    //\r\n    //  Polygon2::Polygon2 -- copy constructor\r\n    //\r\n    //  Inputs\r\n    //  polygon\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    Line2::Line2( const Line2 & v )\r\n    {\r\n        _id                 = v._id;\r\n        _gid                = v._gid;\r\n        _name               = v._name;\r\n        _elements           = v._elements;\r\n\t    _oldElements        = v._oldElements;\r\n        _fixedElements      = v._fixedElements;\r\n        _idElements         = v._idElements;\r\n        _isSelected         = v._isSelected;\r\n\t\t_fineElements       = v._fineElements;\r\n\t\t_elementPointers    = v._elementPointers;\r\n\t\t\r\n\t    _stroke             = v._stroke;\r\n\t    _strokeWidth        = v._strokeWidth;\r\n\r\n\t    _fill               = v._fill;\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tAssignment operators\r\n    //------------------------------------------------------------------------------\r\n\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tSpecial functions\r\n    //------------------------------------------------------------------------------\r\n    void Line2::addSample( Coord2 & coord )\r\n    {\r\n        _elements.push_back( coord );\r\n    }\r\n\r\n\r\n    //\r\n    //  Line2::isOnLine --        check if point a lies on line segment [b,c]\r\n    //\r\n    //  Inputs\r\n    //      Coord2 &a, &b, &c\r\n    //\r\n    //  Outputs\r\n    //      bool\r\n    //\r\n    bool Line2::isOnLine( Coord2 &a, Coord2 &b, Coord2 &c )\r\n    {\r\n        bool isOnLine = false;\r\n\r\n        Coord2 ab = b - a;\r\n        Coord2 ac = c - a;\r\n\r\n        double cross = ab.x() * ac.y() - ab.y() * ac.x();\r\n        if( fabs( cross ) < 0.01 ) {\r\n\r\n            if ( ( MIN2( b.x(), c.x() ) <= a.x() ) && ( a.x() <= MAX2( b.x(), c.x() ) ) &&\r\n                 ( MIN2( b.y(), c.y() ) <= a.y() ) && ( a.y() <= MAX2( b.y(), c.y() ) ) )\r\n                isOnLine = true;\r\n        }\r\n\r\n        return isOnLine;\r\n    }\r\n\r\n\r\n    void Line2::_initChaikinCurve( double unit = 100 )\r\n    {\r\n        // initialization\r\n        _fineElements.clear();\r\n\r\n        // store initial the path\r\n        vector< Coord2 > &elements = _elements;\r\n\r\n        cerr << \"sample.size() = \" << elements.size() << endl;\r\n        if( elements.size() > 0 )\r\n            _fineElements.push_back( elements[0] );\r\n        for( unsigned int j = 1; j < elements.size(); j++ ){\r\n\r\n            Coord2 diff = ( elements[ j%elements.size() ]- elements[ j-1 ] );\r\n            // cerr << \"dist = \" << diff.norm() << endl;\r\n            if( diff.norm() > unit ) {\r\n\r\n                int num = floor( diff.norm()/unit );\r\n                double interval = diff.norm()/(double)num;\r\n\r\n                for( int k = 1; k < num; k++ ){\r\n\r\n                    Coord2 c = elements[j-1] + (double)k * interval * diff / diff.norm();\r\n                    _fineElements.push_back( c );\r\n                }\r\n            }\r\n            _fineElements.push_back( elements[ j ] );\r\n        }\r\n\r\n    #ifdef DEBUG\r\n        cerr << \"fineP = \";\r\n        for( unsigned int i = 0; i < _fineElements.size(); i++ ){\r\n            cerr << \"( \" << _fineElements[i].x() << \", \" << _fineElements[i].y() << \") \";\r\n        }\r\n        cerr << endl;\r\n    #endif // DEBUG\r\n    }\r\n\r\n    void Line2::computeChaikinCurve( int num = 5, double unit = 100 )\r\n    {\r\n        _initChaikinCurve( unit );\r\n\r\n        double interval = 4.0;\r\n        for( int k = 0; k < num; k++ ){\r\n\r\n            vector< Coord2 > core = _fineElements;\r\n\r\n            // compute Chaikin Curve\r\n            _fineElements.clear();\r\n            _fineElements.push_back( core[0] );\r\n            for( unsigned int j = 0; j < core.size()-1; j++ ){\r\n\r\n                Coord2 &p1 = core[j];\r\n                Coord2 &p2 = core[(j+1)%core.size()];\r\n                Coord2 q = (1.0-1.0/interval)*p1 + (1.0/interval)*p2;\r\n                Coord2 r = (1.0/interval)*p1 + (1.0-1.0/interval)*p2;\r\n\r\n                _fineElements.push_back( q );\r\n                _fineElements.push_back( r );\r\n            }\r\n            _fineElements.push_back( core[core.size()-1] );\r\n        }\r\n    }\r\n    \r\n\tvoid Line2::simplifyGeometry( void )\r\n\t{\r\n\t\tvector< Coord2 >        simpleElements;\r\n\t\tif( _elements.size() > 0 ) simpleElements.push_back( _elements[0] );\r\n\r\n\t\tfor( unsigned int i = 1; i < _elements.size()-1; i++ ){\r\n\t\t\tCoord2 pred = _elements[i-1];\r\n\t\t\tCoord2 curr = _elements[i];\r\n\t\t\tCoord2 succ = _elements[i+1];\r\n\t\t\tCoord2 diff1 = curr - pred;\r\n\t\t\tCoord2 diff2 = succ - curr;\r\n#ifdef DEBUG\r\n\t\t\tcerr << \"pred = \" << pred;\r\n\t\t\tcerr << \"curr = \" << curr;\r\n\t\t\tcerr << \"succ = \" << succ;\r\n#endif // DEBUG\r\n\t\t\tif( fabs( diff1.x()*diff2.y() - diff1.y()*diff2.x() ) > 1e-5 ){\r\n\t\t\t\t// not colinear\r\n\t\t\t\t//cerr << \"fabs( diff1.x()*diff2.y() - diff1.y()*diff2.x() ) = \" << fabs( diff1.x()*diff2.y() - diff1.y()*diff2.x() ) << endl;\r\n\t\t\t\tsimpleElements.push_back( curr );\r\n\t\t\t}\r\n\t\t}\r\n\t\tif( _elements.size() > 1 ) simpleElements.push_back( _elements[_elements.size()-1] );\r\n#ifdef DEBUG\r\n\t\tfor( unsigned int i = 0; i < simpleElements.size(); i++ ) {\r\n\t\t\tcerr << simpleElements[i];\r\n\t\t}\r\n\t\tcerr << endl;\r\n#endif // DEBUG\r\n\t\t_fixedElements = _oldElements = _elements = simpleElements;\r\n\t}\r\n\t\r\n\tvoid Line2::initElementPointers( void )\r\n\t{\r\n    \t_elementPointers.resize( _elements.size() );\r\n    \tfor( unsigned int i = 0; i < _elements.size(); i++ ){\r\n    \t\t_elementPointers[ i ] = &_elements[ i ];\r\n\t    }\r\n\t}\r\n\t\r\n\tvoid Line2::updateOldElement( void )\r\n\t{\r\n\t\t_oldElements = _elements;\r\n\t}\r\n\t\r\n\t\r\n\tvoid Line2::updateOldElementByPointers( void )\r\n\t{\r\n    \t\tfor( unsigned int i = 0; i < _elements.size(); i++ ){\r\n\t\t\t_oldElements[i] = *_elementPointers[i];\r\n    \t\t}\r\n    \t\tresetInLocalMove();\r\n\t}\r\n\t\r\n\tvoid Line2::updateIntermediateElements( vector< Coord2 > __elements )\r\n\t{\r\n\t\t_intermediateElements = __elements;\r\n\t\t_inLocalMove = true;\r\n\t}\r\n\t\r\n\tvoid Line2::resetInLocalMove( void )\r\n\t{\r\n\t\t_inLocalMove = false;\r\n\t}\r\n\t\r\n    //------------------------------------------------------------------------------\r\n    //\tFriend functions\r\n    //------------------------------------------------------------------------------\r\n\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tI/O functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  operator << --\toutput\r\n    //\r\n    //  Inputs\r\n    //\ts\t: reference to output stream\r\n    //\tv\t: 2D coordinates\r\n    //\r\n    //  Outputs\r\n    //\treference to output stream\r\n    //\r\n    ostream & operator << ( ostream & stream, const Line2 & obj )\r\n    {\r\n        // set the output formatting\r\n        stream << setiosflags( ios::showpoint );\r\n        stream << setprecision( 8 );\r\n\r\n        int width = 8;\r\n        // print out the elements\r\n        for ( unsigned int i = 0; i < obj.elements().size(); i++ ) {\r\n            stream << setw( width ) << \"(\" << obj.elements()[i].x() << \", \" << obj.elements()[i].y() << \") \";\r\n        }\r\n        stream << endl;\r\n\r\n        return stream;\r\n    }\r\n\r\n\r\n    //\r\n    //  operator >> --\tinput\r\n    //\r\n    //  Inputs\r\n    //\ts\t: reference to input stream\r\n    //\tv\t: 2D coordinates\r\n    //\r\n    //  Outputs\r\n    //\treference to input stream\r\n    //\r\n    istream & operator >> ( istream & stream, Line2 & obj )\r\n    {\r\n        return stream;\r\n    }\r\n\r\n\r\n} // namespace Base\r\n} // namespace KeiRo\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Base/src/Line2.cpp b/Base/src/Line2.cpp
--- a/Base/src/Line2.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Base/src/Line2.cpp	(date 1729410605090)
@@ -1,369 +1,0 @@
-//******************************************************************************
-// Line2.cpp
-//	: program file for 2D Line2 coordinates
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Dec 27 23:15:32 2011
-//
-//******************************************************************************
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <iostream>
-#include <iomanip>
-#include <cctype>
-#include <cmath>
-#include <algorithm>
-
-using namespace std;
-
-#include "Line2.h"
-
-namespace KeiRo {
-namespace Base {
-		
-
-    //------------------------------------------------------------------------------
-    //	Protected Functions
-    //------------------------------------------------------------------------------
-    //
-    //  Line2::init -- initialization
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    //
-    void Line2::_init( void )
-    {
-        _clear();
-    }
-
-    //
-    //  Polygon2::_clear --	clear elements
-    //
-    //  Inputs
-    //
-    //
-    //  Outputs
-    //  none
-    //
-    void Line2::_clear( void )
-    {
-        _elements.clear();
-        _fixedElements.clear();
-        _idElements.clear();
-    }
-
-    //------------------------------------------------------------------------------
-    //	Public functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Constructors & Destructors
-    //------------------------------------------------------------------------------
-    //
-    //  Line2::Line2 -- default constructor
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    Line2::Line2()
-    {
-        _init();
-	
-//	    _stroke.resize( 4 );
-//	    _stroke[0] = _stroke[1] = _stroke[2] = 0;
-//	    _stroke[3] = 255;
-//	    _strokeWidth = 1.0;
-//	    _strokeOpacity = 1.0;
-//
-//	    _fill.resize( 4 );
-//	    _fill[0] = _fill[1] = _fill[2] = 100;
-//	    _fill[3] = 255;
-//	    _fillOpacity = 1.0;
-
-//        _stroke.resize( 4 );
-//        _stroke[0] = _stroke[1] = _stroke[2] = 0;
-//        _stroke[3] = 255;
-//        _fill.resize( 4 );
-//        _fill[0] = _fill[1] = _fill[2] = _fill[3] = 0;
-        //Object::Object();
-    }
-
-    //
-    //  Line2::Line2 -- parameterized constructor
-    //
-    //  Inputs
-    //  __elements
-    //
-    //  Outputs
-    //  none
-    //
-    Line2::Line2( vector< Coord2 > __elements )
-    {
-        _elements           = __elements;
-	    _oldElements        = _elements;
-        _fixedElements      = _elements;
-		
-        _idElements.clear();
-    }
-
-    //
-    //  Polygon2::Polygon2 -- copy constructor
-    //
-    //  Inputs
-    //  polygon
-    //
-    //  Outputs
-    //  none
-    //
-    Line2::Line2( const Line2 & v )
-    {
-        _id                 = v._id;
-        _gid                = v._gid;
-        _name               = v._name;
-        _elements           = v._elements;
-	    _oldElements        = v._oldElements;
-        _fixedElements      = v._fixedElements;
-        _idElements         = v._idElements;
-        _isSelected         = v._isSelected;
-		_fineElements       = v._fineElements;
-		_elementPointers    = v._elementPointers;
-		
-	    _stroke             = v._stroke;
-	    _strokeWidth        = v._strokeWidth;
-
-	    _fill               = v._fill;
-    }
-
-    //------------------------------------------------------------------------------
-    //	Assignment operators
-    //------------------------------------------------------------------------------
-
-
-    //------------------------------------------------------------------------------
-    //	Special functions
-    //------------------------------------------------------------------------------
-    void Line2::addSample( Coord2 & coord )
-    {
-        _elements.push_back( coord );
-    }
-
-
-    //
-    //  Line2::isOnLine --        check if point a lies on line segment [b,c]
-    //
-    //  Inputs
-    //      Coord2 &a, &b, &c
-    //
-    //  Outputs
-    //      bool
-    //
-    bool Line2::isOnLine( Coord2 &a, Coord2 &b, Coord2 &c )
-    {
-        bool isOnLine = false;
-
-        Coord2 ab = b - a;
-        Coord2 ac = c - a;
-
-        double cross = ab.x() * ac.y() - ab.y() * ac.x();
-        if( fabs( cross ) < 0.01 ) {
-
-            if ( ( MIN2( b.x(), c.x() ) <= a.x() ) && ( a.x() <= MAX2( b.x(), c.x() ) ) &&
-                 ( MIN2( b.y(), c.y() ) <= a.y() ) && ( a.y() <= MAX2( b.y(), c.y() ) ) )
-                isOnLine = true;
-        }
-
-        return isOnLine;
-    }
-
-
-    void Line2::_initChaikinCurve( double unit = 100 )
-    {
-        // initialization
-        _fineElements.clear();
-
-        // store initial the path
-        vector< Coord2 > &elements = _elements;
-
-        cerr << "sample.size() = " << elements.size() << endl;
-        if( elements.size() > 0 )
-            _fineElements.push_back( elements[0] );
-        for( unsigned int j = 1; j < elements.size(); j++ ){
-
-            Coord2 diff = ( elements[ j%elements.size() ]- elements[ j-1 ] );
-            // cerr << "dist = " << diff.norm() << endl;
-            if( diff.norm() > unit ) {
-
-                int num = floor( diff.norm()/unit );
-                double interval = diff.norm()/(double)num;
-
-                for( int k = 1; k < num; k++ ){
-
-                    Coord2 c = elements[j-1] + (double)k * interval * diff / diff.norm();
-                    _fineElements.push_back( c );
-                }
-            }
-            _fineElements.push_back( elements[ j ] );
-        }
-
-    #ifdef DEBUG
-        cerr << "fineP = ";
-        for( unsigned int i = 0; i < _fineElements.size(); i++ ){
-            cerr << "( " << _fineElements[i].x() << ", " << _fineElements[i].y() << ") ";
-        }
-        cerr << endl;
-    #endif // DEBUG
-    }
-
-    void Line2::computeChaikinCurve( int num = 5, double unit = 100 )
-    {
-        _initChaikinCurve( unit );
-
-        double interval = 4.0;
-        for( int k = 0; k < num; k++ ){
-
-            vector< Coord2 > core = _fineElements;
-
-            // compute Chaikin Curve
-            _fineElements.clear();
-            _fineElements.push_back( core[0] );
-            for( unsigned int j = 0; j < core.size()-1; j++ ){
-
-                Coord2 &p1 = core[j];
-                Coord2 &p2 = core[(j+1)%core.size()];
-                Coord2 q = (1.0-1.0/interval)*p1 + (1.0/interval)*p2;
-                Coord2 r = (1.0/interval)*p1 + (1.0-1.0/interval)*p2;
-
-                _fineElements.push_back( q );
-                _fineElements.push_back( r );
-            }
-            _fineElements.push_back( core[core.size()-1] );
-        }
-    }
-    
-	void Line2::simplifyGeometry( void )
-	{
-		vector< Coord2 >        simpleElements;
-		if( _elements.size() > 0 ) simpleElements.push_back( _elements[0] );
-
-		for( unsigned int i = 1; i < _elements.size()-1; i++ ){
-			Coord2 pred = _elements[i-1];
-			Coord2 curr = _elements[i];
-			Coord2 succ = _elements[i+1];
-			Coord2 diff1 = curr - pred;
-			Coord2 diff2 = succ - curr;
-#ifdef DEBUG
-			cerr << "pred = " << pred;
-			cerr << "curr = " << curr;
-			cerr << "succ = " << succ;
-#endif // DEBUG
-			if( fabs( diff1.x()*diff2.y() - diff1.y()*diff2.x() ) > 1e-5 ){
-				// not colinear
-				//cerr << "fabs( diff1.x()*diff2.y() - diff1.y()*diff2.x() ) = " << fabs( diff1.x()*diff2.y() - diff1.y()*diff2.x() ) << endl;
-				simpleElements.push_back( curr );
-			}
-		}
-		if( _elements.size() > 1 ) simpleElements.push_back( _elements[_elements.size()-1] );
-#ifdef DEBUG
-		for( unsigned int i = 0; i < simpleElements.size(); i++ ) {
-			cerr << simpleElements[i];
-		}
-		cerr << endl;
-#endif // DEBUG
-		_fixedElements = _oldElements = _elements = simpleElements;
-	}
-	
-	void Line2::initElementPointers( void )
-	{
-    	_elementPointers.resize( _elements.size() );
-    	for( unsigned int i = 0; i < _elements.size(); i++ ){
-    		_elementPointers[ i ] = &_elements[ i ];
-	    }
-	}
-	
-	void Line2::updateOldElement( void )
-	{
-		_oldElements = _elements;
-	}
-	
-	
-	void Line2::updateOldElementByPointers( void )
-	{
-    		for( unsigned int i = 0; i < _elements.size(); i++ ){
-			_oldElements[i] = *_elementPointers[i];
-    		}
-    		resetInLocalMove();
-	}
-	
-	void Line2::updateIntermediateElements( vector< Coord2 > __elements )
-	{
-		_intermediateElements = __elements;
-		_inLocalMove = true;
-	}
-	
-	void Line2::resetInLocalMove( void )
-	{
-		_inLocalMove = false;
-	}
-	
-    //------------------------------------------------------------------------------
-    //	Friend functions
-    //------------------------------------------------------------------------------
-
-
-    //------------------------------------------------------------------------------
-    //	I/O functions
-    //------------------------------------------------------------------------------
-    //
-    //  operator << --	output
-    //
-    //  Inputs
-    //	s	: reference to output stream
-    //	v	: 2D coordinates
-    //
-    //  Outputs
-    //	reference to output stream
-    //
-    ostream & operator << ( ostream & stream, const Line2 & obj )
-    {
-        // set the output formatting
-        stream << setiosflags( ios::showpoint );
-        stream << setprecision( 8 );
-
-        int width = 8;
-        // print out the elements
-        for ( unsigned int i = 0; i < obj.elements().size(); i++ ) {
-            stream << setw( width ) << "(" << obj.elements()[i].x() << ", " << obj.elements()[i].y() << ") ";
-        }
-        stream << endl;
-
-        return stream;
-    }
-
-
-    //
-    //  operator >> --	input
-    //
-    //  Inputs
-    //	s	: reference to input stream
-    //	v	: 2D coordinates
-    //
-    //  Outputs
-    //	reference to input stream
-    //
-    istream & operator >> ( istream & stream, Line2 & obj )
-    {
-        return stream;
-    }
-
-
-} // namespace Base
-} // namespace KeiRo
Index: Base/src/Edge2.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// Edge2.cpp\r\n//\t: program file for 2D Edge2 coordinates\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Dec 27 23:15:32 2011\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <iostream>\r\n#include <iomanip>\r\n#include <cctype>\r\n#include <cmath>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\n#include \"Edge2.h\"\r\n\r\nnamespace KeiRo {\r\nnamespace Base {\r\n\t\t\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tProtected Functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  Edge2::init -- initialization\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void Edge2::_init( void )\r\n    {\r\n\t    _elements.resize(2);\r\n\t    _oldElements.resize(2);\r\n\t    _fixedElements.resize(2);\r\n    }\r\n\r\n    //\r\n    //  Polygon2::_clear --\tclear elements\r\n    //\r\n    //  Inputs\r\n    //\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void Edge2::_clear( void )\r\n    {\r\n        _elements.clear();\r\n\t    _oldElements.clear();\r\n        _fixedElements.clear();\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPublic functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tConstructors & Destructors\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  Edge2::Edge2 -- default constructor\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    Edge2::Edge2()\r\n    {\r\n        _init();\r\n        //Object::Object();\r\n    }\r\n\r\n    //\r\n    //  Edge2::Edge2 -- parameterized constructor\r\n    //\r\n    //  Inputs\r\n    //  __elements\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    Edge2::Edge2( vector< Coord2 > __elements )\r\n    {\r\n        _elements           = __elements;\r\n\t    _oldElements        = _elements;\r\n        _fixedElements      = _elements;\r\n    }\r\n    \r\n    //\r\n    //  Polygon2::Polygon2 -- copy constructor\r\n    //\r\n    //  Inputs\r\n    //  polygon\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    Edge2::Edge2( const Edge2 & v )\r\n    {\r\n        _id                 = v._id;\r\n        _gid                = v._gid;\r\n        _name               = v._name;\r\n        _elements           = v._elements;\r\n\t    _oldElements        = v._oldElements;\r\n        _fixedElements      = v._fixedElements;\r\n        _isSelected         = v._isSelected;\r\n\t\r\n\t    _stroke             = v._stroke;\r\n\t    _strokeWidth        = v._strokeWidth;\r\n\r\n\t    _fill               = v._fill;\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tAssignment operators\r\n    //------------------------------------------------------------------------------\r\n\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tSpecial functions\r\n    //------------------------------------------------------------------------------\r\n    bool Edge2::isIntersected( Edge2 e ){\r\n    \treturn false;\r\n    }\r\n\t\r\n\tbool Edge2::isOnEdge( Coord2 c ) {\r\n\r\n    \tbool isOn = false;\r\n    \tCoord2 diff = _elements[1] - _elements[0];\r\n    \tCoord2 diffC = c - _elements[0];\r\n\t\t\r\n\t\tif( diff.x() == 0 ){\r\n\t\t\tif( diffC.x() == 0 &&\r\n\t\t\t\t( c.y() >= MIN2( _elements[0].y(), _elements[1].y() ) ) &&\r\n\t\t\t\t( c.y() <= MAX2( _elements[0].y(), _elements[1].y() ) )\r\n\t\t\t\t)\r\n\t\t\t\treturn true;\r\n\t\t}\r\n\t\telse{\r\n\t\t\tif( diffC.norm() < diff.norm() ){\r\n\t\t\t\t// L: mx -y + b = 0\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\tdouble m = diff.y()/diff.x();\r\n\t\t\tdouble b = _elements[0].y() - m * _elements[0].x();\r\n\t\t\tdouble dist = fabs( m * c.x() - c.y() + b )/sqrt( SQUARE( m ) + 1.0 );\r\n\t\t\tif( dist == 0.0 &&\r\n\t\t\t    ( c.x() >= MIN2( _elements[0].x(), _elements[1].x() ) ) &&\r\n\t\t\t    ( c.x() <= MAX2( _elements[0].x(), _elements[1].x() ) ) &&\r\n\t\t\t    ( c.y() >= MIN2( _elements[0].y(), _elements[1].y() ) ) &&\r\n\t\t\t    ( c.y() <= MAX2( _elements[0].y(), _elements[1].y() ) )\r\n\t\t\t\t)\r\n\t\t\t\treturn true;\r\n\t\t}\r\n  \r\n\t\treturn isOn;\r\n\t}\r\n\t\r\n    //------------------------------------------------------------------------------\r\n    //\tFriend functions\r\n    //------------------------------------------------------------------------------\r\n\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tI/O functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  operator << --\toutput\r\n    //\r\n    //  Inputs\r\n    //\ts\t: reference to output stream\r\n    //\tv\t: 2D coordinates\r\n    //\r\n    //  Outputs\r\n    //\treference to output stream\r\n    //\r\n    ostream & operator << ( ostream & stream, const Edge2 & obj )\r\n    {\r\n        // set the output formatting\r\n        stream << setiosflags( ios::showpoint );\r\n        stream << setprecision( 8 );\r\n\r\n        int width = 8;\r\n        // print out the elements\r\n        for ( unsigned int i = 0; i < obj.elements().size(); i++ ) {\r\n            stream << setw( width ) << \"(\" << obj.elements()[i].x() << \", \" << obj.elements()[i].y() << \") \";\r\n        }\r\n        stream << endl;\r\n\r\n        return stream;\r\n    }\r\n\r\n\r\n    //\r\n    //  operator >> --\tinput\r\n    //\r\n    //  Inputs\r\n    //\ts\t: reference to input stream\r\n    //\tv\t: 2D coordinates\r\n    //\r\n    //  Outputs\r\n    //\treference to input stream\r\n    //\r\n    istream & operator >> ( istream & stream, Edge2 & obj )\r\n    {\r\n        return stream;\r\n    }\r\n\r\n\r\n} // namespace Base\r\n} // namespace KeiRo\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Base/src/Edge2.cpp b/Base/src/Edge2.cpp
--- a/Base/src/Edge2.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Base/src/Edge2.cpp	(date 1729410605110)
@@ -1,223 +1,0 @@
-//******************************************************************************
-// Edge2.cpp
-//	: program file for 2D Edge2 coordinates
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Dec 27 23:15:32 2011
-//
-//******************************************************************************
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <iostream>
-#include <iomanip>
-#include <cctype>
-#include <cmath>
-#include <algorithm>
-
-using namespace std;
-
-#include "Edge2.h"
-
-namespace KeiRo {
-namespace Base {
-		
-
-    //------------------------------------------------------------------------------
-    //	Protected Functions
-    //------------------------------------------------------------------------------
-    //
-    //  Edge2::init -- initialization
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    //
-    void Edge2::_init( void )
-    {
-	    _elements.resize(2);
-	    _oldElements.resize(2);
-	    _fixedElements.resize(2);
-    }
-
-    //
-    //  Polygon2::_clear --	clear elements
-    //
-    //  Inputs
-    //
-    //
-    //  Outputs
-    //  none
-    //
-    void Edge2::_clear( void )
-    {
-        _elements.clear();
-	    _oldElements.clear();
-        _fixedElements.clear();
-    }
-
-    //------------------------------------------------------------------------------
-    //	Public functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Constructors & Destructors
-    //------------------------------------------------------------------------------
-    //
-    //  Edge2::Edge2 -- default constructor
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    Edge2::Edge2()
-    {
-        _init();
-        //Object::Object();
-    }
-
-    //
-    //  Edge2::Edge2 -- parameterized constructor
-    //
-    //  Inputs
-    //  __elements
-    //
-    //  Outputs
-    //  none
-    //
-    Edge2::Edge2( vector< Coord2 > __elements )
-    {
-        _elements           = __elements;
-	    _oldElements        = _elements;
-        _fixedElements      = _elements;
-    }
-    
-    //
-    //  Polygon2::Polygon2 -- copy constructor
-    //
-    //  Inputs
-    //  polygon
-    //
-    //  Outputs
-    //  none
-    //
-    Edge2::Edge2( const Edge2 & v )
-    {
-        _id                 = v._id;
-        _gid                = v._gid;
-        _name               = v._name;
-        _elements           = v._elements;
-	    _oldElements        = v._oldElements;
-        _fixedElements      = v._fixedElements;
-        _isSelected         = v._isSelected;
-	
-	    _stroke             = v._stroke;
-	    _strokeWidth        = v._strokeWidth;
-
-	    _fill               = v._fill;
-    }
-
-    //------------------------------------------------------------------------------
-    //	Assignment operators
-    //------------------------------------------------------------------------------
-
-
-    //------------------------------------------------------------------------------
-    //	Special functions
-    //------------------------------------------------------------------------------
-    bool Edge2::isIntersected( Edge2 e ){
-    	return false;
-    }
-	
-	bool Edge2::isOnEdge( Coord2 c ) {
-
-    	bool isOn = false;
-    	Coord2 diff = _elements[1] - _elements[0];
-    	Coord2 diffC = c - _elements[0];
-		
-		if( diff.x() == 0 ){
-			if( diffC.x() == 0 &&
-				( c.y() >= MIN2( _elements[0].y(), _elements[1].y() ) ) &&
-				( c.y() <= MAX2( _elements[0].y(), _elements[1].y() ) )
-				)
-				return true;
-		}
-		else{
-			if( diffC.norm() < diff.norm() ){
-				// L: mx -y + b = 0
-				
-			}
-			double m = diff.y()/diff.x();
-			double b = _elements[0].y() - m * _elements[0].x();
-			double dist = fabs( m * c.x() - c.y() + b )/sqrt( SQUARE( m ) + 1.0 );
-			if( dist == 0.0 &&
-			    ( c.x() >= MIN2( _elements[0].x(), _elements[1].x() ) ) &&
-			    ( c.x() <= MAX2( _elements[0].x(), _elements[1].x() ) ) &&
-			    ( c.y() >= MIN2( _elements[0].y(), _elements[1].y() ) ) &&
-			    ( c.y() <= MAX2( _elements[0].y(), _elements[1].y() ) )
-				)
-				return true;
-		}
-  
-		return isOn;
-	}
-	
-    //------------------------------------------------------------------------------
-    //	Friend functions
-    //------------------------------------------------------------------------------
-
-
-    //------------------------------------------------------------------------------
-    //	I/O functions
-    //------------------------------------------------------------------------------
-    //
-    //  operator << --	output
-    //
-    //  Inputs
-    //	s	: reference to output stream
-    //	v	: 2D coordinates
-    //
-    //  Outputs
-    //	reference to output stream
-    //
-    ostream & operator << ( ostream & stream, const Edge2 & obj )
-    {
-        // set the output formatting
-        stream << setiosflags( ios::showpoint );
-        stream << setprecision( 8 );
-
-        int width = 8;
-        // print out the elements
-        for ( unsigned int i = 0; i < obj.elements().size(); i++ ) {
-            stream << setw( width ) << "(" << obj.elements()[i].x() << ", " << obj.elements()[i].y() << ") ";
-        }
-        stream << endl;
-
-        return stream;
-    }
-
-
-    //
-    //  operator >> --	input
-    //
-    //  Inputs
-    //	s	: reference to input stream
-    //	v	: 2D coordinates
-    //
-    //  Outputs
-    //	reference to input stream
-    //
-    istream & operator >> ( istream & stream, Edge2 & obj )
-    {
-        return stream;
-    }
-
-
-} // namespace Base
-} // namespace KeiRo
Index: Base/src/Color.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// Color.cpp\r\n//\t: program file for color schemes\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Sun Sep 16 15:02:45 2019\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include \"Color.h\"\r\n\r\n\r\nnamespace KeiRo {\r\nnamespace Base {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPrivate Functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tProtected Functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPublic functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  Color::RGBtoHex --\tconvert RGB to HEX\r\n    //\r\n    //  Inputs\r\n    //\tr, g, b: color values\r\n    //\r\n    //  Outputs\r\n    //\tunsigned long\r\n    //\r\n    unsigned long Color::RGBtoHex( int r, int g, int b )\r\n    {\r\n        return ((r & 0xff) << 16) + ((g & 0xff) << 8) + (b & 0xff);\r\n    }\r\n\r\n    //\r\n    //  Color::pickMonotoneColor --\tconvert id to RGB color\r\n    //\r\n    //  Inputs\r\n    //\tid: id\r\n    //  rgb: color\r\n    //\r\n    //  Outputs\r\n    //\tnone\r\n    //\r\n    void Color::pickMonotoneColor( vector< double > &rgb )\r\n    {\r\n        rgb.resize( 3 );\r\n\r\n        if ( true ){\r\n            // gray\r\n            rgb[ 0 ] = 217.0;\r\n            rgb[ 1 ] = 217.0;\r\n            rgb[ 2 ] = 217.0;\r\n        }\r\n        else {\r\n            // blue\r\n            rgb[ 0 ] = 198.0;\r\n            rgb[ 1 ] = 219.0;\r\n            rgb[ 2 ] = 239.0;\r\n        }\r\n    }\r\n\r\n    //\r\n    //  Color::pickPastelColor --\t\u001Bconvert id to RGB color\r\n    //\r\n    //  Inputs\r\n    //\tid: id\r\n    //  rgb: color\r\n    //\r\n    //  Outputs\r\n    //\tnone\r\n    //\r\n    void Color::pickPastelColor( unsigned int id, vector< double > &rgb )\r\n    {\r\n        int index = id % MAX_COLOR_TYPE;\r\n        int shift = -2*( id / MAX_COLOR_TYPE );\r\n\r\n        rgb.resize( 3 );\r\n\r\n        switch( index ){\r\n            case 0:\r\n                rgb[ 0 ] = MIN2( 255, shift+169 );\r\n                rgb[ 1 ] = MIN2( 255, shift+207 );\r\n                rgb[ 2 ] = MIN2( 255, shift+244 );\r\n                break;\r\n            case 1:\r\n                rgb[ 0 ] = MIN2( 255, shift+255 );\r\n                rgb[ 1 ] = MIN2( 255, shift+235 );\r\n                rgb[ 2 ] = MIN2( 255, shift+176 );\r\n                break;\r\n            case 2:\r\n                rgb[ 0 ] = MIN2( 255, shift+255 );\r\n                rgb[ 1 ] = MIN2( 255, shift+211 );\r\n                rgb[ 2 ] = MIN2( 255, shift+247 );\r\n                break;\r\n            case 3:\r\n                rgb[ 0 ] = MIN2( 255, shift+219 );\r\n                rgb[ 1 ] = MIN2( 255, shift+231 );\r\n                rgb[ 2 ] = MIN2( 255, shift+155 );\r\n                break;\r\n            case 4:\r\n                rgb[ 0 ] = MIN2( 255, shift+236 );\r\n                rgb[ 1 ] = MIN2( 255, shift+236 );\r\n                rgb[ 2 ] = MIN2( 255, shift+236 );\r\n                break;\r\n            case 5:\r\n                rgb[ 0 ] = MIN2( 255, shift+138 );\r\n                rgb[ 1 ] = MIN2( 255, shift+214 );\r\n                rgb[ 2 ] = MIN2( 255, shift+237 );\r\n                break;\r\n            case 6:\r\n                rgb[ 0 ] = MIN2( 255, shift+254 );\r\n                rgb[ 1 ] = MIN2( 255, shift+212 );\r\n                rgb[ 2 ] = MIN2( 255, shift+190 );\r\n                break;\r\n            case 7:\r\n                rgb[ 0 ] = MIN2( 255, shift+233 );\r\n                rgb[ 1 ] = MIN2( 255, shift+212 );\r\n                rgb[ 2 ] = MIN2( 255, shift+241 );\r\n                break;\r\n            case 8:\r\n                rgb[ 0 ] = MIN2( 255, shift+254 );\r\n                rgb[ 1 ] = MIN2( 255, shift+244 );\r\n                rgb[ 2 ] = MIN2( 255, shift+217 );\r\n                break;\r\n            case 9:\r\n                rgb[ 0 ] = MIN2( 255, shift+251 );\r\n                rgb[ 1 ] = MIN2( 255, shift+220 );\r\n                rgb[ 2 ] = MIN2( 255, shift+226 );\r\n                break;\r\n            case 10:\r\n                rgb[ 0 ] = MIN2( 255, shift+162 );\r\n                rgb[ 1 ] = MIN2( 255, shift+232 );\r\n                rgb[ 2 ] = MIN2( 255, shift+172 );\r\n                break;\r\n            case 11:\r\n                rgb[ 0 ] = MIN2( 255, shift+256 );\r\n                rgb[ 1 ] = MIN2( 255, shift+183 );\r\n                rgb[ 2 ] = MIN2( 255, shift+174 );\r\n                break;\r\n            default:\r\n                cerr << \"sth is wrong here\" << endl;\r\n                break;\r\n        }\r\n    }\r\n\r\n    //\r\n    //  Color::pickBrewerColor --\t\u001Bconvert id to RGB color\r\n    //\r\n    //  Inputs\r\n    //\tid: id\r\n    //  rgb: color\r\n    //\r\n    //  Outputs\r\n    //\tnone\r\n    //\r\n    void Color::pickBrewerColor( unsigned int id, vector< double > &rgb )\r\n    {\r\n        int index = id % MAX_COLOR_TYPE;\r\n        int shift = -2*(id / MAX_COLOR_TYPE );\r\n\r\n        rgb.resize( 3 );\r\n\r\n        switch( index ){\r\n            case 0:\r\n                rgb[ 0 ] = MIN2( 255,  shift+141 );\r\n                rgb[ 1 ] = MIN2( 255,  shift+211 );\r\n                rgb[ 2 ] = MIN2( 255,  shift+199 );\r\n                break;\r\n            case 1:\r\n                rgb[ 0 ] = MIN2( 255,  shift+255 );\r\n                rgb[ 1 ] = MIN2( 255,  shift+255 );\r\n                rgb[ 2 ] = MIN2( 255,  shift+179 );\r\n                break;\r\n            case 2:\r\n                rgb[ 0 ] = MIN2( 255,  shift+190 );\r\n                rgb[ 1 ] = MIN2( 255,  shift+186 );\r\n                rgb[ 2 ] = MIN2( 255,  shift+218 );\r\n                break;\r\n            case 3:\r\n                rgb[ 0 ] = MIN2( 255,  shift+251 );\r\n                rgb[ 1 ] = MIN2( 255,  shift+128 );\r\n                rgb[ 2 ] = MIN2( 255,  shift+114 );\r\n                break;\r\n            case 4:\r\n                rgb[ 0 ] = MIN2( 255,  shift+128 );\r\n                rgb[ 1 ] = MIN2( 255,  shift+177 );\r\n                rgb[ 2 ] = MIN2( 255,  shift+211 );\r\n                break;\r\n            case 5:\r\n                rgb[ 0 ] = MIN2( 255,  shift+253 );\r\n                rgb[ 1 ] = MIN2( 255,  shift+180 );\r\n                rgb[ 2 ] = MIN2( 255,  shift+98 );\r\n                break;\r\n            case 6:\r\n                rgb[ 0 ] = MIN2( 255,  shift+179 );\r\n                rgb[ 1 ] = MIN2( 255,  shift+222 );\r\n                rgb[ 2 ] = MIN2( 255,  shift+105 );\r\n                break;\r\n            case 7:\r\n                rgb[ 0 ] = MIN2( 255,  shift+252 );\r\n                rgb[ 1 ] = MIN2( 255,  shift+205 );\r\n                rgb[ 2 ] = MIN2( 255,  shift+229 );\r\n                break;\r\n            case 8:\r\n                rgb[ 0 ] = MIN2( 255,  shift+217 );\r\n                rgb[ 1 ] = MIN2( 255,  shift+217 );\r\n                rgb[ 2 ] = MIN2( 255,  shift+217 );\r\n                break;\r\n            case 9:\r\n                rgb[ 0 ] = MIN2( 255,  shift+188 );\r\n                rgb[ 1 ] = MIN2( 255,  shift+128 );\r\n                rgb[ 2 ] = MIN2( 255,  shift+189 );\r\n                break;\r\n            case 10:\r\n                rgb[ 0 ] = MIN2( 255,  shift+204 );\r\n                rgb[ 1 ] = MIN2( 255,  shift+235 );\r\n                rgb[ 2 ] = MIN2( 255,  shift+197 );\r\n                break;\r\n            case 11:\r\n                rgb[ 0 ] = MIN2( 255,  shift+255 );\r\n                rgb[ 1 ] = MIN2( 255,  shift+237 );\r\n                rgb[ 2 ] = MIN2( 255,  shift+111 );\r\n                break;\r\n            default:\r\n                cerr << \"sth is wrong here\" << endl;\r\n                break;\r\n        }\r\n    }\r\n\r\n} // namespace Base\r\n} // namespace KeiRo\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Base/src/Color.cpp b/Base/src/Color.cpp
--- a/Base/src/Color.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Base/src/Color.cpp	(date 1729410605120)
@@ -1,243 +1,0 @@
-//******************************************************************************
-// Color.cpp
-//	: program file for color schemes
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Sun Sep 16 15:02:45 2019
-//
-//******************************************************************************
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include "Color.h"
-
-
-namespace KeiRo {
-namespace Base {
-
-    //------------------------------------------------------------------------------
-    //	Private Functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Protected Functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Public functions
-    //------------------------------------------------------------------------------
-    //
-    //  Color::RGBtoHex --	convert RGB to HEX
-    //
-    //  Inputs
-    //	r, g, b: color values
-    //
-    //  Outputs
-    //	unsigned long
-    //
-    unsigned long Color::RGBtoHex( int r, int g, int b )
-    {
-        return ((r & 0xff) << 16) + ((g & 0xff) << 8) + (b & 0xff);
-    }
-
-    //
-    //  Color::pickMonotoneColor --	convert id to RGB color
-    //
-    //  Inputs
-    //	id: id
-    //  rgb: color
-    //
-    //  Outputs
-    //	none
-    //
-    void Color::pickMonotoneColor( vector< double > &rgb )
-    {
-        rgb.resize( 3 );
-
-        if ( true ){
-            // gray
-            rgb[ 0 ] = 217.0;
-            rgb[ 1 ] = 217.0;
-            rgb[ 2 ] = 217.0;
-        }
-        else {
-            // blue
-            rgb[ 0 ] = 198.0;
-            rgb[ 1 ] = 219.0;
-            rgb[ 2 ] = 239.0;
-        }
-    }
-
-    //
-    //  Color::pickPastelColor --	convert id to RGB color
-    //
-    //  Inputs
-    //	id: id
-    //  rgb: color
-    //
-    //  Outputs
-    //	none
-    //
-    void Color::pickPastelColor( unsigned int id, vector< double > &rgb )
-    {
-        int index = id % MAX_COLOR_TYPE;
-        int shift = -2*( id / MAX_COLOR_TYPE );
-
-        rgb.resize( 3 );
-
-        switch( index ){
-            case 0:
-                rgb[ 0 ] = MIN2( 255, shift+169 );
-                rgb[ 1 ] = MIN2( 255, shift+207 );
-                rgb[ 2 ] = MIN2( 255, shift+244 );
-                break;
-            case 1:
-                rgb[ 0 ] = MIN2( 255, shift+255 );
-                rgb[ 1 ] = MIN2( 255, shift+235 );
-                rgb[ 2 ] = MIN2( 255, shift+176 );
-                break;
-            case 2:
-                rgb[ 0 ] = MIN2( 255, shift+255 );
-                rgb[ 1 ] = MIN2( 255, shift+211 );
-                rgb[ 2 ] = MIN2( 255, shift+247 );
-                break;
-            case 3:
-                rgb[ 0 ] = MIN2( 255, shift+219 );
-                rgb[ 1 ] = MIN2( 255, shift+231 );
-                rgb[ 2 ] = MIN2( 255, shift+155 );
-                break;
-            case 4:
-                rgb[ 0 ] = MIN2( 255, shift+236 );
-                rgb[ 1 ] = MIN2( 255, shift+236 );
-                rgb[ 2 ] = MIN2( 255, shift+236 );
-                break;
-            case 5:
-                rgb[ 0 ] = MIN2( 255, shift+138 );
-                rgb[ 1 ] = MIN2( 255, shift+214 );
-                rgb[ 2 ] = MIN2( 255, shift+237 );
-                break;
-            case 6:
-                rgb[ 0 ] = MIN2( 255, shift+254 );
-                rgb[ 1 ] = MIN2( 255, shift+212 );
-                rgb[ 2 ] = MIN2( 255, shift+190 );
-                break;
-            case 7:
-                rgb[ 0 ] = MIN2( 255, shift+233 );
-                rgb[ 1 ] = MIN2( 255, shift+212 );
-                rgb[ 2 ] = MIN2( 255, shift+241 );
-                break;
-            case 8:
-                rgb[ 0 ] = MIN2( 255, shift+254 );
-                rgb[ 1 ] = MIN2( 255, shift+244 );
-                rgb[ 2 ] = MIN2( 255, shift+217 );
-                break;
-            case 9:
-                rgb[ 0 ] = MIN2( 255, shift+251 );
-                rgb[ 1 ] = MIN2( 255, shift+220 );
-                rgb[ 2 ] = MIN2( 255, shift+226 );
-                break;
-            case 10:
-                rgb[ 0 ] = MIN2( 255, shift+162 );
-                rgb[ 1 ] = MIN2( 255, shift+232 );
-                rgb[ 2 ] = MIN2( 255, shift+172 );
-                break;
-            case 11:
-                rgb[ 0 ] = MIN2( 255, shift+256 );
-                rgb[ 1 ] = MIN2( 255, shift+183 );
-                rgb[ 2 ] = MIN2( 255, shift+174 );
-                break;
-            default:
-                cerr << "sth is wrong here" << endl;
-                break;
-        }
-    }
-
-    //
-    //  Color::pickBrewerColor --	convert id to RGB color
-    //
-    //  Inputs
-    //	id: id
-    //  rgb: color
-    //
-    //  Outputs
-    //	none
-    //
-    void Color::pickBrewerColor( unsigned int id, vector< double > &rgb )
-    {
-        int index = id % MAX_COLOR_TYPE;
-        int shift = -2*(id / MAX_COLOR_TYPE );
-
-        rgb.resize( 3 );
-
-        switch( index ){
-            case 0:
-                rgb[ 0 ] = MIN2( 255,  shift+141 );
-                rgb[ 1 ] = MIN2( 255,  shift+211 );
-                rgb[ 2 ] = MIN2( 255,  shift+199 );
-                break;
-            case 1:
-                rgb[ 0 ] = MIN2( 255,  shift+255 );
-                rgb[ 1 ] = MIN2( 255,  shift+255 );
-                rgb[ 2 ] = MIN2( 255,  shift+179 );
-                break;
-            case 2:
-                rgb[ 0 ] = MIN2( 255,  shift+190 );
-                rgb[ 1 ] = MIN2( 255,  shift+186 );
-                rgb[ 2 ] = MIN2( 255,  shift+218 );
-                break;
-            case 3:
-                rgb[ 0 ] = MIN2( 255,  shift+251 );
-                rgb[ 1 ] = MIN2( 255,  shift+128 );
-                rgb[ 2 ] = MIN2( 255,  shift+114 );
-                break;
-            case 4:
-                rgb[ 0 ] = MIN2( 255,  shift+128 );
-                rgb[ 1 ] = MIN2( 255,  shift+177 );
-                rgb[ 2 ] = MIN2( 255,  shift+211 );
-                break;
-            case 5:
-                rgb[ 0 ] = MIN2( 255,  shift+253 );
-                rgb[ 1 ] = MIN2( 255,  shift+180 );
-                rgb[ 2 ] = MIN2( 255,  shift+98 );
-                break;
-            case 6:
-                rgb[ 0 ] = MIN2( 255,  shift+179 );
-                rgb[ 1 ] = MIN2( 255,  shift+222 );
-                rgb[ 2 ] = MIN2( 255,  shift+105 );
-                break;
-            case 7:
-                rgb[ 0 ] = MIN2( 255,  shift+252 );
-                rgb[ 1 ] = MIN2( 255,  shift+205 );
-                rgb[ 2 ] = MIN2( 255,  shift+229 );
-                break;
-            case 8:
-                rgb[ 0 ] = MIN2( 255,  shift+217 );
-                rgb[ 1 ] = MIN2( 255,  shift+217 );
-                rgb[ 2 ] = MIN2( 255,  shift+217 );
-                break;
-            case 9:
-                rgb[ 0 ] = MIN2( 255,  shift+188 );
-                rgb[ 1 ] = MIN2( 255,  shift+128 );
-                rgb[ 2 ] = MIN2( 255,  shift+189 );
-                break;
-            case 10:
-                rgb[ 0 ] = MIN2( 255,  shift+204 );
-                rgb[ 1 ] = MIN2( 255,  shift+235 );
-                rgb[ 2 ] = MIN2( 255,  shift+197 );
-                break;
-            case 11:
-                rgb[ 0 ] = MIN2( 255,  shift+255 );
-                rgb[ 1 ] = MIN2( 255,  shift+237 );
-                rgb[ 2 ] = MIN2( 255,  shift+111 );
-                break;
-            default:
-                cerr << "sth is wrong here" << endl;
-                break;
-        }
-    }
-
-} // namespace Base
-} // namespace KeiRo
Index: Base/src/Polygon2.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// Polygon2.cc\r\n//\t: program file for 2D coordinates\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Sun Sep 16 15:02:45 2012\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <iostream>\r\n#include <iomanip>\r\n#include <cctype>\r\n#include <cmath>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\n#include \"Polygon2.h\"\r\n\r\nnamespace KeiRo {\r\nnamespace Base {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPrivate Functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tProtected Functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  Polygon2::_init --\tinitialization\r\n    //\r\n    //  Inputs\r\n    //  __elements\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void Polygon2::_init( unsigned int __id, vector< KeiRo::Base::Coord2 > __elements )\r\n    {\r\n        _clear();\r\n\r\n        _id             = __id;\r\n        _gid            = 0;\r\n        _fixedElements  = __elements;\r\n        _elements       = __elements;\r\n\t    _area           = 0.0;\r\n        _initArea       = 0.0;\r\n\r\n        _center.zero();        // average of the elements\r\n        _centroid.zero();      // centroid of the elements\r\n        _boundingBox.clear();        // width and height of the bounding box\r\n//        _boxLeftTop.zero();         // left-top corner of the bounding box\r\n\t\r\n//\t    _stroke.resize( 4 );\r\n//\t    _stroke[0] = _stroke[1] = _stroke[2] = 0;\r\n//\t    _stroke[3] = 255;\r\n//\t    _strokeWidth = 1.0;\r\n//\t    _strokeOpacity = 1.0;\r\n//\r\n//\t    _fill.resize( 4 );\r\n//\t    _fill[0] = _fill[1] = _fill[2] = 100;\r\n//\t    _fill[3] = 255;\r\n//\t    _fillOpacity = 1.0;\r\n    }\r\n\r\n    //\r\n    //  Polygon2::_clear --\tclear elements\r\n    //\r\n    //  Inputs\r\n    //\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void Polygon2::_clear( void )\r\n    {\r\n        _elements.clear();\r\n        _fixedElements.clear();\r\n        _idElements.clear();\r\n\t\r\n\t    _center.zero();             // average of the elements\r\n\t    _centroid.zero();           // centroid of the elements\r\n\t    _boundingBox.clear();        // bounding box\r\n//\t    _oldBoundingBox.clear();     // old bounding box\r\n\r\n\t    _area               = 0.0;\r\n\t    _isSelected         = false;// select flag is set to false by default\r\n\t    //_initArea   = 0.0;\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPublic functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tConstructors & Destructors\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  Polygon2::Polygon2 -- default constructor\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    Polygon2::Polygon2()\r\n    {\r\n        _clear();\r\n\r\n        //Object::Object();\r\n    }\r\n\r\n    //\r\n    //  Polygon2::Polygon2 -- parameterized constructor\r\n    //\r\n    //  Inputs\r\n    //  __elements\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    Polygon2::Polygon2( vector< KeiRo::Base::Coord2 > __elements )\r\n    {\r\n        _elements           = __elements;\r\n        _fixedElements      = _elements;\r\n        _isSelected         = false;\r\n        _initArea           = 0.0;\r\n        _idElements.clear();\r\n    }\r\n\r\n    //\r\n    //  Polygon2::Polygon2 -- copy constructor\r\n    //\r\n    //  Inputs\r\n    //  polygon\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    Polygon2::Polygon2( const Polygon2 & v )\r\n    {\r\n        _id                 = v._id;\r\n        _gid                = v._gid;\r\n        _name               = v._name;\r\n\t    _label              = v._label;\r\n        _area               = v._area;\r\n        _center             = v._center;\r\n        _centroid           = v._centroid;\r\n        _elements           = v._elements;\r\n        _fixedElements      = v._fixedElements;\r\n        _idElements         = v._idElements;\r\n        _boundingBox        = v._boundingBox;\r\n        _isSelected         = v._isSelected;\r\n        _initArea           = v._initArea;\r\n\t\r\n\t    _stroke             = v._stroke;\r\n\t    _strokeWidth        = v._strokeWidth;\r\n\t    \r\n\t    _fill               = v._fill;\r\n    }\r\n\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tAssignment operators\r\n    //------------------------------------------------------------------------------\r\n\r\n    //\r\n    //  Polygon2::operator = --\tassignment\r\n    //\r\n    //  Inputs\r\n    //\tv\t: 2D coordinates\r\n    //\r\n    //  Outputs\r\n    //\treference to this object\r\n    //\r\n    Polygon2 & Polygon2::operator = ( const Polygon2 & p )\r\n    {\r\n        if ( this != &p ) {\r\n            _id                 = p._id;\r\n            _gid                = p._gid;\r\n\t        _name               = p._name;\r\n\t        _label               = p._label;\r\n\t        _area               = p._area;\r\n            _center             = p._center;\r\n            _centroid           = p._centroid;\r\n\t        _elements           = p._elements;\r\n            _fixedElements      = p._fixedElements;\r\n            _idElements         = p._idElements;\r\n            _boundingBox        = p._boundingBox;\r\n            _isSelected         = p._isSelected;\r\n            _fill               = p._fill;\r\n            _stroke             = p._stroke;\r\n\t        _strokeWidth        = p._strokeWidth;\r\n            _initArea           = p._initArea;\r\n        }\r\n\r\n        return *this;\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tSpecial functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  Polygon2::computeBoundingBox --    compute bounding box\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void Polygon2::computeBoundingBox( void )\r\n    {\r\n        double minX = INFINITY, maxX = -INFINITY, minY = INFINITY, maxY = -INFINITY;\r\n        for( unsigned int i = 0; i < _elements.size(); i++ ){\r\n            if( minX > _elements[i].x() ) minX = _elements[i].x();\r\n            if( maxX < _elements[i].x() ) maxX = _elements[i].x();\r\n            if( minY > _elements[i].y() ) minY = _elements[i].y();\r\n            if( maxY < _elements[i].y() ) maxY = _elements[i].y();\r\n        }\r\n\r\n//        _boxLeftTop.x() = minX;\r\n//        _boxLeftTop.y() = minY;\r\n\t    _boundingBox.leftBottom().x() = minX;\r\n\t    _boundingBox.leftBottom().y() = minY;\r\n        _boundingBox.width() = maxX - minX;\r\n        _boundingBox.height() = maxY - minY;\r\n\r\n        // compute the initial area\r\n        if( _initArea == 0.0 ) _initArea = _boundingBox.width() * _boundingBox.height();\r\n    }\r\n\t\r\n\t//\r\n\t//  Polygon2::updateCentroid --    update centroid of the polygon\r\n\t//\r\n\t//  Inputs\r\n\t//  none\r\n\t//\r\n\t//  Outputs\r\n\t//  none\r\n\t//\r\n\tvoid Polygon2::updateCentroid( void ) {\r\n\r\n\t\tCGAL::Polygon_2< K > polygon;\r\n\t\t_centroid.x() = 0.0;\r\n\t\t_centroid.y() = 0.0;\r\n\r\n\t\t// initialization\r\n\t\tfor( unsigned int i = 0; i < _elements.size(); i++ ) {\r\n\t\t\tpolygon.push_back( K::Point_2( _elements[ i ].x(), _elements[ i ].y() ) );\r\n\t\t}\r\n\r\n\t\t// check if the polygon has at least three vertices\r\n\t\tif( !( polygon.size() >= 3 ) ) {\r\n\t\t\tcerr << \"sth is wrong here... at \" << __LINE__ << \" in \" << __FILE__ << endl;\r\n\t\t\tcerr << \"polygon.size() = \" << polygon.size() << endl;\r\n\r\n\t\t\tif( polygon.size() == 0 ) return;\r\n\r\n\t\t\tVertex_circulator curr = polygon.vertices_circulator();\r\n\t\t\tVertex_circulator next = curr;\r\n\t\t\t++next;\r\n\t\t\tCGAL::Vector_2< K > center = ( *curr - ORIGIN ) + ( *next - ORIGIN );\r\n\t\t\tdouble x = 0.5 * CGAL::to_double( center.x() );\r\n\t\t\tdouble y = 0.5 * CGAL::to_double( center.y() );\r\n\t\t\t_centroid.x() = x;\r\n\t\t\t_centroid.y() = y;\r\n\r\n\t\t\treturn;\r\n\t\t\tassert( polygon.size() >= 3 );\r\n\t\t}\r\n\t\tVertex_circulator start = polygon.vertices_circulator();\r\n\t\tVertex_circulator cur = start;\r\n\t\tVertex_circulator next = cur;\r\n\t\t++next;\r\n\t\tCGAL::Vector_2< K > center( 0, 0 );\r\n\t\tdouble a = 0.0, atot = 0.0;\r\n\t\tdo {\r\n\t\t\t// cerr << CGAL::to_double( ((*cur).x()) * ((*next).y()) - ((*next).x()) * ((*cur).y()) ) << endl;\r\n\t\t\ta = CGAL::to_double( ( ( *cur ).x() ) * ( ( *next ).y() ) - ( ( *next ).x() ) * ( ( *cur ).y() ) );\r\n\t\t\tcenter = center + a * ( ( *cur - ORIGIN ) + ( *next - ORIGIN ) );\r\n\t\t\tatot = atot + a;\r\n\t\t\tcur = next;\r\n\t\t\t++next;\r\n\t\t} while( cur != start );\r\n\t\tatot = 3 * atot;\r\n\t\tcenter = center / atot;\r\n\r\n\t\tdouble x = CGAL::to_double( ( ORIGIN + center ).x() );\r\n\t\tdouble y = CGAL::to_double( ( ORIGIN + center ).y() );\r\n\t\t_centroid.x() = x;\r\n\t\t_centroid.y() = y;\r\n\r\n\t\t_area = CGAL::to_double( polygon.area() );\r\n\t\t\r\n\t\t// randomCentroid();\r\n\t}\r\n\t\r\n\t//\r\n\t//  Polygon2::computeCenter --    compute average from the elements\r\n\t//\r\n\t//  Inputs\r\n\t//  none\r\n\t//\r\n\t//  Outputs\r\n\t//  none\r\n\t//\r\n\tvoid Polygon2::computeCenter( void )\r\n\t{\r\n    \tCoord2 sum( 0.0, 0.0 );\r\n\t\tfor( unsigned int i = 0; i < _elements.size(); i++ ){\r\n\t\t\tsum = sum + _elements[i];\r\n\t\t}\r\n\t\t_center = sum / (double)_elements.size();\r\n\t}\r\n\t\r\n\t\r\n\t//\r\n//  Polygon2::updateOrientation --    update polygon elements if they are not counterclockwise\r\n//\r\n//  Inputs\r\n//  none\r\n//\r\n//  Outputs\r\n//  none\r\n//\r\n\tvoid Polygon2::updateOrientation( void ) {\r\n\t\t\r\n\t\tCGAL::Polygon_2< K > p;\r\n\t\t\r\n\t\tif( _elements.size() == 0 ) return;\r\n\t\t\r\n\t\tfor( unsigned int i = 0; i < _elements.size(); i++ ) {\r\n\t\t\tdouble x = _elements[ i ].x();\r\n\t\t\tdouble y = _elements[ i ].y();\r\n\t\t\tdouble nx = _elements[ ( i + 1 ) % ( int ) _elements.size() ].x();\r\n\t\t\tdouble ny = _elements[ ( i + 1 ) % ( int ) _elements.size() ].y();\r\n\t\t\t\r\n\t\t\tp.push_back( K::Point_2( x, y ) );\r\n\t\t}\r\n\r\n#ifdef DEBUG\r\n\t\tcerr << \"polygon:\" << endl << p << endl;\r\n#endif // DEBUG\r\n\t\tif( p.is_simple() == false ) {\r\n\t\t\tcerr << \"polygon is not simple...\" << endl\r\n\t\t\t     << p << endl;\r\n\t\t\tassert( false );\r\n\t\t}\r\n\t\t\r\n\t\tif( p.orientation() == -1 ) {\r\n\t\t\tp.reverse_orientation();\r\n\t\t\t\r\n\t\t\t_elements.clear();\r\n\t\t\tfor( unsigned int i = 0; i < p.size(); i++ ) {\r\n\t\t\t\t_elements.push_back( Coord2( CGAL::to_double( p[ i ].x() ), CGAL::to_double( p[ i ].y() ) ) );\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t//\r\n\t//  Polygon2::inPolygon --    check if the coordinate is in the polygon\r\n\t//\r\n\t//  Inputs\r\n\t//  none\r\n\t//\r\n\t//  Outputs\r\n\t//  none\r\n\t//\r\n\tbool Polygon2::inPolygon( const Coord2 &coord ) {\r\n\t\t\r\n\t\tK::Point_2 *points = new K::Point_2[_elements.size()];\r\n\t\tCGAL::Point_2< K > pt( coord.x(), coord.y() );\r\n\t\t\r\n\t\tfor( unsigned int i = 0; i < _elements.size(); i++ ) {\r\n\t\t\tpoints[ i ] = K::Point_2( _elements[ i ].x(), _elements[ i ].y() );\r\n\t\t}\r\n\t\t\r\n\t\tCGAL::Bounded_side bside = CGAL::bounded_side_2( points, points + _elements.size(), pt );\r\n\t\t\r\n\t\tif( bside == CGAL::ON_BOUNDED_SIDE ) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\t\r\n    //\r\n    //  Polygon2::maxRadiusInPolygon --    find the maximun radius in the polygon\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    double Polygon2::maxRadiusInPolygon( const KeiRo::Base::Coord2 &coord )\r\n    {\r\n        double maxR = INFINITY;\r\n\r\n        for( unsigned int i = 0; i < _elements.size(); i++ ){\r\n\t\r\n\t        KeiRo::Base::Coord2 &coordM = _elements[ i ];\r\n            double dist = (coordM-coord).norm();\r\n            // cerr << \" dist = \" << dist;\r\n            if( dist < maxR ) maxR = dist;\r\n        }\r\n        // cerr << \" return \" << maxR << endl;\r\n\r\n        for( unsigned int i = 0; i < _elements.size(); i++ ){\r\n\t\r\n\t        KeiRo::Base::Coord2 &coordM = _elements[ i ];\r\n\t        KeiRo::Base::Coord2 &coordN = _elements[ (i+1)%(int)_elements.size() ];\r\n\t        KeiRo::Base::Coord2 mnVec = coordN - coordM;\r\n\t        KeiRo::Base::Coord2 cmVec = coord - coordM;\r\n            double D = ( mnVec * cmVec ) / mnVec.squaredNorm();\r\n\t        KeiRo::Base::Coord2 coordD = coordM + D*mnVec;\r\n\r\n            if( KeiRo::Base::Line2::isOnLine( coordD, coordM, coordN )){\r\n\r\n                double dist = ( coord - coordD ).norm();\r\n                if( dist < maxR ) maxR = dist;\r\n            }\r\n        }\r\n\r\n        return maxR;\r\n    }\r\n\t\r\n\t//\r\n\t//  Polygon2::isSimple --    is simple polygon\r\n\t//\r\n\t//  Inputs\r\n\t//  none\r\n\t//\r\n\t//  Outputs\r\n\t//  none\r\n\t//\r\n\tbool Polygon2::isSimple( void ) {\r\n\t\t\r\n\t\tCGAL::Polygon_2< K > poly;\r\n\t\t\r\n\t\tfor( unsigned int i = 0; i < _elements.size(); i++ ) {\r\n\t\t\t\r\n\t\t\tpoly.push_back( K::Point_2( _elements[ i ].x(), _elements[ i ].y() ) );\r\n\t\t}\r\n\t\t\r\n\t\tif( poly.is_simple() == false ) {\r\n\t\t\tcerr << \"isSimple = \" << poly.is_simple() << endl;\r\n\t\t\tcerr << \"(overlap)::_polygon = \" << *this << endl;\r\n\t\t}\r\n\t\t\r\n\t\treturn poly.is_simple();\r\n\t}\r\n\t\r\n\t//\r\n\t//  Polygon2::cleanPolygon --    clean up vertices if the polygon is not simple\r\n\t//\r\n\t//  Inputs\r\n\t//  none\r\n\t//\r\n\t//  Outputs\r\n\t//  none\r\n\t//\r\n\tvoid Polygon2::cleanPolygon( void ) {\r\n\t\t\r\n\t\tif( isSimple() == true ) return;\r\n\t\t\r\n\t\tbool isSimple = false;\r\n\t\tPolygon2 ori = _elements;\r\n\t\tbool isUpdated = false;\r\n\t\tint test = 0;\r\n\r\n#ifdef DEBUG\r\n\t\tcerr << \"(before)::_polygon = \" << endl << *this << endl;\r\n#endif // DEBUG\r\n\t\t\r\n\t\twhile( isSimple == false && ( _elements.size() > 0 ) && test < 5 ) {\r\n\t\t\t\r\n\t\t\ttest++;\r\n\t\t\tCGAL::Polygon_2< K > poly;\r\n\t\t\t\r\n\t\t\t// remove picks\r\n\t\t\tPolygon2 tmp;\r\n\t\t\ttmp.elements() = _elements;\r\n\t\t\t_elements.clear();\r\n\t\t\t// cerr << \"size = \" << tmp.elements().size() << endl;\r\n\t\t\tfor( unsigned int i = 0; i < tmp.elements().size(); i++ ) {\r\n\t\t\t\tint idP = ( i - 1 + ( int ) tmp.elements().size() ) % ( int ) tmp.elements().size();\r\n\t\t\t\tint idN = ( i + 1 ) % ( int ) tmp.elements().size();\r\n\t\t\t\tCoord2 &coordP = tmp.elements()[ idP ];\r\n\t\t\t\tCoord2 &coordI = tmp.elements()[ i ];\r\n\t\t\t\tCoord2 &coordN = tmp.elements()[ idN ];\r\n\t\t\t\tCoord2 PI = coordP - coordI;\r\n\t\t\t\tCoord2 NI = coordN - coordI;\r\n\t\t\t\tCoord2 PN = coordP - coordN;\r\n\t\t\t\tdouble acosValue = acos(\r\n\t\t\t\t\t\t( PI.squaredNorm() + NI.squaredNorm() - PN.squaredNorm() ) / ( 2.0 * PI.norm() * NI.norm() ) );\r\n\t\t\t\tif( acosValue > 5.0 / 180.0 * M_PI ) {\r\n\t\t\t\t\t//if( ( acos( (PI.squaredNorm() + NI.squaredNorm() - PN.squaredNorm())/(2.0*PI.norm()*NI.norm()) ) > 1e-5 ) &&\r\n\t\t\t\t\t//    PN.norm()/NI.norm() > 1e-5  ){\r\n\t\t\t\t\t_elements.push_back( tmp.elements()[ i ] );\r\n\t\t\t\t\tpoly.push_back( K::Point_2( tmp.elements()[ i ].x(), tmp.elements()[ i ].y() ) );\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n#ifdef DEBUG\r\n\t\t\t\t\tcerr << \"acosValue = \" << acosValue << endl;\r\n\t\t\t\tcerr << \"idP = \" << idP << \" i = \" << i << \" idN = \" << idN << endl;\r\n\t\t\t\tcerr << \"P = \" << coordP;\r\n\t\t\t\tcerr << \"I = \" << coordI;\r\n\t\t\t\tcerr << \"N = \" << coordN;\r\n\t\t\t\tcerr << \"PI = \" << PI;\r\n\t\t\t\tcerr << \"NI = \" << NI;\r\n\t\t\t\tcerr << \"PN =\" << PN;\r\n#endif // DEBUG\r\n\t\t\t\t\tisUpdated = true;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// put the rest of the vector back and break\r\n\t\t\t\t\tfor( unsigned int j = i + 1; j < tmp.elements().size(); j++ ) {\r\n\t\t\t\t\t\t_elements.push_back( tmp.elements()[ j ] );\r\n\t\t\t\t\t\tpoly.push_back( K::Point_2( tmp.elements()[ j ].x(), tmp.elements()[ j ].y() ) );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// remove overlapped vertices\r\n\t\t\tpoly.clear();\r\n\t\t\tfor( unsigned int j = 0; j < _elements.size(); j++ ) {\r\n\t\t\t\tif( ( _elements[ j ] - _elements[ ( j + 1 ) % ( int ) _elements.size() ] ).norm() > MIN_VERTEX_DISTANCE )\r\n\t\t\t\t\tpoly.push_back( K::Point_2( _elements[ j ].x(), _elements[ j ].y() ) );\r\n\t\t\t\telse {\r\n#ifdef DEBUG\r\n\t\t\t\t\tcerr << \"curr = \" << _elements[ j ]\r\n\t\t\t\t\t << \"next = \" << _elements[ ( j + 1 ) % ( int ) _elements.size() ] << endl;\r\n\t\t\t\tcerr << \"idC = \" << j << \" idN = \" << ( j + 1 ) % ( int ) _elements.size() << endl;\r\n#endif // DEBUG\r\n\t\t\t\t\tisUpdated = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t_elements.clear();\r\n\t\t\tfor( unsigned int j = 0; j < poly.size(); j++ ) {\r\n\t\t\t\t_elements.push_back( Coord2( CGAL::to_double( poly[ j ].x() ),\r\n\t\t\t\t                             CGAL::to_double( poly[ j ].y() ) ) );\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tisSimple = poly.is_simple();\r\n\t\t\tif( poly.is_simple() == false ) {\r\n\t\t\t\tcerr << \"isSimple = \" << poly.is_simple() << endl;\r\n\t\t\t\tcerr << \"(overlap)::_polygon = \" << *this << endl;\r\n\t\t\t\tcerr << \"(original)::_polygon = \" << ori << endl;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif( isUpdated == true )\r\n\t\t\tcerr << \"(clean)::_polygon = \" << endl << *this << endl;\r\n\t}\r\n\t\r\n\t//\r\n\t//  Polygon2::normalization --    normalize the polygon based on input boundary\r\n\t//\r\n\t//  Inputs\r\n\t//  r   : boundary rectangle\r\n\t//\r\n\t//  Outputs\r\n\t//  none\r\n\t//\r\n\tvoid Polygon2::normalization( Rectangle2 &r )\r\n\t{\r\n\t\t_boundingBox.oldLeftBottom().x() = _boundingBox.leftBottom().x();\r\n\t\t_boundingBox.oldLeftBottom().y() = _boundingBox.leftBottom().y();\r\n\t\t_boundingBox.oldWidth() = _boundingBox.width();\r\n\t\t_boundingBox.oldHeight() = _boundingBox.height();\r\n\t\t_boundingBox.leftBottom().x() = r.leftBottom().x();\r\n\t\t_boundingBox.leftBottom().y() = r.leftBottom().y();\r\n\t\t_boundingBox.width()   = r.width();\r\n\t\t_boundingBox.height()  = r.height();\r\n\r\n\t\tdouble minX = INFINITY, minY = INFINITY, maxX = -INFINITY, maxY = -INFINITY;\r\n\t\tfor( unsigned int i = 0; i < _elements.size(); i++ ){\r\n\t\t\tif( _elements[i].x() <= minX ) minX = _elements[i].x();\r\n\t\t\tif( _elements[i].x() >= maxX ) maxX = _elements[i].x();\r\n\t\t\tif( _elements[i].y() <= minY ) minY = _elements[i].y();\r\n\t\t\tif( _elements[i].y() >= maxY ) maxY = _elements[i].y();\r\n\t\t}\r\n\t\t\r\n\t\t// normalize\r\n\t\tfor( unsigned int i = 0; i < _elements.size(); i++ ) {\r\n\t\t\t_elements[i].x() = ( _elements[i].x() - minX ) * r.width() / ( maxX - minX ) + r.leftBottom().x();\r\n\t\t\t_elements[i].y() = ( _elements[i].y() - minY ) * r.height() / ( maxY - minY ) + r.leftBottom().y();\r\n\t\t}\r\n    }\r\n    \r\n    //------------------------------------------------------------------------------\r\n    //\tFriend functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tI/O functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  operator << --\toutput\r\n    //\r\n    //  Inputs\r\n    //\ts\t: reference to output stream\r\n    //\tv\t: 2D coordinates\r\n    //\r\n    //  Outputs\r\n    //\treference to output stream\r\n    //\r\n    ostream & operator << ( ostream & stream, const Polygon2 & obj )\r\n    {\r\n        // set the output formatting\r\n        //stream << setiosflags( ios::showpoint );\r\n        //stream << setprecision( 8 );\r\n        //int width = 16;\r\n        // print out the elements\r\n        for ( unsigned int i = 0; i < obj._elements.size(); i++ ) {\r\n            //stream << setw( width ) << obj._element[ i ];\r\n            stream << setw( 4 ) << obj._elements[ i ];\r\n            if ( i != 1 ) stream << \"\\t\";\r\n        }\r\n        stream << endl;\r\n\r\n        return stream;\r\n    }\r\n\r\n    //\r\n    //  operator >> --\tinput\r\n    //\r\n    //  Inputs\r\n    //\ts\t: reference to input stream\r\n    //\tv\t: 2D coordinates\r\n    //\r\n    //  Outputs\r\n    //\treference to input stream\r\n    //\r\n    istream & operator >> ( istream & stream, Polygon2 & obj )\r\n    {\r\n        // reading the elements\r\n        for ( unsigned int i = 0; i < obj._elements.size(); i++ )\r\n        stream >> obj._elements[ i ];\r\n        return stream;\r\n    }\r\n\r\n} // namespace Base\r\n} // namespace KeiRo\r\n\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Base/src/Polygon2.cpp b/Base/src/Polygon2.cpp
--- a/Base/src/Polygon2.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Base/src/Polygon2.cpp	(date 1729410605140)
@@ -1,662 +1,0 @@
-//******************************************************************************
-// Polygon2.cc
-//	: program file for 2D coordinates
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Sun Sep 16 15:02:45 2012
-//
-//******************************************************************************
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <iostream>
-#include <iomanip>
-#include <cctype>
-#include <cmath>
-#include <algorithm>
-
-using namespace std;
-
-#include "Polygon2.h"
-
-namespace KeiRo {
-namespace Base {
-
-    //------------------------------------------------------------------------------
-    //	Private Functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Protected Functions
-    //------------------------------------------------------------------------------
-    //
-    //  Polygon2::_init --	initialization
-    //
-    //  Inputs
-    //  __elements
-    //
-    //  Outputs
-    //  none
-    //
-    void Polygon2::_init( unsigned int __id, vector< KeiRo::Base::Coord2 > __elements )
-    {
-        _clear();
-
-        _id             = __id;
-        _gid            = 0;
-        _fixedElements  = __elements;
-        _elements       = __elements;
-	    _area           = 0.0;
-        _initArea       = 0.0;
-
-        _center.zero();        // average of the elements
-        _centroid.zero();      // centroid of the elements
-        _boundingBox.clear();        // width and height of the bounding box
-//        _boxLeftTop.zero();         // left-top corner of the bounding box
-	
-//	    _stroke.resize( 4 );
-//	    _stroke[0] = _stroke[1] = _stroke[2] = 0;
-//	    _stroke[3] = 255;
-//	    _strokeWidth = 1.0;
-//	    _strokeOpacity = 1.0;
-//
-//	    _fill.resize( 4 );
-//	    _fill[0] = _fill[1] = _fill[2] = 100;
-//	    _fill[3] = 255;
-//	    _fillOpacity = 1.0;
-    }
-
-    //
-    //  Polygon2::_clear --	clear elements
-    //
-    //  Inputs
-    //
-    //
-    //  Outputs
-    //  none
-    //
-    void Polygon2::_clear( void )
-    {
-        _elements.clear();
-        _fixedElements.clear();
-        _idElements.clear();
-	
-	    _center.zero();             // average of the elements
-	    _centroid.zero();           // centroid of the elements
-	    _boundingBox.clear();        // bounding box
-//	    _oldBoundingBox.clear();     // old bounding box
-
-	    _area               = 0.0;
-	    _isSelected         = false;// select flag is set to false by default
-	    //_initArea   = 0.0;
-    }
-
-    //------------------------------------------------------------------------------
-    //	Public functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	Constructors & Destructors
-    //------------------------------------------------------------------------------
-    //
-    //  Polygon2::Polygon2 -- default constructor
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    //
-    Polygon2::Polygon2()
-    {
-        _clear();
-
-        //Object::Object();
-    }
-
-    //
-    //  Polygon2::Polygon2 -- parameterized constructor
-    //
-    //  Inputs
-    //  __elements
-    //
-    //  Outputs
-    //  none
-    //
-    Polygon2::Polygon2( vector< KeiRo::Base::Coord2 > __elements )
-    {
-        _elements           = __elements;
-        _fixedElements      = _elements;
-        _isSelected         = false;
-        _initArea           = 0.0;
-        _idElements.clear();
-    }
-
-    //
-    //  Polygon2::Polygon2 -- copy constructor
-    //
-    //  Inputs
-    //  polygon
-    //
-    //  Outputs
-    //  none
-    //
-    Polygon2::Polygon2( const Polygon2 & v )
-    {
-        _id                 = v._id;
-        _gid                = v._gid;
-        _name               = v._name;
-	    _label              = v._label;
-        _area               = v._area;
-        _center             = v._center;
-        _centroid           = v._centroid;
-        _elements           = v._elements;
-        _fixedElements      = v._fixedElements;
-        _idElements         = v._idElements;
-        _boundingBox        = v._boundingBox;
-        _isSelected         = v._isSelected;
-        _initArea           = v._initArea;
-	
-	    _stroke             = v._stroke;
-	    _strokeWidth        = v._strokeWidth;
-	    
-	    _fill               = v._fill;
-    }
-
-
-    //------------------------------------------------------------------------------
-    //	Assignment operators
-    //------------------------------------------------------------------------------
-
-    //
-    //  Polygon2::operator = --	assignment
-    //
-    //  Inputs
-    //	v	: 2D coordinates
-    //
-    //  Outputs
-    //	reference to this object
-    //
-    Polygon2 & Polygon2::operator = ( const Polygon2 & p )
-    {
-        if ( this != &p ) {
-            _id                 = p._id;
-            _gid                = p._gid;
-	        _name               = p._name;
-	        _label               = p._label;
-	        _area               = p._area;
-            _center             = p._center;
-            _centroid           = p._centroid;
-	        _elements           = p._elements;
-            _fixedElements      = p._fixedElements;
-            _idElements         = p._idElements;
-            _boundingBox        = p._boundingBox;
-            _isSelected         = p._isSelected;
-            _fill               = p._fill;
-            _stroke             = p._stroke;
-	        _strokeWidth        = p._strokeWidth;
-            _initArea           = p._initArea;
-        }
-
-        return *this;
-    }
-
-    //------------------------------------------------------------------------------
-    //	Special functions
-    //------------------------------------------------------------------------------
-    //
-    //  Polygon2::computeBoundingBox --    compute bounding box
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    //
-    void Polygon2::computeBoundingBox( void )
-    {
-        double minX = INFINITY, maxX = -INFINITY, minY = INFINITY, maxY = -INFINITY;
-        for( unsigned int i = 0; i < _elements.size(); i++ ){
-            if( minX > _elements[i].x() ) minX = _elements[i].x();
-            if( maxX < _elements[i].x() ) maxX = _elements[i].x();
-            if( minY > _elements[i].y() ) minY = _elements[i].y();
-            if( maxY < _elements[i].y() ) maxY = _elements[i].y();
-        }
-
-//        _boxLeftTop.x() = minX;
-//        _boxLeftTop.y() = minY;
-	    _boundingBox.leftBottom().x() = minX;
-	    _boundingBox.leftBottom().y() = minY;
-        _boundingBox.width() = maxX - minX;
-        _boundingBox.height() = maxY - minY;
-
-        // compute the initial area
-        if( _initArea == 0.0 ) _initArea = _boundingBox.width() * _boundingBox.height();
-    }
-	
-	//
-	//  Polygon2::updateCentroid --    update centroid of the polygon
-	//
-	//  Inputs
-	//  none
-	//
-	//  Outputs
-	//  none
-	//
-	void Polygon2::updateCentroid( void ) {
-
-		CGAL::Polygon_2< K > polygon;
-		_centroid.x() = 0.0;
-		_centroid.y() = 0.0;
-
-		// initialization
-		for( unsigned int i = 0; i < _elements.size(); i++ ) {
-			polygon.push_back( K::Point_2( _elements[ i ].x(), _elements[ i ].y() ) );
-		}
-
-		// check if the polygon has at least three vertices
-		if( !( polygon.size() >= 3 ) ) {
-			cerr << "sth is wrong here... at " << __LINE__ << " in " << __FILE__ << endl;
-			cerr << "polygon.size() = " << polygon.size() << endl;
-
-			if( polygon.size() == 0 ) return;
-
-			Vertex_circulator curr = polygon.vertices_circulator();
-			Vertex_circulator next = curr;
-			++next;
-			CGAL::Vector_2< K > center = ( *curr - ORIGIN ) + ( *next - ORIGIN );
-			double x = 0.5 * CGAL::to_double( center.x() );
-			double y = 0.5 * CGAL::to_double( center.y() );
-			_centroid.x() = x;
-			_centroid.y() = y;
-
-			return;
-			assert( polygon.size() >= 3 );
-		}
-		Vertex_circulator start = polygon.vertices_circulator();
-		Vertex_circulator cur = start;
-		Vertex_circulator next = cur;
-		++next;
-		CGAL::Vector_2< K > center( 0, 0 );
-		double a = 0.0, atot = 0.0;
-		do {
-			// cerr << CGAL::to_double( ((*cur).x()) * ((*next).y()) - ((*next).x()) * ((*cur).y()) ) << endl;
-			a = CGAL::to_double( ( ( *cur ).x() ) * ( ( *next ).y() ) - ( ( *next ).x() ) * ( ( *cur ).y() ) );
-			center = center + a * ( ( *cur - ORIGIN ) + ( *next - ORIGIN ) );
-			atot = atot + a;
-			cur = next;
-			++next;
-		} while( cur != start );
-		atot = 3 * atot;
-		center = center / atot;
-
-		double x = CGAL::to_double( ( ORIGIN + center ).x() );
-		double y = CGAL::to_double( ( ORIGIN + center ).y() );
-		_centroid.x() = x;
-		_centroid.y() = y;
-
-		_area = CGAL::to_double( polygon.area() );
-		
-		// randomCentroid();
-	}
-	
-	//
-	//  Polygon2::computeCenter --    compute average from the elements
-	//
-	//  Inputs
-	//  none
-	//
-	//  Outputs
-	//  none
-	//
-	void Polygon2::computeCenter( void )
-	{
-    	Coord2 sum( 0.0, 0.0 );
-		for( unsigned int i = 0; i < _elements.size(); i++ ){
-			sum = sum + _elements[i];
-		}
-		_center = sum / (double)_elements.size();
-	}
-	
-	
-	//
-//  Polygon2::updateOrientation --    update polygon elements if they are not counterclockwise
-//
-//  Inputs
-//  none
-//
-//  Outputs
-//  none
-//
-	void Polygon2::updateOrientation( void ) {
-		
-		CGAL::Polygon_2< K > p;
-		
-		if( _elements.size() == 0 ) return;
-		
-		for( unsigned int i = 0; i < _elements.size(); i++ ) {
-			double x = _elements[ i ].x();
-			double y = _elements[ i ].y();
-			double nx = _elements[ ( i + 1 ) % ( int ) _elements.size() ].x();
-			double ny = _elements[ ( i + 1 ) % ( int ) _elements.size() ].y();
-			
-			p.push_back( K::Point_2( x, y ) );
-		}
-
-#ifdef DEBUG
-		cerr << "polygon:" << endl << p << endl;
-#endif // DEBUG
-		if( p.is_simple() == false ) {
-			cerr << "polygon is not simple..." << endl
-			     << p << endl;
-			assert( false );
-		}
-		
-		if( p.orientation() == -1 ) {
-			p.reverse_orientation();
-			
-			_elements.clear();
-			for( unsigned int i = 0; i < p.size(); i++ ) {
-				_elements.push_back( Coord2( CGAL::to_double( p[ i ].x() ), CGAL::to_double( p[ i ].y() ) ) );
-			}
-		}
-	}
-
-	//
-	//  Polygon2::inPolygon --    check if the coordinate is in the polygon
-	//
-	//  Inputs
-	//  none
-	//
-	//  Outputs
-	//  none
-	//
-	bool Polygon2::inPolygon( const Coord2 &coord ) {
-		
-		K::Point_2 *points = new K::Point_2[_elements.size()];
-		CGAL::Point_2< K > pt( coord.x(), coord.y() );
-		
-		for( unsigned int i = 0; i < _elements.size(); i++ ) {
-			points[ i ] = K::Point_2( _elements[ i ].x(), _elements[ i ].y() );
-		}
-		
-		CGAL::Bounded_side bside = CGAL::bounded_side_2( points, points + _elements.size(), pt );
-		
-		if( bside == CGAL::ON_BOUNDED_SIDE ) {
-			return true;
-		}
-		
-		return false;
-	}
-	
-	
-    //
-    //  Polygon2::maxRadiusInPolygon --    find the maximun radius in the polygon
-    //
-    //  Inputs
-    //  none
-    //
-    //  Outputs
-    //  none
-    //
-    double Polygon2::maxRadiusInPolygon( const KeiRo::Base::Coord2 &coord )
-    {
-        double maxR = INFINITY;
-
-        for( unsigned int i = 0; i < _elements.size(); i++ ){
-	
-	        KeiRo::Base::Coord2 &coordM = _elements[ i ];
-            double dist = (coordM-coord).norm();
-            // cerr << " dist = " << dist;
-            if( dist < maxR ) maxR = dist;
-        }
-        // cerr << " return " << maxR << endl;
-
-        for( unsigned int i = 0; i < _elements.size(); i++ ){
-	
-	        KeiRo::Base::Coord2 &coordM = _elements[ i ];
-	        KeiRo::Base::Coord2 &coordN = _elements[ (i+1)%(int)_elements.size() ];
-	        KeiRo::Base::Coord2 mnVec = coordN - coordM;
-	        KeiRo::Base::Coord2 cmVec = coord - coordM;
-            double D = ( mnVec * cmVec ) / mnVec.squaredNorm();
-	        KeiRo::Base::Coord2 coordD = coordM + D*mnVec;
-
-            if( KeiRo::Base::Line2::isOnLine( coordD, coordM, coordN )){
-
-                double dist = ( coord - coordD ).norm();
-                if( dist < maxR ) maxR = dist;
-            }
-        }
-
-        return maxR;
-    }
-	
-	//
-	//  Polygon2::isSimple --    is simple polygon
-	//
-	//  Inputs
-	//  none
-	//
-	//  Outputs
-	//  none
-	//
-	bool Polygon2::isSimple( void ) {
-		
-		CGAL::Polygon_2< K > poly;
-		
-		for( unsigned int i = 0; i < _elements.size(); i++ ) {
-			
-			poly.push_back( K::Point_2( _elements[ i ].x(), _elements[ i ].y() ) );
-		}
-		
-		if( poly.is_simple() == false ) {
-			cerr << "isSimple = " << poly.is_simple() << endl;
-			cerr << "(overlap)::_polygon = " << *this << endl;
-		}
-		
-		return poly.is_simple();
-	}
-	
-	//
-	//  Polygon2::cleanPolygon --    clean up vertices if the polygon is not simple
-	//
-	//  Inputs
-	//  none
-	//
-	//  Outputs
-	//  none
-	//
-	void Polygon2::cleanPolygon( void ) {
-		
-		if( isSimple() == true ) return;
-		
-		bool isSimple = false;
-		Polygon2 ori = _elements;
-		bool isUpdated = false;
-		int test = 0;
-
-#ifdef DEBUG
-		cerr << "(before)::_polygon = " << endl << *this << endl;
-#endif // DEBUG
-		
-		while( isSimple == false && ( _elements.size() > 0 ) && test < 5 ) {
-			
-			test++;
-			CGAL::Polygon_2< K > poly;
-			
-			// remove picks
-			Polygon2 tmp;
-			tmp.elements() = _elements;
-			_elements.clear();
-			// cerr << "size = " << tmp.elements().size() << endl;
-			for( unsigned int i = 0; i < tmp.elements().size(); i++ ) {
-				int idP = ( i - 1 + ( int ) tmp.elements().size() ) % ( int ) tmp.elements().size();
-				int idN = ( i + 1 ) % ( int ) tmp.elements().size();
-				Coord2 &coordP = tmp.elements()[ idP ];
-				Coord2 &coordI = tmp.elements()[ i ];
-				Coord2 &coordN = tmp.elements()[ idN ];
-				Coord2 PI = coordP - coordI;
-				Coord2 NI = coordN - coordI;
-				Coord2 PN = coordP - coordN;
-				double acosValue = acos(
-						( PI.squaredNorm() + NI.squaredNorm() - PN.squaredNorm() ) / ( 2.0 * PI.norm() * NI.norm() ) );
-				if( acosValue > 5.0 / 180.0 * M_PI ) {
-					//if( ( acos( (PI.squaredNorm() + NI.squaredNorm() - PN.squaredNorm())/(2.0*PI.norm()*NI.norm()) ) > 1e-5 ) &&
-					//    PN.norm()/NI.norm() > 1e-5  ){
-					_elements.push_back( tmp.elements()[ i ] );
-					poly.push_back( K::Point_2( tmp.elements()[ i ].x(), tmp.elements()[ i ].y() ) );
-				}
-				else {
-#ifdef DEBUG
-					cerr << "acosValue = " << acosValue << endl;
-				cerr << "idP = " << idP << " i = " << i << " idN = " << idN << endl;
-				cerr << "P = " << coordP;
-				cerr << "I = " << coordI;
-				cerr << "N = " << coordN;
-				cerr << "PI = " << PI;
-				cerr << "NI = " << NI;
-				cerr << "PN =" << PN;
-#endif // DEBUG
-					isUpdated = true;
-					
-					// put the rest of the vector back and break
-					for( unsigned int j = i + 1; j < tmp.elements().size(); j++ ) {
-						_elements.push_back( tmp.elements()[ j ] );
-						poly.push_back( K::Point_2( tmp.elements()[ j ].x(), tmp.elements()[ j ].y() ) );
-					}
-					break;
-				}
-			}
-			
-			// remove overlapped vertices
-			poly.clear();
-			for( unsigned int j = 0; j < _elements.size(); j++ ) {
-				if( ( _elements[ j ] - _elements[ ( j + 1 ) % ( int ) _elements.size() ] ).norm() > MIN_VERTEX_DISTANCE )
-					poly.push_back( K::Point_2( _elements[ j ].x(), _elements[ j ].y() ) );
-				else {
-#ifdef DEBUG
-					cerr << "curr = " << _elements[ j ]
-					 << "next = " << _elements[ ( j + 1 ) % ( int ) _elements.size() ] << endl;
-				cerr << "idC = " << j << " idN = " << ( j + 1 ) % ( int ) _elements.size() << endl;
-#endif // DEBUG
-					isUpdated = true;
-				}
-			}
-			
-			_elements.clear();
-			for( unsigned int j = 0; j < poly.size(); j++ ) {
-				_elements.push_back( Coord2( CGAL::to_double( poly[ j ].x() ),
-				                             CGAL::to_double( poly[ j ].y() ) ) );
-			}
-			
-			isSimple = poly.is_simple();
-			if( poly.is_simple() == false ) {
-				cerr << "isSimple = " << poly.is_simple() << endl;
-				cerr << "(overlap)::_polygon = " << *this << endl;
-				cerr << "(original)::_polygon = " << ori << endl;
-			}
-			else {
-				break;
-			}
-		}
-		
-		if( isUpdated == true )
-			cerr << "(clean)::_polygon = " << endl << *this << endl;
-	}
-	
-	//
-	//  Polygon2::normalization --    normalize the polygon based on input boundary
-	//
-	//  Inputs
-	//  r   : boundary rectangle
-	//
-	//  Outputs
-	//  none
-	//
-	void Polygon2::normalization( Rectangle2 &r )
-	{
-		_boundingBox.oldLeftBottom().x() = _boundingBox.leftBottom().x();
-		_boundingBox.oldLeftBottom().y() = _boundingBox.leftBottom().y();
-		_boundingBox.oldWidth() = _boundingBox.width();
-		_boundingBox.oldHeight() = _boundingBox.height();
-		_boundingBox.leftBottom().x() = r.leftBottom().x();
-		_boundingBox.leftBottom().y() = r.leftBottom().y();
-		_boundingBox.width()   = r.width();
-		_boundingBox.height()  = r.height();
-
-		double minX = INFINITY, minY = INFINITY, maxX = -INFINITY, maxY = -INFINITY;
-		for( unsigned int i = 0; i < _elements.size(); i++ ){
-			if( _elements[i].x() <= minX ) minX = _elements[i].x();
-			if( _elements[i].x() >= maxX ) maxX = _elements[i].x();
-			if( _elements[i].y() <= minY ) minY = _elements[i].y();
-			if( _elements[i].y() >= maxY ) maxY = _elements[i].y();
-		}
-		
-		// normalize
-		for( unsigned int i = 0; i < _elements.size(); i++ ) {
-			_elements[i].x() = ( _elements[i].x() - minX ) * r.width() / ( maxX - minX ) + r.leftBottom().x();
-			_elements[i].y() = ( _elements[i].y() - minY ) * r.height() / ( maxY - minY ) + r.leftBottom().y();
-		}
-    }
-    
-    //------------------------------------------------------------------------------
-    //	Friend functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	I/O functions
-    //------------------------------------------------------------------------------
-    //
-    //  operator << --	output
-    //
-    //  Inputs
-    //	s	: reference to output stream
-    //	v	: 2D coordinates
-    //
-    //  Outputs
-    //	reference to output stream
-    //
-    ostream & operator << ( ostream & stream, const Polygon2 & obj )
-    {
-        // set the output formatting
-        //stream << setiosflags( ios::showpoint );
-        //stream << setprecision( 8 );
-        //int width = 16;
-        // print out the elements
-        for ( unsigned int i = 0; i < obj._elements.size(); i++ ) {
-            //stream << setw( width ) << obj._element[ i ];
-            stream << setw( 4 ) << obj._elements[ i ];
-            if ( i != 1 ) stream << "\t";
-        }
-        stream << endl;
-
-        return stream;
-    }
-
-    //
-    //  operator >> --	input
-    //
-    //  Inputs
-    //	s	: reference to input stream
-    //	v	: 2D coordinates
-    //
-    //  Outputs
-    //	reference to input stream
-    //
-    istream & operator >> ( istream & stream, Polygon2 & obj )
-    {
-        // reading the elements
-        for ( unsigned int i = 0; i < obj._elements.size(); i++ )
-        stream >> obj._elements[ i ];
-        return stream;
-    }
-
-} // namespace Base
-} // namespace KeiRo
-
-
-
-
Index: Base/src/Base.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#ifndef _Base_H\r\n#define _Base_H\r\n\r\n#include <iostream>\r\n#include <sstream>\r\n#include <fstream>\r\n\r\nusing namespace std;\r\n\r\nnamespace KeiRo {\r\nnamespace Base {\r\n\r\nclass Base\r\n{\r\n\t//------------------------------------------------------------------------------\r\n\t//  Defining Classes\r\n\t//------------------------------------------------------------------------------\r\n\t\r\nprivate:\r\n\r\nprotected:\r\n\r\npublic:\r\n\t\r\n\t//------------------------------------------------------------------------------\r\n\t//      Constructors & Destructors\r\n\t//------------------------------------------------------------------------------\r\n\t// default constructor\r\n\tBase( void ) {}\r\n\t// copy constructor\r\n\tBase( const Base & v ) {}\r\n\t// destructor\r\n\tvirtual ~Base( void ) {}\r\n\t\r\n\t//------------------------------------------------------------------------------\r\n\t//      Special functions\r\n\t//------------------------------------------------------------------------------\r\n\tvirtual void init( void ) = 0;\r\n\tvirtual void run( void ) = 0;\r\n\t\r\n\t//------------------------------------------------------------------------------\r\n\t//      I/O functions\r\n\t//------------------------------------------------------------------------------\r\n\t// output\r\n\tfriend ostream & operator << ( ostream & stream, const Base & obj );\r\n\t// input\r\n\tfriend istream & operator >> ( istream & stream, Base & obj );\r\n\t// class name\r\n\tvirtual const char * className( void ) const { return \"Base\"; }\r\n};\r\n\r\n} // namespace Base\r\n} // namespace KeiRo\r\n\r\n#endif // _Base_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Base/src/Base.h b/Base/src/Base.h
--- a/Base/src/Base.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Base/src/Base.h	(date 1729410605150)
@@ -1,55 +1,0 @@
-#ifndef _Base_H
-#define _Base_H
-
-#include <iostream>
-#include <sstream>
-#include <fstream>
-
-using namespace std;
-
-namespace KeiRo {
-namespace Base {
-
-class Base
-{
-	//------------------------------------------------------------------------------
-	//  Defining Classes
-	//------------------------------------------------------------------------------
-	
-private:
-
-protected:
-
-public:
-	
-	//------------------------------------------------------------------------------
-	//      Constructors & Destructors
-	//------------------------------------------------------------------------------
-	// default constructor
-	Base( void ) {}
-	// copy constructor
-	Base( const Base & v ) {}
-	// destructor
-	virtual ~Base( void ) {}
-	
-	//------------------------------------------------------------------------------
-	//      Special functions
-	//------------------------------------------------------------------------------
-	virtual void init( void ) = 0;
-	virtual void run( void ) = 0;
-	
-	//------------------------------------------------------------------------------
-	//      I/O functions
-	//------------------------------------------------------------------------------
-	// output
-	friend ostream & operator << ( ostream & stream, const Base & obj );
-	// input
-	friend istream & operator >> ( istream & stream, Base & obj );
-	// class name
-	virtual const char * className( void ) const { return "Base"; }
-};
-
-} // namespace Base
-} // namespace KeiRo
-
-#endif // _Base_H
Index: Base/src/Label_todo.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//==============================================================================\r\n// Label.cc\r\n//\t: program file for annotation labels\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\t\t\t\tDate: Sun Jul 22 03:01:14 2012\r\n//\r\n//==============================================================================\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include \"Common.h\"\r\n#include \"Label.h\"\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Macros\r\n//------------------------------------------------------------------------------\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tPrivate Functions\r\n//------------------------------------------------------------------------------\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tProtected Functions\r\n//------------------------------------------------------------------------------\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tPublic Functions\r\n//------------------------------------------------------------------------------\r\n\r\n//------------------------------------------------------------------------------\r\n//\tConstructors\r\n//------------------------------------------------------------------------------\r\n\r\n//\r\n//  Label::Label --\tdefault constructor\r\n//\r\n//  Inputs\r\n//\tnone\r\n//\r\n//  Outputs\r\n//\tnone\r\n//\r\nLabel::Label() \r\n{\r\n    _id = NO_UNSIGNED_ID;\r\n    _width = 0.0;\r\n    _height = 0.0;\r\n    _flag = false;\r\n    _leaderW = 1.0;\r\n    _geoSite.zero();\r\n    _curSite.zero();\r\n    _joint.zero();\r\n    _leftTop.zero();\r\n    _rightBottom.zero();\r\n    _frame.zero();\r\n    _base.zero();\r\n}\r\n\r\n\r\n//\r\n//  Label::Label --\tcopy constructor\r\n//\r\n//  Inputs\r\n//\tobj\t: object of this class\r\n//\r\n//  Outputs\r\n//\tnone\r\n//\r\nLabel::Label( const Label & obj )\r\n{\r\n    _id\t\t= obj._id;\r\n    _width\t= obj._width;\r\n    _height\t= obj._height;\r\n    _flag\t= obj._flag;\r\n    _geoSite\t= obj._geoSite;\r\n    _curSite\t= obj._curSite;\r\n    _leaderW\t= obj._leaderW;\r\n    _joint\t= obj._joint;\r\n    _leftTop\t= obj._leftTop;\r\n    _rightBottom= obj._rightBottom;\r\n    _frame\t= obj._frame;\r\n    _base\t= obj._base;\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDestructor\r\n//------------------------------------------------------------------------------\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tReferring to members\r\n//------------------------------------------------------------------------------\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tFunctions for placing labels\r\n//------------------------------------------------------------------------------\r\n\r\n//\r\n//  Label::minimizeLeader --\tminimize the leader length by searching for the\r\n//\t\t\t\tbest joint position \r\n//\r\n//  Inputs\r\n//\tvariable : explanation of a variable\r\n//\tvariable : explanation of a variable\r\n//\r\n//  Outputs\r\n//\tleader length\r\n//\r\ndouble Label::minimizeLeader( const Coord2 & curSite, const Coord2 & corner, const double & interval,\r\n\t\t\t      Coord2 & coord )\r\n{\r\n    double minDist = INFINITY;\r\n    Coord2 minCoord;\r\n\r\n    int i, j;\r\n    const int m = 5;\r\n\r\n//------------------------------------------------------------------------------\r\n//\ttop horizontal frame segment\r\n//------------------------------------------------------------------------------\r\n    j = 0;\r\n    for ( i = m; i <= _frame.p()*10-m; ++i ) {\r\n\tdouble ii = ( double )i/10.0;\r\n\tCoord2 curCoord = corner + Coord2( ii*interval, (double)-j*interval );\r\n\tdouble curDist = distanceBetween( curSite, curCoord );\r\n#ifdef DEBUG\r\n\tcerr << \"[T] i = \" << i << \" j = \" << j << \" dist = \" << curDist << \" coord = \" << curCoord;\r\n#endif\t// DEBUG\r\n\tif ( curDist < minDist ) {\r\n\t    minDist = curDist;\r\n\t    minCoord = curCoord;\r\n\t}\r\n    }\r\n//------------------------------------------------------------------------------\r\n//\tbottom horizontal frame segment\r\n//------------------------------------------------------------------------------\r\n    j = _frame.q();\r\n    for ( i = m; i <= _frame.p()*10-m; ++i ) {\r\n\tdouble ii = ( double )i/10.0;\r\n\tCoord2 curCoord = corner + Coord2( ii*interval, (double)-j*interval );\r\n\tdouble curDist = distanceBetween( curSite, curCoord );\r\n#ifdef DEBUG\r\n\tcerr << \"[B] i = \" << i << \" j = \" << j << \" dist = \" << curDist << \" coord = \" << curCoord;\r\n#endif\t// DEBUG\r\n\tif ( curDist < minDist ) {\r\n\t    minDist = curDist;\r\n\t    minCoord = curCoord;\r\n\t}\r\n    }\r\n//------------------------------------------------------------------------------\r\n//\tleft vertical frame segment\r\n//------------------------------------------------------------------------------\r\n    i = 0;\r\n    for ( j = m; j <= _frame.q()*10-m; ++j ) {\r\n\tdouble jj = ( double )j/10.0;\r\n\tCoord2 curCoord = corner + Coord2( (double)i*interval, -jj*interval );\r\n\tdouble curDist = distanceBetween( curSite, curCoord );\r\n#ifdef DEBUG\r\n\tcerr << \"[L] i = \" << i << \" j = \" << j << \" dist = \" << curDist << \" coord = \" << curCoord;\r\n#endif\t// DEBUG\r\n\tif ( curDist < minDist ) {\r\n\t    minDist = curDist;\r\n\t    minCoord = curCoord;\r\n\t}\r\n    }\r\n//------------------------------------------------------------------------------\r\n//\tright vertical frame segment\r\n//------------------------------------------------------------------------------\r\n    i = _frame.p();\r\n    for ( j = m; j <= _frame.q()*10-m; ++j ) {\r\n\tdouble jj = ( double )j/10.0;\r\n\tCoord2 curCoord = corner + Coord2( (double)i*interval, (double)-jj*interval );\r\n\tdouble curDist = distanceBetween( curSite, curCoord );\r\n#ifdef DEBUG\r\n\tcerr << \"[R] i = \" << i << \" j = \" << j << \" dist = \" << curDist << \" coord = \" << curCoord;\r\n#endif\t// DEBUG\r\n\tif ( curDist < minDist ) {\r\n\t    minDist = curDist;\r\n\t    minCoord = curCoord;\r\n\t}\r\n    }\r\n\r\n    coord = minCoord;\r\n    return minDist;\r\n}\r\n\r\n\r\n//\r\n//  Label::isOverlapped --\tcheck whether the input line segment intersects\r\n//\t\t\t\twith the label or not.\r\n//\r\n//  Inputs\r\n//\torig, dest\t: endpoints of the segment\r\n//\r\n//  Outputs\r\n//\tboolean value according to the existence of intersection\r\n//\r\nconst bool Label::isOverlapped( const Coord2 & orig, const Coord2 & dest ) const\r\n{\r\n    if ( isIntersected( orig, dest, _curSite, _joint ) ) return true;\r\n    const Coord2 & lt = _leftTop;\r\n    const Coord2 & rb = _rightBottom;\r\n    Coord2 lb = Coord2( _leftTop.x(), _rightBottom.y() );\r\n    Coord2 rt = Coord2( _rightBottom.x(), _leftTop.y() );\r\n    //if ( isIntersected( orig, dest, lt, rt ) ) return true;\r\n    //if ( isIntersected( orig, dest, lt, lb ) ) return true;\r\n    //if ( isIntersected( orig, dest, rb, rt ) ) return true;\r\n    //if ( isIntersected( orig, dest, rb, lb ) ) return true;\r\n    if ( doConflict( orig, dest, lt, rt ) ) return true;\r\n    if ( doConflict( orig, dest, lt, lb ) ) return true;\r\n    if ( doConflict( orig, dest, rb, rt ) ) return true;\r\n    if ( doConflict( orig, dest, rb, lb ) ) return true;\r\n\r\n    return false;\r\n}\r\n\r\n\r\n//\r\n//  Label::isOverlapped --\tcheck whether the input label intersects\r\n//\t\t\t\twith the label or not.\r\n//\r\n//  Inputs\r\n//\tbox\t: label\r\n//\r\n//  Outputs\r\n//\tboolean value according to the existence of intersection\r\n//\r\nconst bool Label::isOverlapped( const Label & box ) const\r\n{\r\n    const double small = SHRINKAGE_RATIO;\r\n\r\n    const Coord2 & lt = _leftTop;\r\n    const Coord2 & rb = _rightBottom;\r\n    const Coord2 & boxLT = box.lt();\r\n    const Coord2 & boxRB = box.rb();\r\n\r\n    if ( ( boxRB.x() <= lt.x() ) ||\r\n\t ( rb.x() <= boxLT.x() ) ||\r\n\t ( boxLT.y() <= rb.y() ) ||\r\n\t ( lt.y() <= boxRB.y() ) ) {\r\n\t;\t\t\t// do nothing\r\n    }\r\n    else return true;\r\n\r\n    Coord2 boxO = ( 1.0-small )*box.curSite() + small*box.joint();\r\n    Coord2 boxD = small*box.curSite()+( 1.0-small ) * box.joint();\r\n\r\n    if ( isOverlapped( boxO, boxD ) ) return true;\r\n\r\n    Coord2 orig = ( 1.0-small )*_curSite + small*_joint;\r\n    Coord2 dest = small*_curSite + ( 1.0-small )*_joint;\r\n\r\n    if ( box.isOverlapped( orig, dest ) ) return true;\r\n\r\n    return false;\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tAssignment opereators\r\n//------------------------------------------------------------------------------\r\n\r\n//\r\n//  Label::operator = --\tassignement\r\n//\t\t\t\t代入\r\n//\r\n//  Inputs\r\n//\tobj\t: objects of this class\r\n//\r\n//  Outputs\r\n//\tthis object\r\n//\r\nLabel & Label::operator = ( const Label & obj )\r\n{\r\n    if ( this != &obj ) {\r\n\t_id\t= obj._id;\r\n\t_width\t= obj._width;\r\n\t_height\t= obj._height;\r\n\t_flag\t= obj._flag;\r\n\t_geoSite= obj._geoSite;\r\n\t_curSite= obj._curSite;\r\n\t_leaderW= obj._leaderW;\r\n\t_joint\t= obj._joint;\r\n\t_leftTop\t= obj._leftTop;\r\n\t_rightBottom\t= obj._rightBottom;\r\n\t_frame\t= obj._frame;\r\n\t_base\t= obj._base;\r\n    }\r\n    return *this;\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tI/O functions\r\n//------------------------------------------------------------------------------\r\n\r\n\r\n\r\n// end of header file\r\n// Do not add any stuff under this line.\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Base/src/Label_todo.cpp b/Base/src/Label_todo.cpp
--- a/Base/src/Label_todo.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Base/src/Label_todo.cpp	(date 1729410605170)
@@ -1,310 +1,0 @@
-//==============================================================================
-// Label.cc
-//	: program file for annotation labels
-//
-//------------------------------------------------------------------------------
-//
-//				Date: Sun Jul 22 03:01:14 2012
-//
-//==============================================================================
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include "Common.h"
-#include "Label.h"
-
-
-//------------------------------------------------------------------------------
-//	Defining Macros
-//------------------------------------------------------------------------------
-
-
-//------------------------------------------------------------------------------
-//	Private Functions
-//------------------------------------------------------------------------------
-
-
-//------------------------------------------------------------------------------
-//	Protected Functions
-//------------------------------------------------------------------------------
-
-
-//------------------------------------------------------------------------------
-//	Public Functions
-//------------------------------------------------------------------------------
-
-//------------------------------------------------------------------------------
-//	Constructors
-//------------------------------------------------------------------------------
-
-//
-//  Label::Label --	default constructor
-//
-//  Inputs
-//	none
-//
-//  Outputs
-//	none
-//
-Label::Label() 
-{
-    _id = NO_UNSIGNED_ID;
-    _width = 0.0;
-    _height = 0.0;
-    _flag = false;
-    _leaderW = 1.0;
-    _geoSite.zero();
-    _curSite.zero();
-    _joint.zero();
-    _leftTop.zero();
-    _rightBottom.zero();
-    _frame.zero();
-    _base.zero();
-}
-
-
-//
-//  Label::Label --	copy constructor
-//
-//  Inputs
-//	obj	: object of this class
-//
-//  Outputs
-//	none
-//
-Label::Label( const Label & obj )
-{
-    _id		= obj._id;
-    _width	= obj._width;
-    _height	= obj._height;
-    _flag	= obj._flag;
-    _geoSite	= obj._geoSite;
-    _curSite	= obj._curSite;
-    _leaderW	= obj._leaderW;
-    _joint	= obj._joint;
-    _leftTop	= obj._leftTop;
-    _rightBottom= obj._rightBottom;
-    _frame	= obj._frame;
-    _base	= obj._base;
-}
-
-
-//------------------------------------------------------------------------------
-//	Destructor
-//------------------------------------------------------------------------------
-
-
-//------------------------------------------------------------------------------
-//	Referring to members
-//------------------------------------------------------------------------------
-
-
-//------------------------------------------------------------------------------
-//	Functions for placing labels
-//------------------------------------------------------------------------------
-
-//
-//  Label::minimizeLeader --	minimize the leader length by searching for the
-//				best joint position 
-//
-//  Inputs
-//	variable : explanation of a variable
-//	variable : explanation of a variable
-//
-//  Outputs
-//	leader length
-//
-double Label::minimizeLeader( const Coord2 & curSite, const Coord2 & corner, const double & interval,
-			      Coord2 & coord )
-{
-    double minDist = INFINITY;
-    Coord2 minCoord;
-
-    int i, j;
-    const int m = 5;
-
-//------------------------------------------------------------------------------
-//	top horizontal frame segment
-//------------------------------------------------------------------------------
-    j = 0;
-    for ( i = m; i <= _frame.p()*10-m; ++i ) {
-	double ii = ( double )i/10.0;
-	Coord2 curCoord = corner + Coord2( ii*interval, (double)-j*interval );
-	double curDist = distanceBetween( curSite, curCoord );
-#ifdef DEBUG
-	cerr << "[T] i = " << i << " j = " << j << " dist = " << curDist << " coord = " << curCoord;
-#endif	// DEBUG
-	if ( curDist < minDist ) {
-	    minDist = curDist;
-	    minCoord = curCoord;
-	}
-    }
-//------------------------------------------------------------------------------
-//	bottom horizontal frame segment
-//------------------------------------------------------------------------------
-    j = _frame.q();
-    for ( i = m; i <= _frame.p()*10-m; ++i ) {
-	double ii = ( double )i/10.0;
-	Coord2 curCoord = corner + Coord2( ii*interval, (double)-j*interval );
-	double curDist = distanceBetween( curSite, curCoord );
-#ifdef DEBUG
-	cerr << "[B] i = " << i << " j = " << j << " dist = " << curDist << " coord = " << curCoord;
-#endif	// DEBUG
-	if ( curDist < minDist ) {
-	    minDist = curDist;
-	    minCoord = curCoord;
-	}
-    }
-//------------------------------------------------------------------------------
-//	left vertical frame segment
-//------------------------------------------------------------------------------
-    i = 0;
-    for ( j = m; j <= _frame.q()*10-m; ++j ) {
-	double jj = ( double )j/10.0;
-	Coord2 curCoord = corner + Coord2( (double)i*interval, -jj*interval );
-	double curDist = distanceBetween( curSite, curCoord );
-#ifdef DEBUG
-	cerr << "[L] i = " << i << " j = " << j << " dist = " << curDist << " coord = " << curCoord;
-#endif	// DEBUG
-	if ( curDist < minDist ) {
-	    minDist = curDist;
-	    minCoord = curCoord;
-	}
-    }
-//------------------------------------------------------------------------------
-//	right vertical frame segment
-//------------------------------------------------------------------------------
-    i = _frame.p();
-    for ( j = m; j <= _frame.q()*10-m; ++j ) {
-	double jj = ( double )j/10.0;
-	Coord2 curCoord = corner + Coord2( (double)i*interval, (double)-jj*interval );
-	double curDist = distanceBetween( curSite, curCoord );
-#ifdef DEBUG
-	cerr << "[R] i = " << i << " j = " << j << " dist = " << curDist << " coord = " << curCoord;
-#endif	// DEBUG
-	if ( curDist < minDist ) {
-	    minDist = curDist;
-	    minCoord = curCoord;
-	}
-    }
-
-    coord = minCoord;
-    return minDist;
-}
-
-
-//
-//  Label::isOverlapped --	check whether the input line segment intersects
-//				with the label or not.
-//
-//  Inputs
-//	orig, dest	: endpoints of the segment
-//
-//  Outputs
-//	boolean value according to the existence of intersection
-//
-const bool Label::isOverlapped( const Coord2 & orig, const Coord2 & dest ) const
-{
-    if ( isIntersected( orig, dest, _curSite, _joint ) ) return true;
-    const Coord2 & lt = _leftTop;
-    const Coord2 & rb = _rightBottom;
-    Coord2 lb = Coord2( _leftTop.x(), _rightBottom.y() );
-    Coord2 rt = Coord2( _rightBottom.x(), _leftTop.y() );
-    //if ( isIntersected( orig, dest, lt, rt ) ) return true;
-    //if ( isIntersected( orig, dest, lt, lb ) ) return true;
-    //if ( isIntersected( orig, dest, rb, rt ) ) return true;
-    //if ( isIntersected( orig, dest, rb, lb ) ) return true;
-    if ( doConflict( orig, dest, lt, rt ) ) return true;
-    if ( doConflict( orig, dest, lt, lb ) ) return true;
-    if ( doConflict( orig, dest, rb, rt ) ) return true;
-    if ( doConflict( orig, dest, rb, lb ) ) return true;
-
-    return false;
-}
-
-
-//
-//  Label::isOverlapped --	check whether the input label intersects
-//				with the label or not.
-//
-//  Inputs
-//	box	: label
-//
-//  Outputs
-//	boolean value according to the existence of intersection
-//
-const bool Label::isOverlapped( const Label & box ) const
-{
-    const double small = SHRINKAGE_RATIO;
-
-    const Coord2 & lt = _leftTop;
-    const Coord2 & rb = _rightBottom;
-    const Coord2 & boxLT = box.lt();
-    const Coord2 & boxRB = box.rb();
-
-    if ( ( boxRB.x() <= lt.x() ) ||
-	 ( rb.x() <= boxLT.x() ) ||
-	 ( boxLT.y() <= rb.y() ) ||
-	 ( lt.y() <= boxRB.y() ) ) {
-	;			// do nothing
-    }
-    else return true;
-
-    Coord2 boxO = ( 1.0-small )*box.curSite() + small*box.joint();
-    Coord2 boxD = small*box.curSite()+( 1.0-small ) * box.joint();
-
-    if ( isOverlapped( boxO, boxD ) ) return true;
-
-    Coord2 orig = ( 1.0-small )*_curSite + small*_joint;
-    Coord2 dest = small*_curSite + ( 1.0-small )*_joint;
-
-    if ( box.isOverlapped( orig, dest ) ) return true;
-
-    return false;
-}
-
-
-//------------------------------------------------------------------------------
-//	Assignment opereators
-//------------------------------------------------------------------------------
-
-//
-//  Label::operator = --	assignement
-//				代入
-//
-//  Inputs
-//	obj	: objects of this class
-//
-//  Outputs
-//	this object
-//
-Label & Label::operator = ( const Label & obj )
-{
-    if ( this != &obj ) {
-	_id	= obj._id;
-	_width	= obj._width;
-	_height	= obj._height;
-	_flag	= obj._flag;
-	_geoSite= obj._geoSite;
-	_curSite= obj._curSite;
-	_leaderW= obj._leaderW;
-	_joint	= obj._joint;
-	_leftTop	= obj._leftTop;
-	_rightBottom	= obj._rightBottom;
-	_frame	= obj._frame;
-	_base	= obj._base;
-    }
-    return *this;
-}
-
-
-//------------------------------------------------------------------------------
-//	I/O functions
-//------------------------------------------------------------------------------
-
-
-
-// end of header file
-// Do not add any stuff under this line.
Index: Base/src/Grid2_todo.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// Grid2.h\r\n//\t: header file for 2D grid coordinaes\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Mon Mar 14 20:13:35 2011\r\n//\r\n//******************************************************************************\r\n\r\n#ifndef\t_Grid2_H\r\n#define _Grid2_H\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <iostream>\r\nusing namespace std;\r\n\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Macros\r\n//------------------------------------------------------------------------------\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Classes\r\n//------------------------------------------------------------------------------\r\n\r\nclass Grid2 {\r\n\r\n  protected:\r\n\r\n    int\t\t\t_element[ 2 ];\t// x, y coordinates\r\n\r\n    virtual void\t_init( void );\t// initialize all coordinates to zero\r\n\r\n  public:\r\n\r\n//------------------------------------------------------------------------------\r\n//\tConstuructors\r\n//------------------------------------------------------------------------------\r\n    Grid2();\t\t\t\t// constructor (default)\r\n    Grid2( const int x, const int y );\r\n\t\t\t\t\t// 2D coordinates as input\r\n    Grid2( const Grid2 & v );\t\t// copy constructor\r\n    virtual ~Grid2() {}\t\t        // destructor\r\n\r\n//------------------------------------------------------------------------------\r\n//\tAssignment opereators\r\n//------------------------------------------------------------------------------\r\n    Grid2 &\t\toperator = ( const Grid2 & v );\r\n\t\t\t\t// assignment\r\n    Grid2 &\t\toperator += ( const Grid2 & v );\r\n\t\t\t\t// addition + assignment\r\n    Grid2 &\t\toperator -= ( const Grid2& v );\r\n\t\t\t\t// subtraction + assignment\r\n    Grid2 &\t\toperator *= ( const int d );\r\n\t\t\t\t// scalar product + assignment\r\n//------------------------------------------------------------------------------\r\n//\tReference to elements\r\n//------------------------------------------------------------------------------\r\n    void\t\tinit( void )\t\t{ _init(); }\r\n    void\t\tzero( void )\t\t{ _init(); }\r\n\t\t\t\t// initialze all the coordinates to zero\r\n    const int &\t\toperator [] ( int i ) const;\r\n    int &\t\toperator [] ( int i );\r\n\t\t\t\t// reference to a specific coordinate\r\n    const int *\t\telement( void ) const\t{ return _element; }\r\n\t\t\t\t// pointer to an array of coordinates\r\n    int &\t\tp( void )\t\t{ return _element[ 0 ]; }\r\n    int &\t\tq( void )\t\t{ return _element[ 1 ]; }\r\n    const int &\t\tp( void ) const\t\t{ return _element[ 0 ]; }\r\n    const int &\t\tq( void ) const\t\t{ return _element[ 1 ]; }\r\n    const int &\t\tgetP( void ) const\t{ return _element[ 0 ]; }\r\n    const int &\t\tgetQ( void ) const\t{ return _element[ 1 ]; }\r\n\t\t\t\t// reference to a specific coordinate\r\n    void\t\tset( const int p, const int q );\r\n    void\t\tsetP( const int p )\t{ _element[ 0 ] = p; }\r\n    void\t\tsetQ( const int q )\t{ _element[ 1 ] = q; }\r\n\t\t\t\t// set the coordinate(s)\r\n\r\n//------------------------------------------------------------------------------\r\n//\tFriend functions\r\n//------------------------------------------------------------------------------\r\n    friend Grid2\toperator - ( const Grid2 & v );\r\n\t\t\t\t// sign change\r\n    friend Grid2\toperator + ( const Grid2 & a, const Grid2 & b );\r\n\t\t\t\t// addition\r\n    friend Grid2\toperator - ( const Grid2 & a, const Grid2 & b );\r\n\t\t\t\t// subtraction\r\n    friend Grid2\toperator * ( const int d, const Grid2 & a );\r\n\t\t\t\t// scalar product\r\n    friend int\t\toperator * ( const Grid2 & a, const Grid2 & b );\r\n\t\t\t\t// inner product\r\n\r\n    friend int\t\toperator == ( const Grid2 & a, const Grid2 & b );\r\n\t\t\t\t// equivalence\r\n    friend int\t\toperator != ( const Grid2 & a, const Grid2 & b ) {\r\n\treturn ( ! ( a == b ) );\r\n    }\t\t\t\t// inequivalence\r\n    friend int\t\toperator < ( const Grid2 & a, const Grid2 & b );\r\n\t\t\t\t// comparison (less than)\r\n    friend int\t\toperator > ( const Grid2 & a, const Grid2 & b );\r\n\t\t\t\t// comparison (more than)\r\n    friend int\t\toperator <= ( const Grid2 & a, const Grid2 & b ) {\r\n\treturn ( ( a == b ) || ( a < b ) );\r\n    }\t\t\t\t// comparison (equal to or less than)\r\n    friend int\t\toperator >= ( const Grid2 & a, const Grid2 & b ) {\r\n\treturn ( ( a == b ) || ( a > b ) );\r\n    }\t\t\t\t// comparison (equal to or more than)\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tI/O functions\r\n//------------------------------------------------------------------------------\r\n    friend ostream &\toperator << ( ostream & s, const Grid2 & v );\r\n\t\t\t\t// \u001B$B=PNO\u001B(B\r\n    friend istream &\toperator >> ( istream & s, Grid2 & v );\r\n\t\t\t\t// \u001B$BF~NO\u001B(B\r\n    virtual const char * className( void ) const { return \"Grid2\"; }\r\n\t\t\t\t// \u001B$B%/%i%9L>\u001B(B\r\n\r\n};\r\n\r\n\r\n#endif // _Grid2_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Base/src/Grid2_todo.h b/Base/src/Grid2_todo.h
--- a/Base/src/Grid2_todo.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Base/src/Grid2_todo.h	(date 1729410605180)
@@ -1,129 +1,0 @@
-//******************************************************************************
-// Grid2.h
-//	: header file for 2D grid coordinaes
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Mon Mar 14 20:13:35 2011
-//
-//******************************************************************************
-
-#ifndef	_Grid2_H
-#define _Grid2_H
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <iostream>
-using namespace std;
-
-
-
-//------------------------------------------------------------------------------
-//	Defining Macros
-//------------------------------------------------------------------------------
-
-
-//------------------------------------------------------------------------------
-//	Defining Classes
-//------------------------------------------------------------------------------
-
-class Grid2 {
-
-  protected:
-
-    int			_element[ 2 ];	// x, y coordinates
-
-    virtual void	_init( void );	// initialize all coordinates to zero
-
-  public:
-
-//------------------------------------------------------------------------------
-//	Constuructors
-//------------------------------------------------------------------------------
-    Grid2();				// constructor (default)
-    Grid2( const int x, const int y );
-					// 2D coordinates as input
-    Grid2( const Grid2 & v );		// copy constructor
-    virtual ~Grid2() {}		        // destructor
-
-//------------------------------------------------------------------------------
-//	Assignment opereators
-//------------------------------------------------------------------------------
-    Grid2 &		operator = ( const Grid2 & v );
-				// assignment
-    Grid2 &		operator += ( const Grid2 & v );
-				// addition + assignment
-    Grid2 &		operator -= ( const Grid2& v );
-				// subtraction + assignment
-    Grid2 &		operator *= ( const int d );
-				// scalar product + assignment
-//------------------------------------------------------------------------------
-//	Reference to elements
-//------------------------------------------------------------------------------
-    void		init( void )		{ _init(); }
-    void		zero( void )		{ _init(); }
-				// initialze all the coordinates to zero
-    const int &		operator [] ( int i ) const;
-    int &		operator [] ( int i );
-				// reference to a specific coordinate
-    const int *		element( void ) const	{ return _element; }
-				// pointer to an array of coordinates
-    int &		p( void )		{ return _element[ 0 ]; }
-    int &		q( void )		{ return _element[ 1 ]; }
-    const int &		p( void ) const		{ return _element[ 0 ]; }
-    const int &		q( void ) const		{ return _element[ 1 ]; }
-    const int &		getP( void ) const	{ return _element[ 0 ]; }
-    const int &		getQ( void ) const	{ return _element[ 1 ]; }
-				// reference to a specific coordinate
-    void		set( const int p, const int q );
-    void		setP( const int p )	{ _element[ 0 ] = p; }
-    void		setQ( const int q )	{ _element[ 1 ] = q; }
-				// set the coordinate(s)
-
-//------------------------------------------------------------------------------
-//	Friend functions
-//------------------------------------------------------------------------------
-    friend Grid2	operator - ( const Grid2 & v );
-				// sign change
-    friend Grid2	operator + ( const Grid2 & a, const Grid2 & b );
-				// addition
-    friend Grid2	operator - ( const Grid2 & a, const Grid2 & b );
-				// subtraction
-    friend Grid2	operator * ( const int d, const Grid2 & a );
-				// scalar product
-    friend int		operator * ( const Grid2 & a, const Grid2 & b );
-				// inner product
-
-    friend int		operator == ( const Grid2 & a, const Grid2 & b );
-				// equivalence
-    friend int		operator != ( const Grid2 & a, const Grid2 & b ) {
-	return ( ! ( a == b ) );
-    }				// inequivalence
-    friend int		operator < ( const Grid2 & a, const Grid2 & b );
-				// comparison (less than)
-    friend int		operator > ( const Grid2 & a, const Grid2 & b );
-				// comparison (more than)
-    friend int		operator <= ( const Grid2 & a, const Grid2 & b ) {
-	return ( ( a == b ) || ( a < b ) );
-    }				// comparison (equal to or less than)
-    friend int		operator >= ( const Grid2 & a, const Grid2 & b ) {
-	return ( ( a == b ) || ( a > b ) );
-    }				// comparison (equal to or more than)
-
-
-//------------------------------------------------------------------------------
-//	I/O functions
-//------------------------------------------------------------------------------
-    friend ostream &	operator << ( ostream & s, const Grid2 & v );
-				// $B=PNO(B
-    friend istream &	operator >> ( istream & s, Grid2 & v );
-				// $BF~NO(B
-    virtual const char * className( void ) const { return "Grid2"; }
-				// $B%/%i%9L>(B
-
-};
-
-
-#endif // _Grid2_H
Index: Base/src/Rectangle2.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// Line2.h\r\n//\t: header file for 2D Line2 coordinates\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Dec 27 23:16:12 2017\r\n//\r\n//******************************************************************************\r\n\r\n#ifndef\t_Base_Rectangle2_H\r\n#define _Base_Rectangle2_H\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <vector>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\n#include \"Coord2.h\"\r\n#include \"Object.h\"\r\n//#include \"ui/vector/GraphicsEdgeItem.h\"\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Macros\r\n//------------------------------------------------------------------------------\r\nnamespace KeiRo {\r\nnamespace Base {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tDefining Classes\r\n    //------------------------------------------------------------------------------\r\n    class Rectangle2 : public Object {\r\n\r\n    protected:\r\n\t\r\n\t    // Rectangle2 fixed coordinates of end points, usually the initial value\r\n\t    Coord2      _fixedLeftBottom;\r\n\t    double      _fixedWidth;\r\n\t    double      _fixedHeight;\r\n\t\r\n\t    // Rectangle2 old coordinates of end points\r\n        Coord2      _oldLeftBottom;\r\n\t    double      _oldWidth;\r\n\t    double      _oldHeight;\r\n\t\r\n\t    // Rectangle2 original coordinates of end points\r\n        Coord2      _leftBottom;\r\n        double      _width;\r\n        double      _height;\r\n        \r\n            // Rectangle2 intermediate coordinates of end points\r\n        Coord2      _intermediateLeftBottom;\r\n        double      _intermediateWidth;\r\n        double      _intermediateHeight;\r\n        \r\n        // Rectangle2 intermediate coordinates of end points\r\n        Coord2      _unshrunkLeftBottom;\r\n        double      _unshrunkWidth;\r\n        double      _unshrunkHeight;\r\n        \r\n        // whether -Intermediate... holds useful information\r\n        bool\t_inLocalMove;\r\n        \r\n        //------------------------------------------------------------------------------\r\n        //\tAttribute\r\n        //------------------------------------------------------------------------------\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tSpecial functions\r\n        //------------------------------------------------------------------------------\r\n        // initialize all coordinates to zero\r\n        void _init( void );\r\n        void _clear( void );\r\n\r\n    public:\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tConstructors & Destructors\r\n        //------------------------------------------------------------------------------\r\n        // default constructor\r\n        Rectangle2( void );\r\n        // parameterized constructor\r\n        Rectangle2( double x, double y, double w, double h );\r\n        // copy constructor\r\n        Rectangle2( const Rectangle2 & v );\r\n        // destructor\r\n        virtual ~Rectangle2( void ) {}\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tAssignment operators\r\n        //------------------------------------------------------------------------------\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tReference to elements\r\n        //------------------------------------------------------------------------------\r\n        \r\n        // left-bottom corner\r\n        Coord2 &\t        fixedLeftBottom( void )         { return _fixedLeftBottom; }\r\n\t    const Coord2 &\t    fixedLeftBottom( void ) const\t{ return _fixedLeftBottom; }\r\n\t\r\n\t    double &\t        fixedWidth( void )\t        { return _fixedWidth; }\r\n\t    const double &\t    fixedWidth( void ) const\t{ return _fixedWidth; }\r\n\t\r\n\t    double &\t        fixedHeight( void )\t        { return _fixedHeight; }\r\n\t    const double &\t    fixedHeight( void ) const\t{ return _fixedHeight; }\r\n\t    \r\n        // left-bottom corner\r\n        Coord2 &\t        oldLeftBottom( void )       { return _oldLeftBottom; }\r\n\t    const Coord2 &\t    oldLeftBottom( void ) const\t{ return _oldLeftBottom; }\r\n\r\n\t    double &\t        oldWidth( void )\t        { return _oldWidth; }\r\n\t    const double &\t    oldWidth( void ) const\t    { return _oldWidth; }\r\n\t\r\n\t    double &\t        oldHeight( void )\t        { return _oldHeight; }\r\n\t    const double &\t    oldHeight( void ) const\t    { return _oldHeight; }\r\n\t\r\n\t    // left-bottom corner\r\n\t    Coord2 &\t        leftBottom( void )\t        { return _leftBottom; }\r\n\t    const Coord2 &\t    leftBottom( void ) const\t{ return _leftBottom; }\r\n\t\r\n\t    double &\t        width( void )\t            { return _width; }\r\n\t    const double &\t    width( void ) const\t        { return _width; }\r\n\t\r\n\t    double &\t        height( void )\t            { return _height; }\r\n\t    const double &\t    height( void ) const\t    { return _height; }\r\n\t    \r\n\t    // left-bottom corner\r\n\t    Coord2 &\t\tintermediateLeftBottom( void )\t{ return _intermediateLeftBottom; }\r\n\t    const Coord2 &\tintermediateLeftBottom( void ) const\t{ return _intermediateLeftBottom; }\r\n\t\r\n\t    double &\t\tintermediateWidth( void )\t\t{ return _intermediateWidth; }\r\n\t    const double &\tintermediateWidth( void ) const\t{ return _intermediateWidth; }\r\n\t\r\n\t    double &\t\tintermediateHeight( void )\t\t{ return _intermediateHeight; }\r\n\t    const double &\tintermediateHeight( void ) const\t{ return _intermediateHeight; }\r\n\t    \r\n\t    Coord2 &\t\tunshrunkLeftBottom( void )\t{ return _unshrunkLeftBottom; }\r\n\t    const Coord2 &\tunshrunkLeftBottom( void ) const\t{ return _unshrunkLeftBottom; }\r\n\t\r\n\t    double &\t\tunshrunkWidth( void )\t\t{ return _unshrunkWidth; }\r\n\t    const double &\tunshrunkWidth( void ) const\t{ return _unshrunkWidth; }\r\n\t\r\n\t    double &\t\tunshrunkHeight( void )\t\t{ return _unshrunkHeight; }\r\n\t    const double &\tunshrunkHeight( void ) const\t{ return _unshrunkHeight; }\r\n\t    \r\n\t    bool &\t\tinLocalMove( void )\t\t{ return _inLocalMove; }\r\n\t    const bool &\tinLocalMove( void ) const\t{ return _inLocalMove; }\r\n\t    \r\n\t    //------------------------------------------------------------------------------\r\n        //\tSpecial functions\r\n        //------------------------------------------------------------------------------\r\n        // initialization\r\n        void init( void ) { _init(); }\r\n\t    void clear( void ) { _clear(); }\r\n        bool isInside( Coord2 c );\r\n\t    bool isOverlap( Rectangle2 r, double &area );\r\n\t    void updateOldElement( void );\r\n\t    void updateIntermediateElement( Coord2 & c, double width, double height );\r\n\t    void updateUnshrunkElement( Coord2 & c, double width, double height );\r\n\t    void resetInLocalMove( void );\r\n\t    void updateFixedElement( void );\r\n\t    Coord2 projectedOnBoundary( Coord2 c );\r\n\t\t\r\n        //------------------------------------------------------------------------------\r\n        //\tFriend functions\r\n        //------------------------------------------------------------------------------\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tI/O functions\r\n        //------------------------------------------------------------------------------\r\n        // output\r\n        friend ostream &\toperator << ( ostream & s, const Rectangle2 & v );\r\n        // input\r\n        friend istream &\toperator >> ( istream & s, Rectangle2 & v );\r\n        // class name\r\n        virtual const char * className( void ) const { return \"Rectangle2\"; }\r\n\r\n    };\r\n\t\r\n} // namespace Base\r\n} // namespace KeiRo\r\n\r\n#endif // _Base_Rectangle2_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Base/src/Rectangle2.h b/Base/src/Rectangle2.h
--- a/Base/src/Rectangle2.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Base/src/Rectangle2.h	(date 1729410605190)
@@ -1,187 +1,0 @@
-//******************************************************************************
-// Line2.h
-//	: header file for 2D Line2 coordinates
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Dec 27 23:16:12 2017
-//
-//******************************************************************************
-
-#ifndef	_Base_Rectangle2_H
-#define _Base_Rectangle2_H
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <vector>
-#include <iostream>
-
-using namespace std;
-
-#include "Coord2.h"
-#include "Object.h"
-//#include "ui/vector/GraphicsEdgeItem.h"
-
-//------------------------------------------------------------------------------
-//	Defining Macros
-//------------------------------------------------------------------------------
-namespace KeiRo {
-namespace Base {
-
-    //------------------------------------------------------------------------------
-    //	Defining Classes
-    //------------------------------------------------------------------------------
-    class Rectangle2 : public Object {
-
-    protected:
-	
-	    // Rectangle2 fixed coordinates of end points, usually the initial value
-	    Coord2      _fixedLeftBottom;
-	    double      _fixedWidth;
-	    double      _fixedHeight;
-	
-	    // Rectangle2 old coordinates of end points
-        Coord2      _oldLeftBottom;
-	    double      _oldWidth;
-	    double      _oldHeight;
-	
-	    // Rectangle2 original coordinates of end points
-        Coord2      _leftBottom;
-        double      _width;
-        double      _height;
-        
-            // Rectangle2 intermediate coordinates of end points
-        Coord2      _intermediateLeftBottom;
-        double      _intermediateWidth;
-        double      _intermediateHeight;
-        
-        // Rectangle2 intermediate coordinates of end points
-        Coord2      _unshrunkLeftBottom;
-        double      _unshrunkWidth;
-        double      _unshrunkHeight;
-        
-        // whether -Intermediate... holds useful information
-        bool	_inLocalMove;
-        
-        //------------------------------------------------------------------------------
-        //	Attribute
-        //------------------------------------------------------------------------------
-
-        //------------------------------------------------------------------------------
-        //	Special functions
-        //------------------------------------------------------------------------------
-        // initialize all coordinates to zero
-        void _init( void );
-        void _clear( void );
-
-    public:
-
-        //------------------------------------------------------------------------------
-        //	Constructors & Destructors
-        //------------------------------------------------------------------------------
-        // default constructor
-        Rectangle2( void );
-        // parameterized constructor
-        Rectangle2( double x, double y, double w, double h );
-        // copy constructor
-        Rectangle2( const Rectangle2 & v );
-        // destructor
-        virtual ~Rectangle2( void ) {}
-
-        //------------------------------------------------------------------------------
-        //	Assignment operators
-        //------------------------------------------------------------------------------
-
-        //------------------------------------------------------------------------------
-        //	Reference to elements
-        //------------------------------------------------------------------------------
-        
-        // left-bottom corner
-        Coord2 &	        fixedLeftBottom( void )         { return _fixedLeftBottom; }
-	    const Coord2 &	    fixedLeftBottom( void ) const	{ return _fixedLeftBottom; }
-	
-	    double &	        fixedWidth( void )	        { return _fixedWidth; }
-	    const double &	    fixedWidth( void ) const	{ return _fixedWidth; }
-	
-	    double &	        fixedHeight( void )	        { return _fixedHeight; }
-	    const double &	    fixedHeight( void ) const	{ return _fixedHeight; }
-	    
-        // left-bottom corner
-        Coord2 &	        oldLeftBottom( void )       { return _oldLeftBottom; }
-	    const Coord2 &	    oldLeftBottom( void ) const	{ return _oldLeftBottom; }
-
-	    double &	        oldWidth( void )	        { return _oldWidth; }
-	    const double &	    oldWidth( void ) const	    { return _oldWidth; }
-	
-	    double &	        oldHeight( void )	        { return _oldHeight; }
-	    const double &	    oldHeight( void ) const	    { return _oldHeight; }
-	
-	    // left-bottom corner
-	    Coord2 &	        leftBottom( void )	        { return _leftBottom; }
-	    const Coord2 &	    leftBottom( void ) const	{ return _leftBottom; }
-	
-	    double &	        width( void )	            { return _width; }
-	    const double &	    width( void ) const	        { return _width; }
-	
-	    double &	        height( void )	            { return _height; }
-	    const double &	    height( void ) const	    { return _height; }
-	    
-	    // left-bottom corner
-	    Coord2 &		intermediateLeftBottom( void )	{ return _intermediateLeftBottom; }
-	    const Coord2 &	intermediateLeftBottom( void ) const	{ return _intermediateLeftBottom; }
-	
-	    double &		intermediateWidth( void )		{ return _intermediateWidth; }
-	    const double &	intermediateWidth( void ) const	{ return _intermediateWidth; }
-	
-	    double &		intermediateHeight( void )		{ return _intermediateHeight; }
-	    const double &	intermediateHeight( void ) const	{ return _intermediateHeight; }
-	    
-	    Coord2 &		unshrunkLeftBottom( void )	{ return _unshrunkLeftBottom; }
-	    const Coord2 &	unshrunkLeftBottom( void ) const	{ return _unshrunkLeftBottom; }
-	
-	    double &		unshrunkWidth( void )		{ return _unshrunkWidth; }
-	    const double &	unshrunkWidth( void ) const	{ return _unshrunkWidth; }
-	
-	    double &		unshrunkHeight( void )		{ return _unshrunkHeight; }
-	    const double &	unshrunkHeight( void ) const	{ return _unshrunkHeight; }
-	    
-	    bool &		inLocalMove( void )		{ return _inLocalMove; }
-	    const bool &	inLocalMove( void ) const	{ return _inLocalMove; }
-	    
-	    //------------------------------------------------------------------------------
-        //	Special functions
-        //------------------------------------------------------------------------------
-        // initialization
-        void init( void ) { _init(); }
-	    void clear( void ) { _clear(); }
-        bool isInside( Coord2 c );
-	    bool isOverlap( Rectangle2 r, double &area );
-	    void updateOldElement( void );
-	    void updateIntermediateElement( Coord2 & c, double width, double height );
-	    void updateUnshrunkElement( Coord2 & c, double width, double height );
-	    void resetInLocalMove( void );
-	    void updateFixedElement( void );
-	    Coord2 projectedOnBoundary( Coord2 c );
-		
-        //------------------------------------------------------------------------------
-        //	Friend functions
-        //------------------------------------------------------------------------------
-
-        //------------------------------------------------------------------------------
-        //	I/O functions
-        //------------------------------------------------------------------------------
-        // output
-        friend ostream &	operator << ( ostream & s, const Rectangle2 & v );
-        // input
-        friend istream &	operator >> ( istream & s, Rectangle2 & v );
-        // class name
-        virtual const char * className( void ) const { return "Rectangle2"; }
-
-    };
-	
-} // namespace Base
-} // namespace KeiRo
-
-#endif // _Base_Rectangle2_H
Index: Base/src/Polygon2.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// Polygon2.h\r\n//\t: header file for 2D polygons\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Mon Feb 10 20:13:35 2020\r\n//\r\n//******************************************************************************\r\n\r\n#ifndef\t_Base_Polygon2_H\r\n#define _Base_Polygon2_H\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <vector>\r\n#include <cmath>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\n#define CGAL_DO_NOT_USE_BOOST_MP\r\n\r\n#include <CGAL/Exact_predicates_exact_constructions_kernel.h>\r\n#include <CGAL/Polygon_2.h>\r\n\r\ntypedef CGAL::Exact_predicates_exact_constructions_kernel K;\r\ntypedef CGAL::Polygon_2< K >::Vertex_circulator Vertex_circulator;\r\n\r\nusing CGAL::ORIGIN;\r\n\r\n#include \"Object.h\"\r\n#include \"Rectangle2.h\"\r\n#include \"Coord2.h\"\r\n#include \"Line2.h\"\r\n//#include \"GraphicsPolygonItem.h\"\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Macros\r\n//------------------------------------------------------------------------------\r\n\r\nnamespace KeiRo {\r\nnamespace Base {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tDefining Classes\r\n    //------------------------------------------------------------------------------\r\n    class Polygon2 : public KeiRo::Base::Object {\r\n\r\n    private:\r\n\r\n    protected:\r\n\r\n        double              _area;          // polygon area size\r\n        Coord2              _center;        // average of the elements\r\n\t    Coord2              _centroid;      // centroid of the elements\r\n\r\n        //Polygon2 original coordinates of end points\r\n        vector< KeiRo::Base::Coord2 >       _fixedElements;\r\n        // Polygon2 sample points\r\n        vector< KeiRo::Base::Coord2 >       _elements;\r\n        // Polygon2 sample id\r\n        vector< unsigned int >              _idElements;\r\n        vector< double >                    _targetEdgeAngles;\r\n\t\r\n        // width and height of the bounding box\r\n        KeiRo::Base::Rectangle2             _boundingBox;\r\n        // initial bounding box size\r\n        double                              _initArea;\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tAttribute\r\n        //------------------------------------------------------------------------------\r\n        // select flag\r\n        bool                    _isSelected;\r\n\r\n        // graphics item pointer\r\n//        Ui::Vector::GraphicsPolygonItem * _itemPtr;\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tSpecial functions\r\n        //------------------------------------------------------------------------------\r\n        virtual void\t        _init( unsigned int __id, vector< KeiRo::Base::Coord2 > __elements );\t// initialize all coordinates to zero\r\n        void                    _init( void ) {}\r\n        void                    _clear( void );\r\n\r\n    public:\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tConstructors & Destructors\r\n        //------------------------------------------------------------------------------\r\n        // default constructor\r\n        Polygon2();\r\n        // parameterized constructor\r\n        Polygon2( vector< KeiRo::Base::Coord2 > __elements );\r\n        // copy constructor\r\n        Polygon2( const Polygon2 & v );\r\n        // destructor\r\n        virtual ~Polygon2() {}\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tAssignment operators\r\n        //------------------------------------------------------------------------------\r\n        // assignment\r\n        Polygon2 &\t\toperator = ( const Polygon2 & p );\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tReference to elements\r\n        //------------------------------------------------------------------------------\r\n        // area\r\n        double &\t                area( void )\t        { return _area; }\r\n        const double &\t            area( void ) const\t    { return _area; }\r\n\r\n        // barycenter\r\n        Coord2 &\t                center( void )\t        { return _center; }\r\n        const Coord2 &\t            center( void ) const\t{ return _center; }\r\n\r\n        // centroid\r\n        Coord2 &\t                centroid( void )\t    { return _centroid; }\r\n        const Coord2 &\t            centroid( void ) const\t{ return _centroid; }\r\n\r\n        // reference to a vector of coordinates\r\n        vector< KeiRo::Base::Coord2 > &\t            elements( void )\t            { return _elements; }\r\n        const vector< KeiRo::Base::Coord2 > &\t    elements( void ) const\t        { return _elements; }\r\n\r\n        // reference to an array of fixed coordinates\r\n        vector< KeiRo::Base::Coord2 > &\t            fixedElements( void )\t        { return _fixedElements; }\r\n        const vector< KeiRo::Base::Coord2 > &\t    fixedElements( void ) const\t    { return _fixedElements; }\r\n\r\n        // reference to an array of coordinate pointers\r\n        vector< unsigned int > &\t    idElements( void )\t            { return _idElements; }\r\n        const vector< unsigned int > &  idElements( void ) const        { return _idElements; }\r\n\r\n        // reference to an array of coordinate pointers\r\n        vector< double > &\t            targetEdgeAngles( void )\t    { return _targetEdgeAngles; }\r\n        const vector< double > &        targetEdgeAngles( void ) const  { return _targetEdgeAngles; }\r\n        \r\n\t    // bounding box\r\n        KeiRo::Base::Rectangle2 &\t        boundingBox( void )\t            { return _boundingBox; }\r\n        const KeiRo::Base::Rectangle2 &\t    boundingBox( void ) const\t    { return _boundingBox; }\r\n\r\n        const double \t                bbArea( void ) const\t        { return _boundingBox.width() * _boundingBox.height(); }\r\n        const double &\t                initArea( void ) const\t        { return _initArea; }\r\n\r\n        // select flag\r\n        bool &\t                        isSelected( void )\t            { return _isSelected; }\r\n        const bool &\t                isSelected( void ) const\t    { return _isSelected; }\r\n        \r\n\t    // graphics item\r\n//        void setItemPtr( Ui::Vector::GraphicsPolygonItem * ptr )\t    { _itemPtr = ptr; }\r\n//        Ui::Vector::GraphicsPolygonItem * getItemPtr( void )            { return _itemPtr; }\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tSpecial functions\r\n        //------------------------------------------------------------------------------\r\n        // initialization\r\n        void init( unsigned int __id, vector< KeiRo::Base::Coord2 > __elements ) {\r\n            _init( __id, __elements );\r\n        }\r\n\t    void update( void ) {\r\n\t\t    computeBoundingBox();\r\n\t\t    computeCenter();\r\n//\t\t    updateCentroid();\r\n        }\r\n        // clear the object\r\n        void clear( void ) { _clear(); }\r\n\r\n        void computeBoundingBox( void );\r\n\t    void computeCenter( void );\r\n        void updateCentroid( void );\r\n        void updateOrientation( void );\r\n        bool inPolygon( const KeiRo::Base::Coord2 &cood );\r\n        double minDistToPolygon( const KeiRo::Base::Coord2 &cood );\r\n        double maxRadiusInPolygon( const KeiRo::Base::Coord2 &coord );\r\n\t    bool isSimple( void );\r\n\t    void cleanPolygon( void );\r\n\t    void normalization( Rectangle2 &r );\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tFriend functions\r\n        //------------------------------------------------------------------------------\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tI/O functions\r\n        //------------------------------------------------------------------------------\r\n        // output\r\n        friend ostream &\toperator << ( ostream & s, const Polygon2 & v );\r\n        // input\r\n        friend istream &\toperator >> ( istream & s, Polygon2 & v );\r\n        // class name\r\n        virtual const char * className( void ) const { return \"Polygon2\"; }\r\n\r\n    };\r\n\r\n} // namespace Base\r\n} // namespace KeiRo\r\n\r\n#endif // _Base_Polygon2_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Base/src/Polygon2.h b/Base/src/Polygon2.h
--- a/Base/src/Polygon2.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Base/src/Polygon2.h	(date 1729410605200)
@@ -1,200 +1,0 @@
-//******************************************************************************
-// Polygon2.h
-//	: header file for 2D polygons
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Mon Feb 10 20:13:35 2020
-//
-//******************************************************************************
-
-#ifndef	_Base_Polygon2_H
-#define _Base_Polygon2_H
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <vector>
-#include <cmath>
-#include <iostream>
-
-using namespace std;
-
-#define CGAL_DO_NOT_USE_BOOST_MP
-
-#include <CGAL/Exact_predicates_exact_constructions_kernel.h>
-#include <CGAL/Polygon_2.h>
-
-typedef CGAL::Exact_predicates_exact_constructions_kernel K;
-typedef CGAL::Polygon_2< K >::Vertex_circulator Vertex_circulator;
-
-using CGAL::ORIGIN;
-
-#include "Object.h"
-#include "Rectangle2.h"
-#include "Coord2.h"
-#include "Line2.h"
-//#include "GraphicsPolygonItem.h"
-
-//------------------------------------------------------------------------------
-//	Defining Macros
-//------------------------------------------------------------------------------
-
-namespace KeiRo {
-namespace Base {
-
-    //------------------------------------------------------------------------------
-    //	Defining Classes
-    //------------------------------------------------------------------------------
-    class Polygon2 : public KeiRo::Base::Object {
-
-    private:
-
-    protected:
-
-        double              _area;          // polygon area size
-        Coord2              _center;        // average of the elements
-	    Coord2              _centroid;      // centroid of the elements
-
-        //Polygon2 original coordinates of end points
-        vector< KeiRo::Base::Coord2 >       _fixedElements;
-        // Polygon2 sample points
-        vector< KeiRo::Base::Coord2 >       _elements;
-        // Polygon2 sample id
-        vector< unsigned int >              _idElements;
-        vector< double >                    _targetEdgeAngles;
-	
-        // width and height of the bounding box
-        KeiRo::Base::Rectangle2             _boundingBox;
-        // initial bounding box size
-        double                              _initArea;
-
-        //------------------------------------------------------------------------------
-        //	Attribute
-        //------------------------------------------------------------------------------
-        // select flag
-        bool                    _isSelected;
-
-        // graphics item pointer
-//        Ui::Vector::GraphicsPolygonItem * _itemPtr;
-
-        //------------------------------------------------------------------------------
-        //	Special functions
-        //------------------------------------------------------------------------------
-        virtual void	        _init( unsigned int __id, vector< KeiRo::Base::Coord2 > __elements );	// initialize all coordinates to zero
-        void                    _init( void ) {}
-        void                    _clear( void );
-
-    public:
-
-        //------------------------------------------------------------------------------
-        //	Constructors & Destructors
-        //------------------------------------------------------------------------------
-        // default constructor
-        Polygon2();
-        // parameterized constructor
-        Polygon2( vector< KeiRo::Base::Coord2 > __elements );
-        // copy constructor
-        Polygon2( const Polygon2 & v );
-        // destructor
-        virtual ~Polygon2() {}
-
-        //------------------------------------------------------------------------------
-        //	Assignment operators
-        //------------------------------------------------------------------------------
-        // assignment
-        Polygon2 &		operator = ( const Polygon2 & p );
-
-        //------------------------------------------------------------------------------
-        //	Reference to elements
-        //------------------------------------------------------------------------------
-        // area
-        double &	                area( void )	        { return _area; }
-        const double &	            area( void ) const	    { return _area; }
-
-        // barycenter
-        Coord2 &	                center( void )	        { return _center; }
-        const Coord2 &	            center( void ) const	{ return _center; }
-
-        // centroid
-        Coord2 &	                centroid( void )	    { return _centroid; }
-        const Coord2 &	            centroid( void ) const	{ return _centroid; }
-
-        // reference to a vector of coordinates
-        vector< KeiRo::Base::Coord2 > &	            elements( void )	            { return _elements; }
-        const vector< KeiRo::Base::Coord2 > &	    elements( void ) const	        { return _elements; }
-
-        // reference to an array of fixed coordinates
-        vector< KeiRo::Base::Coord2 > &	            fixedElements( void )	        { return _fixedElements; }
-        const vector< KeiRo::Base::Coord2 > &	    fixedElements( void ) const	    { return _fixedElements; }
-
-        // reference to an array of coordinate pointers
-        vector< unsigned int > &	    idElements( void )	            { return _idElements; }
-        const vector< unsigned int > &  idElements( void ) const        { return _idElements; }
-
-        // reference to an array of coordinate pointers
-        vector< double > &	            targetEdgeAngles( void )	    { return _targetEdgeAngles; }
-        const vector< double > &        targetEdgeAngles( void ) const  { return _targetEdgeAngles; }
-        
-	    // bounding box
-        KeiRo::Base::Rectangle2 &	        boundingBox( void )	            { return _boundingBox; }
-        const KeiRo::Base::Rectangle2 &	    boundingBox( void ) const	    { return _boundingBox; }
-
-        const double 	                bbArea( void ) const	        { return _boundingBox.width() * _boundingBox.height(); }
-        const double &	                initArea( void ) const	        { return _initArea; }
-
-        // select flag
-        bool &	                        isSelected( void )	            { return _isSelected; }
-        const bool &	                isSelected( void ) const	    { return _isSelected; }
-        
-	    // graphics item
-//        void setItemPtr( Ui::Vector::GraphicsPolygonItem * ptr )	    { _itemPtr = ptr; }
-//        Ui::Vector::GraphicsPolygonItem * getItemPtr( void )            { return _itemPtr; }
-
-        //------------------------------------------------------------------------------
-        //	Special functions
-        //------------------------------------------------------------------------------
-        // initialization
-        void init( unsigned int __id, vector< KeiRo::Base::Coord2 > __elements ) {
-            _init( __id, __elements );
-        }
-	    void update( void ) {
-		    computeBoundingBox();
-		    computeCenter();
-//		    updateCentroid();
-        }
-        // clear the object
-        void clear( void ) { _clear(); }
-
-        void computeBoundingBox( void );
-	    void computeCenter( void );
-        void updateCentroid( void );
-        void updateOrientation( void );
-        bool inPolygon( const KeiRo::Base::Coord2 &cood );
-        double minDistToPolygon( const KeiRo::Base::Coord2 &cood );
-        double maxRadiusInPolygon( const KeiRo::Base::Coord2 &coord );
-	    bool isSimple( void );
-	    void cleanPolygon( void );
-	    void normalization( Rectangle2 &r );
-
-        //------------------------------------------------------------------------------
-        //	Friend functions
-        //------------------------------------------------------------------------------
-
-        //------------------------------------------------------------------------------
-        //	I/O functions
-        //------------------------------------------------------------------------------
-        // output
-        friend ostream &	operator << ( ostream & s, const Polygon2 & v );
-        // input
-        friend istream &	operator >> ( istream & s, Polygon2 & v );
-        // class name
-        virtual const char * className( void ) const { return "Polygon2"; }
-
-    };
-
-} // namespace Base
-} // namespace KeiRo
-
-#endif // _Base_Polygon2_H
Index: Geometry/src/Voronoi.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Voronoi.cpp\r\n//  : program file for the metro network\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//              Date: Mon Dec 10 04:28:26 2012\r\n//\r\n//==============================================================================\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n#include \"Voronoi.h\"\r\n\r\n//------------------------------------------------------------------------------\r\n//\tProtected functions\r\n//------------------------------------------------------------------------------\r\n//\r\n//  Voronoi::_init --        initialization\r\n//\r\n//  Inputs\r\n//      none\r\n//\r\n//  Outputs\r\n//      none\r\n//\r\nvoid Voronoi::_init( vector< Seed > &__seedVec, KeiRo::Base::Polygon2 &__contour ) {\r\n\t_seedVecPtr = &__seedVec;\r\n\t_contourPtr = &__contour;\r\n}\r\n\r\n//\r\n//  Voronoi::_clear --        memory management\r\n//\r\n//  Inputs\r\n//      none\r\n//\r\n//  Outputs\r\n//      none\r\n//\r\nvoid Voronoi::_clear( void ) {\r\n\t_contourPtr = NULL;        // simpleContour of the voronoi diagram\r\n\t\r\n\t// seeds\r\n\t_seedVecPtr = NULL;\r\n\t_polyVec2D.clear();\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n//\tPublic functions\r\n//------------------------------------------------------------------------------\r\nK::Segment_2 Voronoi::_convertToSeg( const CGAL::Object seg_obj, bool outgoing,\r\n                                     bool &isLine, double &slope ) {\r\n\t//CGAL often returns objects that are either segments or rays. This converts\r\n\t//these objects into segments. If the object would have resolved into a ray,\r\n\t//that ray is intersected with the bounding box defined above and returned as\r\n\t//a segment.\r\n\t\r\n\t//One of these will succeed and one will have a NULL pointer\r\n\tconst K::Segment_2 *dseg = CGAL::object_cast< K::Segment_2 >( &seg_obj );\r\n\tconst K::Line_2 *line = CGAL::object_cast< K::Line_2 >( &seg_obj );\r\n\tconst K::Ray_2 *dray = CGAL::object_cast< K::Ray_2 >( &seg_obj );\r\n\t\r\n\tif( dseg != NULL ) { //Okay, we have a segment\r\n\t\t//cerr << \"dseg = \" << *dseg << endl;\r\n\t\treturn *dseg;\r\n\t}\r\n\telse if( dray != NULL ) {    //Must be a ray\r\n\t\t//cerr << \"ray\" << endl;\r\n\t\tconst auto &source = dray->source();\r\n\t\tconst auto dsx = source.x();\r\n\t\tconst auto dsy = source.y();\r\n\t\tconst auto &dir = dray->direction();\r\n\t\tconst auto tpoint = K::Point_2( dsx + RAY_LENGTH * dir.dx(), dsy + RAY_LENGTH * dir.dy() );\r\n\t\tif( outgoing ) {\r\n\t\t\t// cerr << \"source = \" << dray->source() << \", \" << tpoint << endl;\r\n\t\t\treturn K::Segment_2( dray->source(), tpoint );\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn K::Segment_2( tpoint, dray->source() );\r\n\t\t}\r\n\t}\r\n\telse if( line != NULL ) {    //Must be a line\r\n\t\t\r\n\t\tisLine = true;\r\n\t\t//cerr << \"line\" << endl;\r\n\t\t//cerr << \"a = \" << line->a() << \" b = \" << line->b() << \" c = \" << line->c() << endl;\r\n\t\tdouble m;\r\n\t\tif( line->b() == 0.0 )\r\n\t\t\tm = INFINITY;\r\n\t\telse\r\n\t\t\tm = -1.0 * CGAL::to_double( line->a() / line->b() );\r\n\t\t\r\n\t\tif( line->b() == 0.0 ) {\r\n\t\t\t//cerr << \"1st: m = \" << m << endl;\r\n\t\t\tslope = m;\r\n\t\t\tK::Point_2 source( -1.0 * CGAL::to_double( line->c() / line->a() ), -LINE_LENGTH ),\r\n\t\t\t\t\ttarget( -1.0 * CGAL::to_double( line->c() / line->a() ), LINE_LENGTH );\r\n\t\t\treturn K::Segment_2( source, target );\r\n\t\t}\r\n\t\telse if( m >= -1.0 && m <= 1.0 ) {\r\n\t\t\t//cerr << \"2nd: m = \" << m << endl;\r\n\t\t\tslope = -1.0 * CGAL::to_double( line->a() / line->b() );\r\n\t\t\tK::Point_2 source( LINE_LENGTH, line->y_at_x( LINE_LENGTH ) ),\r\n\t\t\t\t\ttarget( -LINE_LENGTH, line->y_at_x( -LINE_LENGTH ) );\r\n\t\t\treturn K::Segment_2( source, target );\r\n\t\t}\r\n\t\telse { // m > 1.0 or m < -1.0\r\n\t\t\t//cerr << \"3rd: m = \" << m << endl;\r\n\t\t\tslope = -1.0 * CGAL::to_double( line->a() / line->b() );\r\n\t\t\tK::Point_2 source( LINE_LENGTH, line->y_at_x( LINE_LENGTH ) ),\r\n\t\t\t\t\ttarget( -LINE_LENGTH, line->y_at_x( -LINE_LENGTH ) );\r\n\t\t\treturn K::Segment_2( source, target );\r\n\t\t}\r\n\t}\r\n\telse {\r\n\t\tcerr << \"Something is wong here at \" << __LINE__ << \" in \" << __FILE__ << endl;\r\n\t}\r\n\t\r\n\t// cerr << \"myslope = \" << slope << endl;\r\n\treturn K::Segment_2( K::Point_2( 0.0, 0.0 ), K::Point_2( 0.0, 0.0 ) ); // should never happens\r\n}\r\n\r\n//\r\n//  Voronoi::createVoronoiDiagram --        create voronoi diagram\r\n//\r\n//  Inputs\r\n//      none\r\n//\r\n//  Outputs\r\n//      none\r\n//\r\nvoid Voronoi::createVoronoiDiagram( bool isWeighted ) {\r\n\t\r\n\tvector< RT2::Weighted_point > wpoints;\r\n\t\r\n\t// initialization\r\n\t_polyVec2D.clear();\r\n\t//_polygonVecPtr->clear();\r\n\twpoints.clear();\r\n\t\r\n\t// copy points\r\n\t//cerr << \"id = \" << _id << \" size = \" << _seedVecPtr->size() << \" points:\" << endl;\r\n\tfor( unsigned int i = 0; i < _seedVecPtr->size(); i++ ) {\r\n\t\t\r\n\t\t// cerr << \"w(\" << i << \") = \" << (*_seedVecPtr)[i].weight << endl;\r\n\t\tif( isWeighted ) {\r\n\t\t\t//if ( _seedVecPtr->size() == 2 ) cerr << \"w = \" << ((*_seedVecPtr)[i].weight ) << endl;\r\n\t\t\twpoints.push_back( RT2::Weighted_point( K::Point_2( ( *_seedVecPtr )[ i ].coordPtr->x(),\r\n\t\t\t                                                    ( *_seedVecPtr )[ i ].coordPtr->y() ),\r\n\t\t\t                                        10.0 * ( ( *_seedVecPtr )[ i ].weight ) ) );\r\n\t\t}\r\n\t\telse {\r\n\t\t\twpoints.push_back( RT2::Weighted_point( K::Point_2( ( *_seedVecPtr )[ i ].coordPtr->x(),\r\n\t\t\t                                                    ( *_seedVecPtr )[ i ].coordPtr->y()  ),\r\n\t\t\t                                        0 ) );\r\n\t\t}\r\n\t\t//cerr << \"sid = \" << (*_seedVecPtr)[i].id << \" coord = \" << (*_seedVecPtr)[i].coord;\r\n\t}\r\n\t\r\n\t//Find the bounding box of the points. This will be used to crop the Voronoi\r\n\t//diagram later.\r\n\t//const K::Iso_rectangle_2 bbox = CGAL::bounding_box( wpoints.begin(), wpoints.end() );\r\n\t//const K::Iso_rectangle_2 bbox( K::Point_2( -(int)_width/2, -(int)_height/2 ), K::Point_2( (int)_width/2, (int)_height/2 ) );\r\n\t//cerr << \"bbox = \" << bbox << endl;\r\n\t\r\n\t//Create a Regular Triangulation from the points\r\n\tRT2 rt( wpoints.begin(), wpoints.end() );\r\n\trt.is_valid();\r\n\t\r\n\t//Wrap the triangulation with a Voronoi diagram adaptor. This is necessary to\r\n\t//get the Voronoi faces.\r\n\tVD vd( rt );\r\n\t\r\n\t//Loop over the faces of the Voronoi diagram in some arbitrary order (does not match with seed order)\r\n\tint fnum = 0;\r\n\tfor( VD::Face_iterator fit = vd.faces_begin(); fit != vd.faces_end(); ++fit, fnum++ ) {\r\n\t\t\r\n\t\tCGAL::Polygon_2< K > pgon;\r\n\t\t\r\n\t\t//Edge circulators traverse endlessly around a face. Make a note of the\r\n\t\t//starting point so we know when to quit.\r\n\t\tVD::Face::Ccb_halfedge_circulator ec_start = fit->ccb();\r\n\t\t\r\n\t\t//Find a bounded edge to start on\r\n\t\t//for(;ec_start->is_unbounded();ec_start++){}\r\n\t\t\r\n\t\t//Current location of the edge circulator\r\n\t\tVD::Face::Ccb_halfedge_circulator ec = ec_start;\r\n\t\t\r\n\t\tbool isLine = false;\r\n\t\tdouble slope = 0.0;\r\n\t\tdo {\r\n\t\t\t//A half edge circulator representing a ray doesn't carry direction\r\n\t\t\t//information. To get it, we take the dual of the dual of the half-edge.\r\n\t\t\t//The dual of a half-edge circulator is the edge of a Delaunay triangle.\r\n\t\t\t//The dual of the edge of Delaunay triangle is either a segment or a ray.\r\n\t\t\t//const CGAL::Object seg_dual = rt.dual( ec->dual() );\r\n\t\t\tconst CGAL::Object seg_dual = vd.dual().dual( ec->dual() );\r\n\t\t\t\r\n\t\t\t// cerr << \"seg_dual = \" << vd << endl;\r\n\t\t\t\r\n\t\t\t//Convert the segment/ray into a segment\r\n\t\t\tK::Segment_2 this_seg = _convertToSeg( seg_dual, ec->has_target(), isLine, slope );\r\n\t\t\t\r\n\t\t\t// const auto this_seg = ConvertToSeg( seg_dual, ec->has_target(), isLine, slope );\r\n\t\t\tpgon.push_back( this_seg.source() );\r\n\t\t\t\r\n\t\t\t//If the segment has no target, it's a ray. This means that the next\r\n\t\t\t//segment will also be a ray. We need to connect those two rays with a\r\n\t\t\t//segment. The following accomplishes this.\r\n\t\t\tif( !ec->has_target() ) {\r\n\t\t\t\tconst CGAL::Object nseg_dual = vd.dual().dual( ec->next()->dual() );\r\n\t\t\t\tK::Segment_2 next_seg = _convertToSeg( nseg_dual, ec->next()->has_target(), isLine, slope );\r\n\t\t\t\tpgon.push_back( next_seg.target() );\r\n\t\t\t}\r\n\t\t\t\r\n\t\t} while( ++ec != ec_start ); //Loop until we get back to the beginning\r\n\t\t\r\n\t\tif( isLine ) {\r\n\t\t\t\r\n\t\t\t//cerr << \"fnum = \" << fnum << endl;\r\n\t\t\tauto end = pgon.vertices_end();\r\n\t\t\tend--;\r\n\t\t\tK::Point_2 source( pgon.vertices_begin()->x(), pgon.vertices_begin()->y() ),\r\n\t\t\t\t\ttarget( end->x(), end->y() );\r\n\t\t\tpgon.clear();\r\n\t\t\tif( fnum == 0 ) {\r\n\t\t\t\t\r\n\t\t\t\tif( slope >= -1.0 && slope <= 1.0 ) {\r\n\t\t\t\t\tpgon.push_back( K::Point_2( source.x(), source.y() ) );\r\n\t\t\t\t\tpgon.push_back( K::Point_2( source.x(), source.y() + LINE_LENGTH ) );\r\n\t\t\t\t\tpgon.push_back( K::Point_2( target.x(), target.y() + LINE_LENGTH ) );\r\n\t\t\t\t\tpgon.push_back( K::Point_2( target.x(), target.y() ) );\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tpgon.push_back( K::Point_2( source.x(), source.y() ) );\r\n\t\t\t\t\tpgon.push_back( K::Point_2( source.x() + LINE_LENGTH, source.y() ) );\r\n\t\t\t\t\tpgon.push_back( K::Point_2( target.x() + LINE_LENGTH, target.y() ) );\r\n\t\t\t\t\tpgon.push_back( K::Point_2( target.x(), target.y() ) );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif( slope >= -1.0 && slope <= 1.0 ) {\r\n\t\t\t\t\tpgon.push_back( K::Point_2( source.x(), source.y() ) );\r\n\t\t\t\t\tpgon.push_back( K::Point_2( target.x(), target.y() ) );\r\n\t\t\t\t\tpgon.push_back( K::Point_2( target.x(), target.y() - LINE_LENGTH ) );\r\n\t\t\t\t\tpgon.push_back( K::Point_2( source.x(), source.y() - LINE_LENGTH ) );\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tpgon.push_back( K::Point_2( source.x(), source.y() ) );\r\n\t\t\t\t\tpgon.push_back( K::Point_2( target.x(), target.y() ) );\r\n\t\t\t\t\tpgon.push_back( K::Point_2( target.x() - LINE_LENGTH, target.y() ) );\r\n\t\t\t\t\tpgon.push_back( K::Point_2( source.x() - LINE_LENGTH, source.y() ) );\r\n\t\t\t\t}\r\n\t\t\t}\r\n#ifdef DEBUG\r\n\t\t\tfor( auto v=pgon.vertices_begin(); v!=pgon.vertices_end(); v++ ) {\r\n\t\t\t\tcerr << \"pgon = \" << v->x() << \" \" << v->y() << endl;\r\n\t\t\t}\r\n\t\t\tcerr << endl << endl;\r\n#endif // DEBUG\r\n\t\t}\r\n\t\t\r\n\t\t//In order to crop the Voronoi diagram, we need to convert the bounding box\r\n\t\t//into a polygon. You'd think there'd be an easy way to do this. But there\r\n\t\t//isn't (or I haven't found it).\r\n\t\tCGAL::Polygon_2< K > bpoly;\r\n\t\tconst vector< KeiRo::Base::Coord2 > &eleVec = _contourPtr->elements();\r\n\t\t\r\n\t\tfor( unsigned int i = 0; i < eleVec.size(); i++ ) {\r\n\t\t\tbpoly.push_back( K::Point_2( eleVec[ i ].x(), eleVec[ i ].y() ) );\r\n\t\t\t//cerr << i << \": eleVec[i] = \" << eleVec[i] << endl;\r\n\t\t}\r\n\t\t\r\n\t\t// cerr << \"slope = \" << slope << endl;\r\n\t\t\r\n\t\tif( pgon.orientation() == -1 ) {     // special case of Line_2\r\n\t\t\t\r\n\t\t\tpgon.reverse_orientation();\r\n#ifdef DEBUG\r\n\t\t\tfor( auto v=pgon.vertices_begin(); v!=pgon.vertices_end(); v++ ) {\r\n\t\t\t\tcerr << \"pgon = \" << v->x() << \" \" << v->y() << endl;\r\n\t\t\t}\r\n\t\t\tcerr << endl << endl;\r\n#endif // DEBUG\r\n\t\t}\r\n\r\n#ifdef DEBUG\r\n\t\tcerr << \"bpoly_orientation: \" << bpoly.orientation() << endl;\r\n\t\tcerr << \"pgon_orientation: \" << pgon.orientation() << endl;\r\n\t\t// check the polygon orientation\r\n\t\tif( bpoly.orientation() == -1 ){\r\n\t\t\tbpoly.reverse_orientation();\r\n\t\t}\r\n\t\tif( pgon.orientation() == -1 ){\r\n\t\t\tpgon.reverse_orientation();\r\n\t\t}\r\n\t\tcerr << \"bpoly_orientation: \" << bpoly << endl;\r\n#endif // DEBUG\r\n\t\t\r\n\t\tif( pgon.is_simple() == false ) {\r\n\t\t\tcerr << \"NOT_SIMPLE::pgon: \" << pgon << endl;\r\n\t\t}\r\n\t\tif( bpoly.is_simple() == false ) {\r\n\t\t\tcerr << \"NOT_SIMPLE::bpoly: \" << bpoly << endl;\r\n\t\t}\r\n\t\t\r\n\t\t//Perform the intersection. Since CGAL is very general, it believes the\r\n\t\t//result might be multiple polygons with holes.\r\n\t\tstd::list< CGAL::Polygon_with_holes_2< K > > isect;\r\n\t\tCGAL::intersection( pgon, bpoly, std::back_inserter( isect ) );\r\n\t\t\r\n\t\t//But we know better. The intersection of a convex polygon and a box is\r\n\t\t//always a single polygon without holes. Let's assert this.\r\n\t\tif( isect.size() == 0 ) {\r\n\t\t\t\r\n\t\t\t// skip small fragments\r\n#ifdef DEBUG\r\n\t\t\tcerr << \"sth is wrong here... at \" << __LINE__ << \" in \" << __FILE__ << endl;\r\n\t\t\tcerr << \"isect.size() = \" << isect.size() << endl;\r\n\t\t\tcerr << \"pgon: \" << pgon.size() << endl;\r\n\t\t\tcerr << \"pgon: \" << pgon << endl << endl;\r\n\t\t\tcerr << \"bpoly: \" << bpoly << endl << endl;\r\n#endif // DEBUG\r\n\t\t\t//assert( isect.size() == 1 );\r\n\t\t}\r\n\t\telse if( isect.size() >= 1 ) {\r\n\t\t\t\r\n\t\t\tif( isect.size() > 1 ) {\r\n\t\t\t\tcerr << \"sth is wrong here... at \" << __LINE__ << \" in \" << __FILE__ << endl;\r\n\t\t\t\tcerr << \"isect.size() = \" << isect.size() << endl;\r\n\t\t\t}\r\n\t\t\t//And recover the polygon of interest\r\n\t\t\tauto &poly_w_holes = isect.front();\r\n\t\t\tauto &poly_outer = poly_w_holes.outer_boundary();\r\n\t\t\t\r\n\t\t\t//Print the polygon as a WKT polygon\r\n\t\t\tvector< K::Point_2 > p;\r\n\t\t\t//cerr << fnum << \", \"\"\\\"POLYGON ((\" << endl;\r\n\t\t\tfor( auto v = poly_outer.vertices_begin(); v != poly_outer.vertices_end(); v++ ) {\r\n\t\t\t\t\r\n\t\t\t\t//cerr << setprecision(20) << \"x = \" << v->x() << \" y = \" << v->y() << endl;\r\n\t\t\t\tp.push_back( K::Point_2( CGAL::to_double( v->x() ), CGAL::to_double( v->y() ) ) );\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// std::cout<<poly_outer.vertices_begin()->x()<<\" \"<<poly_outer.vertices_begin()->y()<<\"))\\\"\\n\";\r\n\t\t\t_polyVec2D.push_back( p );\r\n\t\t}\r\n\t}\r\n\tmapSeedsandPolygons();\r\n}\r\n\r\n//\r\n//  Voronoi::mapSeedsandPolygons -- map seeds and polygons\r\n//\r\n//  Inputs\r\n//  none\r\n//\r\n//  Outputs\r\n//  none\r\n//\r\nvoid Voronoi::mapSeedsandPolygons( void ) {\r\n\t\r\n\tfor( unsigned int i = 0; i < _seedVecPtr->size(); i++ ) {\r\n\t\t\r\n\t\tK::Point_2 pt( ( *_seedVecPtr )[ i ].coordPtr->x(), ( *_seedVecPtr )[ i ].coordPtr->y() );\r\n\t\t\r\n\t\t// find appropriate polygon boundary\r\n\t\tfor( unsigned int m = 0; m < _polyVec2D.size(); m++ ) {\r\n\t\t\t\r\n\t\t\tK::Point_2 *points = new K::Point_2[_polyVec2D[ m ].size()];\r\n\t\t\tvector< KeiRo::Base::Coord2 > coords;\r\n\t\t\tfor( unsigned int n = 0; n < _polyVec2D[ m ].size(); n++ ) {\r\n\t\t\t\t\r\n\t\t\t\t// copy to points\r\n\t\t\t\tpoints[ n ] = K::Point_2( _polyVec2D[ m ][ n ].x(), _polyVec2D[ m ][ n ].y() );\r\n\t\t\t\tcoords.push_back( KeiRo::Base::Coord2( CGAL::to_double( _polyVec2D[ m ][ n ].x() ),\r\n\t\t\t\t                          CGAL::to_double( _polyVec2D[ m ][ n ].y() ) ) );\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tCGAL::Bounded_side bside = CGAL::bounded_side_2( points, points + _polyVec2D[ m ].size(), pt );\r\n\t\t\t\r\n\t\t\tif( bside == CGAL::ON_BOUNDED_SIDE ) {\r\n\t\t\t\t\r\n\t\t\t\t// copy polygon\r\n\t\t\t\tKeiRo::Base::Polygon2 &p = *( *_seedVecPtr )[ i ].voronoiCellPtr;\r\n\t\t\t\tp.elements() = coords;\r\n\t\t\t\tp.updateCentroid();\r\n\t\t\t\tp.center() = p.centroid();\r\n\t\t\t\tp.area() = p.area();\r\n\t\t\t\t\r\n#ifdef  DEBUG\r\n\t\t\t\tcerr << \"poly.coords = \" << poly.elements()[0];\r\n\t\t\t\tcerr << \"test = \" << (*_seedVecPtr)[i].voronoiCellPtr.elements()[0];\r\n\t\t\t\tcerr << \"area = \" << (*_seedVecPtr)[i].voronoiCellPtr->area() << \" c = \" << (*_seedVecPtr)[i].voronoiCellPtr->center();\r\n\t\t\t\tcerr << \"area = \" << itP->second.area() << endl;\r\n\t\t\t\tcerr << \"pgon_area = \" << poly.area() << endl;\r\n#endif  // DEBUG\r\n\t\t\t\t// cout << \" is inside the polygon.\\n\";\r\n\t\t\t\t// point inside\r\n\t\t\t}\r\n\t\t\telse if( bside == CGAL::ON_BOUNDARY ) {\r\n\t\t\t\t//cout << \" is on the polygon boundary.\\n\";\r\n\t\t\t\t// point on the border\r\n\t\t\t}\r\n\t\t\telse if( bside == CGAL::ON_UNBOUNDED_SIDE ) {\r\n\t\t\t\t//cout << \" is outside the polygon.\\n\";\r\n\t\t\t\t// point outside\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tdelete[] points;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n//\r\n//  Voronoi::Voronoi -- default constructor\r\n//\r\n//  Inputs\r\n//  none\r\n//\r\n//  Outputs\r\n//  none\r\n//\r\nVoronoi::Voronoi( void ) {\r\n\t_id = 0;\r\n\t_contourPtr = NULL;\r\n\t_seedVecPtr = NULL;\r\n\t\r\n\t_polyVec2D.clear();\r\n}\r\n\r\n//\r\n//  Voronoi::Voronoi -- copy constructor\r\n//\r\n//  Inputs\r\n//  obj : object of this class\r\n//\r\n//  Outputs\r\n//  none\r\n//\r\nVoronoi::Voronoi( const Voronoi &obj ) {\r\n\t_clear();\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDestructor\r\n//------------------------------------------------------------------------------\r\n\r\n//\r\n//  Voronoi::~Voronoi --    destructor\r\n//\r\n//  Inputs\r\n//  none\r\n//\r\n//  Outputs\r\n//  none\r\n//\r\nVoronoi::~Voronoi( void ) {\r\n}\r\n\r\n// end of header file\r\n// Do not add any stuff under this line.\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Geometry/src/Voronoi.cpp b/Geometry/src/Voronoi.cpp
--- a/Geometry/src/Voronoi.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Geometry/src/Voronoi.cpp	(date 1729410605220)
@@ -1,466 +1,0 @@
-// Voronoi.cpp
-//  : program file for the metro network
-//
-//------------------------------------------------------------------------------
-//
-//              Date: Mon Dec 10 04:28:26 2012
-//
-//==============================================================================
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-#include "Voronoi.h"
-
-//------------------------------------------------------------------------------
-//	Protected functions
-//------------------------------------------------------------------------------
-//
-//  Voronoi::_init --        initialization
-//
-//  Inputs
-//      none
-//
-//  Outputs
-//      none
-//
-void Voronoi::_init( vector< Seed > &__seedVec, KeiRo::Base::Polygon2 &__contour ) {
-	_seedVecPtr = &__seedVec;
-	_contourPtr = &__contour;
-}
-
-//
-//  Voronoi::_clear --        memory management
-//
-//  Inputs
-//      none
-//
-//  Outputs
-//      none
-//
-void Voronoi::_clear( void ) {
-	_contourPtr = NULL;        // simpleContour of the voronoi diagram
-	
-	// seeds
-	_seedVecPtr = NULL;
-	_polyVec2D.clear();
-}
-
-//------------------------------------------------------------------------------
-//	Public functions
-//------------------------------------------------------------------------------
-K::Segment_2 Voronoi::_convertToSeg( const CGAL::Object seg_obj, bool outgoing,
-                                     bool &isLine, double &slope ) {
-	//CGAL often returns objects that are either segments or rays. This converts
-	//these objects into segments. If the object would have resolved into a ray,
-	//that ray is intersected with the bounding box defined above and returned as
-	//a segment.
-	
-	//One of these will succeed and one will have a NULL pointer
-	const K::Segment_2 *dseg = CGAL::object_cast< K::Segment_2 >( &seg_obj );
-	const K::Line_2 *line = CGAL::object_cast< K::Line_2 >( &seg_obj );
-	const K::Ray_2 *dray = CGAL::object_cast< K::Ray_2 >( &seg_obj );
-	
-	if( dseg != NULL ) { //Okay, we have a segment
-		//cerr << "dseg = " << *dseg << endl;
-		return *dseg;
-	}
-	else if( dray != NULL ) {    //Must be a ray
-		//cerr << "ray" << endl;
-		const auto &source = dray->source();
-		const auto dsx = source.x();
-		const auto dsy = source.y();
-		const auto &dir = dray->direction();
-		const auto tpoint = K::Point_2( dsx + RAY_LENGTH * dir.dx(), dsy + RAY_LENGTH * dir.dy() );
-		if( outgoing ) {
-			// cerr << "source = " << dray->source() << ", " << tpoint << endl;
-			return K::Segment_2( dray->source(), tpoint );
-		}
-		else {
-			return K::Segment_2( tpoint, dray->source() );
-		}
-	}
-	else if( line != NULL ) {    //Must be a line
-		
-		isLine = true;
-		//cerr << "line" << endl;
-		//cerr << "a = " << line->a() << " b = " << line->b() << " c = " << line->c() << endl;
-		double m;
-		if( line->b() == 0.0 )
-			m = INFINITY;
-		else
-			m = -1.0 * CGAL::to_double( line->a() / line->b() );
-		
-		if( line->b() == 0.0 ) {
-			//cerr << "1st: m = " << m << endl;
-			slope = m;
-			K::Point_2 source( -1.0 * CGAL::to_double( line->c() / line->a() ), -LINE_LENGTH ),
-					target( -1.0 * CGAL::to_double( line->c() / line->a() ), LINE_LENGTH );
-			return K::Segment_2( source, target );
-		}
-		else if( m >= -1.0 && m <= 1.0 ) {
-			//cerr << "2nd: m = " << m << endl;
-			slope = -1.0 * CGAL::to_double( line->a() / line->b() );
-			K::Point_2 source( LINE_LENGTH, line->y_at_x( LINE_LENGTH ) ),
-					target( -LINE_LENGTH, line->y_at_x( -LINE_LENGTH ) );
-			return K::Segment_2( source, target );
-		}
-		else { // m > 1.0 or m < -1.0
-			//cerr << "3rd: m = " << m << endl;
-			slope = -1.0 * CGAL::to_double( line->a() / line->b() );
-			K::Point_2 source( LINE_LENGTH, line->y_at_x( LINE_LENGTH ) ),
-					target( -LINE_LENGTH, line->y_at_x( -LINE_LENGTH ) );
-			return K::Segment_2( source, target );
-		}
-	}
-	else {
-		cerr << "Something is wong here at " << __LINE__ << " in " << __FILE__ << endl;
-	}
-	
-	// cerr << "myslope = " << slope << endl;
-	return K::Segment_2( K::Point_2( 0.0, 0.0 ), K::Point_2( 0.0, 0.0 ) ); // should never happens
-}
-
-//
-//  Voronoi::createVoronoiDiagram --        create voronoi diagram
-//
-//  Inputs
-//      none
-//
-//  Outputs
-//      none
-//
-void Voronoi::createVoronoiDiagram( bool isWeighted ) {
-	
-	vector< RT2::Weighted_point > wpoints;
-	
-	// initialization
-	_polyVec2D.clear();
-	//_polygonVecPtr->clear();
-	wpoints.clear();
-	
-	// copy points
-	//cerr << "id = " << _id << " size = " << _seedVecPtr->size() << " points:" << endl;
-	for( unsigned int i = 0; i < _seedVecPtr->size(); i++ ) {
-		
-		// cerr << "w(" << i << ") = " << (*_seedVecPtr)[i].weight << endl;
-		if( isWeighted ) {
-			//if ( _seedVecPtr->size() == 2 ) cerr << "w = " << ((*_seedVecPtr)[i].weight ) << endl;
-			wpoints.push_back( RT2::Weighted_point( K::Point_2( ( *_seedVecPtr )[ i ].coordPtr->x(),
-			                                                    ( *_seedVecPtr )[ i ].coordPtr->y() ),
-			                                        10.0 * ( ( *_seedVecPtr )[ i ].weight ) ) );
-		}
-		else {
-			wpoints.push_back( RT2::Weighted_point( K::Point_2( ( *_seedVecPtr )[ i ].coordPtr->x(),
-			                                                    ( *_seedVecPtr )[ i ].coordPtr->y()  ),
-			                                        0 ) );
-		}
-		//cerr << "sid = " << (*_seedVecPtr)[i].id << " coord = " << (*_seedVecPtr)[i].coord;
-	}
-	
-	//Find the bounding box of the points. This will be used to crop the Voronoi
-	//diagram later.
-	//const K::Iso_rectangle_2 bbox = CGAL::bounding_box( wpoints.begin(), wpoints.end() );
-	//const K::Iso_rectangle_2 bbox( K::Point_2( -(int)_width/2, -(int)_height/2 ), K::Point_2( (int)_width/2, (int)_height/2 ) );
-	//cerr << "bbox = " << bbox << endl;
-	
-	//Create a Regular Triangulation from the points
-	RT2 rt( wpoints.begin(), wpoints.end() );
-	rt.is_valid();
-	
-	//Wrap the triangulation with a Voronoi diagram adaptor. This is necessary to
-	//get the Voronoi faces.
-	VD vd( rt );
-	
-	//Loop over the faces of the Voronoi diagram in some arbitrary order (does not match with seed order)
-	int fnum = 0;
-	for( VD::Face_iterator fit = vd.faces_begin(); fit != vd.faces_end(); ++fit, fnum++ ) {
-		
-		CGAL::Polygon_2< K > pgon;
-		
-		//Edge circulators traverse endlessly around a face. Make a note of the
-		//starting point so we know when to quit.
-		VD::Face::Ccb_halfedge_circulator ec_start = fit->ccb();
-		
-		//Find a bounded edge to start on
-		//for(;ec_start->is_unbounded();ec_start++){}
-		
-		//Current location of the edge circulator
-		VD::Face::Ccb_halfedge_circulator ec = ec_start;
-		
-		bool isLine = false;
-		double slope = 0.0;
-		do {
-			//A half edge circulator representing a ray doesn't carry direction
-			//information. To get it, we take the dual of the dual of the half-edge.
-			//The dual of a half-edge circulator is the edge of a Delaunay triangle.
-			//The dual of the edge of Delaunay triangle is either a segment or a ray.
-			//const CGAL::Object seg_dual = rt.dual( ec->dual() );
-			const CGAL::Object seg_dual = vd.dual().dual( ec->dual() );
-			
-			// cerr << "seg_dual = " << vd << endl;
-			
-			//Convert the segment/ray into a segment
-			K::Segment_2 this_seg = _convertToSeg( seg_dual, ec->has_target(), isLine, slope );
-			
-			// const auto this_seg = ConvertToSeg( seg_dual, ec->has_target(), isLine, slope );
-			pgon.push_back( this_seg.source() );
-			
-			//If the segment has no target, it's a ray. This means that the next
-			//segment will also be a ray. We need to connect those two rays with a
-			//segment. The following accomplishes this.
-			if( !ec->has_target() ) {
-				const CGAL::Object nseg_dual = vd.dual().dual( ec->next()->dual() );
-				K::Segment_2 next_seg = _convertToSeg( nseg_dual, ec->next()->has_target(), isLine, slope );
-				pgon.push_back( next_seg.target() );
-			}
-			
-		} while( ++ec != ec_start ); //Loop until we get back to the beginning
-		
-		if( isLine ) {
-			
-			//cerr << "fnum = " << fnum << endl;
-			auto end = pgon.vertices_end();
-			end--;
-			K::Point_2 source( pgon.vertices_begin()->x(), pgon.vertices_begin()->y() ),
-					target( end->x(), end->y() );
-			pgon.clear();
-			if( fnum == 0 ) {
-				
-				if( slope >= -1.0 && slope <= 1.0 ) {
-					pgon.push_back( K::Point_2( source.x(), source.y() ) );
-					pgon.push_back( K::Point_2( source.x(), source.y() + LINE_LENGTH ) );
-					pgon.push_back( K::Point_2( target.x(), target.y() + LINE_LENGTH ) );
-					pgon.push_back( K::Point_2( target.x(), target.y() ) );
-				}
-				else {
-					pgon.push_back( K::Point_2( source.x(), source.y() ) );
-					pgon.push_back( K::Point_2( source.x() + LINE_LENGTH, source.y() ) );
-					pgon.push_back( K::Point_2( target.x() + LINE_LENGTH, target.y() ) );
-					pgon.push_back( K::Point_2( target.x(), target.y() ) );
-				}
-			}
-			else {
-				if( slope >= -1.0 && slope <= 1.0 ) {
-					pgon.push_back( K::Point_2( source.x(), source.y() ) );
-					pgon.push_back( K::Point_2( target.x(), target.y() ) );
-					pgon.push_back( K::Point_2( target.x(), target.y() - LINE_LENGTH ) );
-					pgon.push_back( K::Point_2( source.x(), source.y() - LINE_LENGTH ) );
-				}
-				else {
-					pgon.push_back( K::Point_2( source.x(), source.y() ) );
-					pgon.push_back( K::Point_2( target.x(), target.y() ) );
-					pgon.push_back( K::Point_2( target.x() - LINE_LENGTH, target.y() ) );
-					pgon.push_back( K::Point_2( source.x() - LINE_LENGTH, source.y() ) );
-				}
-			}
-#ifdef DEBUG
-			for( auto v=pgon.vertices_begin(); v!=pgon.vertices_end(); v++ ) {
-				cerr << "pgon = " << v->x() << " " << v->y() << endl;
-			}
-			cerr << endl << endl;
-#endif // DEBUG
-		}
-		
-		//In order to crop the Voronoi diagram, we need to convert the bounding box
-		//into a polygon. You'd think there'd be an easy way to do this. But there
-		//isn't (or I haven't found it).
-		CGAL::Polygon_2< K > bpoly;
-		const vector< KeiRo::Base::Coord2 > &eleVec = _contourPtr->elements();
-		
-		for( unsigned int i = 0; i < eleVec.size(); i++ ) {
-			bpoly.push_back( K::Point_2( eleVec[ i ].x(), eleVec[ i ].y() ) );
-			//cerr << i << ": eleVec[i] = " << eleVec[i] << endl;
-		}
-		
-		// cerr << "slope = " << slope << endl;
-		
-		if( pgon.orientation() == -1 ) {     // special case of Line_2
-			
-			pgon.reverse_orientation();
-#ifdef DEBUG
-			for( auto v=pgon.vertices_begin(); v!=pgon.vertices_end(); v++ ) {
-				cerr << "pgon = " << v->x() << " " << v->y() << endl;
-			}
-			cerr << endl << endl;
-#endif // DEBUG
-		}
-
-#ifdef DEBUG
-		cerr << "bpoly_orientation: " << bpoly.orientation() << endl;
-		cerr << "pgon_orientation: " << pgon.orientation() << endl;
-		// check the polygon orientation
-		if( bpoly.orientation() == -1 ){
-			bpoly.reverse_orientation();
-		}
-		if( pgon.orientation() == -1 ){
-			pgon.reverse_orientation();
-		}
-		cerr << "bpoly_orientation: " << bpoly << endl;
-#endif // DEBUG
-		
-		if( pgon.is_simple() == false ) {
-			cerr << "NOT_SIMPLE::pgon: " << pgon << endl;
-		}
-		if( bpoly.is_simple() == false ) {
-			cerr << "NOT_SIMPLE::bpoly: " << bpoly << endl;
-		}
-		
-		//Perform the intersection. Since CGAL is very general, it believes the
-		//result might be multiple polygons with holes.
-		std::list< CGAL::Polygon_with_holes_2< K > > isect;
-		CGAL::intersection( pgon, bpoly, std::back_inserter( isect ) );
-		
-		//But we know better. The intersection of a convex polygon and a box is
-		//always a single polygon without holes. Let's assert this.
-		if( isect.size() == 0 ) {
-			
-			// skip small fragments
-#ifdef DEBUG
-			cerr << "sth is wrong here... at " << __LINE__ << " in " << __FILE__ << endl;
-			cerr << "isect.size() = " << isect.size() << endl;
-			cerr << "pgon: " << pgon.size() << endl;
-			cerr << "pgon: " << pgon << endl << endl;
-			cerr << "bpoly: " << bpoly << endl << endl;
-#endif // DEBUG
-			//assert( isect.size() == 1 );
-		}
-		else if( isect.size() >= 1 ) {
-			
-			if( isect.size() > 1 ) {
-				cerr << "sth is wrong here... at " << __LINE__ << " in " << __FILE__ << endl;
-				cerr << "isect.size() = " << isect.size() << endl;
-			}
-			//And recover the polygon of interest
-			auto &poly_w_holes = isect.front();
-			auto &poly_outer = poly_w_holes.outer_boundary();
-			
-			//Print the polygon as a WKT polygon
-			vector< K::Point_2 > p;
-			//cerr << fnum << ", ""\"POLYGON ((" << endl;
-			for( auto v = poly_outer.vertices_begin(); v != poly_outer.vertices_end(); v++ ) {
-				
-				//cerr << setprecision(20) << "x = " << v->x() << " y = " << v->y() << endl;
-				p.push_back( K::Point_2( CGAL::to_double( v->x() ), CGAL::to_double( v->y() ) ) );
-			}
-			
-			// std::cout<<poly_outer.vertices_begin()->x()<<" "<<poly_outer.vertices_begin()->y()<<"))\"\n";
-			_polyVec2D.push_back( p );
-		}
-	}
-	mapSeedsandPolygons();
-}
-
-//
-//  Voronoi::mapSeedsandPolygons -- map seeds and polygons
-//
-//  Inputs
-//  none
-//
-//  Outputs
-//  none
-//
-void Voronoi::mapSeedsandPolygons( void ) {
-	
-	for( unsigned int i = 0; i < _seedVecPtr->size(); i++ ) {
-		
-		K::Point_2 pt( ( *_seedVecPtr )[ i ].coordPtr->x(), ( *_seedVecPtr )[ i ].coordPtr->y() );
-		
-		// find appropriate polygon boundary
-		for( unsigned int m = 0; m < _polyVec2D.size(); m++ ) {
-			
-			K::Point_2 *points = new K::Point_2[_polyVec2D[ m ].size()];
-			vector< KeiRo::Base::Coord2 > coords;
-			for( unsigned int n = 0; n < _polyVec2D[ m ].size(); n++ ) {
-				
-				// copy to points
-				points[ n ] = K::Point_2( _polyVec2D[ m ][ n ].x(), _polyVec2D[ m ][ n ].y() );
-				coords.push_back( KeiRo::Base::Coord2( CGAL::to_double( _polyVec2D[ m ][ n ].x() ),
-				                          CGAL::to_double( _polyVec2D[ m ][ n ].y() ) ) );
-			}
-			
-			CGAL::Bounded_side bside = CGAL::bounded_side_2( points, points + _polyVec2D[ m ].size(), pt );
-			
-			if( bside == CGAL::ON_BOUNDED_SIDE ) {
-				
-				// copy polygon
-				KeiRo::Base::Polygon2 &p = *( *_seedVecPtr )[ i ].voronoiCellPtr;
-				p.elements() = coords;
-				p.updateCentroid();
-				p.center() = p.centroid();
-				p.area() = p.area();
-				
-#ifdef  DEBUG
-				cerr << "poly.coords = " << poly.elements()[0];
-				cerr << "test = " << (*_seedVecPtr)[i].voronoiCellPtr.elements()[0];
-				cerr << "area = " << (*_seedVecPtr)[i].voronoiCellPtr->area() << " c = " << (*_seedVecPtr)[i].voronoiCellPtr->center();
-				cerr << "area = " << itP->second.area() << endl;
-				cerr << "pgon_area = " << poly.area() << endl;
-#endif  // DEBUG
-				// cout << " is inside the polygon.\n";
-				// point inside
-			}
-			else if( bside == CGAL::ON_BOUNDARY ) {
-				//cout << " is on the polygon boundary.\n";
-				// point on the border
-			}
-			else if( bside == CGAL::ON_UNBOUNDED_SIDE ) {
-				//cout << " is outside the polygon.\n";
-				// point outside
-			}
-			
-			delete[] points;
-		}
-	}
-}
-
-//
-//  Voronoi::Voronoi -- default constructor
-//
-//  Inputs
-//  none
-//
-//  Outputs
-//  none
-//
-Voronoi::Voronoi( void ) {
-	_id = 0;
-	_contourPtr = NULL;
-	_seedVecPtr = NULL;
-	
-	_polyVec2D.clear();
-}
-
-//
-//  Voronoi::Voronoi -- copy constructor
-//
-//  Inputs
-//  obj : object of this class
-//
-//  Outputs
-//  none
-//
-Voronoi::Voronoi( const Voronoi &obj ) {
-	_clear();
-}
-
-
-//------------------------------------------------------------------------------
-//	Destructor
-//------------------------------------------------------------------------------
-
-//
-//  Voronoi::~Voronoi --    destructor
-//
-//  Inputs
-//  none
-//
-//  Outputs
-//  none
-//
-Voronoi::~Voronoi( void ) {
-}
-
-// end of header file
-// Do not add any stuff under this line.
-
Index: Base/src/Coord2.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// Coord2.h\r\n//\t: header file for 2D coordinaes\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Jun 19 02:36:37 2012\r\n//\r\n//******************************************************************************\r\n\r\n#ifndef\t_Coord2_H\r\n#define _Coord2_H\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <cmath>\r\n#include <iostream>\r\nusing namespace std;\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Macros\r\n//------------------------------------------------------------------------------\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Classes\r\n//------------------------------------------------------------------------------\r\nnamespace KeiRo {\r\nnamespace Base {\r\n\r\nclass Coord2 {\r\n\r\n  protected:\r\n\t\r\n    double\t\t_element[ 2 ];\t    // x, y coordinates\r\n    \tdouble\t\t_oldElement[ 2 ];\t// old x, y coordinates\r\n\tdouble\t\t_intermediateElement[ 2 ];\t// intermediate x, y coordinates\r\n\tbool \t\t_inLocalMove;\t\t\t// whether _intermediateElement holds useful information\r\n\r\n    virtual void\t_init( void );\t// initialize all coordinates to zero\r\n\r\n  public:\r\n\r\n//------------------------------------------------------------------------------\r\n//\tConstructors\r\n//------------------------------------------------------------------------------\r\n    Coord2();\t\t\t\t// constructor (default)\r\n    Coord2( const double x, const double y );\r\n\t\t\t\t\t// 2D coordinates as input\r\n    Coord2( const Coord2 & v );\t\t// copy constructor\r\n    virtual ~Coord2() {}\t\t// destructor\r\n\r\n//------------------------------------------------------------------------------\r\n//\tAssignment operators\r\n//------------------------------------------------------------------------------\r\n    Coord2 &\t\toperator = ( const Coord2 & v );\r\n\t\t\t\t// assignment\r\n    Coord2 &\t\toperator += ( const Coord2 & v );\r\n\t\t\t\t// addition + assignment\r\n    Coord2 &\t\toperator -= ( const Coord2& v );\r\n\t\t\t\t// subtraction + assignment\r\n    Coord2 &\t\toperator *= ( const double d );\r\n\t\t\t\t// scalar product + assignment\r\n    Coord2 &\t\toperator /= ( const double d );\r\n\t\t\t\t// scalar division + assignment\r\n//------------------------------------------------------------------------------\r\n//\tReference to elements\r\n//------------------------------------------------------------------------------\r\n    void\t\tinit( void )\t\t{ _init(); }\r\n    void\t\tzero( void )\t\t{ _init(); }\r\n\t\t\t\t// initialze all the coordinates to zero\r\n    const double &\toperator [] ( int i ) const;\r\n    double &\t\toperator [] ( int i );\r\n\t\t\t\t// reference to a specific coordinate\r\n\tconst double *\telement( void ) const\t    { return _element; }\r\n\tconst double *\toldElement( void ) const\t{ return _oldElement; }\r\n\tconst double *\tintermediateElement( void ) const\t{ return _intermediateElement; }\r\n\tbool & inLocalMove( void )\t \t \t{ return _inLocalMove; }\r\n\tconst bool & inLocalMove( void ) const \t{ return _inLocalMove; }\r\n\t\t\t\t// pointer to an array of coordinates\r\n    double &\tx( void ) \t{ return _element[ 0 ]; }\r\n    const double &\tx( void ) const\t{ return _element[ 0 ]; }\r\n    double &\ty( void ) \t{ return _element[ 1 ]; }\r\n    const double &\ty( void ) const\t{ return _element[ 1 ]; }\r\n    const double &\tgetX( void ) const\t{ return _element[ 0 ]; }\r\n    const double &\tgetY( void ) const\t{ return _element[ 1 ]; }\r\n\t\t\t\t// reference to a specific coordinate\r\n    void\t\tset( const double x, const double y );\r\n    void\t\tsetX( const double x ) { _element[ 0 ] = x; }\r\n    void\t\tsetY( const double y ) { _element[ 1 ] = y; }\r\n\t\t\t\t// set the coordinate(s)\r\n\r\n//------------------------------------------------------------------------------\r\n//\tSpecial functions\r\n//------------------------------------------------------------------------------\r\n    double\t\tnorm( void ) const;\t// norm\r\n    double\t\tmanhattan( void ) const;// manhattan norm\r\n    double\t\tsquaredNorm( void ) const;\r\n\t\t\t\t\t\t// squared norm\r\n    Coord2 &\t\tnormalize( void );\t// transformed into a unit vector\r\n    Coord2\t\tunit( void ) const;\t// return a unit vector\r\n\t\t\t\t\t\t// without normalization of that vector\r\n\tvoid\t\tupdateOldElement( void );\r\n\tvoid\t\tupdateIntermediateElement( double x, double y ); //set intermediate element if participating in local move\r\n\tvoid\t\tresetInLocalMove( void ); //reset _inLocalMove to false\r\n\t\r\n//------------------------------------------------------------------------------\r\n//\tIntersection check\r\n//------------------------------------------------------------------------------\r\n    friend double\tcrossProd\t( const Coord2 & a, const Coord2 & b );\r\n    friend double\tdoubleArea\t( const Coord2 & a, const Coord2 & b, const Coord2 & c );\r\n    friend bool\t\tisCollinear\t( const Coord2 & a, const Coord2 & b, const Coord2 & c );\r\n    friend bool\t\tisLeft\t\t( const Coord2 & a, const Coord2 & b, const Coord2 & c );\r\n    friend bool\t\tisCCW\t\t( const Coord2 & a, const Coord2 & b, const Coord2 & c );\r\n    friend bool\t\tisLeftOn\t( const Coord2 & a, const Coord2 & b, const Coord2 & c );\r\n    friend bool\t\tisSeparate\t( const Coord2 & a, const Coord2 & b,\r\n\t\t\t\t\t  const Coord2 & c, const Coord2 & d );\r\n    friend bool\t\tisIntersected\t( const Coord2 & a, const Coord2 & b,\r\n\t\t\t\t\t  const Coord2 & c, const Coord2 & d );\r\n    friend bool\t\tisIntersected\t( const Coord2 & a, const Coord2 & b,\r\n\t\t\t\t\t  const Coord2 & c, const Coord2 & d,\r\n\t\t\t\t\t  Coord2 & intersection );\r\n    friend bool\t\tdoConflict\t( const Coord2 & a, const Coord2 & b,\r\n\t\t\t\t\t  const Coord2 & c, const Coord2 & d );\r\n\r\n    friend double\tdistanceBetween\t( const Coord2 & a, const Coord2 & b ) {\r\n\treturn ( ( a - b ).norm() );\r\n    }\r\n\r\n//------------------------------------------------------------------------------\r\n//\tFriend functions\r\n//------------------------------------------------------------------------------\r\n    friend Coord2\toperator - ( const Coord2 & v );\r\n\t\t\t\t// sign change\r\n    friend Coord2\toperator + ( const Coord2 & a, const Coord2 & b );\r\n\t\t\t\t// addition\r\n    friend Coord2\toperator - ( const Coord2 & a, const Coord2 & b );\r\n\t\t\t\t// subtraction\r\n    friend Coord2\toperator * ( const double d, const Coord2 & a );\r\n\t\t\t\t// scalar product\r\n    friend double\toperator * ( const Coord2 & a, const Coord2 & b );\r\n\t\t\t\t// inner product\r\n    friend Coord2\toperator / ( const Coord2 & a, const double d );\r\n\t\t\t\t// scalar division\r\n\r\n    friend int\t\toperator == ( const Coord2 & a, const Coord2 & b );\r\n\t\t\t\t// equivalence\r\n    friend int\t\toperator != ( const Coord2 & a, const Coord2 & b ) {\r\n\treturn ( ! ( a == b ) );\r\n    }\t\t\t\t// inequivalence\r\n    friend int\t\toperator < ( const Coord2 & a, const Coord2 & b );\r\n\t\t\t\t// comparison (less than)\r\n    friend int\t\toperator > ( const Coord2 & a, const Coord2 & b );\r\n\t\t\t\t// comparison (more than)\r\n    friend int\t\toperator <= ( const Coord2 & a, const Coord2 & b ) {\r\n\treturn ( ( a == b ) || ( a < b ) );\r\n    }\t\t\t\t// comparison (equal to or less than)\r\n    friend int\t\toperator >= ( const Coord2 & a, const Coord2 & b ) {\r\n\treturn ( ( a == b ) || ( a > b ) );\r\n    }\t\t\t\t// comparison (equal to or more than)\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tI/O functions\r\n//------------------------------------------------------------------------------\r\n    friend ostream &\toperator << ( ostream & s, const Coord2 & v );\r\n\t\t\t\t// \u001B$B=PNO\u001B(B\r\n    friend istream &\toperator >> ( istream & s, Coord2 & v );\r\n\t\t\t\t// \u001B$BF~NO\u001B(B\r\n    virtual const char * className( void ) const { return \"Coord2\"; }\r\n\t\t\t\t// \u001B$B%/%i%9L>\u001B(B\r\n\r\n};\r\n} // namespace Base\r\n} // namespace KeiRo\r\n\r\n#endif // _Coord2_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Base/src/Coord2.h b/Base/src/Coord2.h
--- a/Base/src/Coord2.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Base/src/Coord2.h	(date 1729410605230)
@@ -1,180 +1,0 @@
-//******************************************************************************
-// Coord2.h
-//	: header file for 2D coordinaes
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Jun 19 02:36:37 2012
-//
-//******************************************************************************
-
-#ifndef	_Coord2_H
-#define _Coord2_H
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <cmath>
-#include <iostream>
-using namespace std;
-
-
-//------------------------------------------------------------------------------
-//	Defining Macros
-//------------------------------------------------------------------------------
-
-
-//------------------------------------------------------------------------------
-//	Defining Classes
-//------------------------------------------------------------------------------
-namespace KeiRo {
-namespace Base {
-
-class Coord2 {
-
-  protected:
-	
-    double		_element[ 2 ];	    // x, y coordinates
-    	double		_oldElement[ 2 ];	// old x, y coordinates
-	double		_intermediateElement[ 2 ];	// intermediate x, y coordinates
-	bool 		_inLocalMove;			// whether _intermediateElement holds useful information
-
-    virtual void	_init( void );	// initialize all coordinates to zero
-
-  public:
-
-//------------------------------------------------------------------------------
-//	Constructors
-//------------------------------------------------------------------------------
-    Coord2();				// constructor (default)
-    Coord2( const double x, const double y );
-					// 2D coordinates as input
-    Coord2( const Coord2 & v );		// copy constructor
-    virtual ~Coord2() {}		// destructor
-
-//------------------------------------------------------------------------------
-//	Assignment operators
-//------------------------------------------------------------------------------
-    Coord2 &		operator = ( const Coord2 & v );
-				// assignment
-    Coord2 &		operator += ( const Coord2 & v );
-				// addition + assignment
-    Coord2 &		operator -= ( const Coord2& v );
-				// subtraction + assignment
-    Coord2 &		operator *= ( const double d );
-				// scalar product + assignment
-    Coord2 &		operator /= ( const double d );
-				// scalar division + assignment
-//------------------------------------------------------------------------------
-//	Reference to elements
-//------------------------------------------------------------------------------
-    void		init( void )		{ _init(); }
-    void		zero( void )		{ _init(); }
-				// initialze all the coordinates to zero
-    const double &	operator [] ( int i ) const;
-    double &		operator [] ( int i );
-				// reference to a specific coordinate
-	const double *	element( void ) const	    { return _element; }
-	const double *	oldElement( void ) const	{ return _oldElement; }
-	const double *	intermediateElement( void ) const	{ return _intermediateElement; }
-	bool & inLocalMove( void )	 	 	{ return _inLocalMove; }
-	const bool & inLocalMove( void ) const 	{ return _inLocalMove; }
-				// pointer to an array of coordinates
-    double &	x( void ) 	{ return _element[ 0 ]; }
-    const double &	x( void ) const	{ return _element[ 0 ]; }
-    double &	y( void ) 	{ return _element[ 1 ]; }
-    const double &	y( void ) const	{ return _element[ 1 ]; }
-    const double &	getX( void ) const	{ return _element[ 0 ]; }
-    const double &	getY( void ) const	{ return _element[ 1 ]; }
-				// reference to a specific coordinate
-    void		set( const double x, const double y );
-    void		setX( const double x ) { _element[ 0 ] = x; }
-    void		setY( const double y ) { _element[ 1 ] = y; }
-				// set the coordinate(s)
-
-//------------------------------------------------------------------------------
-//	Special functions
-//------------------------------------------------------------------------------
-    double		norm( void ) const;	// norm
-    double		manhattan( void ) const;// manhattan norm
-    double		squaredNorm( void ) const;
-						// squared norm
-    Coord2 &		normalize( void );	// transformed into a unit vector
-    Coord2		unit( void ) const;	// return a unit vector
-						// without normalization of that vector
-	void		updateOldElement( void );
-	void		updateIntermediateElement( double x, double y ); //set intermediate element if participating in local move
-	void		resetInLocalMove( void ); //reset _inLocalMove to false
-	
-//------------------------------------------------------------------------------
-//	Intersection check
-//------------------------------------------------------------------------------
-    friend double	crossProd	( const Coord2 & a, const Coord2 & b );
-    friend double	doubleArea	( const Coord2 & a, const Coord2 & b, const Coord2 & c );
-    friend bool		isCollinear	( const Coord2 & a, const Coord2 & b, const Coord2 & c );
-    friend bool		isLeft		( const Coord2 & a, const Coord2 & b, const Coord2 & c );
-    friend bool		isCCW		( const Coord2 & a, const Coord2 & b, const Coord2 & c );
-    friend bool		isLeftOn	( const Coord2 & a, const Coord2 & b, const Coord2 & c );
-    friend bool		isSeparate	( const Coord2 & a, const Coord2 & b,
-					  const Coord2 & c, const Coord2 & d );
-    friend bool		isIntersected	( const Coord2 & a, const Coord2 & b,
-					  const Coord2 & c, const Coord2 & d );
-    friend bool		isIntersected	( const Coord2 & a, const Coord2 & b,
-					  const Coord2 & c, const Coord2 & d,
-					  Coord2 & intersection );
-    friend bool		doConflict	( const Coord2 & a, const Coord2 & b,
-					  const Coord2 & c, const Coord2 & d );
-
-    friend double	distanceBetween	( const Coord2 & a, const Coord2 & b ) {
-	return ( ( a - b ).norm() );
-    }
-
-//------------------------------------------------------------------------------
-//	Friend functions
-//------------------------------------------------------------------------------
-    friend Coord2	operator - ( const Coord2 & v );
-				// sign change
-    friend Coord2	operator + ( const Coord2 & a, const Coord2 & b );
-				// addition
-    friend Coord2	operator - ( const Coord2 & a, const Coord2 & b );
-				// subtraction
-    friend Coord2	operator * ( const double d, const Coord2 & a );
-				// scalar product
-    friend double	operator * ( const Coord2 & a, const Coord2 & b );
-				// inner product
-    friend Coord2	operator / ( const Coord2 & a, const double d );
-				// scalar division
-
-    friend int		operator == ( const Coord2 & a, const Coord2 & b );
-				// equivalence
-    friend int		operator != ( const Coord2 & a, const Coord2 & b ) {
-	return ( ! ( a == b ) );
-    }				// inequivalence
-    friend int		operator < ( const Coord2 & a, const Coord2 & b );
-				// comparison (less than)
-    friend int		operator > ( const Coord2 & a, const Coord2 & b );
-				// comparison (more than)
-    friend int		operator <= ( const Coord2 & a, const Coord2 & b ) {
-	return ( ( a == b ) || ( a < b ) );
-    }				// comparison (equal to or less than)
-    friend int		operator >= ( const Coord2 & a, const Coord2 & b ) {
-	return ( ( a == b ) || ( a > b ) );
-    }				// comparison (equal to or more than)
-
-
-//------------------------------------------------------------------------------
-//	I/O functions
-//------------------------------------------------------------------------------
-    friend ostream &	operator << ( ostream & s, const Coord2 & v );
-				// $B=PNO(B
-    friend istream &	operator >> ( istream & s, Coord2 & v );
-				// $BF~NO(B
-    virtual const char * className( void ) const { return "Coord2"; }
-				// $B%/%i%9L>(B
-
-};
-} // namespace Base
-} // namespace KeiRo
-
-#endif // _Coord2_H
Index: Base/src/Config.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// Config.h\r\n//\t: header file for system configuration\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Jun 19 02:36:37 2019\r\n//\r\n//******************************************************************************\r\n\r\n#ifndef _Base_Config_H\r\n#define _Base_Config_H\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <map>\r\n#include <vector>\r\n#include <string>\r\n#include <fstream>\r\n#include <iostream>\r\n#include <cstdlib>\r\n#ifndef _WIN32\r\n    #include <unistd.h>\r\n#endif\r\n\r\n\r\nusing namespace::std;\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Macros\r\n//------------------------------------------------------------------------------\r\n\r\nnamespace KeiRo {\r\nnamespace Base {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tDefining Classes\r\n    //------------------------------------------------------------------------------\r\n\tclass Config {\r\n\r\n    private:\r\n\r\n        map< string, string > m_map;\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tSpecial functions\r\n        //------------------------------------------------------------------------------\r\n        void split( const string& in, vector< string >& out );\r\n        void loadConfigFile( const string& filename );\r\n\r\n    protected:\r\n\r\n    public:\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tConstructors & Destructors\r\n        //------------------------------------------------------------------------------\r\n        // default constructor\r\n        Config( void );\r\n        // parameterized constructor\r\n        Config( const string& filename = \"\" ) {\r\n            loadConfigFile( filename );\r\n        }\r\n        // copy constructor\r\n        Config( const Config & c ) {}\r\n        // destructor\r\n        ~Config( void ){}\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tSpecial functions\r\n        //------------------------------------------------------------------------------\r\n        double      getlf   ( const string& key ) const;\r\n        float       getf    ( const string& key ) const;\r\n        int         geti    ( const string& key ) const;\r\n        string      gets    ( const string& key ) const;\r\n        bool        has     ( const string& key ) const;\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tI/O functions\r\n        //------------------------------------------------------------------------------\r\n        // output\r\n        friend ostream &\toperator << ( ostream & s, const Config & c );\r\n        // input\r\n        friend istream &\toperator >> ( istream & s, Config & c );\r\n        // \u001Bclass name\r\n        virtual const char * className( void ) const { return \"Config\"; }\r\n    };\r\n\r\n} // namespace Base\r\n} // namespace KeiRo\r\n\r\n\r\n#endif // _Base_Config_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Base/src/Config.h b/Base/src/Config.h
--- a/Base/src/Config.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Base/src/Config.h	(date 1729410605250)
@@ -1,95 +1,0 @@
-//******************************************************************************
-// Config.h
-//	: header file for system configuration
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Jun 19 02:36:37 2019
-//
-//******************************************************************************
-
-#ifndef _Base_Config_H
-#define _Base_Config_H
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <map>
-#include <vector>
-#include <string>
-#include <fstream>
-#include <iostream>
-#include <cstdlib>
-#ifndef _WIN32
-    #include <unistd.h>
-#endif
-
-
-using namespace::std;
-
-//------------------------------------------------------------------------------
-//	Defining Macros
-//------------------------------------------------------------------------------
-
-namespace KeiRo {
-namespace Base {
-
-    //------------------------------------------------------------------------------
-    //	Defining Classes
-    //------------------------------------------------------------------------------
-	class Config {
-
-    private:
-
-        map< string, string > m_map;
-
-        //------------------------------------------------------------------------------
-        //	Special functions
-        //------------------------------------------------------------------------------
-        void split( const string& in, vector< string >& out );
-        void loadConfigFile( const string& filename );
-
-    protected:
-
-    public:
-
-        //------------------------------------------------------------------------------
-        //	Constructors & Destructors
-        //------------------------------------------------------------------------------
-        // default constructor
-        Config( void );
-        // parameterized constructor
-        Config( const string& filename = "" ) {
-            loadConfigFile( filename );
-        }
-        // copy constructor
-        Config( const Config & c ) {}
-        // destructor
-        ~Config( void ){}
-
-        //------------------------------------------------------------------------------
-        //	Special functions
-        //------------------------------------------------------------------------------
-        double      getlf   ( const string& key ) const;
-        float       getf    ( const string& key ) const;
-        int         geti    ( const string& key ) const;
-        string      gets    ( const string& key ) const;
-        bool        has     ( const string& key ) const;
-
-        //------------------------------------------------------------------------------
-        //	I/O functions
-        //------------------------------------------------------------------------------
-        // output
-        friend ostream &	operator << ( ostream & s, const Config & c );
-        // input
-        friend istream &	operator >> ( istream & s, Config & c );
-        // class name
-        virtual const char * className( void ) const { return "Config"; }
-    };
-
-} // namespace Base
-} // namespace KeiRo
-
-
-#endif // _Base_Config_H
Index: Base/src/Line2.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// Line2.h\r\n//\t: header file for 2D Line2 coordinates\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Dec 27 23:16:12 2017\r\n//\r\n//******************************************************************************\r\n\r\n#ifndef\t_Base_Line2_H\r\n#define _Base_Line2_H\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <vector>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\n#include \"Coord2.h\"\r\n#include \"Object.h\"\r\n//#include \"ui/vector/GraphicsEdgeItem.h\"\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Macros\r\n//------------------------------------------------------------------------------\r\nnamespace KeiRo {\r\nnamespace Base {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tDefining Classes\r\n    //------------------------------------------------------------------------------\r\n    class Line2 : public Object {\r\n\r\n    protected:\r\n\r\n        // Line2 original coordinates of end points\r\n        vector< Coord2 >        _fixedElements;\r\n\t    // Line2 old sample points\r\n\t    vector< Coord2 >        _oldElements;\r\n        // Line2 intermediate sample points\r\n        vector< Coord2 >        _intermediateElements;\r\n        // holds whether _intermediateElement holds useful information\r\n        bool\t\t\t _inLocalMove;\r\n        // Line2 sample points\r\n        vector< Coord2 >        _elements;\r\n\t    // Line2 pointer-based sample points\r\n\t    vector< Coord2* >       _elementPointers;\r\n        // Line2 sample id\r\n        vector< unsigned int >  _idElements;\r\n        // Line2 curve sample points\r\n        vector< Coord2 >        _fineElements;\r\n        \r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tAttribute\r\n        //------------------------------------------------------------------------------\r\n        // select flag\r\n        bool                    _isSelected;\r\n\r\n        // graphics item pointer\r\n//        Ui::Vector::GraphicsEdgeItem * _itemPtr;\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tSpecial functions\r\n        //------------------------------------------------------------------------------\r\n        // initialize all coordinates to zero\r\n        void _init( void );\r\n        void _clear( void );\r\n        void _initChaikinCurve( double unit );\r\n\r\n    public:\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tConstructors & Destructors\r\n        //------------------------------------------------------------------------------\r\n        // default constructor\r\n        Line2( void );\r\n        // parameterized constructor\r\n        Line2( vector< Coord2 > __elements );\r\n        // copy constructor\r\n        Line2( const Line2 & v );\r\n        // destructor\r\n        virtual ~Line2( void ) {}\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tAssignment operators\r\n        //------------------------------------------------------------------------------\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tReference to elements\r\n        //------------------------------------------------------------------------------\r\n\t\r\n\t    // reference to a vector of coordinates\r\n\t    vector< Coord2 > &\t            oldElements( void )\t            { return _oldElements; }\r\n\t    const vector< Coord2 > &\t    oldElements( void ) const\t    { return _oldElements; }\r\n\r\n        // reference to a vector of coordinates\r\n        vector< Coord2 > &\t            intermediateElements( void )\t            { return _intermediateElements; }\r\n        const vector< Coord2 > &\t    intermediateElements( void ) const\t        { return _intermediateElements; }\r\n        \r\n        bool &\t                        inLocalMove( void )\t            { return _inLocalMove; }\r\n        const bool &\t                inLocalMove( void ) const\t    { return _inLocalMove; }\r\n        \r\n        // reference to a vector of coordinates\r\n        vector< Coord2 > &\t            elements( void )\t            { return _elements; }\r\n        const vector< Coord2 > &\t    elements( void ) const\t        { return _elements; }\r\n\t\r\n\t    // reference to a vector of coordinates\r\n\t    vector< Coord2* > &\t            elementPointers( void )\t        { return _elementPointers; }\r\n\t    const vector< Coord2* > &\t    elementPointers( void ) const   { return _elementPointers; }\r\n\r\n        // reference to an array of fixed coordinates\r\n        vector< Coord2 > &\t            fixedElements( void )\t        { return _fixedElements; }\r\n        const vector< Coord2 > &\t    fixedElements( void ) const\t    { return _fixedElements; }\r\n\r\n        // reference to an array of coordinate pointers\r\n        vector< unsigned int > &\t    idElements( void )\t            { return _idElements; }\r\n        const vector< unsigned int > &  idElements( void ) const        { return _idElements; }\r\n\r\n        // reference to the fine sample points\r\n        vector< Coord2 > &              fineElements( void )            { return _fineElements; }\r\n        const vector< Coord2 > &        fineElements( void ) const      { return _fineElements; }\r\n\r\n        // select flag\r\n        bool &\t                        isSelected( void )\t            { return _isSelected; }\r\n        const bool &\t                isSelected( void ) const\t    { return _isSelected; }\r\n        \r\n        \r\n\t    // graphics item\r\n//        void setItemPtr( Ui::Vector::GraphicsEdgeItem * ptr )\t        { _itemPtr = ptr; }\r\n//        Ui::Vector::GraphicsEdgeItem * getItemPtr( void )               { return _itemPtr; }\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tSpecial functions\r\n        //------------------------------------------------------------------------------\r\n        // initialization\r\n        void init( void ) { _init(); }\r\n        void initElementPointers( void );\r\n\r\n        void addSample( Coord2 &coord );\r\n        void computeChaikinCurve( int num, double unit );\r\n\r\n        static bool isOnLine( Coord2 &a, Coord2 &b, Coord2 &c );\r\n\t    void updateOldElement( void );\r\n\t    void updateOldElementByPointers( void );\r\n\t    void updateIntermediateElements( vector< Coord2 > __elements );\r\n\t    void resetInLocalMove( void );\r\n\t    void simplifyGeometry( void );\r\n\t\r\n\t    //------------------------------------------------------------------------------\r\n        //\tFriend functions\r\n        //------------------------------------------------------------------------------\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tI/O functions\r\n        //------------------------------------------------------------------------------\r\n        // output\r\n        friend ostream &\toperator << ( ostream & s, const Line2 & v );\r\n        // input\r\n        friend istream &\toperator >> ( istream & s, Line2 & v );\r\n        // \u001Bclass name\r\n        virtual const char * className( void ) const { return \"Line2\"; }\r\n\r\n    };\r\n\t\r\n} // namespace Base\r\n} // namespace KeiRo\r\n\r\n#endif // _Base_Line2_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Base/src/Line2.h b/Base/src/Line2.h
--- a/Base/src/Line2.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Base/src/Line2.h	(date 1729410605260)
@@ -1,173 +1,0 @@
-//******************************************************************************
-// Line2.h
-//	: header file for 2D Line2 coordinates
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Dec 27 23:16:12 2017
-//
-//******************************************************************************
-
-#ifndef	_Base_Line2_H
-#define _Base_Line2_H
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <vector>
-#include <iostream>
-
-using namespace std;
-
-#include "Coord2.h"
-#include "Object.h"
-//#include "ui/vector/GraphicsEdgeItem.h"
-
-//------------------------------------------------------------------------------
-//	Defining Macros
-//------------------------------------------------------------------------------
-namespace KeiRo {
-namespace Base {
-
-    //------------------------------------------------------------------------------
-    //	Defining Classes
-    //------------------------------------------------------------------------------
-    class Line2 : public Object {
-
-    protected:
-
-        // Line2 original coordinates of end points
-        vector< Coord2 >        _fixedElements;
-	    // Line2 old sample points
-	    vector< Coord2 >        _oldElements;
-        // Line2 intermediate sample points
-        vector< Coord2 >        _intermediateElements;
-        // holds whether _intermediateElement holds useful information
-        bool			 _inLocalMove;
-        // Line2 sample points
-        vector< Coord2 >        _elements;
-	    // Line2 pointer-based sample points
-	    vector< Coord2* >       _elementPointers;
-        // Line2 sample id
-        vector< unsigned int >  _idElements;
-        // Line2 curve sample points
-        vector< Coord2 >        _fineElements;
-        
-
-        //------------------------------------------------------------------------------
-        //	Attribute
-        //------------------------------------------------------------------------------
-        // select flag
-        bool                    _isSelected;
-
-        // graphics item pointer
-//        Ui::Vector::GraphicsEdgeItem * _itemPtr;
-
-        //------------------------------------------------------------------------------
-        //	Special functions
-        //------------------------------------------------------------------------------
-        // initialize all coordinates to zero
-        void _init( void );
-        void _clear( void );
-        void _initChaikinCurve( double unit );
-
-    public:
-
-        //------------------------------------------------------------------------------
-        //	Constructors & Destructors
-        //------------------------------------------------------------------------------
-        // default constructor
-        Line2( void );
-        // parameterized constructor
-        Line2( vector< Coord2 > __elements );
-        // copy constructor
-        Line2( const Line2 & v );
-        // destructor
-        virtual ~Line2( void ) {}
-
-        //------------------------------------------------------------------------------
-        //	Assignment operators
-        //------------------------------------------------------------------------------
-
-        //------------------------------------------------------------------------------
-        //	Reference to elements
-        //------------------------------------------------------------------------------
-	
-	    // reference to a vector of coordinates
-	    vector< Coord2 > &	            oldElements( void )	            { return _oldElements; }
-	    const vector< Coord2 > &	    oldElements( void ) const	    { return _oldElements; }
-
-        // reference to a vector of coordinates
-        vector< Coord2 > &	            intermediateElements( void )	            { return _intermediateElements; }
-        const vector< Coord2 > &	    intermediateElements( void ) const	        { return _intermediateElements; }
-        
-        bool &	                        inLocalMove( void )	            { return _inLocalMove; }
-        const bool &	                inLocalMove( void ) const	    { return _inLocalMove; }
-        
-        // reference to a vector of coordinates
-        vector< Coord2 > &	            elements( void )	            { return _elements; }
-        const vector< Coord2 > &	    elements( void ) const	        { return _elements; }
-	
-	    // reference to a vector of coordinates
-	    vector< Coord2* > &	            elementPointers( void )	        { return _elementPointers; }
-	    const vector< Coord2* > &	    elementPointers( void ) const   { return _elementPointers; }
-
-        // reference to an array of fixed coordinates
-        vector< Coord2 > &	            fixedElements( void )	        { return _fixedElements; }
-        const vector< Coord2 > &	    fixedElements( void ) const	    { return _fixedElements; }
-
-        // reference to an array of coordinate pointers
-        vector< unsigned int > &	    idElements( void )	            { return _idElements; }
-        const vector< unsigned int > &  idElements( void ) const        { return _idElements; }
-
-        // reference to the fine sample points
-        vector< Coord2 > &              fineElements( void )            { return _fineElements; }
-        const vector< Coord2 > &        fineElements( void ) const      { return _fineElements; }
-
-        // select flag
-        bool &	                        isSelected( void )	            { return _isSelected; }
-        const bool &	                isSelected( void ) const	    { return _isSelected; }
-        
-        
-	    // graphics item
-//        void setItemPtr( Ui::Vector::GraphicsEdgeItem * ptr )	        { _itemPtr = ptr; }
-//        Ui::Vector::GraphicsEdgeItem * getItemPtr( void )               { return _itemPtr; }
-
-        //------------------------------------------------------------------------------
-        //	Special functions
-        //------------------------------------------------------------------------------
-        // initialization
-        void init( void ) { _init(); }
-        void initElementPointers( void );
-
-        void addSample( Coord2 &coord );
-        void computeChaikinCurve( int num, double unit );
-
-        static bool isOnLine( Coord2 &a, Coord2 &b, Coord2 &c );
-	    void updateOldElement( void );
-	    void updateOldElementByPointers( void );
-	    void updateIntermediateElements( vector< Coord2 > __elements );
-	    void resetInLocalMove( void );
-	    void simplifyGeometry( void );
-	
-	    //------------------------------------------------------------------------------
-        //	Friend functions
-        //------------------------------------------------------------------------------
-
-        //------------------------------------------------------------------------------
-        //	I/O functions
-        //------------------------------------------------------------------------------
-        // output
-        friend ostream &	operator << ( ostream & s, const Line2 & v );
-        // input
-        friend istream &	operator >> ( istream & s, Line2 & v );
-        // class name
-        virtual const char * className( void ) const { return "Line2"; }
-
-    };
-	
-} // namespace Base
-} // namespace KeiRo
-
-#endif // _Base_Line2_H
Index: Base/src/Edge2.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// Edge2.h\r\n//\t: header file for 2D Edge2 coordinates\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Dec 27 23:16:12 2017\r\n//\r\n//******************************************************************************\r\n\r\n#ifndef\t_Base_Edge2_H\r\n#define _Base_Edge2_H\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <vector>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\n#include \"Coord2.h\"\r\n#include \"Object.h\"\r\n//#include \"ui/vector/GraphicsEdgeItem.h\"\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Macros\r\n//------------------------------------------------------------------------------\r\nnamespace KeiRo {\r\nnamespace Base {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tDefining Classes\r\n    //------------------------------------------------------------------------------\r\n    class Edge2 : public Object {\r\n\r\n    protected:\r\n\r\n        // Edge2 original coordinates of end points\r\n        vector< Coord2 >        _fixedElements;\r\n\t    // Edge2 old sample points\r\n\t    vector< Coord2 >        _oldElements;\r\n        // Edge2 sample points\r\n        vector< Coord2 >        _elements;\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tAttribute\r\n        //------------------------------------------------------------------------------\r\n        // select flag\r\n        bool                    _isSelected;\r\n\t\t\r\n\t    // edge style\r\n\t    bool                    _isClosed;\r\n\r\n        // graphics item pointer\r\n//        Ui::Vector::GraphicsEdgeItem * _itemPtr;\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tSpecial functions\r\n        //------------------------------------------------------------------------------\r\n        // initialize all coordinates to zero\r\n        void _init( void );\r\n        void _clear( void );\r\n        void _initChaikinCurve( double unit );\r\n\r\n    public:\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tConstructors & Destructors\r\n        //------------------------------------------------------------------------------\r\n        // default constructor\r\n        Edge2( void );\r\n        // parameterized constructor\r\n        Edge2( vector< Coord2 > __elements );\r\n        // copy constructor\r\n        Edge2( const Edge2 & v );\r\n        // destructor\r\n        virtual ~Edge2( void ) {}\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tAssignment operators\r\n        //------------------------------------------------------------------------------\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tReference to elements\r\n        //------------------------------------------------------------------------------\r\n\t\r\n\t    // reference to a vector of coordinates\r\n\t    vector< Coord2 > &\t            oldElements( void )\t            { return _oldElements; }\r\n\t    const vector< Coord2 > &\t    oldElements( void ) const\t    { return _oldElements; }\r\n\r\n        // reference to a vector of coordinates\r\n        vector< Coord2 > &\t            elements( void )\t            { return _elements; }\r\n        const vector< Coord2 > &\t    elements( void ) const\t        { return _elements; }\r\n\r\n        // reference to an array of fixed coordinates\r\n        vector< Coord2 > &\t            fixedElements( void )\t        { return _fixedElements; }\r\n        const vector< Coord2 > &\t    fixedElements( void ) const\t    { return _fixedElements; }\r\n\r\n\t\t// style\r\n\t\tbool &\t                        isClosed( void )\t            { return _isClosed; }\r\n\t    const bool &\t                isClosed( void ) const\t        { return _isClosed; }\r\n\t\t\r\n\t    // graphics item\r\n//        void setItemPtr( Ui::Vector::GraphicsEdgeItem * ptr )\t        { _itemPtr = ptr; }\r\n//        Ui::Vector::GraphicsEdgeItem * getItemPtr( void )               { return _itemPtr; }\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tSpecial functions\r\n        //------------------------------------------------------------------------------\r\n        // initialization\r\n        void init( void ) { _init(); }\r\n        bool isIntersected( Edge2 e );\r\n        bool isOnEdge( Coord2 c );\r\n        \r\n\t    //------------------------------------------------------------------------------\r\n        //\tFriend functions\r\n        //------------------------------------------------------------------------------\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tI/O functions\r\n        //------------------------------------------------------------------------------\r\n        // output\r\n        friend ostream &\toperator << ( ostream & s, const Edge2 & v );\r\n        // input\r\n        friend istream &\toperator >> ( istream & s, Edge2 & v );\r\n        // \u001Bclass name\r\n        virtual const char * className( void ) const { return \"Edge2\"; }\r\n\r\n    };\r\n\t\r\n} // namespace Base\r\n} // namespace KeiRo\r\n\r\n#endif // _Base_Edge2_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Base/src/Edge2.h b/Base/src/Edge2.h
--- a/Base/src/Edge2.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Base/src/Edge2.h	(date 1729410605280)
@@ -1,136 +1,0 @@
-//******************************************************************************
-// Edge2.h
-//	: header file for 2D Edge2 coordinates
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Dec 27 23:16:12 2017
-//
-//******************************************************************************
-
-#ifndef	_Base_Edge2_H
-#define _Base_Edge2_H
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <vector>
-#include <iostream>
-
-using namespace std;
-
-#include "Coord2.h"
-#include "Object.h"
-//#include "ui/vector/GraphicsEdgeItem.h"
-
-//------------------------------------------------------------------------------
-//	Defining Macros
-//------------------------------------------------------------------------------
-namespace KeiRo {
-namespace Base {
-
-    //------------------------------------------------------------------------------
-    //	Defining Classes
-    //------------------------------------------------------------------------------
-    class Edge2 : public Object {
-
-    protected:
-
-        // Edge2 original coordinates of end points
-        vector< Coord2 >        _fixedElements;
-	    // Edge2 old sample points
-	    vector< Coord2 >        _oldElements;
-        // Edge2 sample points
-        vector< Coord2 >        _elements;
-
-        //------------------------------------------------------------------------------
-        //	Attribute
-        //------------------------------------------------------------------------------
-        // select flag
-        bool                    _isSelected;
-		
-	    // edge style
-	    bool                    _isClosed;
-
-        // graphics item pointer
-//        Ui::Vector::GraphicsEdgeItem * _itemPtr;
-
-        //------------------------------------------------------------------------------
-        //	Special functions
-        //------------------------------------------------------------------------------
-        // initialize all coordinates to zero
-        void _init( void );
-        void _clear( void );
-        void _initChaikinCurve( double unit );
-
-    public:
-
-        //------------------------------------------------------------------------------
-        //	Constructors & Destructors
-        //------------------------------------------------------------------------------
-        // default constructor
-        Edge2( void );
-        // parameterized constructor
-        Edge2( vector< Coord2 > __elements );
-        // copy constructor
-        Edge2( const Edge2 & v );
-        // destructor
-        virtual ~Edge2( void ) {}
-
-        //------------------------------------------------------------------------------
-        //	Assignment operators
-        //------------------------------------------------------------------------------
-
-        //------------------------------------------------------------------------------
-        //	Reference to elements
-        //------------------------------------------------------------------------------
-	
-	    // reference to a vector of coordinates
-	    vector< Coord2 > &	            oldElements( void )	            { return _oldElements; }
-	    const vector< Coord2 > &	    oldElements( void ) const	    { return _oldElements; }
-
-        // reference to a vector of coordinates
-        vector< Coord2 > &	            elements( void )	            { return _elements; }
-        const vector< Coord2 > &	    elements( void ) const	        { return _elements; }
-
-        // reference to an array of fixed coordinates
-        vector< Coord2 > &	            fixedElements( void )	        { return _fixedElements; }
-        const vector< Coord2 > &	    fixedElements( void ) const	    { return _fixedElements; }
-
-		// style
-		bool &	                        isClosed( void )	            { return _isClosed; }
-	    const bool &	                isClosed( void ) const	        { return _isClosed; }
-		
-	    // graphics item
-//        void setItemPtr( Ui::Vector::GraphicsEdgeItem * ptr )	        { _itemPtr = ptr; }
-//        Ui::Vector::GraphicsEdgeItem * getItemPtr( void )               { return _itemPtr; }
-
-        //------------------------------------------------------------------------------
-        //	Special functions
-        //------------------------------------------------------------------------------
-        // initialization
-        void init( void ) { _init(); }
-        bool isIntersected( Edge2 e );
-        bool isOnEdge( Coord2 c );
-        
-	    //------------------------------------------------------------------------------
-        //	Friend functions
-        //------------------------------------------------------------------------------
-
-        //------------------------------------------------------------------------------
-        //	I/O functions
-        //------------------------------------------------------------------------------
-        // output
-        friend ostream &	operator << ( ostream & s, const Edge2 & v );
-        // input
-        friend istream &	operator >> ( istream & s, Edge2 & v );
-        // class name
-        virtual const char * className( void ) const { return "Edge2"; }
-
-    };
-	
-} // namespace Base
-} // namespace KeiRo
-
-#endif // _Base_Edge2_H
Index: Base/src/Label_todo.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#ifndef _Label_H\r\n#define _Label_H\r\n\r\n#include <vector>\r\n#include \"Coord2.h\"\r\n#include \"Grid2.h\"\r\n\r\nusing namespace std;\r\n\r\n\r\nclass Label\r\n{\r\nprivate:\r\n    unsigned int        _id;\r\n    double              _width;\r\n    double              _height;\r\n    double              _leaderW;\r\n    bool                _flag;\r\n    Coord2              _curSite;\r\n    Coord2              _geoSite;\r\n    Coord2              _joint;\r\n    Coord2              _leftTop;\r\n    Coord2              _rightBottom;\r\n    Grid2               _frame;\r\n    Grid2               _base;\r\n#ifdef  REWRITE\r\n    VertexDescriptor    _ptrVertex;\r\n#endif  // REWRITE\r\n\r\npublic:\r\n\r\n\r\n    Label();\r\n    Label( const Label & obj );\r\n\r\n//------------------------------------------------------------------------------\r\n//      Handling member variables\r\n//------------------------------------------------------------------------------\r\n\r\n    unsigned int & id( void )                   { return _id; }\r\n    const unsigned int & id( void )  const      { return _id; }\r\n    const unsigned int & getID( void ) const    { return _id; }\r\n    void setID( unsigned int __id )             { _id = __id; }\r\n\r\n\r\n    double & width( void )                     { return _width; }\r\n    const double & width( void ) const         { return _width; }\r\n\r\n    double & height( void )                     { return _height; }\r\n    const double & height( void ) const         { return _height; }\r\n\r\n    double & leaderWeight( void )               { return _leaderW; }\r\n    const double & leaderWeight( void ) const   { return _leaderW; }\r\n\r\n    const bool & flag( void ) const             { return _flag; }\r\n    void setFlag( void )                        { _flag = true; }\r\n    void clearFlag( void )                      { _flag = false; }\r\n\r\n    Coord2 & geoSite( void )                    { return _geoSite; }\r\n    const Coord2 & geoSite( void ) const        { return _geoSite; }\r\n    void setGeoSite( const Coord2 & __geoSite ) { _geoSite = __geoSite; }\r\n\r\n    Coord2 & curSite( void )                    { return _curSite; }\r\n    const Coord2 & curSite( void ) const        { return _curSite; }\r\n    void setCurSite( const Coord2 & __curSite ) { _curSite = __curSite; }\r\n\r\n    Coord2 & joint( void )                      { return _joint; }\r\n    const Coord2 & joint( void ) const          { return _joint; }\r\n    void setJoint( const Coord2 & __joint )     { _joint = __joint; }\r\n\r\n    Coord2 & lt( void )                         { return _leftTop; }\r\n    const Coord2 & lt( void ) const             { return _leftTop; }\r\n    void setLT( const Coord2 & __lt )           { _leftTop = __lt; }\r\n\r\n    Coord2 & rb( void )                         { return _rightBottom; }\r\n    const Coord2 & rb( void ) const             { return _rightBottom; }\r\n    void setRB( const Coord2 & __rb )           { _rightBottom = __rb; }\r\n\r\n    Grid2 & frame( void )                       { return _frame; }\r\n    const Grid2 & frame( void ) const           { return _frame; }\r\n    void setFrame( const Grid2 & __frame )      { _frame = __frame; }\r\n\r\n    Grid2 & base( void )                        { return _base; }\r\n    const Grid2 & base( void ) const            { return _base; }\r\n    void setBase( const Grid2 & __base )        { _base = __base; }\r\n\r\n#ifdef  REWRITE\r\n    VertexDescriptor ptrVertex( void )                  { return _ptrVertex; }\r\n    void setPtrVertex( VertexDescriptor __ptrVertex )   { _ptrVertex = __ptrVertex; }\r\n#endif  // REWRITE\r\n\r\n//------------------------------------------------------------------------------\r\n//      Specific functions\r\n//------------------------------------------------------------------------------\r\n\r\n    double minimizeLeader( const Coord2 & curSite, const Coord2 & corner, const double & interval,\r\n                           Coord2 & coord );\r\n\r\n    const bool isOverlapped( const Coord2 & orig, const Coord2 & dest ) const;\r\n\r\n    const bool isOverlapped( const Label & box ) const;\r\n\r\n//------------------------------------------------------------------------------\r\n//      Assignment opereators\r\n//------------------------------------------------------------------------------\r\n\r\n    Label & operator = ( const Label & obj );\r\n\r\n};\r\n\r\n#endif // _Label_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Base/src/Label_todo.h b/Base/src/Label_todo.h
--- a/Base/src/Label_todo.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Base/src/Label_todo.h	(date 1729410605290)
@@ -1,111 +1,0 @@
-#ifndef _Label_H
-#define _Label_H
-
-#include <vector>
-#include "Coord2.h"
-#include "Grid2.h"
-
-using namespace std;
-
-
-class Label
-{
-private:
-    unsigned int        _id;
-    double              _width;
-    double              _height;
-    double              _leaderW;
-    bool                _flag;
-    Coord2              _curSite;
-    Coord2              _geoSite;
-    Coord2              _joint;
-    Coord2              _leftTop;
-    Coord2              _rightBottom;
-    Grid2               _frame;
-    Grid2               _base;
-#ifdef  REWRITE
-    VertexDescriptor    _ptrVertex;
-#endif  // REWRITE
-
-public:
-
-
-    Label();
-    Label( const Label & obj );
-
-//------------------------------------------------------------------------------
-//      Handling member variables
-//------------------------------------------------------------------------------
-
-    unsigned int & id( void )                   { return _id; }
-    const unsigned int & id( void )  const      { return _id; }
-    const unsigned int & getID( void ) const    { return _id; }
-    void setID( unsigned int __id )             { _id = __id; }
-
-
-    double & width( void )                     { return _width; }
-    const double & width( void ) const         { return _width; }
-
-    double & height( void )                     { return _height; }
-    const double & height( void ) const         { return _height; }
-
-    double & leaderWeight( void )               { return _leaderW; }
-    const double & leaderWeight( void ) const   { return _leaderW; }
-
-    const bool & flag( void ) const             { return _flag; }
-    void setFlag( void )                        { _flag = true; }
-    void clearFlag( void )                      { _flag = false; }
-
-    Coord2 & geoSite( void )                    { return _geoSite; }
-    const Coord2 & geoSite( void ) const        { return _geoSite; }
-    void setGeoSite( const Coord2 & __geoSite ) { _geoSite = __geoSite; }
-
-    Coord2 & curSite( void )                    { return _curSite; }
-    const Coord2 & curSite( void ) const        { return _curSite; }
-    void setCurSite( const Coord2 & __curSite ) { _curSite = __curSite; }
-
-    Coord2 & joint( void )                      { return _joint; }
-    const Coord2 & joint( void ) const          { return _joint; }
-    void setJoint( const Coord2 & __joint )     { _joint = __joint; }
-
-    Coord2 & lt( void )                         { return _leftTop; }
-    const Coord2 & lt( void ) const             { return _leftTop; }
-    void setLT( const Coord2 & __lt )           { _leftTop = __lt; }
-
-    Coord2 & rb( void )                         { return _rightBottom; }
-    const Coord2 & rb( void ) const             { return _rightBottom; }
-    void setRB( const Coord2 & __rb )           { _rightBottom = __rb; }
-
-    Grid2 & frame( void )                       { return _frame; }
-    const Grid2 & frame( void ) const           { return _frame; }
-    void setFrame( const Grid2 & __frame )      { _frame = __frame; }
-
-    Grid2 & base( void )                        { return _base; }
-    const Grid2 & base( void ) const            { return _base; }
-    void setBase( const Grid2 & __base )        { _base = __base; }
-
-#ifdef  REWRITE
-    VertexDescriptor ptrVertex( void )                  { return _ptrVertex; }
-    void setPtrVertex( VertexDescriptor __ptrVertex )   { _ptrVertex = __ptrVertex; }
-#endif  // REWRITE
-
-//------------------------------------------------------------------------------
-//      Specific functions
-//------------------------------------------------------------------------------
-
-    double minimizeLeader( const Coord2 & curSite, const Coord2 & corner, const double & interval,
-                           Coord2 & coord );
-
-    const bool isOverlapped( const Coord2 & orig, const Coord2 & dest ) const;
-
-    const bool isOverlapped( const Label & box ) const;
-
-//------------------------------------------------------------------------------
-//      Assignment opereators
-//------------------------------------------------------------------------------
-
-    Label & operator = ( const Label & obj );
-
-};
-
-#endif // _Label_H
Index: Base/src/Object.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// Object.h\r\n//\t: header file for object schemes\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Jun 19 02:36:37 2019\r\n//\r\n//******************************************************************************\r\n\r\n#ifndef _Base_Object_H\r\n#define _Base_Object_H\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <vector>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\n#include \"Common.h\"\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Macros\r\n//------------------------------------------------------------------------------\r\nnamespace KeiRo {\r\nnamespace Base {\r\n\t\r\n    //------------------------------------------------------------------------------\r\n    //\tDefining Classes\r\n    //------------------------------------------------------------------------------\r\n    class Object {\r\n\r\n    private:\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tSpecial functions\r\n        //------------------------------------------------------------------------------\r\n\r\n    protected:\r\n\r\n        unsigned int            _id;\r\n        unsigned int            _gid;\r\n        unsigned int            _level;\r\n        string                  _name;\r\n        string                  _label;\r\n        Common::IDPair          _parentFileID;\r\n        unsigned int            _parentPolygonID;\r\n        bool                    _isVisible;\r\n\t    bool                    _isTextVisible;\r\n\t\r\n\t    // graphics item id\r\n\t    unsigned int            _itemID;\r\n\t\r\n\t    // attributes\r\n\t    // stroke color\r\n\t    vector< unsigned int >  _stroke;\r\n\t    double                  _strokeWidth;\r\n\t\t\r\n\t    // fill color\r\n\t    vector< unsigned int >  _fill;\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tSpecial functions\r\n        //------------------------------------------------------------------------------\r\n        virtual void\t    _init( void );\r\n        virtual void        _clear( void ) {}\r\n\r\n    public:\r\n    \t\r\n        //------------------------------------------------------------------------------\r\n        //\tConstructors & Destructors\r\n        //------------------------------------------------------------------------------\r\n        // default constructor\r\n        Object( void );\r\n        // copy constructor\r\n        Object( const Object & c );\r\n        // destructor\r\n        ~Object( void ){}\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tAssignment operators\r\n        //------------------------------------------------------------------------------\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tReference to elements\r\n        //------------------------------------------------------------------------------\r\n        // id\r\n        unsigned int &\t            id( void )\t            { return _id; }\r\n        const unsigned int &\t    id( void ) const\t    { return _id; }\r\n        // group id\r\n        unsigned int &\t            gid( void )\t            { return _gid; }\r\n        const unsigned int &\t    gid( void ) const\t    { return _gid; }\r\n        // name\r\n        string &\t                name( void )\t        { return _name; }\r\n        const string &\t            name( void ) const\t    { return _name; }\r\n\t    // label\r\n\t    string &\t                label( void )\t        { return _label; }\r\n\t    const string &\t            label( void ) const\t    { return _label; }\r\n\t    // level\r\n\t    unsigned int &\t            level( void )\t        { return _level; }\r\n\t    const unsigned int &\t    level( void ) const\t    { return _level; }\r\n\r\n        // parent file id\r\n        Common::IDPair &\t        parentFileID( void )\t        { return _parentFileID; }\r\n        const Common::IDPair &      parentFileID( void ) const\t    { return _parentFileID; }\r\n\r\n        // parent polygon id\r\n        unsigned int &\t            parentPolygonID( void )\t        { return _parentPolygonID; }\r\n        const unsigned int &\t    parentPolygonID( void ) const\t{ return _parentPolygonID; }\r\n\t\r\n\t    // reference to stroke\r\n\t    vector< unsigned int > &\t    stroke( void )\t                { return _stroke; }\r\n\t    const vector< unsigned int > &  stroke( void ) const            { return _stroke; }\r\n\t\r\n\t    double &\t                    strokeWidth( void )\t            { return _strokeWidth; }\r\n\t    const double &                  strokeWidth( void ) const       { return _strokeWidth; }\r\n\t\t\r\n\t    // reference to fill\r\n\t    vector< unsigned int > &\t    fill( void )\t                { return _fill; }\r\n\t    const vector< unsigned int > &  fill( void ) const              { return _fill; }\r\n\t\r\n\t\r\n\t    // parent name\r\n        // string &\t                parent( void )\t        { return _parent; }\r\n        //const string &\t            parent( void ) const\t{ return _parent; }\r\n        // is visible\r\n        bool &\t                    isVisible( void )       { return _isVisible; }\r\n        const bool &\t            isVisible( void ) const { return _isVisible; }\r\n\t\r\n\t    bool &\t                    isTextVisible( void )       { return _isTextVisible; }\r\n\t    const bool &\t            isTextVisible( void ) const { return _isTextVisible; }\r\n\r\n\t    // reference to itemID\r\n\t    unsigned int &\t                itemID( void )\t                { return _itemID; }\r\n\t    const unsigned int &            itemID( void ) const            { return _itemID; }\r\n\t\r\n\t    //------------------------------------------------------------------------------\r\n        //\tSpecial functions\r\n        //------------------------------------------------------------------------------\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tFriend functions\r\n        //------------------------------------------------------------------------------\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tI/O functions\r\n        //------------------------------------------------------------------------------\r\n        // output\r\n        friend ostream &\toperator << ( ostream & s, const Object & v );\r\n        // input\r\n        friend istream &\toperator >> ( istream & s, Object & v );\r\n        // class name\r\n        virtual const char * className( void ) const { return \"Object\"; }\r\n\r\n    };\r\n\r\n} // namespace Base\r\n} // namespace KeiRo\r\n\r\n#endif // _Base_Object_H
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Base/src/Object.h b/Base/src/Object.h
--- a/Base/src/Object.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Base/src/Object.h	(date 1729410605300)
@@ -1,163 +1,0 @@
-//******************************************************************************
-// Object.h
-//	: header file for object schemes
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Jun 19 02:36:37 2019
-//
-//******************************************************************************
-
-#ifndef _Base_Object_H
-#define _Base_Object_H
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <vector>
-#include <iostream>
-
-using namespace std;
-
-#include "Common.h"
-
-//------------------------------------------------------------------------------
-//	Defining Macros
-//------------------------------------------------------------------------------
-namespace KeiRo {
-namespace Base {
-	
-    //------------------------------------------------------------------------------
-    //	Defining Classes
-    //------------------------------------------------------------------------------
-    class Object {
-
-    private:
-
-        //------------------------------------------------------------------------------
-        //	Special functions
-        //------------------------------------------------------------------------------
-
-    protected:
-
-        unsigned int            _id;
-        unsigned int            _gid;
-        unsigned int            _level;
-        string                  _name;
-        string                  _label;
-        Common::IDPair          _parentFileID;
-        unsigned int            _parentPolygonID;
-        bool                    _isVisible;
-	    bool                    _isTextVisible;
-	
-	    // graphics item id
-	    unsigned int            _itemID;
-	
-	    // attributes
-	    // stroke color
-	    vector< unsigned int >  _stroke;
-	    double                  _strokeWidth;
-		
-	    // fill color
-	    vector< unsigned int >  _fill;
-
-        //------------------------------------------------------------------------------
-        //	Special functions
-        //------------------------------------------------------------------------------
-        virtual void	    _init( void );
-        virtual void        _clear( void ) {}
-
-    public:
-    	
-        //------------------------------------------------------------------------------
-        //	Constructors & Destructors
-        //------------------------------------------------------------------------------
-        // default constructor
-        Object( void );
-        // copy constructor
-        Object( const Object & c );
-        // destructor
-        ~Object( void ){}
-
-        //------------------------------------------------------------------------------
-        //	Assignment operators
-        //------------------------------------------------------------------------------
-
-        //------------------------------------------------------------------------------
-        //	Reference to elements
-        //------------------------------------------------------------------------------
-        // id
-        unsigned int &	            id( void )	            { return _id; }
-        const unsigned int &	    id( void ) const	    { return _id; }
-        // group id
-        unsigned int &	            gid( void )	            { return _gid; }
-        const unsigned int &	    gid( void ) const	    { return _gid; }
-        // name
-        string &	                name( void )	        { return _name; }
-        const string &	            name( void ) const	    { return _name; }
-	    // label
-	    string &	                label( void )	        { return _label; }
-	    const string &	            label( void ) const	    { return _label; }
-	    // level
-	    unsigned int &	            level( void )	        { return _level; }
-	    const unsigned int &	    level( void ) const	    { return _level; }
-
-        // parent file id
-        Common::IDPair &	        parentFileID( void )	        { return _parentFileID; }
-        const Common::IDPair &      parentFileID( void ) const	    { return _parentFileID; }
-
-        // parent polygon id
-        unsigned int &	            parentPolygonID( void )	        { return _parentPolygonID; }
-        const unsigned int &	    parentPolygonID( void ) const	{ return _parentPolygonID; }
-	
-	    // reference to stroke
-	    vector< unsigned int > &	    stroke( void )	                { return _stroke; }
-	    const vector< unsigned int > &  stroke( void ) const            { return _stroke; }
-	
-	    double &	                    strokeWidth( void )	            { return _strokeWidth; }
-	    const double &                  strokeWidth( void ) const       { return _strokeWidth; }
-		
-	    // reference to fill
-	    vector< unsigned int > &	    fill( void )	                { return _fill; }
-	    const vector< unsigned int > &  fill( void ) const              { return _fill; }
-	
-	
-	    // parent name
-        // string &	                parent( void )	        { return _parent; }
-        //const string &	            parent( void ) const	{ return _parent; }
-        // is visible
-        bool &	                    isVisible( void )       { return _isVisible; }
-        const bool &	            isVisible( void ) const { return _isVisible; }
-	
-	    bool &	                    isTextVisible( void )       { return _isTextVisible; }
-	    const bool &	            isTextVisible( void ) const { return _isTextVisible; }
-
-	    // reference to itemID
-	    unsigned int &	                itemID( void )	                { return _itemID; }
-	    const unsigned int &            itemID( void ) const            { return _itemID; }
-	
-	    //------------------------------------------------------------------------------
-        //	Special functions
-        //------------------------------------------------------------------------------
-
-        //------------------------------------------------------------------------------
-        //	Friend functions
-        //------------------------------------------------------------------------------
-
-        //------------------------------------------------------------------------------
-        //	I/O functions
-        //------------------------------------------------------------------------------
-        // output
-        friend ostream &	operator << ( ostream & s, const Object & v );
-        // input
-        friend istream &	operator >> ( istream & s, Object & v );
-        // class name
-        virtual const char * className( void ) const { return "Object"; }
-
-    };
-
-} // namespace Base
-} // namespace KeiRo
-
-#endif // _Base_Object_H
\ No newline at end of file
Index: Base/src/Color.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// Color.h\r\n//\t: header file for color schemes\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Jun 19 02:36:37 2019\r\n//\r\n//******************************************************************************\r\n\r\n#ifndef _Base_Color_H\r\n#define _Base_Color_H\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <vector>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\n#include \"Common.h\"\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Macros\r\n//------------------------------------------------------------------------------\r\n#define MAX_COLOR_TYPE      (12)\r\n\r\nnamespace KeiRo {\r\nnamespace Base {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tDefining Classes\r\n    //------------------------------------------------------------------------------\r\n    class Color {\r\n\r\n    private:\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tSpecial functions\r\n        //------------------------------------------------------------------------------\r\n        // initialize color\r\n        virtual void\t_init( void );\r\n\r\n    protected:\r\n\r\n    public:\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tConstructors & Destructors\r\n        //------------------------------------------------------------------------------\r\n        // default constructor\r\n        Color( void ) {}\r\n        // copy constructor\r\n        Color( const Color & c ) {}\r\n        // destructor\r\n        ~Color( void ){}\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tAssignment operators\r\n        //------------------------------------------------------------------------------\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tReference to elements\r\n        //------------------------------------------------------------------------------\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tSpecial functions\r\n        //------------------------------------------------------------------------------\r\n        static unsigned long RGBtoHex( int r, int g, int b );\r\n        // select a color scheme\r\n        static void pickMonotoneColor( vector< double > &rgb );\r\n        static void pickPastelColor( unsigned int id, vector< double > &rgb );\r\n        static void pickBrewerColor( unsigned int id, vector< double > &rgb );\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tFriend functions\r\n        //------------------------------------------------------------------------------\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tI/O functions\r\n        //------------------------------------------------------------------------------\r\n        // output\r\n        friend ostream &\toperator << ( ostream & s, const Color & v );\r\n        // input\r\n        friend istream &\toperator >> ( istream & s, Color & v );\r\n        // class name\r\n        virtual const char * className( void ) const { return \"Color\"; }\r\n\r\n    };\r\n\t\r\n} // namespace Base\r\n} // namespace KeiRo\r\n\r\n#endif // _Base_Color_H
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Base/src/Color.h b/Base/src/Color.h
--- a/Base/src/Color.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Base/src/Color.h	(date 1729410605320)
@@ -1,96 +1,0 @@
-//******************************************************************************
-// Color.h
-//	: header file for color schemes
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Jun 19 02:36:37 2019
-//
-//******************************************************************************
-
-#ifndef _Base_Color_H
-#define _Base_Color_H
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <vector>
-#include <iostream>
-
-using namespace std;
-
-#include "Common.h"
-
-//------------------------------------------------------------------------------
-//	Defining Macros
-//------------------------------------------------------------------------------
-#define MAX_COLOR_TYPE      (12)
-
-namespace KeiRo {
-namespace Base {
-
-    //------------------------------------------------------------------------------
-    //	Defining Classes
-    //------------------------------------------------------------------------------
-    class Color {
-
-    private:
-
-        //------------------------------------------------------------------------------
-        //	Special functions
-        //------------------------------------------------------------------------------
-        // initialize color
-        virtual void	_init( void );
-
-    protected:
-
-    public:
-
-        //------------------------------------------------------------------------------
-        //	Constructors & Destructors
-        //------------------------------------------------------------------------------
-        // default constructor
-        Color( void ) {}
-        // copy constructor
-        Color( const Color & c ) {}
-        // destructor
-        ~Color( void ){}
-
-        //------------------------------------------------------------------------------
-        //	Assignment operators
-        //------------------------------------------------------------------------------
-
-        //------------------------------------------------------------------------------
-        //	Reference to elements
-        //------------------------------------------------------------------------------
-
-        //------------------------------------------------------------------------------
-        //	Special functions
-        //------------------------------------------------------------------------------
-        static unsigned long RGBtoHex( int r, int g, int b );
-        // select a color scheme
-        static void pickMonotoneColor( vector< double > &rgb );
-        static void pickPastelColor( unsigned int id, vector< double > &rgb );
-        static void pickBrewerColor( unsigned int id, vector< double > &rgb );
-
-        //------------------------------------------------------------------------------
-        //	Friend functions
-        //------------------------------------------------------------------------------
-
-        //------------------------------------------------------------------------------
-        //	I/O functions
-        //------------------------------------------------------------------------------
-        // output
-        friend ostream &	operator << ( ostream & s, const Color & v );
-        // input
-        friend istream &	operator >> ( istream & s, Color & v );
-        // class name
-        virtual const char * className( void ) const { return "Color"; }
-
-    };
-	
-} // namespace Base
-} // namespace KeiRo
-
-#endif // _Base_Color_H
\ No newline at end of file
Index: Base/src/Grid2_todo.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// Grid2.cc\r\n//\t: program file for 2D grid coordinatse\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Mon Mar 14 02:16:23 2011\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <iostream>\r\n#include <iomanip>\r\n#include <cctype>\r\n#include <cmath>\r\nusing namespace std;\r\n\r\n#include \"Grid2.h\"\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tMacro Definitions\r\n//------------------------------------------------------------------------------\r\n\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tProtected Functions\r\n//------------------------------------------------------------------------------\r\n\r\n//\r\n//  Grid2::_init --\t\u001B$B$9$Y$F$NMWAG$r%<%m$K$9$k\u001B(B\r\n//\r\n//  \u001B$B0z?t\u001B(B\r\n//\t\u001B$B$J$7\u001B(B\r\n//\r\n//  \u001B$BJV$jCM\u001B(B\r\n//\t\u001B$B$J$7\u001B(B\r\n//\r\nvoid Grid2::_init( void )\r\n{\r\n    _element[ 0 ] = _element[ 1 ] = 0;\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n//\tPublic functions\r\n//------------------------------------------------------------------------------\r\n\r\n//------------------------------------------------------------------------------\r\n//\tConstuructors\r\n//------------------------------------------------------------------------------\r\n\r\n//\r\n//  Grid2::Grid2 --\t\u001B$B%3%s%9%H%i%/%?\u001B(B(\u001B$B%G%U%)%k%H\u001B(B)\r\n//\r\n//  \u001B$B0z?t\u001B(B\r\n//\t\u001B$B$J$7\u001B(B\r\n//\r\n//  \u001B$BJV$jCM\u001B(B\r\n//\t\u001B$B$J$7\u001B(B\r\n//\r\nGrid2::Grid2()\r\n{\r\n    _init();\r\n}\r\n\r\n\r\n//\r\n//  Grid2::Grid2 --\t\u001B$B:BI8$rF~NO\u001B(B\r\n//\r\n//  \u001B$B0z?t\u001B(B\r\n//\tx, y :\t2\u001B$B<!85:BI8\u001B(B\r\n//\r\n//  \u001B$BJV$jCM\u001B(B\r\n//\t\u001B$B$J$7\u001B(B\r\n//\r\nGrid2::Grid2( const int x, const int y )\r\n{\r\n    _element[ 0 ]\t= x;\r\n    _element[ 1 ]\t= y;\r\n}\r\n\r\n//\r\n//  Grid2::Grid2 --\t\u001B$B%3%T!<!&%3%s%9%H%i%/%?\u001B(B\r\n//\r\n//  \u001B$B0z?t\u001B(B\r\n//\tv\t: 2\u001B$B<!85%Y%/%H%k!&%*%V%8%'%/%H\u001B(B\r\n//\r\n//  \u001B$BJV$jCM\u001B(B\r\n//\t\u001B$B$J$7\u001B(B\r\n//\r\nGrid2::Grid2( const Grid2 & v )\r\n{\r\n    _element[ 0 ]\t= v._element[ 0 ];\r\n    _element[ 1 ]\t= v._element[ 1 ];\r\n }\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tAssignment opereators\r\n//------------------------------------------------------------------------------\r\n\r\n//\r\n//  Grid2::operator = --\tassignment\r\n//\r\n//  Inputs\r\n//\tv\t: 2D coordinates\r\n//\r\n//  Outputs\r\n//\treference to this object\r\n//\r\nGrid2 & Grid2::operator = ( const Grid2 & v )\r\n{\r\n    if ( this != &v ) {\r\n\t_element[ 0 ]\t= v._element[ 0 ];\r\n\t_element[ 1 ]\t= v._element[ 1 ];\r\n    }\r\n    return *this;\r\n}\r\n\r\n\r\n//\r\n//  Grid2::operator += --\taddition + assignment\r\n//\r\n//  Inputs\r\n//\tv\t: 2D coordinates\r\n//\r\n//  Outputs\r\n//\treference to this object\r\n//\r\nGrid2 & Grid2::operator += ( const Grid2 & v )\r\n{\r\n    _element[ 0 ]\t+= v._element[ 0 ];\r\n    _element[ 1 ]\t+= v._element[ 1 ];\r\n    return *this;\r\n}\r\n\r\n\r\n//\r\n//  Grid2::operator -= --\tsubtraction + assignment\r\n//\r\n//  Inputs\r\n//\tv\t: 2D coordinates\r\n//\r\n//  Outputs\r\n//\treference to this object\r\n//\r\nGrid2 & Grid2::operator -= ( const Grid2 & v )\r\n{\r\n    _element[ 0 ]\t-= v._element[ 0 ];\r\n    _element[ 1 ]\t-= v._element[ 1 ];\r\n    return *this;\r\n}\r\n\r\n\r\n//\r\n//  Grid2::operator -= --\tscalar product + assignment\r\n//\r\n//  Inputs\r\n//\td\t: scalar value\r\n//\r\n//  Outputs\r\n//\treference to this object\r\n//\r\nGrid2 & Grid2::operator *= ( const int d )\r\n{\r\n    _element[ 0 ]\t*= d;\r\n    _element[ 1 ]\t*= d;\r\n    return *this;\r\n}\r\n\r\n\r\n//\r\n//  Grid2::operator [] --\treference to an element\r\n//\r\n//  Inputs\r\n//\ti\t: index of the coordinate\r\n//\r\n//  Outputs\r\n//\tthe corresponding coordinate\r\n//\r\nconst int & Grid2::operator [] ( int i ) const\r\n{\r\n#ifdef GRID2_INDEX_CHECK\r\n    const char theName[] = \"Grid2::operator [] : \";\r\n    if ( ( i < 0 ) || ( i > 1 ) ) {\r\n\tcerr << theName << \" index = \" << i << endl;\r\n\tassert( ( 0 <= i ) && ( i <= 1 ) );\r\n    }\r\n#endif\t// GRID2_INDEX_CHECK\r\n    return _element[ i ];\r\n}\r\n\r\n\r\n//\r\n//  Grid2::operator [] --\treference to an element\r\n//\r\n//  Inputs\r\n//\ti\t: index of the coordinate\r\n//\r\n//  Outputs\r\n//\tthe corresponding coordinate\r\n//\r\nint & Grid2::operator [] ( int i )\r\n{\r\n#ifdef GRID2_INDEX_CHECK\r\n    const char theName[] = \"Grid2::operator [] : \";\r\n    if ( ( i < 0 ) || ( i > 1 ) ) {\r\n\tcerr << theName << \" index = \" << i << endl;\r\n\tassert( ( 0 <= i ) && ( i <= 1 ) );\r\n    }\r\n#endif\t// GRID2_INDEX_CHECK\r\n    return _element[ i ];\r\n}\r\n\r\n\r\n//\r\n//  Grid2::set --\tset all the coordinates\r\n//\r\n//  Inputs\r\n//\tx, y\t: x and y coordinates\r\n//\r\n//  Returns\r\n//\tnone\r\n//\r\nvoid Grid2::set( const int x, const int y )\r\n{\r\n    _element[ 0 ]\t= x;\r\n    _element[ 1 ]\t= y;\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tFriend functions\r\n//------------------------------------------------------------------------------\r\n\r\n//\r\n//  operator - --\tsign change\r\n//\r\n//  Inputs\r\n//\ta\t: 2D coordinates\r\n//\r\n//  Outputs\r\n//\t2D coordinates in the opposite direction\r\n//\r\nGrid2 operator - ( const Grid2 & a )\r\n{\r\n    return Grid2( -a._element[ 0 ], -a._element[ 1 ] );\r\n}\r\n\r\n\r\n//\r\n//  operator + --\taddition\r\n//\r\n//  Inputs\r\n//\ta, b\t: 2D coordinates\r\n//\r\n//  Outputs\r\n//\taddition of the two 2D coordinates\r\n//\r\nGrid2 operator + ( const Grid2 & a, const Grid2 & b )\r\n{\r\n    return Grid2( a._element[ 0 ] + b._element[ 0 ],\r\n\t\t  a._element[ 1 ] + b._element[ 1 ] );\r\n}\r\n\r\n\r\n//\r\n//  operator - --\tdifference\r\n//\r\n//  Inputs\r\n//\ta, b\t: 2D coordinates\r\n//\r\n//  Outputs\r\n//\tdifference of the two 2D coordinates\r\n//\r\nGrid2 operator - ( const Grid2 & a, const Grid2 & b )\r\n{\r\n    return Grid2( a._element[ 0 ] - b._element[ 0 ],\r\n\t\t  a._element[ 1 ] - b._element[ 1 ] );\r\n}\r\n\r\n\r\n//\r\n//  operator * --\tscalar product\r\n//\r\n//  Inputs\r\n//\td\t: scalar value\r\n//\ta\t: 2D coordinates\r\n//\r\n//  Outputs\r\n//\tscalar product \r\n//\r\nGrid2 operator * ( const int d, const Grid2 & a )\r\n{\r\n    return Grid2( d * a._element[ 0 ], d * a._element[ 1 ] );\r\n}\r\n\r\n\r\n//\r\n//  operator * --\tinner product\r\n//\r\n//  Inputs\r\n//\ta, b\t: 2D coordinates\r\n//\r\n//  Outputs\r\n//\tinner product\r\n//\r\nint operator * ( const Grid2 & a, const Grid2 & b )\r\n{\r\n    return ( a._element[ 0 ] * b._element[ 0 ] +\r\n\t     a._element[ 1 ] * b._element[ 1 ] );\r\n}\r\n\r\n\r\n//\r\n//  operator == --\tequivalence\r\n//\r\n//  Inputs\r\n//\ta, b\t: 2D coordinates\r\n//\r\n//  Outputs\r\n//\tboolean value\r\n//\r\nint operator == ( const Grid2 & a, const Grid2 & b )\r\n{\r\n    return ( ( a._element[ 0 ] == b._element[ 0 ] ) &&\r\n\t     ( a._element[ 1 ] == b._element[ 1 ] ) );\r\n}\r\n\r\n\r\n//\r\n//  operator < --\tcomparison (less than)\r\n//\r\n//  Inputs\r\n//\ta, b\t: 2D coordinates\r\n//\r\n//  Outputs\r\n//\tboolean value\r\n//\r\nint operator < ( const Grid2 & a, const Grid2 & b )\r\n{\r\n    if ( a._element[ 0 ] < b._element[ 0 ] ) return true;\r\n    else if ( a._element[ 0 ] > b._element[ 0 ] ) return false;\r\n    else {\r\n\tif ( a._element[ 1 ] < b._element[ 1 ] ) return true;\r\n\telse if ( a._element[ 1 ] > b._element[ 1 ] ) return false;\r\n\telse return false;\r\n    }\r\n}\r\n\r\n\r\n//\r\n//  operator > --\tcomparison (more than)\r\n//\r\n//  Inputs\r\n//\ta, b\t: 2D coordinates\r\n//\r\n//  Outputs\r\n//\tboolean value\r\n//\r\nint operator > ( const Grid2 & a, const Grid2 & b )\r\n{\r\n    if ( a._element[ 0 ] > b._element[ 0 ] ) return true;\r\n    else if ( a._element[ 0 ] < b._element[ 0 ] ) return false;\r\n    else {\r\n\tif ( a._element[ 1 ] > b._element[ 1 ] ) return true;\r\n\telse if ( a._element[ 1 ] < b._element[ 1 ] ) return false;\r\n\telse return false;\r\n    }\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tI/O functions\r\n//------------------------------------------------------------------------------\r\n\r\n//\r\n//  operator << --\toutput\r\n//\r\n//  Inputs\r\n//\ts\t: reference to output stream\r\n//\tv\t: 2D coordinates\r\n//\r\n//  Outputs\r\n//\treference to output stream\r\n//\r\nostream & operator << ( ostream & stream, const Grid2 & obj )\r\n{\r\n    // set the output formatting\r\n    int width = 16;\r\n    // print out the elements\r\n    for ( int i = 0; i < 2; i++ ) {\r\n\tstream << setw( width ) << obj._element[ i ];\r\n\tif ( i != 1 ) stream << \"\\t\";\r\n    }\r\n    stream << endl;\r\n\r\n    return stream;\r\n}\r\n\r\n\r\n//\r\n//  operator >> --\tinput\r\n//\r\n//  Inputs\r\n//\ts\t: reference to input stream\r\n//\tv\t: 2D coordinates\r\n//\r\n//  Outputs\r\n//\treference to input stream\r\n//\r\nistream & operator >> ( istream & stream, Grid2 & obj )\r\n{\r\n    // reading the elements\r\n    for ( int i = 0; i < 2; i++ )\r\n\tstream >> obj._element[ i ];\r\n    return stream;\r\n}\r\n\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Base/src/Grid2_todo.cpp b/Base/src/Grid2_todo.cpp
--- a/Base/src/Grid2_todo.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Base/src/Grid2_todo.cpp	(date 1729410605330)
@@ -1,426 +1,0 @@
-//******************************************************************************
-// Grid2.cc
-//	: program file for 2D grid coordinatse
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Mon Mar 14 02:16:23 2011
-//
-//******************************************************************************
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <iostream>
-#include <iomanip>
-#include <cctype>
-#include <cmath>
-using namespace std;
-
-#include "Grid2.h"
-
-
-//------------------------------------------------------------------------------
-//	Macro Definitions
-//------------------------------------------------------------------------------
-
-
-
-//------------------------------------------------------------------------------
-//	Protected Functions
-//------------------------------------------------------------------------------
-
-//
-//  Grid2::_init --	$B$9$Y$F$NMWAG$r%<%m$K$9$k(B
-//
-//  $B0z?t(B
-//	$B$J$7(B
-//
-//  $BJV$jCM(B
-//	$B$J$7(B
-//
-void Grid2::_init( void )
-{
-    _element[ 0 ] = _element[ 1 ] = 0;
-}
-
-//------------------------------------------------------------------------------
-//	Public functions
-//------------------------------------------------------------------------------
-
-//------------------------------------------------------------------------------
-//	Constuructors
-//------------------------------------------------------------------------------
-
-//
-//  Grid2::Grid2 --	$B%3%s%9%H%i%/%?(B($B%G%U%)%k%H(B)
-//
-//  $B0z?t(B
-//	$B$J$7(B
-//
-//  $BJV$jCM(B
-//	$B$J$7(B
-//
-Grid2::Grid2()
-{
-    _init();
-}
-
-
-//
-//  Grid2::Grid2 --	$B:BI8$rF~NO(B
-//
-//  $B0z?t(B
-//	x, y :	2$B<!85:BI8(B
-//
-//  $BJV$jCM(B
-//	$B$J$7(B
-//
-Grid2::Grid2( const int x, const int y )
-{
-    _element[ 0 ]	= x;
-    _element[ 1 ]	= y;
-}
-
-//
-//  Grid2::Grid2 --	$B%3%T!<!&%3%s%9%H%i%/%?(B
-//
-//  $B0z?t(B
-//	v	: 2$B<!85%Y%/%H%k!&%*%V%8%'%/%H(B
-//
-//  $BJV$jCM(B
-//	$B$J$7(B
-//
-Grid2::Grid2( const Grid2 & v )
-{
-    _element[ 0 ]	= v._element[ 0 ];
-    _element[ 1 ]	= v._element[ 1 ];
- }
-
-
-//------------------------------------------------------------------------------
-//	Assignment opereators
-//------------------------------------------------------------------------------
-
-//
-//  Grid2::operator = --	assignment
-//
-//  Inputs
-//	v	: 2D coordinates
-//
-//  Outputs
-//	reference to this object
-//
-Grid2 & Grid2::operator = ( const Grid2 & v )
-{
-    if ( this != &v ) {
-	_element[ 0 ]	= v._element[ 0 ];
-	_element[ 1 ]	= v._element[ 1 ];
-    }
-    return *this;
-}
-
-
-//
-//  Grid2::operator += --	addition + assignment
-//
-//  Inputs
-//	v	: 2D coordinates
-//
-//  Outputs
-//	reference to this object
-//
-Grid2 & Grid2::operator += ( const Grid2 & v )
-{
-    _element[ 0 ]	+= v._element[ 0 ];
-    _element[ 1 ]	+= v._element[ 1 ];
-    return *this;
-}
-
-
-//
-//  Grid2::operator -= --	subtraction + assignment
-//
-//  Inputs
-//	v	: 2D coordinates
-//
-//  Outputs
-//	reference to this object
-//
-Grid2 & Grid2::operator -= ( const Grid2 & v )
-{
-    _element[ 0 ]	-= v._element[ 0 ];
-    _element[ 1 ]	-= v._element[ 1 ];
-    return *this;
-}
-
-
-//
-//  Grid2::operator -= --	scalar product + assignment
-//
-//  Inputs
-//	d	: scalar value
-//
-//  Outputs
-//	reference to this object
-//
-Grid2 & Grid2::operator *= ( const int d )
-{
-    _element[ 0 ]	*= d;
-    _element[ 1 ]	*= d;
-    return *this;
-}
-
-
-//
-//  Grid2::operator [] --	reference to an element
-//
-//  Inputs
-//	i	: index of the coordinate
-//
-//  Outputs
-//	the corresponding coordinate
-//
-const int & Grid2::operator [] ( int i ) const
-{
-#ifdef GRID2_INDEX_CHECK
-    const char theName[] = "Grid2::operator [] : ";
-    if ( ( i < 0 ) || ( i > 1 ) ) {
-	cerr << theName << " index = " << i << endl;
-	assert( ( 0 <= i ) && ( i <= 1 ) );
-    }
-#endif	// GRID2_INDEX_CHECK
-    return _element[ i ];
-}
-
-
-//
-//  Grid2::operator [] --	reference to an element
-//
-//  Inputs
-//	i	: index of the coordinate
-//
-//  Outputs
-//	the corresponding coordinate
-//
-int & Grid2::operator [] ( int i )
-{
-#ifdef GRID2_INDEX_CHECK
-    const char theName[] = "Grid2::operator [] : ";
-    if ( ( i < 0 ) || ( i > 1 ) ) {
-	cerr << theName << " index = " << i << endl;
-	assert( ( 0 <= i ) && ( i <= 1 ) );
-    }
-#endif	// GRID2_INDEX_CHECK
-    return _element[ i ];
-}
-
-
-//
-//  Grid2::set --	set all the coordinates
-//
-//  Inputs
-//	x, y	: x and y coordinates
-//
-//  Returns
-//	none
-//
-void Grid2::set( const int x, const int y )
-{
-    _element[ 0 ]	= x;
-    _element[ 1 ]	= y;
-}
-
-
-//------------------------------------------------------------------------------
-//	Friend functions
-//------------------------------------------------------------------------------
-
-//
-//  operator - --	sign change
-//
-//  Inputs
-//	a	: 2D coordinates
-//
-//  Outputs
-//	2D coordinates in the opposite direction
-//
-Grid2 operator - ( const Grid2 & a )
-{
-    return Grid2( -a._element[ 0 ], -a._element[ 1 ] );
-}
-
-
-//
-//  operator + --	addition
-//
-//  Inputs
-//	a, b	: 2D coordinates
-//
-//  Outputs
-//	addition of the two 2D coordinates
-//
-Grid2 operator + ( const Grid2 & a, const Grid2 & b )
-{
-    return Grid2( a._element[ 0 ] + b._element[ 0 ],
-		  a._element[ 1 ] + b._element[ 1 ] );
-}
-
-
-//
-//  operator - --	difference
-//
-//  Inputs
-//	a, b	: 2D coordinates
-//
-//  Outputs
-//	difference of the two 2D coordinates
-//
-Grid2 operator - ( const Grid2 & a, const Grid2 & b )
-{
-    return Grid2( a._element[ 0 ] - b._element[ 0 ],
-		  a._element[ 1 ] - b._element[ 1 ] );
-}
-
-
-//
-//  operator * --	scalar product
-//
-//  Inputs
-//	d	: scalar value
-//	a	: 2D coordinates
-//
-//  Outputs
-//	scalar product 
-//
-Grid2 operator * ( const int d, const Grid2 & a )
-{
-    return Grid2( d * a._element[ 0 ], d * a._element[ 1 ] );
-}
-
-
-//
-//  operator * --	inner product
-//
-//  Inputs
-//	a, b	: 2D coordinates
-//
-//  Outputs
-//	inner product
-//
-int operator * ( const Grid2 & a, const Grid2 & b )
-{
-    return ( a._element[ 0 ] * b._element[ 0 ] +
-	     a._element[ 1 ] * b._element[ 1 ] );
-}
-
-
-//
-//  operator == --	equivalence
-//
-//  Inputs
-//	a, b	: 2D coordinates
-//
-//  Outputs
-//	boolean value
-//
-int operator == ( const Grid2 & a, const Grid2 & b )
-{
-    return ( ( a._element[ 0 ] == b._element[ 0 ] ) &&
-	     ( a._element[ 1 ] == b._element[ 1 ] ) );
-}
-
-
-//
-//  operator < --	comparison (less than)
-//
-//  Inputs
-//	a, b	: 2D coordinates
-//
-//  Outputs
-//	boolean value
-//
-int operator < ( const Grid2 & a, const Grid2 & b )
-{
-    if ( a._element[ 0 ] < b._element[ 0 ] ) return true;
-    else if ( a._element[ 0 ] > b._element[ 0 ] ) return false;
-    else {
-	if ( a._element[ 1 ] < b._element[ 1 ] ) return true;
-	else if ( a._element[ 1 ] > b._element[ 1 ] ) return false;
-	else return false;
-    }
-}
-
-
-//
-//  operator > --	comparison (more than)
-//
-//  Inputs
-//	a, b	: 2D coordinates
-//
-//  Outputs
-//	boolean value
-//
-int operator > ( const Grid2 & a, const Grid2 & b )
-{
-    if ( a._element[ 0 ] > b._element[ 0 ] ) return true;
-    else if ( a._element[ 0 ] < b._element[ 0 ] ) return false;
-    else {
-	if ( a._element[ 1 ] > b._element[ 1 ] ) return true;
-	else if ( a._element[ 1 ] < b._element[ 1 ] ) return false;
-	else return false;
-    }
-}
-
-
-//------------------------------------------------------------------------------
-//	I/O functions
-//------------------------------------------------------------------------------
-
-//
-//  operator << --	output
-//
-//  Inputs
-//	s	: reference to output stream
-//	v	: 2D coordinates
-//
-//  Outputs
-//	reference to output stream
-//
-ostream & operator << ( ostream & stream, const Grid2 & obj )
-{
-    // set the output formatting
-    int width = 16;
-    // print out the elements
-    for ( int i = 0; i < 2; i++ ) {
-	stream << setw( width ) << obj._element[ i ];
-	if ( i != 1 ) stream << "\t";
-    }
-    stream << endl;
-
-    return stream;
-}
-
-
-//
-//  operator >> --	input
-//
-//  Inputs
-//	s	: reference to input stream
-//	v	: 2D coordinates
-//
-//  Outputs
-//	reference to input stream
-//
-istream & operator >> ( istream & stream, Grid2 & obj )
-{
-    // reading the elements
-    for ( int i = 0; i < 2; i++ )
-	stream >> obj._element[ i ];
-    return stream;
-}
-
-
-
-
Index: Base/src/Common.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//==============================================================================\r\n// Common.cc\r\n//\t: macro definitions common to this package\r\n//\r\n//==============================================================================\r\n\r\n#ifndef _Common_H               // begining of header file\r\n#define _Common_H               // notifying that this file is included\r\n\r\n#include <string>\r\n#include <iostream>\r\n#include <sstream>\r\n\r\n//------------------------------------------------------------------------------\r\n//\tMacro Switches\r\n//------------------------------------------------------------------------------\r\n//#define ENABLE_FACE_CONSTRAINTS\r\n\r\n//------------------------------------------------------------------------------\r\n//\tMacro definitions\r\n//------------------------------------------------------------------------------\r\n#ifndef TRUE\r\n#define TRUE\t\t\t(1)\r\n#endif\t// TRUE\r\n#ifndef FALSE\r\n#define FALSE\t\t\t(0)\r\n#endif\t// FALSE\r\n\r\n#define MAX_STR\t\t\t(256)\r\n\r\n#define SQRT2\t\t\t(1.414213562)\r\n#define TWOPI\t\t\t(2.0*M_PI)\r\n\r\n#ifndef INFINITY\r\n#define\tINFINITY\t\t(1.0e+8)\t\r\n#endif\t// INFINITY\r\n\r\n#ifndef MININUM_INTEGER\r\n#define MINIMUM_INTEGER (-2147483648)\r\n#endif\t// MINIMUM_INTEGER\r\n\r\n#ifndef MAXINUM_INTEGER\r\n#define MAXIMUM_INTEGER (2147483647)\r\n#endif\t// MAXIMUM_INTEGER\r\n\r\n#ifndef USER_EPS\r\n#define\tUSER_EPS\t\t(1.0e-8)\r\n#endif\t// USER_EPS\r\n\r\n#define MAX2( x, y )\t(( (x)<(y) )? (y) : (x) )\r\n#define MIN2( x, y )\t(( (x)>(y) )? (y) : (x) )\r\n#define ABS( x )\t(( (x)>0 )? (x) : (-(x)) )\r\n\r\n#define SQUARE( x )\t((x)*(x))\r\n\r\n#define FLIP( type, a, b )\t{ type temp = a; a = b; b = temp; }\r\n\r\n\r\n//#define DIM_OF_SPACE\t(2)\r\n#define NO_INDEX\t(-1)\r\n#define NO_UNSIGNED_ID\t(65536)\r\n\r\n#define BUFFER_SIZE\t(256)\r\n#define ORTHOGONAL_SECTOR (4)\r\n#define OCTILINEAR_SECTOR (8)\r\n\r\n#define DEFAULT_VERTEX_PRIORITY\t(-1.0)\r\n#define DEFAULT_EDGE_WEIGHT\t(1.0)\r\n\r\n#define INIT_VERTEX_LABEL\t(0)\r\n#define INIT_EDGE_LABEL\t\t(0)\r\n\r\n// Default sector is EAST\r\n#define DEFAULT_VERTEX_SECTOR\t(0)\r\n#define DEFAULT_VERTEX_ANGLE\t(0.0)\r\n\r\n#define SMOOTHING_COEFFICIENT\t(0.1)\r\n\r\n#define MAX_EDGE_LENGTH\t\t(20.0)\r\n\r\n#define ENDPOINT_REGION_WEIGHT\t(0.6)\r\n#define SHRINKAGE_RATIO\t\t(0.01)\r\n\r\n//#define DEFAULT_HEIGHT        (64)\r\n//#define DEFAULT_WIDTH (64)\r\n//#define DEFAULT_HEIGHT        (200)\r\n//#define DEFAULT_WIDTH (200)\r\n//#define DEFAULT_HEIGHT  (576)\r\n//#define DEFAULT_WIDTH   (768)\r\n//#define DEFAULT_HEIGHT        (768)\r\n//#define DEFAULT_WIDTH   (768)\r\n//#define DEFAULT_HEIGHT        (600)\r\n//#define DEFAULT_WIDTH (800)\r\n//#define DEFAULT_HEIGHT        (768)\r\n//#define DEFAULT_WIDTH (1024)\r\n//#define DEFAULT_HEIGHT        (1024)\r\n//#define DEFAULT_WIDTH (1280)\r\n//#define DEFAULT_HEIGHT        (720)\r\n//#define DEFAULT_WIDTH (1296)\r\n//#define DEFAULT_HEIGHT        (800)\r\n//#define DEFAULT_WIDTH (1440)\r\n\r\n// #define DEFAULT_HEIGHT        (1152) // <-\r\n// #define DEFAULT_WIDTH (1536) // <-\r\n#define DEFAULT_ASPECT\t\t(1.0)\r\n#define DEFAULT_SIDE\t\t(1.2)\r\n#define DEFAULT_GRIDSIZE\t(32)\r\n#define TOPBOTTOM_MARGIN\t(50)\r\n#define LEFTRIGHT_MARGIN\t(50)\r\n\r\n#define DEFAULT_TEXTURE_BLOCK_SIZE\t(64)\r\n#define TEXTURE_GRID_MARGIN\t\t(0)\r\n#define BORDER_GRID_MARGIN\t\t(1)\r\n\r\n#define ANGLE_SPAN_LIMIT\t((165.0/180.0)*M_PI)\r\n\r\n#define\tGAUGI_RADIUS\t\t(64.0)\r\n#define GAUGI_OFFSET\t\t( 8.0)\r\n#define GAUGI_ALPHA\t\t( 0.7)\r\n#define GAUGI_SLANT\t\t(75.0)\r\n#define GAUGI_NDIVS\t\t(  32)\r\n#define NUM_BORDERS\t\t   (8)\r\n\r\n#define USE_VERTEX_HOME\r\n#define DILATION_SIZE   (64)\r\n\r\n/*\r\n#define SECTOR_0\t(-150.0)\r\n#define SECTOR_1\t(-105.0)\r\n#define SECTOR_2\t( -75.0)\r\n#define SECTOR_3\t( -30.0)\r\n#define SECTOR_4\t(  30.0)\r\n#define SECTOR_5\t(  75.0)\r\n#define SECTOR_6\t( 105.0)\r\n#define SECTOR_7\t( 150.0)\r\n*/\r\n\r\n#define SECTOR_0\t(-157.5)\r\n#define SECTOR_1\t(-112.5)\r\n#define SECTOR_2\t( -67.5)\r\n#define SECTOR_3\t( -22.5)\r\n#define SECTOR_4\t(  22.5)\r\n#define SECTOR_5\t(  67.5)\r\n#define SECTOR_6\t( 112.5)\r\n#define SECTOR_7\t( 157.5)\r\n\r\n//#define MIN_DISTANCE    (0.0)\r\n//#define MIN_DISTANCE    (0.5)\r\n#define MIN_DISTANCE    (30.0)\r\n//#define MIN_DISTANCE    ( 1.0 * cos( M_PI/4.0 ) )\r\n\r\n#define MAGNIFICATION_RADIUS (100.0)\r\n//#define MAGNIFICATION_RADIUS (150.0)\r\n//#define MAGNIFICATION_THRESHOLD (3.0)\r\n#define RNG_SAMPLES     (25)\r\n\r\n#define OUTDISK_SMALL   (1.5)\r\n#define OUTDISK_LARGE   (2.6)\r\n#define DOI_MIN         (1.0)\r\n//#define DOI_MAX         (3.0)\r\n#define DOI_MAX         (4.0)\r\n//#define DOI_MAX         (5.0)\r\n//#define DOI_MAX         (8.0)\r\n\r\n#define TIMER_STEP      (100)\r\n#define MIN_VERTEX_DISTANCE (0.5)\r\n\r\nenum METROTYPE{ GEOGRAPHY, SMOOTH, OCTILINEAR };\r\nenum OPTTYPE{ LEAST_SQUARE, CONJUGATE_GRADIENT };\r\nenum GRAPHICSTYPE{ GRAPHICS_BASE, GRAPHICS_BALL, GRAPHICS_VERTEX, GRAPHICS_EDGE, GRAPHICS_POLYGON };\r\nenum LENSTYPE{ LENS_FISHEYE, LENS_CONTENTADAPTIVE };\r\nenum XMLTAGTYPE{ XMLTAGTYPE_DEFAULT, XMLTAGTYPE_M, XMLTAGTYPE_m, XMLTAGTYPE_c, XMLTAGTYPE_v, XMLTAGTYPE_h, XMLTAGTYPE_l, XMLTAGTYPE_z };\r\nenum DATATYPE{ DATA_SVG, DATA_GRAPHML };\r\n\r\n//------------------------------------------------------------------------------\r\n//      Indexes\r\n//------------------------------------------------------------------------------\r\n//extern enum segmentClass       segment_index;\r\n\r\n//------------------------------------------------------------------------------\r\n//      Variables\r\n//------------------------------------------------------------------------------\r\nextern double           routing_margin;\r\nextern double           label_margin;\r\nextern int              window_height;\r\nextern int              window_width;\r\nextern int\t\t        grid_size;\r\nextern int      \t    min_grid_size;\r\nextern int              magnified_radius;\r\nextern int              rng_samples;\r\nextern int              doi_max;\r\nextern int              doi_min;\r\n\r\nnamespace KeiRo {\r\nnamespace Base {\r\n\t\r\n\t//------------------------------------------------------------------------------\r\n\t//\tDefining Macros\r\n\t//------------------------------------------------------------------------------\r\n\t\r\n\t//------------------------------------------------------------------------------\r\n\t//\tDefining Classes\r\n\t//------------------------------------------------------------------------------\r\n\tclass Common{\r\n\t\r\n\tprivate:\r\n\t\t\r\n\t\tstatic double _mainwidget_width;\r\n\t\tstatic double _mainwidget_height;\r\n\t\tstatic double _maincontent_width;           // could be larger than mainwidget\r\n\t\tstatic double _maincontent_height;          // could be larger than mainwidget\r\n\t\tstatic double _dockwidget_width;\r\n\t\tstatic double _menubar_height;\r\n\t\tstatic unsigned int _font_size;\r\n\t\tstatic std::string _batch_str;\r\n\t\t\r\n\tprotected:\r\n\t\r\n\tpublic:\r\n\t\t\r\n\t\ttypedef std::pair< int, int >\t                    IDPair;\r\n\t\ttypedef std::pair< unsigned int, unsigned int >\t    UIDPair;\r\n\t\t\r\n\t\t//------------------------------------------------------------------------------\r\n\t\t//\tConstructors & Destructors\r\n\t\t//------------------------------------------------------------------------------\r\n\t\t// default constructor\r\n\t\tCommon( void );\r\n\t\t// copy constructor\r\n\t\tCommon( const Common & c ) {}\r\n\t\t// destructor\r\n\t\t~Common( void ){}\r\n\t\t\r\n\t\t//------------------------------------------------------------------------------\r\n\t\t//\tAssignment operators\r\n\t\t//------------------------------------------------------------------------------\r\n\t\t\r\n\t\t//------------------------------------------------------------------------------\r\n\t\t//\tReference to elements\r\n\t\t//------------------------------------------------------------------------------\r\n\t\tstatic const double &getMainwidgetWidth( void );\r\n\t\t\r\n\t\tstatic void setMainwidgetWidth( double _mainwidgetWidth );\r\n\t\t\r\n\t\tstatic double &  mainwidgetWidth( void );\r\n\t\t\r\n\t\tstatic const double &getMainwidgetHeight( void );\r\n\t\t\r\n\t\tstatic void setMainwidgetHeight( double _mainwidgetHeight );\r\n\r\n\t\tstatic double &  mainwidgetHeight( void );\r\n\t\t\r\n\t\tstatic const double &getMaincontentWidth( void );\r\n\t\t\r\n\t\tstatic void setMaincontentWidth( double _maincontentWidth );\r\n\t\t\r\n\t\tstatic double &  maincontentWidth( void );\r\n\t\t\r\n\t\tstatic const double &getMaincontentHeight( void );\r\n\t\t\r\n\t\tstatic void setMaincontentHeight( double _maincontentHeight );\r\n\t\t\r\n\t\tstatic double &  maincontentHeight( void );\r\n\t\t\r\n\t\tstatic const double getDockWidgetWidth( void );\r\n\t\t\r\n\t\tstatic void setDockWidgetWidth( double _dockwidgetWidth );\r\n\t\t\r\n\t\tstatic const double getMenubarHeight( void );\r\n\t\t\r\n\t\tstatic void setMenubarHeight( double _menubarHeight );\r\n\t\t\r\n\t\tstatic const unsigned int getFontSize( void );\r\n\t\t\r\n\t\tstatic void setFontSize( unsigned int fontSize );\r\n\t\t\r\n\t\tstatic const std::string &getBatchStr( void );\r\n\t\t\r\n\t\tstatic void setBatchStr( const std::string &batchStr );\r\n\t\t\r\n\t\t//------------------------------------------------------------------------------\r\n\t\t//\tSpecial functions\r\n\t\t//------------------------------------------------------------------------------\r\n\t\tstatic double stringToDouble( std::string str );\r\n\t\t\r\n\t\ttemplate <typename T>\r\n\t\tstatic std::string to_string_with_precision( const T a_value, const int n = 20 )\r\n\t\t{\r\n\t\t\tstd::ostringstream out;\r\n\t\t\tout.precision(n);\r\n\t\t\tout << std::fixed << a_value;\r\n\t\t\treturn out.str();\r\n\t\t}\r\n\t\t\r\n\t\t//------------------------------------------------------------------------------\r\n\t\t//\tFriend functions\r\n\t\t//------------------------------------------------------------------------------\r\n\t\t\r\n\t\t//------------------------------------------------------------------------------\r\n\t\t//\tI/O functions\r\n\t\t//------------------------------------------------------------------------------\r\n\t\t// output\r\n\t\tfriend std::ostream &\toperator << ( std::ostream & s, const Common & v );\r\n\t\t// input\r\n\t\tfriend std::istream &\toperator >> ( std::istream & s, Common & v );\r\n\t\t// class name\r\n\t\tvirtual const char * className( void ) const { return \"Common\"; }\r\n\t\t\r\n\t};\r\n\t\r\n} // namespace Base\r\n} // namespace KeiRo\r\n\r\n#endif // _Common_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Base/src/Common.h b/Base/src/Common.h
--- a/Base/src/Common.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Base/src/Common.h	(date 1729410605340)
@@ -1,314 +1,0 @@
-//==============================================================================
-// Common.cc
-//	: macro definitions common to this package
-//
-//==============================================================================
-
-#ifndef _Common_H               // begining of header file
-#define _Common_H               // notifying that this file is included
-
-#include <string>
-#include <iostream>
-#include <sstream>
-
-//------------------------------------------------------------------------------
-//	Macro Switches
-//------------------------------------------------------------------------------
-//#define ENABLE_FACE_CONSTRAINTS
-
-//------------------------------------------------------------------------------
-//	Macro definitions
-//------------------------------------------------------------------------------
-#ifndef TRUE
-#define TRUE			(1)
-#endif	// TRUE
-#ifndef FALSE
-#define FALSE			(0)
-#endif	// FALSE
-
-#define MAX_STR			(256)
-
-#define SQRT2			(1.414213562)
-#define TWOPI			(2.0*M_PI)
-
-#ifndef INFINITY
-#define	INFINITY		(1.0e+8)	
-#endif	// INFINITY
-
-#ifndef MININUM_INTEGER
-#define MINIMUM_INTEGER (-2147483648)
-#endif	// MINIMUM_INTEGER
-
-#ifndef MAXINUM_INTEGER
-#define MAXIMUM_INTEGER (2147483647)
-#endif	// MAXIMUM_INTEGER
-
-#ifndef USER_EPS
-#define	USER_EPS		(1.0e-8)
-#endif	// USER_EPS
-
-#define MAX2( x, y )	(( (x)<(y) )? (y) : (x) )
-#define MIN2( x, y )	(( (x)>(y) )? (y) : (x) )
-#define ABS( x )	(( (x)>0 )? (x) : (-(x)) )
-
-#define SQUARE( x )	((x)*(x))
-
-#define FLIP( type, a, b )	{ type temp = a; a = b; b = temp; }
-
-
-//#define DIM_OF_SPACE	(2)
-#define NO_INDEX	(-1)
-#define NO_UNSIGNED_ID	(65536)
-
-#define BUFFER_SIZE	(256)
-#define ORTHOGONAL_SECTOR (4)
-#define OCTILINEAR_SECTOR (8)
-
-#define DEFAULT_VERTEX_PRIORITY	(-1.0)
-#define DEFAULT_EDGE_WEIGHT	(1.0)
-
-#define INIT_VERTEX_LABEL	(0)
-#define INIT_EDGE_LABEL		(0)
-
-// Default sector is EAST
-#define DEFAULT_VERTEX_SECTOR	(0)
-#define DEFAULT_VERTEX_ANGLE	(0.0)
-
-#define SMOOTHING_COEFFICIENT	(0.1)
-
-#define MAX_EDGE_LENGTH		(20.0)
-
-#define ENDPOINT_REGION_WEIGHT	(0.6)
-#define SHRINKAGE_RATIO		(0.01)
-
-//#define DEFAULT_HEIGHT        (64)
-//#define DEFAULT_WIDTH (64)
-//#define DEFAULT_HEIGHT        (200)
-//#define DEFAULT_WIDTH (200)
-//#define DEFAULT_HEIGHT  (576)
-//#define DEFAULT_WIDTH   (768)
-//#define DEFAULT_HEIGHT        (768)
-//#define DEFAULT_WIDTH   (768)
-//#define DEFAULT_HEIGHT        (600)
-//#define DEFAULT_WIDTH (800)
-//#define DEFAULT_HEIGHT        (768)
-//#define DEFAULT_WIDTH (1024)
-//#define DEFAULT_HEIGHT        (1024)
-//#define DEFAULT_WIDTH (1280)
-//#define DEFAULT_HEIGHT        (720)
-//#define DEFAULT_WIDTH (1296)
-//#define DEFAULT_HEIGHT        (800)
-//#define DEFAULT_WIDTH (1440)
-
-// #define DEFAULT_HEIGHT        (1152) // <-
-// #define DEFAULT_WIDTH (1536) // <-
-#define DEFAULT_ASPECT		(1.0)
-#define DEFAULT_SIDE		(1.2)
-#define DEFAULT_GRIDSIZE	(32)
-#define TOPBOTTOM_MARGIN	(50)
-#define LEFTRIGHT_MARGIN	(50)
-
-#define DEFAULT_TEXTURE_BLOCK_SIZE	(64)
-#define TEXTURE_GRID_MARGIN		(0)
-#define BORDER_GRID_MARGIN		(1)
-
-#define ANGLE_SPAN_LIMIT	((165.0/180.0)*M_PI)
-
-#define	GAUGI_RADIUS		(64.0)
-#define GAUGI_OFFSET		( 8.0)
-#define GAUGI_ALPHA		( 0.7)
-#define GAUGI_SLANT		(75.0)
-#define GAUGI_NDIVS		(  32)
-#define NUM_BORDERS		   (8)
-
-#define USE_VERTEX_HOME
-#define DILATION_SIZE   (64)
-
-/*
-#define SECTOR_0	(-150.0)
-#define SECTOR_1	(-105.0)
-#define SECTOR_2	( -75.0)
-#define SECTOR_3	( -30.0)
-#define SECTOR_4	(  30.0)
-#define SECTOR_5	(  75.0)
-#define SECTOR_6	( 105.0)
-#define SECTOR_7	( 150.0)
-*/
-
-#define SECTOR_0	(-157.5)
-#define SECTOR_1	(-112.5)
-#define SECTOR_2	( -67.5)
-#define SECTOR_3	( -22.5)
-#define SECTOR_4	(  22.5)
-#define SECTOR_5	(  67.5)
-#define SECTOR_6	( 112.5)
-#define SECTOR_7	( 157.5)
-
-//#define MIN_DISTANCE    (0.0)
-//#define MIN_DISTANCE    (0.5)
-#define MIN_DISTANCE    (30.0)
-//#define MIN_DISTANCE    ( 1.0 * cos( M_PI/4.0 ) )
-
-#define MAGNIFICATION_RADIUS (100.0)
-//#define MAGNIFICATION_RADIUS (150.0)
-//#define MAGNIFICATION_THRESHOLD (3.0)
-#define RNG_SAMPLES     (25)
-
-#define OUTDISK_SMALL   (1.5)
-#define OUTDISK_LARGE   (2.6)
-#define DOI_MIN         (1.0)
-//#define DOI_MAX         (3.0)
-#define DOI_MAX         (4.0)
-//#define DOI_MAX         (5.0)
-//#define DOI_MAX         (8.0)
-
-#define TIMER_STEP      (100)
-#define MIN_VERTEX_DISTANCE (0.5)
-
-enum METROTYPE{ GEOGRAPHY, SMOOTH, OCTILINEAR };
-enum OPTTYPE{ LEAST_SQUARE, CONJUGATE_GRADIENT };
-enum GRAPHICSTYPE{ GRAPHICS_BASE, GRAPHICS_BALL, GRAPHICS_VERTEX, GRAPHICS_EDGE, GRAPHICS_POLYGON };
-enum LENSTYPE{ LENS_FISHEYE, LENS_CONTENTADAPTIVE };
-enum XMLTAGTYPE{ XMLTAGTYPE_DEFAULT, XMLTAGTYPE_M, XMLTAGTYPE_m, XMLTAGTYPE_c, XMLTAGTYPE_v, XMLTAGTYPE_h, XMLTAGTYPE_l, XMLTAGTYPE_z };
-enum DATATYPE{ DATA_SVG, DATA_GRAPHML };
-
-//------------------------------------------------------------------------------
-//      Indexes
-//------------------------------------------------------------------------------
-//extern enum segmentClass       segment_index;
-
-//------------------------------------------------------------------------------
-//      Variables
-//------------------------------------------------------------------------------
-extern double           routing_margin;
-extern double           label_margin;
-extern int              window_height;
-extern int              window_width;
-extern int		        grid_size;
-extern int      	    min_grid_size;
-extern int              magnified_radius;
-extern int              rng_samples;
-extern int              doi_max;
-extern int              doi_min;
-
-namespace KeiRo {
-namespace Base {
-	
-	//------------------------------------------------------------------------------
-	//	Defining Macros
-	//------------------------------------------------------------------------------
-	
-	//------------------------------------------------------------------------------
-	//	Defining Classes
-	//------------------------------------------------------------------------------
-	class Common{
-	
-	private:
-		
-		static double _mainwidget_width;
-		static double _mainwidget_height;
-		static double _maincontent_width;           // could be larger than mainwidget
-		static double _maincontent_height;          // could be larger than mainwidget
-		static double _dockwidget_width;
-		static double _menubar_height;
-		static unsigned int _font_size;
-		static std::string _batch_str;
-		
-	protected:
-	
-	public:
-		
-		typedef std::pair< int, int >	                    IDPair;
-		typedef std::pair< unsigned int, unsigned int >	    UIDPair;
-		
-		//------------------------------------------------------------------------------
-		//	Constructors & Destructors
-		//------------------------------------------------------------------------------
-		// default constructor
-		Common( void );
-		// copy constructor
-		Common( const Common & c ) {}
-		// destructor
-		~Common( void ){}
-		
-		//------------------------------------------------------------------------------
-		//	Assignment operators
-		//------------------------------------------------------------------------------
-		
-		//------------------------------------------------------------------------------
-		//	Reference to elements
-		//------------------------------------------------------------------------------
-		static const double &getMainwidgetWidth( void );
-		
-		static void setMainwidgetWidth( double _mainwidgetWidth );
-		
-		static double &  mainwidgetWidth( void );
-		
-		static const double &getMainwidgetHeight( void );
-		
-		static void setMainwidgetHeight( double _mainwidgetHeight );
-
-		static double &  mainwidgetHeight( void );
-		
-		static const double &getMaincontentWidth( void );
-		
-		static void setMaincontentWidth( double _maincontentWidth );
-		
-		static double &  maincontentWidth( void );
-		
-		static const double &getMaincontentHeight( void );
-		
-		static void setMaincontentHeight( double _maincontentHeight );
-		
-		static double &  maincontentHeight( void );
-		
-		static const double getDockWidgetWidth( void );
-		
-		static void setDockWidgetWidth( double _dockwidgetWidth );
-		
-		static const double getMenubarHeight( void );
-		
-		static void setMenubarHeight( double _menubarHeight );
-		
-		static const unsigned int getFontSize( void );
-		
-		static void setFontSize( unsigned int fontSize );
-		
-		static const std::string &getBatchStr( void );
-		
-		static void setBatchStr( const std::string &batchStr );
-		
-		//------------------------------------------------------------------------------
-		//	Special functions
-		//------------------------------------------------------------------------------
-		static double stringToDouble( std::string str );
-		
-		template <typename T>
-		static std::string to_string_with_precision( const T a_value, const int n = 20 )
-		{
-			std::ostringstream out;
-			out.precision(n);
-			out << std::fixed << a_value;
-			return out.str();
-		}
-		
-		//------------------------------------------------------------------------------
-		//	Friend functions
-		//------------------------------------------------------------------------------
-		
-		//------------------------------------------------------------------------------
-		//	I/O functions
-		//------------------------------------------------------------------------------
-		// output
-		friend std::ostream &	operator << ( std::ostream & s, const Common & v );
-		// input
-		friend std::istream &	operator >> ( std::istream & s, Common & v );
-		// class name
-		virtual const char * className( void ) const { return "Common"; }
-		
-	};
-	
-} // namespace Base
-} // namespace KeiRo
-
-#endif // _Common_H
Index: Composite/src/CompressionGrid.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// Compression.h\r\n//\t: header file for Compression\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Mon Mar 16 07:58:23 2020\r\n//\r\n//******************************************************************************\r\n\r\n#ifndef\t_CompressionGrid_H\r\n#define _CompressionGrid_H\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <cmath>\r\n#include <iostream>\r\n#include <iomanip>\r\n\r\nusing namespace std;\r\n\r\n#include <qapplication.h>\r\n\r\n//#include \"Config.h\"\r\n#include \"Polygon2.h\"\r\n#include \"Line2.h\"\r\n#include \"Grid2.h\"\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Macros\r\n//------------------------------------------------------------------------------\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Classes\r\n//------------------------------------------------------------------------------\r\nclass CompressionGrid {\r\n\r\nprivate:\r\n\r\n    double                                              _min_point_distance;\r\n\r\n    vector< KeiRo::Base::Coord2 >                       _fixedSamples;\r\n    vector< KeiRo::Base::Coord2 >                       _samples;\r\n\r\n    vector< KeiRo::Base::Polygon2 >                     *_polygonVecPtr;\r\n    vector< KeiRo::Base::Line2 >                        *_polylineVecPtr;\r\n    Grid2                                               *_gridPtr;\r\n\r\n    bool        _closeToSamples( KeiRo::Base::Coord2 &coord, unsigned int &index );\r\n\r\nprotected:\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tSpecial functions\r\n    //------------------------------------------------------------------------------\r\n    void\t    _init( Grid2 * __gridPtr,\r\n                       vector< KeiRo::Base::Polygon2 > *__polygonVecPtr,\r\n                       vector< KeiRo::Base::Line2 > *__polylineVecPtr );\r\n    void\t    _clear( void );\r\n\r\npublic:\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tConstructors\r\n    //------------------------------------------------------------------------------\r\n    // default constructor\r\n    CompressionGrid( void );\r\n\t// copy constructor\r\n\tCompressionGrid( const CompressionGrid & v );\r\n    // destructor\r\n    virtual ~CompressionGrid( void );\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tAssignment operators\r\n    //------------------------------------------------------------------------------\r\n\tCompressionGrid &\t\toperator = ( const CompressionGrid & v );\r\n\t\r\n    //------------------------------------------------------------------------------\r\n    //\tReference to elements\r\n    //------------------------------------------------------------------------------\r\n    vector< KeiRo::Base::Coord2 > &              fixedSamples( void )\t\t{ return _fixedSamples; }\r\n    const vector< KeiRo::Base::Coord2 > &\t    fixedSamples( void ) const  { return _fixedSamples; }\r\n\r\n    vector< KeiRo::Base::Coord2 > &              samples( void )\t\t        { return _samples; }\r\n    const vector< KeiRo::Base::Coord2 > &\t    samples( void ) const \t    { return _samples; }\r\n\r\n    vector< KeiRo::Base::Polygon2 > *\t        polygonVecPtr( void ) \t        { return _polygonVecPtr; }\r\n    const vector< KeiRo::Base::Polygon2 > *\tpolygonVecPtr( void ) const\t{ return _polygonVecPtr; }\r\n    vector< KeiRo::Base::Line2 > *\t            polylineVecPtr( void ) \t    { return _polylineVecPtr; }\r\n    const vector< KeiRo::Base::Line2 > *\t    polylineVecPtr( void ) const\t{ return _polylineVecPtr; }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tSpecial functions\r\n    //------------------------------------------------------------------------------\r\n    void init( Grid2 * __gridPtr,\r\n               vector< KeiRo::Base::Polygon2 > *__polygonVecPtr,\r\n               vector< KeiRo::Base::Line2 > *__polylineVecPtr ){\r\n        _init( __gridPtr, __polygonVecPtr, __polylineVecPtr );\r\n    }\r\n    void clear( void ){\r\n        _clear();\r\n    }\r\n    void createCompressedSamples( void );\r\n    void createCompressedJoints( void );\r\n    void createCompressedGridJoints( void );\r\n    void createCompression( bool isOn );\r\n\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tFriend functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tI/O functions\r\n    //------------------------------------------------------------------------------\r\n    // output\r\n    friend ostream &\toperator << ( ostream & s, const CompressionGrid & v );\r\n    // input\r\n    friend istream &\toperator >> ( istream & s, CompressionGrid & v );\r\n    // class name\r\n    virtual const char * className( void ) const { return \"Compression\"; }\r\n\r\n};\r\n\r\n\r\n#endif // _CompressionGrid_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Composite/src/CompressionGrid.h b/Composite/src/CompressionGrid.h
--- a/Composite/src/CompressionGrid.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Composite/src/CompressionGrid.h	(date 1729410605360)
@@ -1,128 +1,0 @@
-//******************************************************************************
-// Compression.h
-//	: header file for Compression
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Mon Mar 16 07:58:23 2020
-//
-//******************************************************************************
-
-#ifndef	_CompressionGrid_H
-#define _CompressionGrid_H
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <cmath>
-#include <iostream>
-#include <iomanip>
-
-using namespace std;
-
-#include <qapplication.h>
-
-//#include "Config.h"
-#include "Polygon2.h"
-#include "Line2.h"
-#include "Grid2.h"
-
-//------------------------------------------------------------------------------
-//	Defining Macros
-//------------------------------------------------------------------------------
-
-//------------------------------------------------------------------------------
-//	Defining Classes
-//------------------------------------------------------------------------------
-class CompressionGrid {
-
-private:
-
-    double                                              _min_point_distance;
-
-    vector< KeiRo::Base::Coord2 >                       _fixedSamples;
-    vector< KeiRo::Base::Coord2 >                       _samples;
-
-    vector< KeiRo::Base::Polygon2 >                     *_polygonVecPtr;
-    vector< KeiRo::Base::Line2 >                        *_polylineVecPtr;
-    Grid2                                               *_gridPtr;
-
-    bool        _closeToSamples( KeiRo::Base::Coord2 &coord, unsigned int &index );
-
-protected:
-
-    //------------------------------------------------------------------------------
-    //	Special functions
-    //------------------------------------------------------------------------------
-    void	    _init( Grid2 * __gridPtr,
-                       vector< KeiRo::Base::Polygon2 > *__polygonVecPtr,
-                       vector< KeiRo::Base::Line2 > *__polylineVecPtr );
-    void	    _clear( void );
-
-public:
-
-    //------------------------------------------------------------------------------
-    //	Constructors
-    //------------------------------------------------------------------------------
-    // default constructor
-    CompressionGrid( void );
-	// copy constructor
-	CompressionGrid( const CompressionGrid & v );
-    // destructor
-    virtual ~CompressionGrid( void );
-
-    //------------------------------------------------------------------------------
-    //	Assignment operators
-    //------------------------------------------------------------------------------
-	CompressionGrid &		operator = ( const CompressionGrid & v );
-	
-    //------------------------------------------------------------------------------
-    //	Reference to elements
-    //------------------------------------------------------------------------------
-    vector< KeiRo::Base::Coord2 > &              fixedSamples( void )		{ return _fixedSamples; }
-    const vector< KeiRo::Base::Coord2 > &	    fixedSamples( void ) const  { return _fixedSamples; }
-
-    vector< KeiRo::Base::Coord2 > &              samples( void )		        { return _samples; }
-    const vector< KeiRo::Base::Coord2 > &	    samples( void ) const 	    { return _samples; }
-
-    vector< KeiRo::Base::Polygon2 > *	        polygonVecPtr( void ) 	        { return _polygonVecPtr; }
-    const vector< KeiRo::Base::Polygon2 > *	polygonVecPtr( void ) const	{ return _polygonVecPtr; }
-    vector< KeiRo::Base::Line2 > *	            polylineVecPtr( void ) 	    { return _polylineVecPtr; }
-    const vector< KeiRo::Base::Line2 > *	    polylineVecPtr( void ) const	{ return _polylineVecPtr; }
-
-    //------------------------------------------------------------------------------
-    //	Special functions
-    //------------------------------------------------------------------------------
-    void init( Grid2 * __gridPtr,
-               vector< KeiRo::Base::Polygon2 > *__polygonVecPtr,
-               vector< KeiRo::Base::Line2 > *__polylineVecPtr ){
-        _init( __gridPtr, __polygonVecPtr, __polylineVecPtr );
-    }
-    void clear( void ){
-        _clear();
-    }
-    void createCompressedSamples( void );
-    void createCompressedJoints( void );
-    void createCompressedGridJoints( void );
-    void createCompression( bool isOn );
-
-
-    //------------------------------------------------------------------------------
-    //	Friend functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	I/O functions
-    //------------------------------------------------------------------------------
-    // output
-    friend ostream &	operator << ( ostream & s, const CompressionGrid & v );
-    // input
-    friend istream &	operator >> ( istream & s, CompressionGrid & v );
-    // class name
-    virtual const char * className( void ) const { return "Compression"; }
-
-};
-
-
-#endif // _CompressionGrid_H
Index: Composite/src/Compression.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// Compression.h\r\n//\t: header file for Compression\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Mon Sep 06 20:58:23 2021\r\n//\r\n//******************************************************************************\r\n\r\n#ifndef\t_Compression_H\r\n#define _Compression_H\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <cmath>\r\n#include <iostream>\r\n#include <iomanip>\r\n\r\nusing namespace std;\r\n\r\n#include \"BaseUndirectedGraph.h\"\r\n#include \"Edge2.h\"\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Macros\r\n//------------------------------------------------------------------------------\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Classes\r\n//------------------------------------------------------------------------------\r\nclass Compression {\r\n\r\nprivate:\r\n\r\n    Graph::BaseUndirectedGraph                  _graph;\r\n    bool        _closeToSamplesInt( KeiRo::Base::Coord2 coordS,\r\n\t\t\t\t\t\t\t\t\tKeiRo::Base::Coord2 coordT );\r\n\r\nprotected:\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tSpecial functions\r\n    //------------------------------------------------------------------------------\r\n    void\t    _init( void );\r\n    void\t    _clear( void );\r\n\r\npublic:\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tConstructors\r\n    //------------------------------------------------------------------------------\r\n    // default constructor\r\n    Compression( void );\r\n\t// copy constructor\r\n\tCompression( const Compression & v );\r\n    // destructor\r\n    virtual ~Compression( void );\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tAssignment operators\r\n    //------------------------------------------------------------------------------\r\n\tCompression &\t\toperator = ( const Compression & v );\r\n\t\r\n    //------------------------------------------------------------------------------\r\n    //\tReference to elements\r\n    //------------------------------------------------------------------------------\r\n    \r\n    Graph::BaseUndirectedGraph &                graph( void )\t\t        { return _graph; }\r\n    const Graph::BaseUndirectedGraph &\t        graph( void ) const \t    { return _graph; }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tSpecial functions\r\n    //------------------------------------------------------------------------------\r\n    void init( void ){\r\n        _init();\r\n    }\r\n\r\n    void clear( void ){\r\n        _clear();\r\n    }\r\n\r\n    bool findVertex( KeiRo::Base::Coord2 coord, unsigned int sortedID, unsigned int &index );\r\n    unsigned int addVertex( KeiRo::Base::Coord2 coord, unsigned int level, unsigned int sortedID );\r\n    void addEdge( unsigned int idS, unsigned int idT, vector< unsigned int > &intermediateVec,\r\n\t\t\t\t  unsigned int sortedID, bool isCompressed );\r\n    void addBridgeEdge( unsigned int idS, unsigned int idT );\r\n    \r\n    //------------------------------------------------------------------------------\r\n    //\tFriend functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tI/O functions\r\n    //------------------------------------------------------------------------------\r\n    // output\r\n    friend ostream &\toperator << ( ostream & s, const Compression & v );\r\n    // input\r\n    friend istream &\toperator >> ( istream & s, Compression & v );\r\n    // class name\r\n    virtual const char * className( void ) const { return \"Compression\"; }\r\n\r\n};\r\n\r\n\r\n#endif // _Compression_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Composite/src/Compression.h b/Composite/src/Compression.h
--- a/Composite/src/Compression.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Composite/src/Compression.h	(date 1729410605370)
@@ -1,108 +1,0 @@
-//******************************************************************************
-// Compression.h
-//	: header file for Compression
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Mon Sep 06 20:58:23 2021
-//
-//******************************************************************************
-
-#ifndef	_Compression_H
-#define _Compression_H
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <cmath>
-#include <iostream>
-#include <iomanip>
-
-using namespace std;
-
-#include "BaseUndirectedGraph.h"
-#include "Edge2.h"
-
-//------------------------------------------------------------------------------
-//	Defining Macros
-//------------------------------------------------------------------------------
-
-//------------------------------------------------------------------------------
-//	Defining Classes
-//------------------------------------------------------------------------------
-class Compression {
-
-private:
-
-    Graph::BaseUndirectedGraph                  _graph;
-    bool        _closeToSamplesInt( KeiRo::Base::Coord2 coordS,
-									KeiRo::Base::Coord2 coordT );
-
-protected:
-
-    //------------------------------------------------------------------------------
-    //	Special functions
-    //------------------------------------------------------------------------------
-    void	    _init( void );
-    void	    _clear( void );
-
-public:
-
-    //------------------------------------------------------------------------------
-    //	Constructors
-    //------------------------------------------------------------------------------
-    // default constructor
-    Compression( void );
-	// copy constructor
-	Compression( const Compression & v );
-    // destructor
-    virtual ~Compression( void );
-
-    //------------------------------------------------------------------------------
-    //	Assignment operators
-    //------------------------------------------------------------------------------
-	Compression &		operator = ( const Compression & v );
-	
-    //------------------------------------------------------------------------------
-    //	Reference to elements
-    //------------------------------------------------------------------------------
-    
-    Graph::BaseUndirectedGraph &                graph( void )		        { return _graph; }
-    const Graph::BaseUndirectedGraph &	        graph( void ) const 	    { return _graph; }
-
-    //------------------------------------------------------------------------------
-    //	Special functions
-    //------------------------------------------------------------------------------
-    void init( void ){
-        _init();
-    }
-
-    void clear( void ){
-        _clear();
-    }
-
-    bool findVertex( KeiRo::Base::Coord2 coord, unsigned int sortedID, unsigned int &index );
-    unsigned int addVertex( KeiRo::Base::Coord2 coord, unsigned int level, unsigned int sortedID );
-    void addEdge( unsigned int idS, unsigned int idT, vector< unsigned int > &intermediateVec,
-				  unsigned int sortedID, bool isCompressed );
-    void addBridgeEdge( unsigned int idS, unsigned int idT );
-    
-    //------------------------------------------------------------------------------
-    //	Friend functions
-    //------------------------------------------------------------------------------
-
-    //------------------------------------------------------------------------------
-    //	I/O functions
-    //------------------------------------------------------------------------------
-    // output
-    friend ostream &	operator << ( ostream & s, const Compression & v );
-    // input
-    friend istream &	operator >> ( istream & s, Compression & v );
-    // class name
-    virtual const char * className( void ) const { return "Compression"; }
-
-};
-
-
-#endif // _Compression_H
Index: Composite/src/Contour2.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// Contour2.h\r\n//\t: header file for Contour2\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Jun 19 02:36:37 2018\r\n//\r\n//******************************************************************************\r\n\r\n#ifndef _Contour2_H\r\n#define _Contour2_H\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <vector>\r\n#include <cmath>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\n#include \"Polygon2.h\"\r\n#include \"BaseUndirectedGraph.h\"\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Macros\r\n//------------------------------------------------------------------------------\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Classes\r\n//------------------------------------------------------------------------------\r\n\r\nclass Contour2 {\r\n\r\nprotected:\r\n\t\r\n\tunsigned int _id;\r\n\tKeiRo::Base::Polygon2 _contour;                  // contour elements\r\n\tvector< KeiRo::Base::Polygon2 > _polygons;       // subcell of the contour\r\n\tKeiRo::Base::Polygon2 _fineContour;              // curvy simpleContour\r\n\t\r\n\tvirtual void _init( unsigned int __id, vector< KeiRo::Base::Polygon2 > __polygons );\r\n\t\r\n\tvoid _clear( void );\r\n\t\r\n\tvoid _initChaikinCurve( double unit );\r\n\r\npublic:\r\n\r\n//------------------------------------------------------------------------------\r\n//\tConstructors\r\n//------------------------------------------------------------------------------\r\n\tContour2();                // constructor (default)\r\n\tContour2( vector< KeiRo::Base::Polygon2 > __polygons );\r\n\t\r\n\t// coordinates as input\r\n\tContour2( const Contour2 &v );        // copy constructor\r\n\tvirtual ~Contour2() {}        // destructor\r\n\r\n//------------------------------------------------------------------------------\r\n//\tAssignment operators\r\n//------------------------------------------------------------------------------\r\n\tContour2 &operator=( const Contour2 &p );\r\n\t// assignment\r\n\r\n//------------------------------------------------------------------------------\r\n//\tReference to elements\r\n//------------------------------------------------------------------------------\r\n\tvoid init( unsigned int __id, vector< KeiRo::Base::Polygon2 > __polygons ) { _init( __id, __polygons ); }\r\n\t\r\n\tvoid clear( void ) { _clear(); }\r\n\t\r\n\t// id\r\n\tunsigned int &id( void ) { return _id; }\r\n\t\r\n\tconst unsigned int &id( void ) const { return _id; }\r\n\t\r\n\t// simpleContour\r\n\tKeiRo::Base::Polygon2 &contour( void ) { return _contour; }\r\n\t\r\n\tconst KeiRo::Base::Polygon2 &contour( void ) const { return _contour; }\r\n\t\r\n\t// a vector of polygons\r\n\tvector< KeiRo::Base::Polygon2 > &polygons( void ) { return _polygons; }\r\n\t\r\n\tconst vector< KeiRo::Base::Polygon2 > &polygons( void ) const { return _polygons; }\r\n\t\r\n\t// fine simpleContour\r\n\tKeiRo::Base::Polygon2 &fineContour( void ) { return _fineContour; }\r\n\t\r\n\tconst KeiRo::Base::Polygon2 &fineContour( void ) const { return _fineContour; }\r\n\r\n//------------------------------------------------------------------------------\r\n//\tSpecial functions\r\n//------------------------------------------------------------------------------\r\n\tbool findVertexInComplex( const KeiRo::Base::Coord2 &coord, Graph::BaseUndirectedGraph &complex,\r\n\t                          Graph::BaseUndirectedGraph::vertex_descriptor &target );\r\n\t\r\n\tvoid createContour( void );\r\n\t\r\n\tbool inContour( KeiRo::Base::Coord2 &coord );\r\n\t\r\n\tdouble minDistToPolygon( const KeiRo::Base::Coord2 &coord );\r\n\t\r\n\tdouble randomCentroid( void );\r\n\t\r\n\tvoid computeChaikinCurve( int num, double unit );\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIntersection check\r\n//------------------------------------------------------------------------------\r\n\r\n//------------------------------------------------------------------------------\r\n//\tFriend functions\r\n//------------------------------------------------------------------------------\r\n\r\n//------------------------------------------------------------------------------\r\n//\tI/O functions\r\n//------------------------------------------------------------------------------\r\n\tfriend ostream &operator<<( ostream &s, const Contour2 &v );\r\n\t\r\n\tfriend istream &operator>>( istream &s, Contour2 &v );\r\n\t\r\n\tvirtual const char *className( void ) const { return \"Contour2\"; }\r\n\t\r\n};\r\n\r\n\r\n#endif // _Contour2_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Composite/src/Contour2.h b/Composite/src/Contour2.h
--- a/Composite/src/Contour2.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Composite/src/Contour2.h	(date 1729410605380)
@@ -1,132 +1,0 @@
-//******************************************************************************
-// Contour2.h
-//	: header file for Contour2
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Jun 19 02:36:37 2018
-//
-//******************************************************************************
-
-#ifndef _Contour2_H
-#define _Contour2_H
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <vector>
-#include <cmath>
-#include <iostream>
-
-using namespace std;
-
-#include "Polygon2.h"
-#include "BaseUndirectedGraph.h"
-
-//------------------------------------------------------------------------------
-//	Defining Macros
-//------------------------------------------------------------------------------
-
-
-//------------------------------------------------------------------------------
-//	Defining Classes
-//------------------------------------------------------------------------------
-
-class Contour2 {
-
-protected:
-	
-	unsigned int _id;
-	KeiRo::Base::Polygon2 _contour;                  // contour elements
-	vector< KeiRo::Base::Polygon2 > _polygons;       // subcell of the contour
-	KeiRo::Base::Polygon2 _fineContour;              // curvy simpleContour
-	
-	virtual void _init( unsigned int __id, vector< KeiRo::Base::Polygon2 > __polygons );
-	
-	void _clear( void );
-	
-	void _initChaikinCurve( double unit );
-
-public:
-
-//------------------------------------------------------------------------------
-//	Constructors
-//------------------------------------------------------------------------------
-	Contour2();                // constructor (default)
-	Contour2( vector< KeiRo::Base::Polygon2 > __polygons );
-	
-	// coordinates as input
-	Contour2( const Contour2 &v );        // copy constructor
-	virtual ~Contour2() {}        // destructor
-
-//------------------------------------------------------------------------------
-//	Assignment operators
-//------------------------------------------------------------------------------
-	Contour2 &operator=( const Contour2 &p );
-	// assignment
-
-//------------------------------------------------------------------------------
-//	Reference to elements
-//------------------------------------------------------------------------------
-	void init( unsigned int __id, vector< KeiRo::Base::Polygon2 > __polygons ) { _init( __id, __polygons ); }
-	
-	void clear( void ) { _clear(); }
-	
-	// id
-	unsigned int &id( void ) { return _id; }
-	
-	const unsigned int &id( void ) const { return _id; }
-	
-	// simpleContour
-	KeiRo::Base::Polygon2 &contour( void ) { return _contour; }
-	
-	const KeiRo::Base::Polygon2 &contour( void ) const { return _contour; }
-	
-	// a vector of polygons
-	vector< KeiRo::Base::Polygon2 > &polygons( void ) { return _polygons; }
-	
-	const vector< KeiRo::Base::Polygon2 > &polygons( void ) const { return _polygons; }
-	
-	// fine simpleContour
-	KeiRo::Base::Polygon2 &fineContour( void ) { return _fineContour; }
-	
-	const KeiRo::Base::Polygon2 &fineContour( void ) const { return _fineContour; }
-
-//------------------------------------------------------------------------------
-//	Special functions
-//------------------------------------------------------------------------------
-	bool findVertexInComplex( const KeiRo::Base::Coord2 &coord, Graph::BaseUndirectedGraph &complex,
-	                          Graph::BaseUndirectedGraph::vertex_descriptor &target );
-	
-	void createContour( void );
-	
-	bool inContour( KeiRo::Base::Coord2 &coord );
-	
-	double minDistToPolygon( const KeiRo::Base::Coord2 &coord );
-	
-	double randomCentroid( void );
-	
-	void computeChaikinCurve( int num, double unit );
-
-//------------------------------------------------------------------------------
-//	Intersection check
-//------------------------------------------------------------------------------
-
-//------------------------------------------------------------------------------
-//	Friend functions
-//------------------------------------------------------------------------------
-
-//------------------------------------------------------------------------------
-//	I/O functions
-//------------------------------------------------------------------------------
-	friend ostream &operator<<( ostream &s, const Contour2 &v );
-	
-	friend istream &operator>>( istream &s, Contour2 &v );
-	
-	virtual const char *className( void ) const { return "Contour2"; }
-	
-};
-
-
-#endif // _Contour2_H
Index: Composite/src/Grid2.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// Grid2.h\r\n//\t: header file for 2D grid coordinates\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Mon Feb 10 20:13:35 2020\r\n//\r\n//******************************************************************************\r\n\r\n#ifndef _Base_Grid2_H\r\n#define _Base_Grid2_H\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <vector>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\n#include <qapplication.h>\r\n#include \"Config.h\"\r\n#include \"Coord2.h\"\r\n#include \"GridGraph.h\"\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Macros\r\n//------------------------------------------------------------------------------\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Classes\r\n//------------------------------------------------------------------------------\r\nclass Grid2 {\r\n\r\nprivate:\r\n\t\r\n\t// window width and height\r\n\tdouble const * _widthPtr;\r\n\tdouble const * _heightPtr;\r\n\t// grid graph\r\n\tGraph::GridGraph _grid;\r\n\tvector< vector< Graph::GridGraph::vertex_descriptor > > _quadFourCorners;\r\n\t// grid level\r\n\tunsigned int _level;\r\n\r\nprotected:\r\n\t\r\n\t// grid range\r\n\tunsigned int _minRange;\r\n\tvector< unsigned int > _range;\r\n\t// width and height of a quad\r\n\tdouble _quadSize;\r\n\tvector< vector< KeiRo::Base::Common::IDPair > > _gridIDMatrix;\r\n\tvector< vector< KeiRo::Base::Coord2 > > _gridCoord2Matrix;\r\n\t\r\n\t// x, y coordinates\r\n\tint _element[2];\r\n\t\r\n\t//------------------------------------------------------------------------------\r\n\t//\tSpecial functions\r\n\t//------------------------------------------------------------------------------\r\n\t// initialize griz\r\n\tvirtual void _init( const double *_widthPtr, const double *_heightPtr );\r\n\t\r\n\tvirtual void _clear( void );\r\n\r\npublic:\r\n\t\r\n\t//------------------------------------------------------------------------------\r\n\t//\tConstructors & Destructors\r\n\t//------------------------------------------------------------------------------\r\n\t// default constructor\r\n\tGrid2( void );\r\n\t\r\n\t// parameterized constructor\r\n\tGrid2( const int x, const int y );\r\n\t\r\n\t// copy constructor\r\n\tGrid2( const Grid2 &v );\r\n\t\r\n\t// destructor\r\n\tvirtual ~Grid2( void ) {}\r\n\t\r\n\t//------------------------------------------------------------------------------\r\n\t//\tAssignment operators\r\n\t//------------------------------------------------------------------------------\r\n\t// assignment\r\n\tGrid2 &operator=( const Grid2 &v );\r\n\t\r\n\t// addition + assignment\r\n\tGrid2 &operator+=( const Grid2 &v );\r\n\t\r\n\t// subtraction + assignment\r\n\tGrid2 &operator-=( const Grid2 &v );\r\n\t\r\n\t// scalar product + assignment\r\n\tGrid2 &operator*=( const int d );\r\n\t\r\n\t//------------------------------------------------------------------------------\r\n\t//\tReference to elements\r\n\t//------------------------------------------------------------------------------\r\n\t// reference to a specific coordinate\r\n\tconst int &operator[]( int i ) const;\r\n\t\r\n\tint &operator[]( int i );\r\n\t\r\n\t// pointer to an array of coordinates\r\n\tconst int *element( void ) const { return _element; }\r\n\t\r\n\tint &p( void ) { return _element[ 0 ]; }\r\n\t\r\n\tint &q( void ) { return _element[ 1 ]; }\r\n\t\r\n\tconst int &p( void ) const { return _element[ 0 ]; }\r\n\t\r\n\tconst int &q( void ) const { return _element[ 1 ]; }\r\n\t\r\n\t// reference to a specific coordinate\r\n\tconst int &getP( void ) const { return _element[ 0 ]; }\r\n\t\r\n\tconst int &getQ( void ) const { return _element[ 1 ]; }\r\n\t\r\n\t// set the coordinate(s)\r\n\tvoid set( const int p, const int q );\r\n\t\r\n\tvoid setP( const int p ) { _element[ 0 ] = p; }\r\n\t\r\n\tvoid setQ( const int q ) { _element[ 1 ] = q; }\r\n\t\r\n\t\r\n\tGraph::GridGraph &gridG( void ) { return _grid; }\r\n\t\r\n\tconst Graph::GridGraph &gridG( void ) const { return _grid; }\r\n\t\r\n\tunsigned int &minRange( void ) { return _minRange; }\r\n\t\r\n\tconst unsigned int &minRange( void ) const { return _minRange; }\r\n\t\r\n\tvector< unsigned int > &range( void ) { return _range; }\r\n\t\r\n\tconst vector< unsigned int > &range( void ) const { return _range; }\r\n\t\r\n\tdouble &quadSize( void ) { return _quadSize; }\r\n\t\r\n\tconst double &qudaSize( void ) const { return _quadSize; }\r\n\t\r\n\t// grid level\r\n\tunsigned int &level( void ) { return _level; }\r\n\t\r\n\tconst unsigned int &level( void ) const { return _level; }\r\n\t\r\n\tvector< vector< Graph::GridGraph::vertex_descriptor > > &quadFourCorners( void ) { return _quadFourCorners; }\r\n\t\r\n\tconst vector< vector< Graph::GridGraph::vertex_descriptor > > &\r\n\tquadFourCorners( void ) const { return _quadFourCorners; }\r\n\t\r\n\t//vector< vector< Base::Common::IDPair > > &          gridIDMatrix( void )            { return _gridIDMatrix; }\r\n\t//const vector< vector< Base::Common::IDPair > > &    gridIDMatrix( void ) const      { return _gridIDMatrix; }\r\n\t//vector< vector< Base::Coord2 > > &                  gridCoordMatrix( void )         { return _gridCoord2Matrix; }\r\n\t//const vector< vector< Base::Coord2 > > &            gridCoordMatrix( void ) const   { return _gridCoord2Matrix; }\r\n\t\r\n\t\r\n\t//------------------------------------------------------------------------------\r\n\t//\tSpecial functions\r\n\t//------------------------------------------------------------------------------\r\n\t// initialization\r\n\tvoid init( const double *__widthPtr, const double *__heightPtr  ) {\r\n\t\t_init( __widthPtr, __heightPtr );\r\n\t}\r\n\t\r\n\t// clear\r\n\tvoid clear( void ) { _clear(); }\r\n\t\r\n\tvoid getQuadVD( unsigned int i, unsigned int j,\r\n\t                vector< Graph::GridGraph::vertex_descriptor > &vdVec );\r\n\t\r\n\tvoid createDefaultGrid( void );\r\n\t\r\n\tvoid resetGridPosition( void );\r\n\t\r\n\t//------------------------------------------------------------------------------\r\n\t//\tFriend functions\r\n\t//------------------------------------------------------------------------------\r\n\t// sign change\r\n\tfriend Grid2 operator-( const Grid2 &v );\r\n\t\r\n\t// addition\r\n\tfriend Grid2 operator+( const Grid2 &a, const Grid2 &b );\r\n\t\r\n\t// subtraction\r\n\tfriend Grid2 operator-( const Grid2 &a, const Grid2 &b );\r\n\t\r\n\t// scalar product\r\n\tfriend Grid2 operator*( const int d, const Grid2 &a );\r\n\t\r\n\t// inner product\r\n\tfriend int operator*( const Grid2 &a, const Grid2 &b );\r\n\t\r\n\t// equivalence\r\n\tfriend int operator==( const Grid2 &a, const Grid2 &b );\r\n\t\r\n\t// inequivalence\r\n\tfriend int operator!=( const Grid2 &a, const Grid2 &b ) {\r\n\t\treturn ( !( a == b ) );\r\n\t}\r\n\t\r\n\t// comparison (less than)\r\n\tfriend int operator<( const Grid2 &a, const Grid2 &b );\r\n\t\r\n\t// comparison (more than)\r\n\tfriend int operator>( const Grid2 &a, const Grid2 &b );\r\n\t\r\n\t// comparison (equal to or less than)\r\n\tfriend int operator<=( const Grid2 &a, const Grid2 &b ) {\r\n\t\treturn ( ( a == b ) || ( a < b ) );\r\n\t}\r\n\t\r\n\t// comparison (equal to or more than)\r\n\tfriend int operator>=( const Grid2 &a, const Grid2 &b ) {\r\n\t\treturn ( ( a == b ) || ( a > b ) );\r\n\t}\r\n\t\r\n\t//------------------------------------------------------------------------------\r\n\t//\tI/O functions\r\n\t//------------------------------------------------------------------------------\r\n\t// output\r\n\tfriend ostream &operator<<( ostream &s, const Grid2 &v );\r\n\t\r\n\t// input\r\n\tfriend istream &operator>>( istream &s, Grid2 &v );\r\n\t\r\n\t// class name\r\n\tvirtual const char *className( void ) const { return \"Grid2\"; }\r\n\t\r\n};\r\n\r\n\r\n#endif // _Base_Grid2_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Composite/src/Grid2.h b/Composite/src/Grid2.h
--- a/Composite/src/Grid2.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Composite/src/Grid2.h	(date 1729410605400)
@@ -1,240 +1,0 @@
-//******************************************************************************
-// Grid2.h
-//	: header file for 2D grid coordinates
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Mon Feb 10 20:13:35 2020
-//
-//******************************************************************************
-
-#ifndef _Base_Grid2_H
-#define _Base_Grid2_H
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <vector>
-#include <iostream>
-
-using namespace std;
-
-#include <qapplication.h>
-#include "Config.h"
-#include "Coord2.h"
-#include "GridGraph.h"
-
-//------------------------------------------------------------------------------
-//	Defining Macros
-//------------------------------------------------------------------------------
-
-//------------------------------------------------------------------------------
-//	Defining Classes
-//------------------------------------------------------------------------------
-class Grid2 {
-
-private:
-	
-	// window width and height
-	double const * _widthPtr;
-	double const * _heightPtr;
-	// grid graph
-	Graph::GridGraph _grid;
-	vector< vector< Graph::GridGraph::vertex_descriptor > > _quadFourCorners;
-	// grid level
-	unsigned int _level;
-
-protected:
-	
-	// grid range
-	unsigned int _minRange;
-	vector< unsigned int > _range;
-	// width and height of a quad
-	double _quadSize;
-	vector< vector< KeiRo::Base::Common::IDPair > > _gridIDMatrix;
-	vector< vector< KeiRo::Base::Coord2 > > _gridCoord2Matrix;
-	
-	// x, y coordinates
-	int _element[2];
-	
-	//------------------------------------------------------------------------------
-	//	Special functions
-	//------------------------------------------------------------------------------
-	// initialize griz
-	virtual void _init( const double *_widthPtr, const double *_heightPtr );
-	
-	virtual void _clear( void );
-
-public:
-	
-	//------------------------------------------------------------------------------
-	//	Constructors & Destructors
-	//------------------------------------------------------------------------------
-	// default constructor
-	Grid2( void );
-	
-	// parameterized constructor
-	Grid2( const int x, const int y );
-	
-	// copy constructor
-	Grid2( const Grid2 &v );
-	
-	// destructor
-	virtual ~Grid2( void ) {}
-	
-	//------------------------------------------------------------------------------
-	//	Assignment operators
-	//------------------------------------------------------------------------------
-	// assignment
-	Grid2 &operator=( const Grid2 &v );
-	
-	// addition + assignment
-	Grid2 &operator+=( const Grid2 &v );
-	
-	// subtraction + assignment
-	Grid2 &operator-=( const Grid2 &v );
-	
-	// scalar product + assignment
-	Grid2 &operator*=( const int d );
-	
-	//------------------------------------------------------------------------------
-	//	Reference to elements
-	//------------------------------------------------------------------------------
-	// reference to a specific coordinate
-	const int &operator[]( int i ) const;
-	
-	int &operator[]( int i );
-	
-	// pointer to an array of coordinates
-	const int *element( void ) const { return _element; }
-	
-	int &p( void ) { return _element[ 0 ]; }
-	
-	int &q( void ) { return _element[ 1 ]; }
-	
-	const int &p( void ) const { return _element[ 0 ]; }
-	
-	const int &q( void ) const { return _element[ 1 ]; }
-	
-	// reference to a specific coordinate
-	const int &getP( void ) const { return _element[ 0 ]; }
-	
-	const int &getQ( void ) const { return _element[ 1 ]; }
-	
-	// set the coordinate(s)
-	void set( const int p, const int q );
-	
-	void setP( const int p ) { _element[ 0 ] = p; }
-	
-	void setQ( const int q ) { _element[ 1 ] = q; }
-	
-	
-	Graph::GridGraph &gridG( void ) { return _grid; }
-	
-	const Graph::GridGraph &gridG( void ) const { return _grid; }
-	
-	unsigned int &minRange( void ) { return _minRange; }
-	
-	const unsigned int &minRange( void ) const { return _minRange; }
-	
-	vector< unsigned int > &range( void ) { return _range; }
-	
-	const vector< unsigned int > &range( void ) const { return _range; }
-	
-	double &quadSize( void ) { return _quadSize; }
-	
-	const double &qudaSize( void ) const { return _quadSize; }
-	
-	// grid level
-	unsigned int &level( void ) { return _level; }
-	
-	const unsigned int &level( void ) const { return _level; }
-	
-	vector< vector< Graph::GridGraph::vertex_descriptor > > &quadFourCorners( void ) { return _quadFourCorners; }
-	
-	const vector< vector< Graph::GridGraph::vertex_descriptor > > &
-	quadFourCorners( void ) const { return _quadFourCorners; }
-	
-	//vector< vector< Base::Common::IDPair > > &          gridIDMatrix( void )            { return _gridIDMatrix; }
-	//const vector< vector< Base::Common::IDPair > > &    gridIDMatrix( void ) const      { return _gridIDMatrix; }
-	//vector< vector< Base::Coord2 > > &                  gridCoordMatrix( void )         { return _gridCoord2Matrix; }
-	//const vector< vector< Base::Coord2 > > &            gridCoordMatrix( void ) const   { return _gridCoord2Matrix; }
-	
-	
-	//------------------------------------------------------------------------------
-	//	Special functions
-	//------------------------------------------------------------------------------
-	// initialization
-	void init( const double *__widthPtr, const double *__heightPtr  ) {
-		_init( __widthPtr, __heightPtr );
-	}
-	
-	// clear
-	void clear( void ) { _clear(); }
-	
-	void getQuadVD( unsigned int i, unsigned int j,
-	                vector< Graph::GridGraph::vertex_descriptor > &vdVec );
-	
-	void createDefaultGrid( void );
-	
-	void resetGridPosition( void );
-	
-	//------------------------------------------------------------------------------
-	//	Friend functions
-	//------------------------------------------------------------------------------
-	// sign change
-	friend Grid2 operator-( const Grid2 &v );
-	
-	// addition
-	friend Grid2 operator+( const Grid2 &a, const Grid2 &b );
-	
-	// subtraction
-	friend Grid2 operator-( const Grid2 &a, const Grid2 &b );
-	
-	// scalar product
-	friend Grid2 operator*( const int d, const Grid2 &a );
-	
-	// inner product
-	friend int operator*( const Grid2 &a, const Grid2 &b );
-	
-	// equivalence
-	friend int operator==( const Grid2 &a, const Grid2 &b );
-	
-	// inequivalence
-	friend int operator!=( const Grid2 &a, const Grid2 &b ) {
-		return ( !( a == b ) );
-	}
-	
-	// comparison (less than)
-	friend int operator<( const Grid2 &a, const Grid2 &b );
-	
-	// comparison (more than)
-	friend int operator>( const Grid2 &a, const Grid2 &b );
-	
-	// comparison (equal to or less than)
-	friend int operator<=( const Grid2 &a, const Grid2 &b ) {
-		return ( ( a == b ) || ( a < b ) );
-	}
-	
-	// comparison (equal to or more than)
-	friend int operator>=( const Grid2 &a, const Grid2 &b ) {
-		return ( ( a == b ) || ( a > b ) );
-	}
-	
-	//------------------------------------------------------------------------------
-	//	I/O functions
-	//------------------------------------------------------------------------------
-	// output
-	friend ostream &operator<<( ostream &s, const Grid2 &v );
-	
-	// input
-	friend istream &operator>>( istream &s, Grid2 &v );
-	
-	// class name
-	virtual const char *className( void ) const { return "Grid2"; }
-	
-};
-
-
-#endif // _Base_Grid2_H
Index: UI/src/BaseView.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#pragma once\r\n#include <QtWidgets/QWidget>\r\n\r\nnamespace Ui\r\n{\r\n\tclass BaseView\r\n\t{\r\n\tpublic:\r\n\t\tBaseView();\r\n\t\tvirtual ~BaseView();\r\n\t\tvirtual QWidget* getSettings() = 0;\r\n\t\t\r\n\t\tvoid loadFile();\r\n\r\n\tprotected:\r\n\t\tQWidget* m_settings;\r\n\r\n\t\tvirtual void processFile(std::string path) = 0;\r\n\t};\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/UI/src/BaseView.h b/UI/src/BaseView.h
--- a/UI/src/BaseView.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/UI/src/BaseView.h	(date 1729410605410)
@@ -1,20 +1,0 @@
-#pragma once
-#include <QtWidgets/QWidget>
-
-namespace Ui
-{
-	class BaseView
-	{
-	public:
-		BaseView();
-		virtual ~BaseView();
-		virtual QWidget* getSettings() = 0;
-		
-		void loadFile();
-
-	protected:
-		QWidget* m_settings;
-
-		virtual void processFile(std::string path) = 0;
-	};
-}
\ No newline at end of file
Index: UI/src/GraphicsPathItem.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// GraphicsEdgeItem.h\r\n//\t: header file for edge items\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Jun 19 02:36:37 2019\r\n//\r\n//******************************************************************************\r\n\r\n#ifndef Ui_Vector_GraphicsPathItem_H\r\n#define Ui_Vector_GraphicsPathItem_H\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <iostream>\r\n#include <iomanip>\r\n#include <fstream>\r\n#include <map>\r\n#include <list>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <cmath>\r\n#include <ctime>\r\n#include <cstdlib>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\n#include <QtWidgets/QGraphicsScene>\r\n#include <QtWidgets/QGraphicsItem>\r\n//#include <QtGui/QPainter>\r\n//#include <QtCore/QString>\r\n//#include <QtWidgets/QGraphicsSceneMouseEvent>\r\n#include <QPropertyAnimation>\r\n\r\n#ifndef Q_MOC_RUN\r\n#include \"GraphicsBase.h\"\r\n#endif // Q_MOC_RUN\r\n\r\nQ_DECLARE_METATYPE (QPainterPath)\r\n\r\nnamespace Ui {\r\nnamespace Vector {\r\n\t\r\n\t\r\n\t//------------------------------------------------------------------------------\r\n    //\tClass definition\r\n    //------------------------------------------------------------------------------\r\n    class GraphicsPathItem : public  QGraphicsPathItem, public GraphicsBase {\r\n    \r\n\t    \r\n    private:\r\n    \r\n    protected:\r\n\t    \r\n    \t//------------------------------------------------------------------------------\r\n\t    //\tSpecial functions\r\n\t    //------------------------------------------------------------------------------\r\n\t    void            _init( void );\r\n\t    \r\n    public:\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tConstructors & Destructors\r\n        //------------------------------------------------------------------------------\r\n        // default constructor\r\n        explicit GraphicsPathItem( QGraphicsItem *parent = Q_NULLPTR );\r\n        // copy constructor\r\n        explicit GraphicsPathItem( const QPainterPath &path, QGraphicsItem *parent = Q_NULLPTR );\r\n        // destructor\r\n        ~GraphicsPathItem( void ) {}\r\n\r\n        //------------------------------------------------------------------------------\r\n        //      Reimplementation\r\n        //------------------------------------------------------------------------------\r\n        // source from the qt library\r\n        //QPainterPath path() const;\r\n        //void setPath(const QPainterPath &path);\r\n\r\n        //QPainterPath shape() const Q_DECL_OVERRIDE;\r\n        //bool contains(const QPointF &point) const Q_DECL_OVERRIDE;\r\n\r\n        QRectF boundingRect() const Q_DECL_OVERRIDE;\r\n        int type( void ) const Q_DECL_OVERRIDE;\r\n\r\n        void paint( QPainter *painter, const QStyleOptionGraphicsItem *option,\r\n                    QWidget *widget = Q_NULLPTR ) Q_DECL_OVERRIDE;\r\n\r\n        //------------------------------------------------------------------------------\r\n        //      Reference to elements\r\n        //------------------------------------------------------------------------------\r\n\t\r\n\t    //------------------------------------------------------------------------------\r\n\t    //\tSpecial functions\r\n\t    //------------------------------------------------------------------------------\r\n\t    void init( void ) { _init(); }\r\n\r\n    };\r\n\r\n} // namespace Vector\r\n} // namespace Ui\r\n\r\n\r\n#endif // Ui_Vector_GraphicsPathItem_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/UI/src/GraphicsPathItem.h b/UI/src/GraphicsPathItem.h
--- a/UI/src/GraphicsPathItem.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/UI/src/GraphicsPathItem.h	(date 1729410605420)
@@ -1,107 +1,0 @@
-//******************************************************************************
-// GraphicsEdgeItem.h
-//	: header file for edge items
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Jun 19 02:36:37 2019
-//
-//******************************************************************************
-
-#ifndef Ui_Vector_GraphicsPathItem_H
-#define Ui_Vector_GraphicsPathItem_H
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <iostream>
-#include <iomanip>
-#include <fstream>
-#include <map>
-#include <list>
-#include <vector>
-#include <algorithm>
-#include <cmath>
-#include <ctime>
-#include <cstdlib>
-#include <string>
-
-using namespace std;
-
-#include <QtWidgets/QGraphicsScene>
-#include <QtWidgets/QGraphicsItem>
-//#include <QtGui/QPainter>
-//#include <QtCore/QString>
-//#include <QtWidgets/QGraphicsSceneMouseEvent>
-#include <QPropertyAnimation>
-
-#ifndef Q_MOC_RUN
-#include "GraphicsBase.h"
-#endif // Q_MOC_RUN
-
-Q_DECLARE_METATYPE (QPainterPath)
-
-namespace Ui {
-namespace Vector {
-	
-	
-	//------------------------------------------------------------------------------
-    //	Class definition
-    //------------------------------------------------------------------------------
-    class GraphicsPathItem : public  QGraphicsPathItem, public GraphicsBase {
-    
-	    
-    private:
-    
-    protected:
-	    
-    	//------------------------------------------------------------------------------
-	    //	Special functions
-	    //------------------------------------------------------------------------------
-	    void            _init( void );
-	    
-    public:
-
-        //------------------------------------------------------------------------------
-        //	Constructors & Destructors
-        //------------------------------------------------------------------------------
-        // default constructor
-        explicit GraphicsPathItem( QGraphicsItem *parent = Q_NULLPTR );
-        // copy constructor
-        explicit GraphicsPathItem( const QPainterPath &path, QGraphicsItem *parent = Q_NULLPTR );
-        // destructor
-        ~GraphicsPathItem( void ) {}
-
-        //------------------------------------------------------------------------------
-        //      Reimplementation
-        //------------------------------------------------------------------------------
-        // source from the qt library
-        //QPainterPath path() const;
-        //void setPath(const QPainterPath &path);
-
-        //QPainterPath shape() const Q_DECL_OVERRIDE;
-        //bool contains(const QPointF &point) const Q_DECL_OVERRIDE;
-
-        QRectF boundingRect() const Q_DECL_OVERRIDE;
-        int type( void ) const Q_DECL_OVERRIDE;
-
-        void paint( QPainter *painter, const QStyleOptionGraphicsItem *option,
-                    QWidget *widget = Q_NULLPTR ) Q_DECL_OVERRIDE;
-
-        //------------------------------------------------------------------------------
-        //      Reference to elements
-        //------------------------------------------------------------------------------
-	
-	    //------------------------------------------------------------------------------
-	    //	Special functions
-	    //------------------------------------------------------------------------------
-	    void init( void ) { _init(); }
-
-    };
-
-} // namespace Vector
-} // namespace Ui
-
-
-#endif // Ui_Vector_GraphicsPathItem_H
Index: UI/src/BaseView.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"BaseView.h\"\r\n\r\nnamespace Ui\r\n{\r\n\tBaseView::BaseView() \r\n\t{\r\n\t\tm_settings = nullptr;\r\n\t}\r\n\t\r\n\tBaseView::~BaseView() \r\n\t{\r\n\t}\r\n\r\n\tvoid BaseView::loadFile()\r\n\t{\r\n\t\tQUrl url = QFileDialog::getOpenFileUrl();\r\n\r\n\t\tprocessFile(url.toLocalFile().toStdString());\r\n\t}\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/UI/src/BaseView.cpp b/UI/src/BaseView.cpp
--- a/UI/src/BaseView.cpp	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/UI/src/BaseView.cpp	(date 1729410605430)
@@ -1,20 +1,0 @@
-#include "BaseView.h"
-
-namespace Ui
-{
-	BaseView::BaseView() 
-	{
-		m_settings = nullptr;
-	}
-	
-	BaseView::~BaseView() 
-	{
-	}
-
-	void BaseView::loadFile()
-	{
-		QUrl url = QFileDialog::getOpenFileUrl();
-
-		processFile(url.toLocalFile().toStdString());
-	}
-}
\ No newline at end of file
Index: UI/src/GraphicsEdgeItem.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// GraphicsEdgeItem.h\r\n//\t: header file for edge items\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Jun 19 02:36:37 2019\r\n//\r\n//******************************************************************************\r\n\r\n#ifndef Ui_Vector_GraphicsEdgeItem_H\r\n#define Ui_Vector_GraphicsEdgeItem_H\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <iostream>\r\n#include <iomanip>\r\n#include <fstream>\r\n#include <map>\r\n#include <list>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <cmath>\r\n#include <ctime>\r\n#include <cstdlib>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\n#include <QtWidgets/QGraphicsScene>\r\n#include <QtWidgets/QGraphicsItem>\r\n//#include <QtGui/QPainter>\r\n//#include <QtCore/QString>\r\n//#include <QtWidgets/QGraphicsSceneMouseEvent>\r\n#include <QPropertyAnimation>\r\n\r\n#ifndef Q_MOC_RUN\r\n#include \"GraphicsBase.h\"\r\n#endif // Q_MOC_RUN\r\n\r\nnamespace Ui {\r\nnamespace Vector {\r\n\t\r\n\t\r\n\t//------------------------------------------------------------------------------\r\n    //\tClass definition\r\n    //------------------------------------------------------------------------------\r\n    class GraphicsEdgeItem : public QObject, public  QGraphicsLineItem, public GraphicsBase {\r\n\r\n        Q_OBJECT\r\n\t    Q_PROPERTY( QLineF line READ getLine WRITE setLine )\r\n\t    Q_INTERFACES( QGraphicsItem )\r\n\t    \r\n    private:\r\n    \r\n    protected:\r\n\t    \r\n    \t//------------------------------------------------------------------------------\r\n\t    //\tSpecial functions\r\n\t    //------------------------------------------------------------------------------\r\n\t    void            _init( void );\r\n\t    \r\n    public:\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tConstructors & Destructors\r\n        //------------------------------------------------------------------------------\r\n        // default constructor\r\n        explicit GraphicsEdgeItem( QGraphicsItem *parent = Q_NULLPTR );\r\n        // copy constructor\r\n        explicit GraphicsEdgeItem( const QLineF &line, QGraphicsItem *parent = Q_NULLPTR );\r\n        // destructor\r\n        ~GraphicsEdgeItem( void ) {}\r\n\r\n        //------------------------------------------------------------------------------\r\n        //      Reimplementation\r\n        //------------------------------------------------------------------------------\r\n        // source from the qt library\r\n        //QPainterPath path() const;\r\n        //void setPath(const QPainterPath &path);\r\n\r\n        //QPainterPath shape() const Q_DECL_OVERRIDE;\r\n        //bool contains(const QPointF &point) const Q_DECL_OVERRIDE;\r\n\r\n//        QRectF boundingRect() const Q_DECL_OVERRIDE;\r\n        int type( void ) const Q_DECL_OVERRIDE;\r\n\r\n        void paint( QPainter *painter, const QStyleOptionGraphicsItem *option,\r\n                    QWidget *widget = Q_NULLPTR ) Q_DECL_OVERRIDE;\r\n\r\n        //------------------------------------------------------------------------------\r\n        //      Reference to elements\r\n        //------------------------------------------------------------------------------\r\n        QLineF        getLine() const {\r\n\t        return line();\r\n        }\r\n//\t    void         setLine( QLineF __line ) {\r\n//\t\t    _line = __line;\r\n//\t    }\r\n\t\r\n\t    //------------------------------------------------------------------------------\r\n\t    //\tSpecial functions\r\n\t    //------------------------------------------------------------------------------\r\n\t    void init( void ) { _init(); }\r\n\r\n    };\r\n\r\n} // namespace Vector\r\n} // namespace Ui\r\n\r\n\r\n#endif // Ui_Vector_GraphicsEdgeItem_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/UI/src/GraphicsEdgeItem.h b/UI/src/GraphicsEdgeItem.h
--- a/UI/src/GraphicsEdgeItem.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/UI/src/GraphicsEdgeItem.h	(date 1729410605440)
@@ -1,114 +1,0 @@
-//******************************************************************************
-// GraphicsEdgeItem.h
-//	: header file for edge items
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Jun 19 02:36:37 2019
-//
-//******************************************************************************
-
-#ifndef Ui_Vector_GraphicsEdgeItem_H
-#define Ui_Vector_GraphicsEdgeItem_H
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <iostream>
-#include <iomanip>
-#include <fstream>
-#include <map>
-#include <list>
-#include <vector>
-#include <algorithm>
-#include <cmath>
-#include <ctime>
-#include <cstdlib>
-#include <string>
-
-using namespace std;
-
-#include <QtWidgets/QGraphicsScene>
-#include <QtWidgets/QGraphicsItem>
-//#include <QtGui/QPainter>
-//#include <QtCore/QString>
-//#include <QtWidgets/QGraphicsSceneMouseEvent>
-#include <QPropertyAnimation>
-
-#ifndef Q_MOC_RUN
-#include "GraphicsBase.h"
-#endif // Q_MOC_RUN
-
-namespace Ui {
-namespace Vector {
-	
-	
-	//------------------------------------------------------------------------------
-    //	Class definition
-    //------------------------------------------------------------------------------
-    class GraphicsEdgeItem : public QObject, public  QGraphicsLineItem, public GraphicsBase {
-
-        Q_OBJECT
-	    Q_PROPERTY( QLineF line READ getLine WRITE setLine )
-	    Q_INTERFACES( QGraphicsItem )
-	    
-    private:
-    
-    protected:
-	    
-    	//------------------------------------------------------------------------------
-	    //	Special functions
-	    //------------------------------------------------------------------------------
-	    void            _init( void );
-	    
-    public:
-
-        //------------------------------------------------------------------------------
-        //	Constructors & Destructors
-        //------------------------------------------------------------------------------
-        // default constructor
-        explicit GraphicsEdgeItem( QGraphicsItem *parent = Q_NULLPTR );
-        // copy constructor
-        explicit GraphicsEdgeItem( const QLineF &line, QGraphicsItem *parent = Q_NULLPTR );
-        // destructor
-        ~GraphicsEdgeItem( void ) {}
-
-        //------------------------------------------------------------------------------
-        //      Reimplementation
-        //------------------------------------------------------------------------------
-        // source from the qt library
-        //QPainterPath path() const;
-        //void setPath(const QPainterPath &path);
-
-        //QPainterPath shape() const Q_DECL_OVERRIDE;
-        //bool contains(const QPointF &point) const Q_DECL_OVERRIDE;
-
-//        QRectF boundingRect() const Q_DECL_OVERRIDE;
-        int type( void ) const Q_DECL_OVERRIDE;
-
-        void paint( QPainter *painter, const QStyleOptionGraphicsItem *option,
-                    QWidget *widget = Q_NULLPTR ) Q_DECL_OVERRIDE;
-
-        //------------------------------------------------------------------------------
-        //      Reference to elements
-        //------------------------------------------------------------------------------
-        QLineF        getLine() const {
-	        return line();
-        }
-//	    void         setLine( QLineF __line ) {
-//		    _line = __line;
-//	    }
-	
-	    //------------------------------------------------------------------------------
-	    //	Special functions
-	    //------------------------------------------------------------------------------
-	    void init( void ) { _init(); }
-
-    };
-
-} // namespace Vector
-} // namespace Ui
-
-
-#endif // Ui_Vector_GraphicsEdgeItem_H
Index: UI/src/GraphicsView.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// GraphicsView.h\r\n//\t: header file for graphics scene\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Jun 19 02:36:37 2019\r\n//\r\n//******************************************************************************\r\n\r\n#ifndef Ui_GraphicsView_H\r\n#define Ui_GraphicsView_H\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <iostream>\r\n#include <iomanip>\r\n#include <fstream>\r\n#include <sstream>\r\n#include <map>\r\n#include <list>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <cmath>\r\n#include <ctime>\r\n#include <cstdlib>\r\n#include <thread>\r\n\r\nusing namespace std;\r\n\r\n#include <QtWidgets/QGraphicsScene>\r\n#include <QtWidgets/QGraphicsView>\r\n#include <QtWidgets/QApplication>\r\n#include <QtWidgets/QGraphicsSceneDragDropEvent>\r\n#include <QtWidgets/QFileDialog>\r\n#include <QtGui/QMouseEvent>\r\n#include <QtCore/QMimeData>\r\n#include <QtCore/QDir>\r\n#include <QtCore/QTimer>\r\n#include <QtSvg/QSvgGenerator>\r\n\r\n#ifndef Q_MOC_RUN\r\n#include \"Base.h\"\r\n#include \"Common.h\"\r\n#include \"GraphicsVertexItem.h\"\r\n#include \"GraphicsCellItem.h\"\r\n#include \"GraphicsPathItem.h\"\r\n#endif // Q_MOC_RUN\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Macros\r\n//------------------------------------------------------------------------------\r\n\r\nnamespace Ui{\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tClass definition\r\n    //------------------------------------------------------------------------------\r\n    class GraphicsView : public QGraphicsView\r\n    {\r\n        Q_OBJECT\r\n\r\n    private:\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tUI\r\n        //------------------------------------------------------------------------------\r\n\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tSpecial functions\r\n        //------------------------------------------------------------------------------\r\n//        virtual void _init              ( void ) = 0;\r\n//\t    virtual void _clear             ( void ) = 0;\r\n\r\n    protected:\r\n\t\r\n\t    // picking testing\r\n\t    QPainterPath                    _selectionArea;\r\n\t\r\n\t    //------------------------------------------------------------------------------\r\n\t    //\tUI\r\n\t    //------------------------------------------------------------------------------\r\n\t    double                          _min_point_distance;\r\n\t\r\n\t    QPoint                          _oldCursor, _cursor;\r\n\t    bool                            _left_button_pressed,\r\n\t\t\t\t                        _middle_button_pressed,\r\n\t\t\t\t\t\t\t\t\t    _right_button_pressed;\r\n\t    double                          _wheel_scale;\r\n\t\r\n\t    //------------------------------------------------------------------------------\r\n\t    //\tData\r\n\t    //------------------------------------------------------------------------------\r\n\t    // scene\r\n\t    QGraphicsScene                  *_scenePtr;\r\n\t    KeiRo::Base::Base               *_basePtr;\r\n\t    \r\n\t    //------------------------------------------------------------------------------\r\n        //\tEvent handlers\r\n        //------------------------------------------------------------------------------\r\n//\t    void keyPressEvent      ( QKeyEvent *event )    Q_DECL_OVERRIDE;\r\n//\t    void mousePressEvent    ( QMouseEvent *event )  Q_DECL_OVERRIDE;\r\n//\t    void mouseMoveEvent     ( QMouseEvent *event )  Q_DECL_OVERRIDE;\r\n//\t    void mouseReleaseEvent  ( QMouseEvent *event )  Q_DECL_OVERRIDE;\r\n\t\r\n\t    //------------------------------------------------------------------------------\r\n        //\tDrawing functions\r\n        //------------------------------------------------------------------------------\r\n\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tSpecial functions\r\n        //------------------------------------------------------------------------------\r\n        virtual void _readInputData( void ) = 0;\r\n        \r\n    public:\r\n\r\n        //settings\r\n        // QWidget* getSettings() override;\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tConstructors & Destructors\r\n        //------------------------------------------------------------------------------\r\n        // default constructor\r\n        explicit GraphicsView( QWidget *parent = Q_NULLPTR );\r\n        // copy constructor\r\n        explicit GraphicsView( GraphicsView *parent = Q_NULLPTR ) {}\r\n        // destructor\r\n        ~GraphicsView( void ) {}\r\n\r\n        //------------------------------------------------------------------------------\r\n        //      Reimplementation\r\n        //------------------------------------------------------------------------------\r\n\r\n        //------------------------------------------------------------------------------\r\n        //      Reference to elements\r\n        //------------------------------------------------------------------------------\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\t    Special functions\r\n        //------------------------------------------------------------------------------\r\n\t\r\n\t    virtual void init               ( KeiRo::Base::Base *__b_ptr ) = 0;\r\n        virtual void initSceneItems     ( void ) = 0;\r\n        virtual void updateSceneItems   ( void ) = 0;\r\n\t\r\n\t    void simulateKey        ( Qt::Key key );\r\n        void exportPNG ( double x, double y, double w, double h );\r\n        void exportSVG ( double x, double y, double w, double h );\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tI/O functions\r\n        //------------------------------------------------------------------------------\r\n        // output\r\n        friend ostream &\toperator << ( ostream & s, const GraphicsView & m );\r\n        // input\r\n        friend istream &\toperator >> ( istream & s, GraphicsView & m );\r\n        // class name\r\n        virtual const char * className( void ) const { return \"GraphicsView\"; }\r\n        \r\n    Q_SIGNALS:\r\n\t\r\n\t    virtual void dataInitialized() = 0;\r\n\t    virtual void dataChanged() = 0;\r\n     \r\n    public Q_SLOTS:\r\n\r\n    };\r\n\r\n} // namespace Ui\r\n\r\n#endif // Ui_Vector_GraphicsView_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/UI/src/GraphicsView.h b/UI/src/GraphicsView.h
--- a/UI/src/GraphicsView.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/UI/src/GraphicsView.h	(date 1729410605450)
@@ -1,175 +1,0 @@
-//******************************************************************************
-// GraphicsView.h
-//	: header file for graphics scene
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Jun 19 02:36:37 2019
-//
-//******************************************************************************
-
-#ifndef Ui_GraphicsView_H
-#define Ui_GraphicsView_H
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <iostream>
-#include <iomanip>
-#include <fstream>
-#include <sstream>
-#include <map>
-#include <list>
-#include <vector>
-#include <algorithm>
-#include <cmath>
-#include <ctime>
-#include <cstdlib>
-#include <thread>
-
-using namespace std;
-
-#include <QtWidgets/QGraphicsScene>
-#include <QtWidgets/QGraphicsView>
-#include <QtWidgets/QApplication>
-#include <QtWidgets/QGraphicsSceneDragDropEvent>
-#include <QtWidgets/QFileDialog>
-#include <QtGui/QMouseEvent>
-#include <QtCore/QMimeData>
-#include <QtCore/QDir>
-#include <QtCore/QTimer>
-#include <QtSvg/QSvgGenerator>
-
-#ifndef Q_MOC_RUN
-#include "Base.h"
-#include "Common.h"
-#include "GraphicsVertexItem.h"
-#include "GraphicsCellItem.h"
-#include "GraphicsPathItem.h"
-#endif // Q_MOC_RUN
-
-//------------------------------------------------------------------------------
-//	Defining Macros
-//------------------------------------------------------------------------------
-
-namespace Ui{
-
-    //------------------------------------------------------------------------------
-    //	Class definition
-    //------------------------------------------------------------------------------
-    class GraphicsView : public QGraphicsView
-    {
-        Q_OBJECT
-
-    private:
-
-        //------------------------------------------------------------------------------
-        //	UI
-        //------------------------------------------------------------------------------
-
-
-        //------------------------------------------------------------------------------
-        //	Special functions
-        //------------------------------------------------------------------------------
-//        virtual void _init              ( void ) = 0;
-//	    virtual void _clear             ( void ) = 0;
-
-    protected:
-	
-	    // picking testing
-	    QPainterPath                    _selectionArea;
-	
-	    //------------------------------------------------------------------------------
-	    //	UI
-	    //------------------------------------------------------------------------------
-	    double                          _min_point_distance;
-	
-	    QPoint                          _oldCursor, _cursor;
-	    bool                            _left_button_pressed,
-				                        _middle_button_pressed,
-									    _right_button_pressed;
-	    double                          _wheel_scale;
-	
-	    //------------------------------------------------------------------------------
-	    //	Data
-	    //------------------------------------------------------------------------------
-	    // scene
-	    QGraphicsScene                  *_scenePtr;
-	    KeiRo::Base::Base               *_basePtr;
-	    
-	    //------------------------------------------------------------------------------
-        //	Event handlers
-        //------------------------------------------------------------------------------
-//	    void keyPressEvent      ( QKeyEvent *event )    Q_DECL_OVERRIDE;
-//	    void mousePressEvent    ( QMouseEvent *event )  Q_DECL_OVERRIDE;
-//	    void mouseMoveEvent     ( QMouseEvent *event )  Q_DECL_OVERRIDE;
-//	    void mouseReleaseEvent  ( QMouseEvent *event )  Q_DECL_OVERRIDE;
-	
-	    //------------------------------------------------------------------------------
-        //	Drawing functions
-        //------------------------------------------------------------------------------
-
-
-        //------------------------------------------------------------------------------
-        //	Special functions
-        //------------------------------------------------------------------------------
-        virtual void _readInputData( void ) = 0;
-        
-    public:
-
-        //settings
-        // QWidget* getSettings() override;
-
-        //------------------------------------------------------------------------------
-        //	Constructors & Destructors
-        //------------------------------------------------------------------------------
-        // default constructor
-        explicit GraphicsView( QWidget *parent = Q_NULLPTR );
-        // copy constructor
-        explicit GraphicsView( GraphicsView *parent = Q_NULLPTR ) {}
-        // destructor
-        ~GraphicsView( void ) {}
-
-        //------------------------------------------------------------------------------
-        //      Reimplementation
-        //------------------------------------------------------------------------------
-
-        //------------------------------------------------------------------------------
-        //      Reference to elements
-        //------------------------------------------------------------------------------
-
-        //------------------------------------------------------------------------------
-        //	    Special functions
-        //------------------------------------------------------------------------------
-	
-	    virtual void init               ( KeiRo::Base::Base *__b_ptr ) = 0;
-        virtual void initSceneItems     ( void ) = 0;
-        virtual void updateSceneItems   ( void ) = 0;
-	
-	    void simulateKey        ( Qt::Key key );
-        void exportPNG ( double x, double y, double w, double h );
-        void exportSVG ( double x, double y, double w, double h );
-
-        //------------------------------------------------------------------------------
-        //	I/O functions
-        //------------------------------------------------------------------------------
-        // output
-        friend ostream &	operator << ( ostream & s, const GraphicsView & m );
-        // input
-        friend istream &	operator >> ( istream & s, GraphicsView & m );
-        // class name
-        virtual const char * className( void ) const { return "GraphicsView"; }
-        
-    Q_SIGNALS:
-	
-	    virtual void dataInitialized() = 0;
-	    virtual void dataChanged() = 0;
-     
-    public Q_SLOTS:
-
-    };
-
-} // namespace Ui
-
-#endif // Ui_Vector_GraphicsView_H
Index: UI/src/GraphicsBase.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// GraphicsBase.h\r\n//\t: header file for base items\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: The Dec 20 10:48:37 2020\r\n//\r\n//******************************************************************************\r\n\r\n#ifndef Ui_Vector_GraphicsBase_H\r\n#define Ui_Vector_GraphicsBase_H\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <QtGui/QPainter>\r\n#include <QtCore/QString>\r\n#include <QtCore/QDebug>\r\n\r\n#ifndef Q_MOC_RUN\r\n#endif // Q_MOC_RUN\r\n\r\nnamespace Ui {\r\nnamespace Vector {\r\n\t\r\n\t//------------------------------------------------------------------------------\r\n\t//\tClass definition\r\n\t//------------------------------------------------------------------------------\r\n\tclass GraphicsBase {\r\n\r\n\tprivate:\r\n\t\r\n\tprotected:\r\n\t\t\r\n\t\t// graphics item\r\n\t\tunsigned int    _id;\r\n\t\tdouble          _weight;\r\n\t\tQString         _name;          // object name\r\n\t\t\r\n\t\t// associated text\r\n\t\tQString         _text;          // shown object name, usually a acronym of _name\r\n\t\tbool            _textOn;\r\n\t\tQFont           _font;\r\n\t\tQPen            _textpen;\r\n\t\t\r\n\t\t//------------------------------------------------------------------------------\r\n\t\t//\tSpecial functions\r\n\t\t//------------------------------------------------------------------------------\r\n\t\tvoid            _init( void );\r\n\t\t\r\n\tpublic:\r\n\t\t\r\n\t\t//------------------------------------------------------------------------------\r\n\t\t//\tConstructors & Destructors\r\n\t\t//------------------------------------------------------------------------------\r\n\t\t// default constructor\r\n\t\texplicit GraphicsBase( void ) {\r\n\t\t\t_init();\r\n\t\t}\r\n\t\t\r\n\t\t// parameterized constructor\r\n\t\t\r\n\t\t// copy constructor\r\n\t\texplicit GraphicsBase( GraphicsBase &o );\r\n\t\t\r\n\t\t// destructor\r\n\t\t~GraphicsBase( void ) {}\r\n\t\t\r\n\t\t//------------------------------------------------------------------------------\r\n\t\t//      Reference to elements\r\n\t\t//------------------------------------------------------------------------------\r\n\t\tunsigned int &id( void ) { return _id; }\r\n\t\t\r\n\t\tconst unsigned int &id( void ) const { return _id; }\r\n\t\t\r\n\t\tdouble &weight( void ) { return _weight; }\r\n\r\n\t\tconst double &weight( void ) const { return _weight; }\r\n\t\t\r\n\t\tQString &name( void ) { return _name; }\r\n\t\t\r\n\t\tconst QString &name( void ) const { return _name; }\r\n\t\t\r\n\t\tQString &text( void ) { return _text; }\r\n\t\t\r\n\t\tconst QString &text( void ) const { return _text; }\r\n\t\t\r\n\t\tbool &textOn( void ) { return _textOn; }\r\n\t\t\r\n\t\tconst bool &textOn( void ) const { return _textOn; }\r\n\t\t\r\n\t\tQFont &font( void ) { return _font; }\r\n\t\t\r\n\t\tconst QFont &font( void ) const { return _font; }\r\n\t\t\r\n\t\tQPen &textpen( void ) { return _textpen; }\r\n\t\t\r\n\t\tconst QPen &textpen( void ) const { return _textpen; }\r\n\t\t\r\n\t\t//------------------------------------------------------------------------------\r\n\t\t//\tSpecial functions\r\n\t\t//------------------------------------------------------------------------------\r\n\t\tvoid init( void ) { _init(); }\r\n\t\t\r\n\t};\r\n}\r\n} // namespace Ui\r\n\r\n#endif // Ui_Vector_GraphicsBase_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/UI/src/GraphicsBase.h b/UI/src/GraphicsBase.h
--- a/UI/src/GraphicsBase.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/UI/src/GraphicsBase.h	(date 1729410605470)
@@ -1,111 +1,0 @@
-//******************************************************************************
-// GraphicsBase.h
-//	: header file for base items
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: The Dec 20 10:48:37 2020
-//
-//******************************************************************************
-
-#ifndef Ui_Vector_GraphicsBase_H
-#define Ui_Vector_GraphicsBase_H
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <QtGui/QPainter>
-#include <QtCore/QString>
-#include <QtCore/QDebug>
-
-#ifndef Q_MOC_RUN
-#endif // Q_MOC_RUN
-
-namespace Ui {
-namespace Vector {
-	
-	//------------------------------------------------------------------------------
-	//	Class definition
-	//------------------------------------------------------------------------------
-	class GraphicsBase {
-
-	private:
-	
-	protected:
-		
-		// graphics item
-		unsigned int    _id;
-		double          _weight;
-		QString         _name;          // object name
-		
-		// associated text
-		QString         _text;          // shown object name, usually a acronym of _name
-		bool            _textOn;
-		QFont           _font;
-		QPen            _textpen;
-		
-		//------------------------------------------------------------------------------
-		//	Special functions
-		//------------------------------------------------------------------------------
-		void            _init( void );
-		
-	public:
-		
-		//------------------------------------------------------------------------------
-		//	Constructors & Destructors
-		//------------------------------------------------------------------------------
-		// default constructor
-		explicit GraphicsBase( void ) {
-			_init();
-		}
-		
-		// parameterized constructor
-		
-		// copy constructor
-		explicit GraphicsBase( GraphicsBase &o );
-		
-		// destructor
-		~GraphicsBase( void ) {}
-		
-		//------------------------------------------------------------------------------
-		//      Reference to elements
-		//------------------------------------------------------------------------------
-		unsigned int &id( void ) { return _id; }
-		
-		const unsigned int &id( void ) const { return _id; }
-		
-		double &weight( void ) { return _weight; }
-
-		const double &weight( void ) const { return _weight; }
-		
-		QString &name( void ) { return _name; }
-		
-		const QString &name( void ) const { return _name; }
-		
-		QString &text( void ) { return _text; }
-		
-		const QString &text( void ) const { return _text; }
-		
-		bool &textOn( void ) { return _textOn; }
-		
-		const bool &textOn( void ) const { return _textOn; }
-		
-		QFont &font( void ) { return _font; }
-		
-		const QFont &font( void ) const { return _font; }
-		
-		QPen &textpen( void ) { return _textpen; }
-		
-		const QPen &textpen( void ) const { return _textpen; }
-		
-		//------------------------------------------------------------------------------
-		//	Special functions
-		//------------------------------------------------------------------------------
-		void init( void ) { _init(); }
-		
-	};
-}
-} // namespace Ui
-
-#endif // Ui_Vector_GraphicsBase_H
Index: UI/src/GraphicsCellItem.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// GraphicsCellItem.h\r\n//\t: header file for vertex items\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Jun 19 02:36:37 2019\r\n//\r\n//******************************************************************************\r\n\r\n#ifndef Ui_Vector_GraphicsCellItem_H\r\n#define Ui_Vector_GraphicsCellItem_H\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <iostream>\r\n#include <iomanip>\r\n#include <fstream>\r\n#include <map>\r\n#include <list>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <cmath>\r\n#include <ctime>\r\n#include <cstdlib>\r\n#include <cassert>\r\n\r\nusing namespace std;\r\n\r\n#include <QtWidgets/QGraphicsScene>\r\n#include <QtWidgets/QGraphicsItem>\r\n#include <QtCore/QObject>\r\n\r\n#ifndef Q_MOC_RUN\r\n#include \"GraphicsBase.h\"\r\n#endif // Q_MOC_RUN\r\n\r\n\r\nnamespace Ui {\r\nnamespace Vector {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tClass definition\r\n    //------------------------------------------------------------------------------\r\n    class GraphicsCellItem : public QObject, public  QGraphicsRectItem, public GraphicsBase {\r\n\r\n    Q_OBJECT\r\n    Q_PROPERTY( QRectF geometry READ geometry WRITE setGeometry )\r\n    Q_INTERFACES( QGraphicsItem )\r\n    \r\n    private:\r\n\t\r\n\t    QRectF   _sourceRect;\r\n    \tQRectF   _targetRect;\r\n\r\n        QRect           _bbox;\r\n\t    unsigned long   _attributeID;\r\n\r\n    protected:\r\n\t    \r\n    \t//------------------------------------------------------------------------------\r\n\t    //\tSpecial functions\r\n\t    //------------------------------------------------------------------------------\r\n\t    void            _init( void );\r\n\t    \r\n    public:\r\n        QRect &\t                bbox( void )        { return _bbox; }\r\n        const QRect &\t        bbox( void ) const\t{ return _bbox; }\r\n\t\r\n\t    unsigned long &\t        attributeID( void )         { return _attributeID; }\r\n\t    const unsigned long &\tattributeID( void ) const\t{ return _attributeID; }\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tConstructors & Destructors\r\n        //------------------------------------------------------------------------------\r\n        // default constructor\r\n        explicit GraphicsCellItem( QGraphicsItem *parent = Q_NULLPTR );\r\n        // parameterized constructor\r\n        explicit GraphicsCellItem( qreal x, qreal y, qreal w, qreal h, QGraphicsItem *parent = Q_NULLPTR );\r\n        // copy constructor\r\n        explicit GraphicsCellItem( const QRectF &rect, QGraphicsItem *parent = Q_NULLPTR );\r\n        // destructor\r\n        ~GraphicsCellItem( void ) {}\r\n\r\n        // source from the qt library\r\n        //QRectF rect() const;\r\n        //void setRect(const QRectF &rect);\r\n        //inline void setRect(qreal x, qreal y, qreal w, qreal h);\r\n\r\n        //QPainterPath shape() const Q_DECL_OVERRIDE;\r\n        //bool contains(const QPointF &point) const Q_DECL_OVERRIDE;\r\n\r\n        //bool isObscuredBy(const QGraphicsItem *item) const Q_DECL_OVERRIDE;\r\n        //QPainterPath opaqueArea() const Q_DECL_OVERRIDE;\r\n\r\n        //------------------------------------------------------------------------------\r\n        //      Reimplementation\r\n        //------------------------------------------------------------------------------\r\n        QRectF boundingRect() const Q_DECL_OVERRIDE;\r\n        int type( void ) const Q_DECL_OVERRIDE;\r\n\r\n        void paint( QPainter *painter, const QStyleOptionGraphicsItem *option,\r\n                    QWidget *widget = Q_NULLPTR ) Q_DECL_OVERRIDE;\r\n\r\n        //------------------------------------------------------------------------------\r\n        //      Reference to elements\r\n        //------------------------------------------------------------------------------\r\n        QRectF &sourceRect( void ) { return _sourceRect; }\r\n\t\r\n\t    const QRectF &sourceRect( void ) const { return _sourceRect; }\r\n\t\r\n\t    QRectF &targetRect( void ) { return _targetRect; }\r\n\t\r\n\t    const QRectF &targetRect( void ) const { return _targetRect; }\r\n\r\n\t    //------------------------------------------------------------------------------\r\n\t    //\tSpecial functions\r\n\t    //------------------------------------------------------------------------------\r\n\t    void init( void ) { _init(); }\r\n\r\n\t    QRectF geometry( void ) const {\r\n        \treturn _sourceRect;\r\n        }\r\n\r\n\t    void setGeometry( const QRectF &value ) {\r\n      \r\n\t\t    if( _sourceRect != value ){\r\n\t\t\t    _sourceRect = value;\r\n\t\t\t    setRect( value );\r\n\t\t\t    update();\r\n\t\t    }\r\n        }\r\n\r\n    private:\r\n\r\n    };\r\n\r\n} // namespace Vector\r\n} // namespace Ui\r\n\r\n#endif // Ui_Vector_GraphicsCellItem_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/UI/src/GraphicsCellItem.h b/UI/src/GraphicsCellItem.h
--- a/UI/src/GraphicsCellItem.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/UI/src/GraphicsCellItem.h	(date 1729410605480)
@@ -1,143 +1,0 @@
-//******************************************************************************
-// GraphicsCellItem.h
-//	: header file for vertex items
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Jun 19 02:36:37 2019
-//
-//******************************************************************************
-
-#ifndef Ui_Vector_GraphicsCellItem_H
-#define Ui_Vector_GraphicsCellItem_H
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <iostream>
-#include <iomanip>
-#include <fstream>
-#include <map>
-#include <list>
-#include <vector>
-#include <algorithm>
-#include <cmath>
-#include <ctime>
-#include <cstdlib>
-#include <cassert>
-
-using namespace std;
-
-#include <QtWidgets/QGraphicsScene>
-#include <QtWidgets/QGraphicsItem>
-#include <QtCore/QObject>
-
-#ifndef Q_MOC_RUN
-#include "GraphicsBase.h"
-#endif // Q_MOC_RUN
-
-
-namespace Ui {
-namespace Vector {
-
-    //------------------------------------------------------------------------------
-    //	Class definition
-    //------------------------------------------------------------------------------
-    class GraphicsCellItem : public QObject, public  QGraphicsRectItem, public GraphicsBase {
-
-    Q_OBJECT
-    Q_PROPERTY( QRectF geometry READ geometry WRITE setGeometry )
-    Q_INTERFACES( QGraphicsItem )
-    
-    private:
-	
-	    QRectF   _sourceRect;
-    	QRectF   _targetRect;
-
-        QRect           _bbox;
-	    unsigned long   _attributeID;
-
-    protected:
-	    
-    	//------------------------------------------------------------------------------
-	    //	Special functions
-	    //------------------------------------------------------------------------------
-	    void            _init( void );
-	    
-    public:
-        QRect &	                bbox( void )        { return _bbox; }
-        const QRect &	        bbox( void ) const	{ return _bbox; }
-	
-	    unsigned long &	        attributeID( void )         { return _attributeID; }
-	    const unsigned long &	attributeID( void ) const	{ return _attributeID; }
-
-        //------------------------------------------------------------------------------
-        //	Constructors & Destructors
-        //------------------------------------------------------------------------------
-        // default constructor
-        explicit GraphicsCellItem( QGraphicsItem *parent = Q_NULLPTR );
-        // parameterized constructor
-        explicit GraphicsCellItem( qreal x, qreal y, qreal w, qreal h, QGraphicsItem *parent = Q_NULLPTR );
-        // copy constructor
-        explicit GraphicsCellItem( const QRectF &rect, QGraphicsItem *parent = Q_NULLPTR );
-        // destructor
-        ~GraphicsCellItem( void ) {}
-
-        // source from the qt library
-        //QRectF rect() const;
-        //void setRect(const QRectF &rect);
-        //inline void setRect(qreal x, qreal y, qreal w, qreal h);
-
-        //QPainterPath shape() const Q_DECL_OVERRIDE;
-        //bool contains(const QPointF &point) const Q_DECL_OVERRIDE;
-
-        //bool isObscuredBy(const QGraphicsItem *item) const Q_DECL_OVERRIDE;
-        //QPainterPath opaqueArea() const Q_DECL_OVERRIDE;
-
-        //------------------------------------------------------------------------------
-        //      Reimplementation
-        //------------------------------------------------------------------------------
-        QRectF boundingRect() const Q_DECL_OVERRIDE;
-        int type( void ) const Q_DECL_OVERRIDE;
-
-        void paint( QPainter *painter, const QStyleOptionGraphicsItem *option,
-                    QWidget *widget = Q_NULLPTR ) Q_DECL_OVERRIDE;
-
-        //------------------------------------------------------------------------------
-        //      Reference to elements
-        //------------------------------------------------------------------------------
-        QRectF &sourceRect( void ) { return _sourceRect; }
-	
-	    const QRectF &sourceRect( void ) const { return _sourceRect; }
-	
-	    QRectF &targetRect( void ) { return _targetRect; }
-	
-	    const QRectF &targetRect( void ) const { return _targetRect; }
-
-	    //------------------------------------------------------------------------------
-	    //	Special functions
-	    //------------------------------------------------------------------------------
-	    void init( void ) { _init(); }
-
-	    QRectF geometry( void ) const {
-        	return _sourceRect;
-        }
-
-	    void setGeometry( const QRectF &value ) {
-      
-		    if( _sourceRect != value ){
-			    _sourceRect = value;
-			    setRect( value );
-			    update();
-		    }
-        }
-
-    private:
-
-    };
-
-} // namespace Vector
-} // namespace Ui
-
-#endif // Ui_Vector_GraphicsCellItem_H
Index: UI/src/GraphicsVertexItem.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// GraphicsVertexItem.h\r\n//\t: header file for vertex items\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Jun 19 02:36:37 2019\r\n//\r\n//******************************************************************************\r\n\r\n#ifndef Ui_Vector_GraphicsVertexItem_H\r\n#define Ui_Vector_GraphicsVertexItem_H\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include <iostream>\r\n#include <iomanip>\r\n#include <fstream>\r\n#include <map>\r\n#include <list>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <cmath>\r\n#include <ctime>\r\n#include <cstdlib>\r\n#include <cassert>\r\n\r\nusing namespace std;\r\n\r\n#include <QtWidgets/QGraphicsScene>\r\n#include <QtWidgets/QGraphicsItem>\r\n\r\n#ifndef Q_MOC_RUN\r\n#include \"GraphicsBase.h\"\r\n#endif // Q_MOC_RUN\r\n\r\n\r\nnamespace Ui {\r\nnamespace Vector {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tClass definition\r\n    //------------------------------------------------------------------------------\r\n    class GraphicsVertexItem : public QObject, public  QGraphicsRectItem, public GraphicsBase {\r\n\r\n    Q_OBJECT\r\n    Q_PROPERTY( QRectF geometry READ geometry WRITE setGeometry )\r\n    Q_INTERFACES( QGraphicsItem )\r\n\t   \r\n    private:\r\n\t\r\n\t    QRectF   _sourceRect;\r\n\t    QRectF   _intermediateRect;\r\n\t    QRectF   _targetRect;\r\n\t\r\n\t    double          _radius;\r\n        bool            _isSimple;\r\n\r\n    protected:\r\n\t    \r\n    \t//------------------------------------------------------------------------------\r\n\t    //\tSpecial functions\r\n\t    //------------------------------------------------------------------------------\r\n\t    void            _init( void );\r\n\t    \r\n    public:\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tConstructors & Destructors\r\n        //------------------------------------------------------------------------------\r\n        // default constructor\r\n        explicit GraphicsVertexItem( QGraphicsItem *parent = Q_NULLPTR );\r\n        // parameterized constructor\r\n        explicit GraphicsVertexItem( qreal x, qreal y, qreal w, qreal h, QGraphicsItem *parent = Q_NULLPTR );\r\n        // copy constructor\r\n        explicit GraphicsVertexItem( const QRectF &rect, QGraphicsItem *parent = Q_NULLPTR );\r\n        // destructor\r\n        ~GraphicsVertexItem( void ) {}\r\n\r\n        // source from the qt library\r\n        //QRectF rect() const;\r\n        //void setRect(const QRectF &rect);\r\n        //inline void setRect(qreal x, qreal y, qreal w, qreal h);\r\n\r\n        //QPainterPath shape() const Q_DECL_OVERRIDE;\r\n        //bool contains(const QPointF &point) const Q_DECL_OVERRIDE;\r\n\r\n        //bool isObscuredBy(const QGraphicsItem *item) const Q_DECL_OVERRIDE;\r\n        //QPainterPath opaqueArea() const Q_DECL_OVERRIDE;\r\n\r\n        //------------------------------------------------------------------------------\r\n        //      Reimplementation\r\n        //------------------------------------------------------------------------------\r\n        QRectF boundingRect() const Q_DECL_OVERRIDE;\r\n        int type( void ) const Q_DECL_OVERRIDE;\r\n\r\n        void paint( QPainter *painter, const QStyleOptionGraphicsItem *option,\r\n                    QWidget *widget = Q_NULLPTR ) Q_DECL_OVERRIDE;\r\n\r\n        //------------------------------------------------------------------------------\r\n        //      Reference to elements\r\n        //------------------------------------------------------------------------------\r\n        bool &isSimple( void ) { return _isSimple; }\r\n\t\r\n\t    const bool &isSimple( void ) const { return _isSimple; }\r\n\t\r\n\t    double &radius( void ) { return _radius; }\r\n\t\r\n\t    const double &radius( void ) const { return _radius; }\r\n\r\n\t    QRectF &sourceRect( void ) { return _sourceRect; }\r\n\t\r\n\t    const QRectF &sourceRect( void ) const { return _sourceRect; }\r\n\t\r\n\t    QRectF &intermediateRect( void ) { return _intermediateRect; }\r\n\t\r\n\t    const QRectF &intermediateRect( void ) const { return _intermediateRect; }\r\n\t    \r\n\t    QRectF &targetRect( void ) { return _targetRect; }\r\n\t\r\n\t    const QRectF &targetRect( void ) const { return _targetRect; }\r\n\t    \r\n\t    //------------------------------------------------------------------------------\r\n\t    //\tSpecial functions\r\n\t    //------------------------------------------------------------------------------\r\n\t    void init( void ) { _init(); }\r\n\t\r\n\t    QRectF geometry( void ) const {\r\n\t\t    return _sourceRect;\r\n\t    }\r\n\t\r\n\t    void setGeometry( const QRectF &value ) {\r\n\t\t\r\n\t\t    if( _sourceRect != value ){\r\n\t\t\t    _sourceRect = value;\r\n\t\t\t    setRect( value );\r\n\t\t\t    update();\r\n\t\t    }\r\n\t    }\r\n\t    \r\n    private:\r\n\r\n    };\r\n\r\n} // namespace Vector\r\n} // namespace Ui\r\n\r\n#endif // Ui_Vector_GraphicsVertexItem_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/UI/src/GraphicsVertexItem.h b/UI/src/GraphicsVertexItem.h
--- a/UI/src/GraphicsVertexItem.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/UI/src/GraphicsVertexItem.h	(date 1729410605490)
@@ -1,150 +1,0 @@
-//******************************************************************************
-// GraphicsVertexItem.h
-//	: header file for vertex items
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Jun 19 02:36:37 2019
-//
-//******************************************************************************
-
-#ifndef Ui_Vector_GraphicsVertexItem_H
-#define Ui_Vector_GraphicsVertexItem_H
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-
-#include <iostream>
-#include <iomanip>
-#include <fstream>
-#include <map>
-#include <list>
-#include <vector>
-#include <algorithm>
-#include <cmath>
-#include <ctime>
-#include <cstdlib>
-#include <cassert>
-
-using namespace std;
-
-#include <QtWidgets/QGraphicsScene>
-#include <QtWidgets/QGraphicsItem>
-
-#ifndef Q_MOC_RUN
-#include "GraphicsBase.h"
-#endif // Q_MOC_RUN
-
-
-namespace Ui {
-namespace Vector {
-
-    //------------------------------------------------------------------------------
-    //	Class definition
-    //------------------------------------------------------------------------------
-    class GraphicsVertexItem : public QObject, public  QGraphicsRectItem, public GraphicsBase {
-
-    Q_OBJECT
-    Q_PROPERTY( QRectF geometry READ geometry WRITE setGeometry )
-    Q_INTERFACES( QGraphicsItem )
-	   
-    private:
-	
-	    QRectF   _sourceRect;
-	    QRectF   _intermediateRect;
-	    QRectF   _targetRect;
-	
-	    double          _radius;
-        bool            _isSimple;
-
-    protected:
-	    
-    	//------------------------------------------------------------------------------
-	    //	Special functions
-	    //------------------------------------------------------------------------------
-	    void            _init( void );
-	    
-    public:
-
-        //------------------------------------------------------------------------------
-        //	Constructors & Destructors
-        //------------------------------------------------------------------------------
-        // default constructor
-        explicit GraphicsVertexItem( QGraphicsItem *parent = Q_NULLPTR );
-        // parameterized constructor
-        explicit GraphicsVertexItem( qreal x, qreal y, qreal w, qreal h, QGraphicsItem *parent = Q_NULLPTR );
-        // copy constructor
-        explicit GraphicsVertexItem( const QRectF &rect, QGraphicsItem *parent = Q_NULLPTR );
-        // destructor
-        ~GraphicsVertexItem( void ) {}
-
-        // source from the qt library
-        //QRectF rect() const;
-        //void setRect(const QRectF &rect);
-        //inline void setRect(qreal x, qreal y, qreal w, qreal h);
-
-        //QPainterPath shape() const Q_DECL_OVERRIDE;
-        //bool contains(const QPointF &point) const Q_DECL_OVERRIDE;
-
-        //bool isObscuredBy(const QGraphicsItem *item) const Q_DECL_OVERRIDE;
-        //QPainterPath opaqueArea() const Q_DECL_OVERRIDE;
-
-        //------------------------------------------------------------------------------
-        //      Reimplementation
-        //------------------------------------------------------------------------------
-        QRectF boundingRect() const Q_DECL_OVERRIDE;
-        int type( void ) const Q_DECL_OVERRIDE;
-
-        void paint( QPainter *painter, const QStyleOptionGraphicsItem *option,
-                    QWidget *widget = Q_NULLPTR ) Q_DECL_OVERRIDE;
-
-        //------------------------------------------------------------------------------
-        //      Reference to elements
-        //------------------------------------------------------------------------------
-        bool &isSimple( void ) { return _isSimple; }
-	
-	    const bool &isSimple( void ) const { return _isSimple; }
-	
-	    double &radius( void ) { return _radius; }
-	
-	    const double &radius( void ) const { return _radius; }
-
-	    QRectF &sourceRect( void ) { return _sourceRect; }
-	
-	    const QRectF &sourceRect( void ) const { return _sourceRect; }
-	
-	    QRectF &intermediateRect( void ) { return _intermediateRect; }
-	
-	    const QRectF &intermediateRect( void ) const { return _intermediateRect; }
-	    
-	    QRectF &targetRect( void ) { return _targetRect; }
-	
-	    const QRectF &targetRect( void ) const { return _targetRect; }
-	    
-	    //------------------------------------------------------------------------------
-	    //	Special functions
-	    //------------------------------------------------------------------------------
-	    void init( void ) { _init(); }
-	
-	    QRectF geometry( void ) const {
-		    return _sourceRect;
-	    }
-	
-	    void setGeometry( const QRectF &value ) {
-		
-		    if( _sourceRect != value ){
-			    _sourceRect = value;
-			    setRect( value );
-			    update();
-		    }
-	    }
-	    
-    private:
-
-    };
-
-} // namespace Vector
-} // namespace Ui
-
-#endif // Ui_Vector_GraphicsVertexItem_H
Index: UI/src/MainWindow.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// MainWindow.h\r\n//\t: header file for main window\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Jun 19 02:36:37 2019\r\n//\r\n//******************************************************************************\r\n\r\n#ifndef Ui_MainWindow_H\r\n#define Ui_MainWindow_H\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n#include \"istream\"\r\n\r\n#include <QtWidgets/QMenu>\r\n#include <QtWidgets/QMenuBar>\r\n#include <QtWidgets/QMainWindow>\r\n#include <QtWidgets>\r\n\r\nQT_BEGIN_NAMESPACE\r\n//class QAction;\r\n//class QMenu;\r\nQT_END_NAMESPACE\r\n\r\n#ifndef Q_MOC_RUN\r\n#include \"GraphicsView.h\"\r\n#include \"Config.h\"\r\n#endif // Q_MOC_RUN\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining Macros\r\n//------------------------------------------------------------------------------\r\n\r\nnamespace Ui {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tClass definition\r\n    //------------------------------------------------------------------------------\r\n    class MainWindow : public QMainWindow\r\n    {\r\n        Q_OBJECT\r\n\r\n    private:\r\n\t\r\n\t    KeiRo::Base::Base                           *_basePtr;\r\n\t    \r\n        // setup timer\r\n\t    QTimer                                      *_timerptr;\r\n\t    \r\n    private:\r\n\r\n        GraphicsView                                *_mainGV;\r\n\t    QDockWidget                                 *_settingsDock;\r\n\t    QDockWidget                                 *_interactionDock;\r\n        QWidget                                     *_setting;\r\n\t    GraphicsView                                *_interaction;\r\n        QMenu                                       *_viewMenu;\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tSpecial functions\r\n        //------------------------------------------------------------------------------\r\n        template <class T1, class T2, class T3> void _init  ( T1 *__mvPtr = NULL, T2 *__setPtr = NULL, T3 *__interactPtr = NULL ){\r\n        \t\r\n\t        _createMainView( __mvPtr );\r\n\t\r\n\t        _createActions();\r\n\t        _createStatusBar();\r\n\t        _createDockWindows( __setPtr, __interactPtr );\r\n\t\r\n\t        setWindowTitle( tr(\"KeiRo\") );\r\n\t        setMouseTracking( false );\r\n\t        setUnifiedTitleAndToolBarOnMac(true );\r\n        }\r\n        void _createActions     ( void );\r\n        void _createStatusBar   ( void );\r\n\t    template <class T> void _createMainView( T *__mvPtr ){\r\n\t\t\r\n\t\t    _mainGV = __mvPtr;\r\n\t\t    // _mainGV = new Ui::GraphicsView( this );\r\n\t\t    _mainGV->setStyleSheet(\"background: white; border: transparent;\");\r\n\t\t    _mainGV->setGeometry( QRect( 0, 0, KeiRo::Base::Common::getDockWidgetWidth(),\r\n\t\t                                 KeiRo::Base::Common::getMainwidgetHeight() ) );\r\n\t\t    _mainGV->setMinimumSize( QSize( KeiRo::Base::Common::getDockWidgetWidth(),\r\n\t\t                                    KeiRo::Base::Common::getMainwidgetHeight() ) );\r\n\t\t    _mainGV->setMouseTracking( true );\r\n//\t\t    _mainGV->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);\r\n//\t\t    _mainGV->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);\r\n\t\t    _mainGV->init( _basePtr );\r\n\t\t    _mainGV->initSceneItems();\r\n\t\t\r\n\t\t    setCentralWidget( _mainGV );\r\n\t    }\r\n\t    \r\n\t    template <class T1, class T2> void _createDockWindows ( T1 *__setPtr = NULL, T2 *__interactPtr = NULL ){\r\n\t    \t\r\n\t    \t// setting\r\n\t\t    _settingsDock = new QDockWidget(tr(\"Setting\"), this );\r\n\t\t    _settingsDock->setAllowedAreas( Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);\r\n\t\t\r\n\t\t    _setting = __setPtr;\r\n\t\t    _setting->setGeometry( QRect(0,0,KeiRo::Base::Common::getDockWidgetWidth(),\r\n\t\t                                 KeiRo::Base::Common::getMainwidgetHeight()/2.0 ) );\r\n\t\t    _setting->setMinimumSize( QSize( KeiRo::Base::Common::getDockWidgetWidth(),\r\n\t\t                                     KeiRo::Base::Common::getMainwidgetHeight()/3.0 ) );\r\n//\t    _setting->setMaximumSize( QSize( KeiRo::Base::Common::getDockWidgetWidth(),\r\n//\t                                     KeiRo::Base::Common::getMainwidgetHeight()/3.0 ) );\r\n//        _setting->setMouseTracking( false );\r\n\t\t    _settingsDock->setWidget( _setting );\r\n\t\t    addDockWidget(Qt::RightDockWidgetArea, _settingsDock );\r\n\t\t    _viewMenu->addAction(_settingsDock->toggleViewAction() );\r\n\t\t\r\n\t\t\r\n\t\t    // interaction\r\n\t\t    _interactionDock = new QDockWidget(tr(\"Interaction\"), this );\r\n\t\t    _interactionDock->setAllowedAreas( Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);\r\n\t\t\r\n\t\t    _interaction = __interactPtr;\r\n\t\t    _interaction->setGeometry( QRect(0,0,KeiRo::Base::Common::getDockWidgetWidth(),\r\n\t\t                                     KeiRo::Base::Common::getDockWidgetWidth()*KeiRo::Base::Common::getMainwidgetHeight()/KeiRo::Base::Common::getMainwidgetWidth() ) );\r\n\t\t    _interaction->setMinimumSize( QSize( KeiRo::Base::Common::getDockWidgetWidth(),\r\n\t\t                                         KeiRo::Base::Common::getDockWidgetWidth()*KeiRo::Base::Common::getMainwidgetHeight()/KeiRo::Base::Common::getMainwidgetWidth() ) );\r\n\t\t    _interaction->setMaximumSize( QSize( KeiRo::Base::Common::getDockWidgetWidth(),\r\n\t\t                                         KeiRo::Base::Common::getDockWidgetWidth()*KeiRo::Base::Common::getMainwidgetHeight()/KeiRo::Base::Common::getMainwidgetWidth() ) );\r\n//        _interaction->setMouseTracking( false );\r\n\t\t\t_interaction->init( _basePtr );\r\n\t\t\r\n\t\t    _interactionDock->setWidget( _interaction );\r\n\t\t    addDockWidget(Qt::RightDockWidgetArea, _interactionDock );\r\n\t\t    _viewMenu->addAction( _interactionDock->toggleViewAction() );\r\n\t\t\r\n//\t        connect( _setting, &QWidget::windowIconChanged, this, &MainWindow::_updateSetting );\r\n//\t        connect( _interaction, &QWidget::windowIconChanged, this, &MainWindow::_updateInteraction );\r\n\t    }\r\n\r\n        void setSettings(QWidget* settingsWidget);\r\n\t    void setInteraction(QWidget* interactionWidget);\r\n\r\n    protected:\r\n\r\n        void mouseMoveEvent     ( QMouseEvent *event )  Q_DECL_OVERRIDE {\r\n#ifdef DEBUG\r\n            cerr << \"#########################\" << endl;\r\n            cerr << \" MainWindow::mouseMoveEvent\" << endl;\r\n            cerr << \"#########################\" << endl;\r\n#endif // DEBUG\r\n        };\r\n\r\n\r\n    public:\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tConstructors & Destructors\r\n        //------------------------------------------------------------------------------\r\n        // default constructor\r\n        explicit MainWindow( QWidget *parent = Q_NULLPTR );\r\n        // destructor\r\n        ~MainWindow( void ) {}\r\n\r\n        //------------------------------------------------------------------------------\r\n        //\tSpecific functions\r\n        //------------------------------------------------------------------------------\r\n        template <class T1, class T2, class T3> void init  ( KeiRo::Base::Base *__bPtr, T1 *__mvPtr = NULL,\r\n        \t\t                                             T2 *__setPtr = NULL, T3 *__interactPtr = NULL ){\r\n\t        _basePtr = __bPtr;\r\n\t        _init( __mvPtr, __setPtr, __interactPtr );\r\n        }\r\n        \r\n\r\n\r\n\t    //------------------------------------------------------------------------------\r\n        //\tI/O functions\r\n        //------------------------------------------------------------------------------\r\n        // output\r\n        friend ostream &\toperator << ( ostream & s, const MainWindow & m );\r\n        // input\r\n        friend istream &\toperator >> ( istream & s, MainWindow & m );\r\n        // class name\r\n        virtual const char * className( void ) const { return \"MainWindow\"; }\r\n\r\n    private slots:\r\n\r\n        void newFile( void );\r\n        void save   ( void );\r\n        void print  ( void );\r\n        void undo   ( void );\r\n        void about  ( void );\r\n\t    void _initAllDocks      ( void );\r\n\t    void _initSetting       ( const QString &setting );\r\n\t    void _initInteraction   ( const QString &interaction );\r\n        void _updateSetting     ( const QString &setting );\r\n        void _updateInteraction ( const QString &interaction );\r\n        void _updateAllDocks    ( void );\r\n        \r\n    public slots:\r\n    \t\r\n\t    void exportPNG( void );\r\n\t\r\n    };\r\n\r\n} // namespace Ui\r\n\r\n#endif // Ui_MainWindow_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/UI/src/MainWindow.h b/UI/src/MainWindow.h
--- a/UI/src/MainWindow.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/UI/src/MainWindow.h	(date 1729410605500)
@@ -1,206 +1,0 @@
-//******************************************************************************
-// MainWindow.h
-//	: header file for main window
-//
-//------------------------------------------------------------------------------
-//
-//	Ver 1.00		Date: Tue Jun 19 02:36:37 2019
-//
-//******************************************************************************
-
-#ifndef Ui_MainWindow_H
-#define Ui_MainWindow_H
-
-//------------------------------------------------------------------------------
-//	Including Header Files
-//------------------------------------------------------------------------------
-#include "istream"
-
-#include <QtWidgets/QMenu>
-#include <QtWidgets/QMenuBar>
-#include <QtWidgets/QMainWindow>
-#include <QtWidgets>
-
-QT_BEGIN_NAMESPACE
-//class QAction;
-//class QMenu;
-QT_END_NAMESPACE
-
-#ifndef Q_MOC_RUN
-#include "GraphicsView.h"
-#include "Config.h"
-#endif // Q_MOC_RUN
-
-//------------------------------------------------------------------------------
-//	Defining Macros
-//------------------------------------------------------------------------------
-
-namespace Ui {
-
-    //------------------------------------------------------------------------------
-    //	Class definition
-    //------------------------------------------------------------------------------
-    class MainWindow : public QMainWindow
-    {
-        Q_OBJECT
-
-    private:
-	
-	    KeiRo::Base::Base                           *_basePtr;
-	    
-        // setup timer
-	    QTimer                                      *_timerptr;
-	    
-    private:
-
-        GraphicsView                                *_mainGV;
-	    QDockWidget                                 *_settingsDock;
-	    QDockWidget                                 *_interactionDock;
-        QWidget                                     *_setting;
-	    GraphicsView                                *_interaction;
-        QMenu                                       *_viewMenu;
-
-        //------------------------------------------------------------------------------
-        //	Special functions
-        //------------------------------------------------------------------------------
-        template <class T1, class T2, class T3> void _init  ( T1 *__mvPtr = NULL, T2 *__setPtr = NULL, T3 *__interactPtr = NULL ){
-        	
-	        _createMainView( __mvPtr );
-	
-	        _createActions();
-	        _createStatusBar();
-	        _createDockWindows( __setPtr, __interactPtr );
-	
-	        setWindowTitle( tr("KeiRo") );
-	        setMouseTracking( false );
-	        setUnifiedTitleAndToolBarOnMac(true );
-        }
-        void _createActions     ( void );
-        void _createStatusBar   ( void );
-	    template <class T> void _createMainView( T *__mvPtr ){
-		
-		    _mainGV = __mvPtr;
-		    // _mainGV = new Ui::GraphicsView( this );
-		    _mainGV->setStyleSheet("background: white; border: transparent;");
-		    _mainGV->setGeometry( QRect( 0, 0, KeiRo::Base::Common::getDockWidgetWidth(),
-		                                 KeiRo::Base::Common::getMainwidgetHeight() ) );
-		    _mainGV->setMinimumSize( QSize( KeiRo::Base::Common::getDockWidgetWidth(),
-		                                    KeiRo::Base::Common::getMainwidgetHeight() ) );
-		    _mainGV->setMouseTracking( true );
-//		    _mainGV->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
-//		    _mainGV->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
-		    _mainGV->init( _basePtr );
-		    _mainGV->initSceneItems();
-		
-		    setCentralWidget( _mainGV );
-	    }
-	    
-	    template <class T1, class T2> void _createDockWindows ( T1 *__setPtr = NULL, T2 *__interactPtr = NULL ){
-	    	
-	    	// setting
-		    _settingsDock = new QDockWidget(tr("Setting"), this );
-		    _settingsDock->setAllowedAreas( Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);
-		
-		    _setting = __setPtr;
-		    _setting->setGeometry( QRect(0,0,KeiRo::Base::Common::getDockWidgetWidth(),
-		                                 KeiRo::Base::Common::getMainwidgetHeight()/2.0 ) );
-		    _setting->setMinimumSize( QSize( KeiRo::Base::Common::getDockWidgetWidth(),
-		                                     KeiRo::Base::Common::getMainwidgetHeight()/3.0 ) );
-//	    _setting->setMaximumSize( QSize( KeiRo::Base::Common::getDockWidgetWidth(),
-//	                                     KeiRo::Base::Common::getMainwidgetHeight()/3.0 ) );
-//        _setting->setMouseTracking( false );
-		    _settingsDock->setWidget( _setting );
-		    addDockWidget(Qt::RightDockWidgetArea, _settingsDock );
-		    _viewMenu->addAction(_settingsDock->toggleViewAction() );
-		
-		
-		    // interaction
-		    _interactionDock = new QDockWidget(tr("Interaction"), this );
-		    _interactionDock->setAllowedAreas( Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);
-		
-		    _interaction = __interactPtr;
-		    _interaction->setGeometry( QRect(0,0,KeiRo::Base::Common::getDockWidgetWidth(),
-		                                     KeiRo::Base::Common::getDockWidgetWidth()*KeiRo::Base::Common::getMainwidgetHeight()/KeiRo::Base::Common::getMainwidgetWidth() ) );
-		    _interaction->setMinimumSize( QSize( KeiRo::Base::Common::getDockWidgetWidth(),
-		                                         KeiRo::Base::Common::getDockWidgetWidth()*KeiRo::Base::Common::getMainwidgetHeight()/KeiRo::Base::Common::getMainwidgetWidth() ) );
-		    _interaction->setMaximumSize( QSize( KeiRo::Base::Common::getDockWidgetWidth(),
-		                                         KeiRo::Base::Common::getDockWidgetWidth()*KeiRo::Base::Common::getMainwidgetHeight()/KeiRo::Base::Common::getMainwidgetWidth() ) );
-//        _interaction->setMouseTracking( false );
-			_interaction->init( _basePtr );
-		
-		    _interactionDock->setWidget( _interaction );
-		    addDockWidget(Qt::RightDockWidgetArea, _interactionDock );
-		    _viewMenu->addAction( _interactionDock->toggleViewAction() );
-		
-//	        connect( _setting, &QWidget::windowIconChanged, this, &MainWindow::_updateSetting );
-//	        connect( _interaction, &QWidget::windowIconChanged, this, &MainWindow::_updateInteraction );
-	    }
-
-        void setSettings(QWidget* settingsWidget);
-	    void setInteraction(QWidget* interactionWidget);
-
-    protected:
-
-        void mouseMoveEvent     ( QMouseEvent *event )  Q_DECL_OVERRIDE {
-#ifdef DEBUG
-            cerr << "#########################" << endl;
-            cerr << " MainWindow::mouseMoveEvent" << endl;
-            cerr << "#########################" << endl;
-#endif // DEBUG
-        };
-
-
-    public:
-
-        //------------------------------------------------------------------------------
-        //	Constructors & Destructors
-        //------------------------------------------------------------------------------
-        // default constructor
-        explicit MainWindow( QWidget *parent = Q_NULLPTR );
-        // destructor
-        ~MainWindow( void ) {}
-
-        //------------------------------------------------------------------------------
-        //	Specific functions
-        //------------------------------------------------------------------------------
-        template <class T1, class T2, class T3> void init  ( KeiRo::Base::Base *__bPtr, T1 *__mvPtr = NULL,
-        		                                             T2 *__setPtr = NULL, T3 *__interactPtr = NULL ){
-	        _basePtr = __bPtr;
-	        _init( __mvPtr, __setPtr, __interactPtr );
-        }
-        
-
-
-	    //------------------------------------------------------------------------------
-        //	I/O functions
-        //------------------------------------------------------------------------------
-        // output
-        friend ostream &	operator << ( ostream & s, const MainWindow & m );
-        // input
-        friend istream &	operator >> ( istream & s, MainWindow & m );
-        // class name
-        virtual const char * className( void ) const { return "MainWindow"; }
-
-    private slots:
-
-        void newFile( void );
-        void save   ( void );
-        void print  ( void );
-        void undo   ( void );
-        void about  ( void );
-	    void _initAllDocks      ( void );
-	    void _initSetting       ( const QString &setting );
-	    void _initInteraction   ( const QString &interaction );
-        void _updateSetting     ( const QString &setting );
-        void _updateInteraction ( const QString &interaction );
-        void _updateAllDocks    ( void );
-        
-    public slots:
-    	
-	    void exportPNG( void );
-	
-    };
-
-} // namespace Ui
-
-#endif // Ui_MainWindow_H
Index: Optimization/src/LaplacianOptimization.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//==============================================================================\r\n// LaplacianOptimization.h\r\n//  : header file for the laplacian optimization\r\n//\r\n//==============================================================================\r\n\r\n#ifndef _LaplacianOptimization_H        // beginning of header file\r\n#define _LaplacianOptimization_H        // notifying that this file is included\r\n\r\n//----------------------------------------------------------------------\r\n//  Including header files\r\n//----------------------------------------------------------------------\r\n\r\n#include <iostream>\r\n#include <iomanip>\r\n#include <eigen3/Eigen/Core>\r\n#include <eigen3/Eigen/Dense>\r\n\r\nusing namespace std;\r\n\r\n#include \"Common.h\"\r\n#include \"Config.h\"\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining data types\r\n//------------------------------------------------------------------------------\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining macros\r\n//------------------------------------------------------------------------------\r\nclass LaplacianOptimization {\r\n\r\nprivate:\r\n\r\nprotected:\r\n\t\r\n\tOPTTYPE _optType;\r\n\t\r\n\tEigen::VectorXd _var;           // x\r\n\tEigen::VectorXd _output;        // b\r\n\tEigen::MatrixXd _coef;          // A\r\n\t\r\n\tunsigned int _nVars;\r\n\tunsigned int _nConstrs;\r\n\tunsigned int _iteration;        // iteration for the optimization\r\n\t\r\n\tvirtual void _initCoefs( void ) = 0;\r\n\t\r\n\tvirtual void _setConstraints( unsigned int &nRows ) = 0;\r\n\t\r\n\tvirtual void _initVars( void ) = 0;\r\n\t\r\n\tvirtual void _setVars( unsigned int &nRows ) = 0;\r\n\t\r\n\tvirtual void _initOutputs( void ) = 0;\r\n\t\r\n\tvirtual void _updateCoefs( void ) = 0;\r\n\t\r\n\tvirtual void _updateOutputs( void ) = 0;\r\n\t\r\n\tvirtual void _init( string confFileName ) = 0;\r\n\t\r\n\tvoid _reset( void );\r\n\r\npublic:\r\n\t\r\n\t// default constructor\r\n\tLaplacianOptimization( void ){ _reset(); }\r\n\t// Copy constructor\r\n\tLaplacianOptimization( const LaplacianOptimization  &obj ) {;}\r\n\t// Destructor\r\n\t~LaplacianOptimization( void ) {;}\r\n\r\n//------------------------------------------------------------------------------\r\n//  Reference to members\r\n//------------------------------------------------------------------------------\r\n\t\r\n\tconst OPTTYPE &opttype( void ) const { return _optType; }\r\n\t\r\n\tOPTTYPE &opttype( void ) { return _optType; }\r\n\r\n//------------------------------------------------------------------------------\r\n//  Specific functions\r\n//------------------------------------------------------------------------------\r\n\tdouble _LeastSquare( void );\r\n\r\n\tdouble _ConjugateGradient( void );\r\n\r\n//------------------------------------------------------------------------------\r\n//      Initialization functions\r\n//------------------------------------------------------------------------------\r\n\tvoid prepare( string confFileName ) {\r\n\t\t_init( confFileName );\r\n\t}\r\n\r\n//------------------------------------------------------------------------------\r\n//  File I/O\r\n//------------------------------------------------------------------------------\r\n\tvoid clear( void );\r\n\t\r\n\tvirtual void retrieve( void ) = 0;\r\n\r\n//------------------------------------------------------------------------------\r\n//      I/O\r\n//------------------------------------------------------------------------------\r\n\t// Output\r\n\tfriend ostream &operator<<( ostream &stream, const LaplacianOptimization &obj );\r\n\t\r\n\t// Input\r\n\tfriend istream &operator>>( istream &stream, LaplacianOptimization &obj );\r\n\t\r\n\t// Class name\r\n\tvirtual const char *className( void ) const { return \"LaplacianOptimization\"; }\r\n};\r\n\r\n#endif // _LaplacianOptimization_H\r\n\r\n// end of header file\r\n// Do not add any stuff under this line.\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Optimization/src/LaplacianOptimization.h b/Optimization/src/LaplacianOptimization.h
--- a/Optimization/src/LaplacianOptimization.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Optimization/src/LaplacianOptimization.h	(date 1729410605520)
@@ -1,119 +1,0 @@
-//==============================================================================
-// LaplacianOptimization.h
-//  : header file for the laplacian optimization
-//
-//==============================================================================
-
-#ifndef _LaplacianOptimization_H        // beginning of header file
-#define _LaplacianOptimization_H        // notifying that this file is included
-
-//----------------------------------------------------------------------
-//  Including header files
-//----------------------------------------------------------------------
-
-#include <iostream>
-#include <iomanip>
-#include <eigen3/Eigen/Core>
-#include <eigen3/Eigen/Dense>
-
-using namespace std;
-
-#include "Common.h"
-#include "Config.h"
-
-//------------------------------------------------------------------------------
-//	Defining data types
-//------------------------------------------------------------------------------
-
-//------------------------------------------------------------------------------
-//	Defining macros
-//------------------------------------------------------------------------------
-class LaplacianOptimization {
-
-private:
-
-protected:
-	
-	OPTTYPE _optType;
-	
-	Eigen::VectorXd _var;           // x
-	Eigen::VectorXd _output;        // b
-	Eigen::MatrixXd _coef;          // A
-	
-	unsigned int _nVars;
-	unsigned int _nConstrs;
-	unsigned int _iteration;        // iteration for the optimization
-	
-	virtual void _initCoefs( void ) = 0;
-	
-	virtual void _setConstraints( unsigned int &nRows ) = 0;
-	
-	virtual void _initVars( void ) = 0;
-	
-	virtual void _setVars( unsigned int &nRows ) = 0;
-	
-	virtual void _initOutputs( void ) = 0;
-	
-	virtual void _updateCoefs( void ) = 0;
-	
-	virtual void _updateOutputs( void ) = 0;
-	
-	virtual void _init( string confFileName ) = 0;
-	
-	void _reset( void );
-
-public:
-	
-	// default constructor
-	LaplacianOptimization( void ){ _reset(); }
-	// Copy constructor
-	LaplacianOptimization( const LaplacianOptimization  &obj ) {;}
-	// Destructor
-	~LaplacianOptimization( void ) {;}
-
-//------------------------------------------------------------------------------
-//  Reference to members
-//------------------------------------------------------------------------------
-	
-	const OPTTYPE &opttype( void ) const { return _optType; }
-	
-	OPTTYPE &opttype( void ) { return _optType; }
-
-//------------------------------------------------------------------------------
-//  Specific functions
-//------------------------------------------------------------------------------
-	double _LeastSquare( void );
-
-	double _ConjugateGradient( void );
-
-//------------------------------------------------------------------------------
-//      Initialization functions
-//------------------------------------------------------------------------------
-	void prepare( string confFileName ) {
-		_init( confFileName );
-	}
-
-//------------------------------------------------------------------------------
-//  File I/O
-//------------------------------------------------------------------------------
-	void clear( void );
-	
-	virtual void retrieve( void ) = 0;
-
-//------------------------------------------------------------------------------
-//      I/O
-//------------------------------------------------------------------------------
-	// Output
-	friend ostream &operator<<( ostream &stream, const LaplacianOptimization &obj );
-	
-	// Input
-	friend istream &operator>>( istream &stream, LaplacianOptimization &obj );
-	
-	// Class name
-	virtual const char *className( void ) const { return "LaplacianOptimization"; }
-};
-
-#endif // _LaplacianOptimization_H
-
-// end of header file
-// Do not add any stuff under this line.
Index: Optimization/src/Schematization.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//==============================================================================\r\n// Schematization.h\r\n//  : header file for the optimization\r\n//\r\n//==============================================================================\r\n\r\n#ifndef _Schematization_H        // begining of header file\r\n#define _Schematization_H        // notifying that this file is included\r\n\r\n//----------------------------------------------------------------------\r\n//  Including header files\r\n//----------------------------------------------------------------------\r\n\r\n#include <iostream>\r\n#include <iomanip>\r\n#include <eigen3/Eigen/Core>\r\n#include <eigen3/Eigen/Dense>\r\n\r\nusing namespace std;\r\n\r\n#include \"Config.h\"\r\n#include \"SchematicGraph.h\"\r\n#include \"LaplacianOptimization.h\"\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining data types\r\n//------------------------------------------------------------------------------\r\n//#define Schematization_CONFLICT\r\n//#define Schematization_BOUNDARY\r\n\r\n//------------------------------------------------------------------------------\r\n//\tDefining macros\r\n//------------------------------------------------------------------------------\r\ntemplate <typename GraphType>\r\nclass Schematization : public LaplacianOptimization\r\n\t{\r\nprivate:\r\n\t\r\n\tGraphType _graph;               // inner + outer boundary\r\n\t\r\n\tdouble _half_width;             // half_window_width\r\n\tdouble _half_height;            // half_window_height\r\n\t\r\n\tunsigned int _schematization_degree;    // othogonal, octilinear, or others\r\n\tdouble _w_schematization, _w_position, _w_fixposition;\r\n\tdouble _w_boundary, _w_crossing;\r\n\t//double _d_Alpha;\r\n\tdouble _d_Beta;\r\n\tvector< double > _theta;         // closest Schematization theta\r\n\r\nprotected:\r\n\t\r\n\tvoid _initCoefs( void ) override;\r\n\t\r\n\tvoid _setConstraints( unsigned int &nRows ) override;\r\n\t\r\n\tvoid _initVars( void ) override;\r\n\t\r\n\tvoid _setVars( unsigned int &nRows ) override;\r\n\t\r\n\tvoid _initOutputs( void ) override;\r\n\t\r\n\tvoid _updateCoefs( void ) override;\r\n\t\r\n\tvoid _updateOutputs( void ) override;\r\n\t\r\n\tvoid _init( string confFileName ) override;\r\n\r\n\tvoid _reset( void );\r\n\r\n\tvoid _setTargetAngle( void );\r\n\t\r\n\tvoid _updateEdgeCurAngle( void );\r\n\t\r\n\tbool _isOnLine( KeiRo::Base::Coord2 &a, KeiRo::Base::Coord2 &b, KeiRo::Base::Coord2 &c );\r\n\r\npublic:\r\n\t\r\n\t// default constructor\r\n\tSchematization ( void ) {\r\n\t\t_reset();\r\n\t}\r\n\t// Copy constructor\r\n\tSchematization( const Schematization<GraphType> &obj );\r\n\t// Destructor\r\n\t~Schematization( void );\r\n\r\n//------------------------------------------------------------------------------\r\n//  Reference to members\r\n//------------------------------------------------------------------------------\r\n\tconst GraphType &graph( void ) const { return _graph; }\r\n\t\r\n\tGraphType &graph( void ) { return _graph; }\r\n\r\n//------------------------------------------------------------------------------\r\n//  Specific functions\r\n//------------------------------------------------------------------------------\r\n\tdouble LeastSquare( void ){\r\n\t\t_LeastSquare();\r\n\t};\r\n\t\r\n\tdouble ConjugateGradient( void ){\r\n\t\t_ConjugateGradient();\r\n\t};\r\n\r\n//------------------------------------------------------------------------------\r\n//      Initialization functions\r\n//------------------------------------------------------------------------------\r\n//\tvoid prepare( string confFileName ) {\r\n//\t\t_init( confFileName );\r\n//\t}\r\n\r\n//------------------------------------------------------------------------------\r\n//  File I/O\r\n//------------------------------------------------------------------------------\r\n\tvoid clear( void );\r\n\t\r\n\tvoid retrieve( void );\r\n\r\n//------------------------------------------------------------------------------\r\n//      I/O\r\n//------------------------------------------------------------------------------\r\n\tfriend ostream &operator<<( ostream &stream, const Schematization<GraphType> &obj );\r\n\t// Output\r\n\t\r\n\tfriend istream &operator>>( istream &stream, Schematization<GraphType> &obj );\r\n\t// Input\r\n\t\r\n\tvirtual const char *className( void ) const { return \"Schematization\"; }\r\n\t// Class name\r\n};\r\n\r\n//------------------------------------------------------------------------------\r\n//\tProtected functions\r\n//------------------------------------------------------------------------------\r\n//\r\n//  Schematization::_reset --        reset the class\r\n//\r\n//  Inputs\r\n//      none\r\n//\r\n//  Outputs\r\n//      none\r\n//\r\ntemplate <typename GraphType>\r\nvoid Schematization<GraphType>::_reset( void ) {\r\n\t\r\n\t_optType = LEAST_SQUARE;\r\n\t\r\n\t_graph = NULL;\r\n\t_half_width = 0.0;    // window_width\r\n\t_half_height = 0.0;   // window_height\r\n\t\r\n\t_nVars = 0;\r\n\t_nConstrs = 0;\r\n\t_w_schematization = 0.0;\r\n\t_w_position = 0.0;\r\n\t_w_fixposition = 0.0;\r\n\t_w_boundary = 0.0;\r\n\t_w_crossing = 0.0;\r\n\t//_d_Alpha = 0.0;\r\n\t_d_Beta = 0.0;\r\n\t_theta.clear();\r\n}\r\n\r\n//\r\n//  Schematization::_init --        initialize the constrained optimization problem\r\n//\r\n//  Inputs\r\n//      __boundary : pointer to boundary\r\n//\r\n//  Outputs\r\n//      none\r\n//\r\ntemplate <typename GraphType>\r\nvoid Schematization<GraphType>::_init( string confFileName ) {\r\n\t\r\n\tGraphType &g = _graph;\r\n\tunsigned int nVertices = num_vertices( g );\r\n\tunsigned int nEdges = num_edges( g );\r\n\t\r\n\t// initialization\r\n\t_nVars = _nConstrs = 0;\r\n\t_half_width = KeiRo::Base::Common::getMainwidgetWidth() / 2.0;\r\n\t_half_height = KeiRo::Base::Common::getMainwidgetHeight() / 2.0;\r\n\t\r\n\t//_d_Alpha = _OrthogonalBoundaryVec->dAlpha();\r\n\t_d_Beta = 1.0;\r\n\t\r\n\t// read config file\r\n\tstring configFilePath = qApp->applicationDirPath().toStdString() + confFileName;\r\n\t// string configFilePath = qApp->applicationDirPath().toStdString() + \"/../../ResponsiveLens/config/Orthogonal.conf\";\r\n\t\r\n\tKeiRo::Base::Config conf( configFilePath );\r\n\t\r\n\tif( conf.has( \"schematization_degree\" ) ) {\r\n\t\tstring paramDegree = conf.gets( \"schematization_degree\" );\r\n\t\t_schematization_degree = KeiRo::Base::Common::stringToDouble( paramDegree );\r\n\t}\r\n\t\r\n\tif( conf.has( \"iteration\" ) ) {\r\n\t\tstring paramIteration = conf.gets( \"iteration\" );\r\n\t\t_iteration = KeiRo::Base::Common::stringToDouble( paramIteration );\r\n\t}\r\n\t\r\n\tif( conf.has( \"w_schematization\" ) ) {\r\n\t\tstring paramSchematization = conf.gets( \"w_schematization\" );\r\n\t\t_w_schematization = sqrt( KeiRo::Base::Common::stringToDouble( paramSchematization ) );\r\n\t}\r\n\t\r\n\tif( conf.has( \"w_position\" ) ) {\r\n\t\tstring paramPosition = conf.gets( \"w_position\" );\r\n\t\t_w_position = sqrt( KeiRo::Base::Common::stringToDouble( paramPosition ) );\r\n\t}\r\n\t\r\n\tif( conf.has( \"w_fixposition\" ) ) {\r\n\t\tstring paramFixPosition = conf.gets( \"w_fixposition\" );\r\n\t\t_w_fixposition = sqrt( KeiRo::Base::Common::stringToDouble( paramFixPosition ) );\r\n\t}\r\n\t\r\n\tif( conf.has( \"w_boundary\" ) ) {\r\n\t\tstring paramBoundary = conf.gets( \"w_boundary\" );\r\n\t\t_w_boundary = sqrt( KeiRo::Base::Common::stringToDouble( paramBoundary ) );\r\n\t}\r\n\t\r\n\tif( conf.has( \"w_crossing\" ) ) {\r\n\t\tstring paramCrossing = conf.gets( \"w_crossing\" );\r\n\t\t_w_crossing = sqrt( KeiRo::Base::Common::stringToDouble( paramCrossing ) );\r\n\t}\r\n\t\r\n\tif( conf.has( \"opttype\" ) ) {\r\n\t\tstring paramType = conf.gets( \"opttype\" );\r\n\t\tif( paramType == \"LEAST_SQUARE\" )\r\n\t\t\t_optType = LEAST_SQUARE;\r\n\t\telse if( paramType == \"CONJUGATE_GRADIENT\" )\r\n\t\t\t_optType = CONJUGATE_GRADIENT;\r\n\t\telse {\r\n\t\t\tassert( false );\r\n\t\t}\r\n\t}\r\n\r\n// #ifdef DEBUG\r\n\t//cerr << \"nAlpha = \" << nAlpha << \" nBeta = \" << nBeta << \" nVertices = \" << nEdges << endl;\r\n\t//cerr << \"_d_Alpha = \" << _d_Alpha << endl;\r\n\t//cerr << \" _d_Beta = \" << _d_Beta << endl;\r\n\tcerr << \" w_schematization = \" << _w_schematization << endl;\r\n\tcerr << \" schematization_degree = \" << _schematization_degree << endl;\r\n\tcerr << \" iteration = \" << _iteration << endl;\r\n// #endif  // DEBUG\r\n\r\n//------------------------------------------------------------------------------\r\n//      Total number of linear variables\r\n//------------------------------------------------------------------------------\r\n\t_nVars = 2 * nVertices;\r\n\r\n//------------------------------------------------------------------------------\r\n//      Total number of linear constraints\r\n//------------------------------------------------------------------------------\r\n\t// Regular edge length\r\n\t_nConstrs += 2 * nEdges;\r\n\t\r\n\t// Positional constraints\r\n\t_nConstrs += 2 * nVertices;\r\n\t\r\n\t_initCoefs();\r\n\t_initVars();\r\n\t_initOutputs();\r\n\t_updateCoefs();\r\n\t_updateOutputs();\r\n\r\n#ifdef  DEBUG\r\n\t//printGraph( g );\r\n\tcerr << \" nVertices = \" << nVertices << \" nEdges = \" << nEdges << endl;\r\n\tcerr << \" nVars = \" << _nVars << \" nConstrs = \" << _nConstrs << endl;\r\n\tcerr << \"Finished initializing the linear system\" << endl;\r\n\tcerr << \"_opttype = \" << _opttype << endl;\r\n#endif  // DEBUG\r\n}\r\n\r\n//\r\n//  Schematization::_initCoefs --        initialize the coefficient\r\n//\r\n//  Inputs\r\n//      none\r\n//\r\n//  Outputs\r\n//      none\r\n//\r\ntemplate <typename GraphType>\r\nvoid Schematization<GraphType>::_initCoefs( void ) {\r\n\t\r\n\tGraphType &g = _graph;\r\n\tunsigned int nVertices = num_vertices( g );\r\n\t\r\n\t// initialization\r\n\tunsigned int nRows = 0;\r\n\t_coef.resize( _nConstrs, _nVars );\r\n\t_coef << Eigen::MatrixXd::Zero( _nConstrs, _nVars );\r\n\t\r\n\t// Regular edge schematization\r\n\tBGL_FORALL_EDGES_T( edge, g, GraphType) {\r\n\t\t\t\r\n\t\t\ttypename GraphType::vertex_descriptor vdS = source( edge, g );\r\n\t\t\ttypename GraphType::vertex_descriptor vdT = target( edge, g );\r\n\t\t\tunsigned int idS = MIN2( g[ vdS ].id, g[ vdT ].id );\r\n\t\t\tunsigned int idT = MAX2( g[ vdS ].id, g[ vdT ].id );\r\n\t\t\t\r\n\t\t\t// x\r\n\t\t\t_coef( nRows, idS ) = _w_schematization;\r\n\t\t\t_coef( nRows, idT ) = -_w_schematization;\r\n\t\t\tnRows++;\r\n\t\t\t\r\n\t\t\t// y\r\n\t\t\t_coef( nRows, idS + nVertices ) = _w_schematization;\r\n\t\t\t_coef( nRows, idT + nVertices ) = -_w_schematization;\r\n\t\t\tnRows++;\r\n\t\t}\r\n\t\r\n\t// Positional constraints\r\n\tBGL_FORALL_VERTICES_T( vertex, g, GraphType ) {\r\n\t\t\t\r\n\t\t\tunsigned int id = g[ vertex ].id;\r\n\t\t\tbool fix = false;\r\n\t\t\t\r\n\t\t\t// collect fixed vertices\r\n\t\t\tvector< typename GraphType::vertex_descriptor > vdVec;\r\n\t\t\ttypename GraphType::out_edge_iterator eo, eo_end;\r\n\t\t\tfor( tie( eo, eo_end ) = out_edges( vertex, g ); eo != eo_end; ++eo ) {\r\n\t\t\t\t\r\n\t\t\t\ttypename GraphType::edge_descriptor ed = *eo;\r\n\t\t\t\ttypename GraphType::vertex_descriptor vdT = target( ed, g );\r\n\t\t\t\t\r\n\t\t\t\tif( g[ vertex ].isFixed == true ) {\r\n\t\t\t\t\tvdVec.push_back( vdT );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// check if on a line\r\n\t\t\tif( vdVec.size() == 2 ) {\r\n\t\t\t\t\r\n\t\t\t\tfix = ! KeiRo::Base::Line2::isOnLine( *g[ vertex ].coordPtr,\r\n\t\t\t\t                                      *g[ vdVec[ 0 ] ].coordPtr, *g[ vdVec[ 1 ] ].coordPtr );\r\n\t\t\t\t\r\n\t\t\t\t// cerr << \"vid = \" << g[ vertex ].id << endl;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif( fix == true ) {\r\n\t\t\t\t\r\n\t\t\t\t// cerr << \"vid = \" << g[ vertex ].id << \" node = \" << *g[ vertex ].coordPtr;\r\n\t\t\t\t\r\n\t\t\t\t// x\r\n\t\t\t\t_coef( nRows, id ) = _w_fixposition;\r\n\t\t\t\tnRows++;\r\n\t\t\t\t\r\n\t\t\t\t// y\r\n\t\t\t\t_coef( nRows, id + nVertices ) = _w_fixposition;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// x\r\n\t\t\t\t_coef( nRows, id ) = _w_position;\r\n\t\t\t\tnRows++;\r\n\t\t\t\t\r\n\t\t\t\t// y\r\n\t\t\t\t_coef( nRows, id + nVertices ) = _w_position;\r\n\t\t\t}\r\n\t\t\tnRows++;\r\n\t\t}\r\n\r\n#ifdef  DEBUG\r\n\tcerr << \"_coef:\" << endl;\r\n\tcerr << _coef << endl;\r\n#endif  // DEBUG\r\n}\r\n\r\n//\r\n//  Schematization::_setConstraints --        set the Constraints\r\n//\r\n//  Inputs\r\n//      none\r\n//\r\n//  Outputs\r\n//      none\r\n//\r\ntemplate <typename GraphType>\r\nvoid Schematization<GraphType>::_setConstraints( unsigned int &nRow ) {\r\n\r\n}\r\n\r\n//\r\n//  Schematization::_initVars --        initialize the variables\r\n//\r\n//  Inputs\r\n//      none\r\n//\r\n//  Outputs\r\n//      none\r\n//\r\ntemplate <typename GraphType>\r\nvoid Schematization<GraphType>::_initVars( void ) {\r\n\t\r\n\tGraphType &g = _graph;\r\n\tunsigned int nVertices = num_vertices( g );\r\n\t\r\n\t// initialization\r\n\t_var.resize( _nVars );\r\n\t\r\n\tunsigned int nRows = 0;\r\n\tBGL_FORALL_VERTICES_T( vertex, g, GraphType ) {\r\n\t\t\t\r\n\t\t\t_var( nRows, 0 ) = g[ vertex ].coordPtr->x();\r\n\t\t\t_var( nRows + nVertices, 0 ) = g[ vertex ].coordPtr->y();\r\n\t\t\tnRows++;\r\n\t\t}\r\n\r\n#ifdef  DEBUG\r\n\tcerr << \"_initvar:\" << endl;\r\n\tcerr << _var << endl;\r\n#endif  // DEBUG\r\n}\r\n\r\n//\r\n//  Schematization::_setVars --        set the variables\r\n//\r\n//  Inputs\r\n//      none\r\n//\r\n//  Outputs\r\n//      none\r\n//\r\ntemplate <typename GraphType>\r\nvoid Schematization<GraphType>::_setVars( unsigned int &nRow ) {\r\n\r\n}\r\n\r\ntemplate <typename GraphType>\r\nvoid Schematization<GraphType>::_updateEdgeCurAngle( void ) {\r\n\t\r\n\tGraphType &g = _graph;\r\n\t\r\n\t// initialization\r\n\tBGL_FORALL_EDGES_T( edge, g, GraphType ) {\r\n\t\t\t\r\n\t\t\ttypename GraphType::vertex_descriptor vS = source( edge, g );\r\n\t\t\ttypename GraphType::vertex_descriptor vT = target( edge, g );\r\n\t\t\tKeiRo::Base::Coord2 vi, vj;\r\n\t\t\tif( g[ vS ].id < g[ vT ].id ) {\r\n\t\t\t\tvi = *g[ vS ].coordPtr;\r\n\t\t\t\tvj = *g[ vT ].coordPtr;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvi = *g[ vT ].coordPtr;\r\n\t\t\t\tvj = *g[ vS ].coordPtr;\r\n\t\t\t}\r\n\t\t\tKeiRo::Base::Coord2 vji = vj - vi;\r\n\t\t\t\r\n\t\t\tdouble angle = atan2( vji.y(), vji.x() );\r\n\t\t\tg[ edge ].angle = angle;\r\n\t\t}\r\n\r\n#ifdef  DEBUG\r\n\tBGL_FORALL_EDGES( edge, g, GraphType ){\r\n\t\tcerr << \"EID = \" << g[ edge ].id\r\n\t\t\t << \", edgeCurAngle = \" << g[ edge ].angle << endl;\r\n\t}\r\n#endif  // DEBUG\r\n}\r\n\r\ntemplate <typename GraphType>\r\nvoid Schematization<GraphType>::_setTargetAngle( void ) {\r\n\t\r\n\tGraphType &g = _graph;\r\n\t\r\n\tunsigned int axis = _schematization_degree + 1;\r\n\tvector< double > sector;\r\n\tfor( unsigned int i = 0; i < axis; i++ ){\r\n\t\tdouble m = (axis - 1.0) / 2.0;\r\n\t\tdouble angle = ( 0 + (double)i * 1.0/m ) * M_PI -M_PI;\r\n\t\t// cerr << \"i = \" << angle << endl;\r\n\t\tsector.push_back( angle );\r\n\t}\r\n//\tdouble sector[9] = {-M_PI, -3.0 * M_PI / 4.0, -M_PI / 2.0, -M_PI / 4.0, 0.0,\r\n//\t                    M_PI / 4.0, M_PI / 2.0, 3.0 * M_PI / 4.0, M_PI};\r\n\t\r\n\t// initialization\r\n\tBGL_FORALL_EDGES_T( edge, g, GraphType ) {\r\n\t\t\t\r\n\t\t\tdouble targetAngle = 2.0 * M_PI;\r\n\t\t\tdouble minDist = 2.0 * M_PI + 1.0;\r\n\t\t\tfor( unsigned int i = 0; i < axis; i++ ) {\r\n\t\t\t\tdouble dist = fabs( g[ edge ].geoAngle - sector[ i ] );\r\n\t\t\t\tif( dist < minDist ) {\r\n\t\t\t\t\tminDist = dist;\r\n\t\t\t\t\ttargetAngle = sector[ i ];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tg[ edge ].targetAngle = targetAngle;\r\n\t\t}\r\n}\r\n\r\n#ifdef  SKIP\r\nvoid Schematization::_setTargetAngle( void )\r\n{\r\n\tGraphType        & g            = _OrthogonalBoundaryVec->boundary();\r\n\r\n\tdouble sector[ 9 ] = { -M_PI, -3.0*M_PI/4.0, -M_PI/2.0, -M_PI/4.0, 0.0,\r\n\t\t\t\t\t\t   M_PI/4.0, M_PI/2.0, 3.0*M_PI/4.0, M_PI };\r\n\r\n\tvector< vector< GraphType::vertex_descriptor > > vdVec( Orthogonal_SECTOR );\r\n\tBGL_FORALL_VERTICES( vertex, g, GraphType ){\r\n\t\tGraphType::degree_size_type degrees = out_degree( vertex, g );\r\n\t\tvdVec[ Orthogonal_SECTOR - degrees ].push_back( vertex );\r\n\t}\r\n\r\n#ifdef  DEBUG\r\n\tfor( int i = 0; i < vdVec.size(); i++ ){\r\n\t\tcerr << \" i = \" << Orthogonal_SECTOR-i << \" \";\r\n\t\tfor( int j = 0; j < vdVec[ i ].size(); j++ ){\r\n\t\t\tcerr << vertexCoord[ vdVec[i][j] ] <<  \" \";\r\n\t\t}\r\n\t\tcerr << endl;\r\n\t}\r\n#endif  // DEBUG\r\n\r\n\t// initialization\r\n\tBGL_FORALL_EDGES( edge, g, GraphType ){\r\n\t\tg[ edge ].targetAngle = 2.0*M_PI;\r\n\t}\r\n\r\n\t// set target angles\r\n\tfor( int i = 0; i < vdVec.size(); i++ ){\r\n\t\tfor( int j = 0; j < vdVec[ i ].size(); j++ ){\r\n\r\n\t\t\tmap< double, GraphType::edge_descriptor > circM;\r\n\t\t\t// sort the angle\r\n\t\t\tGraphType::out_edge_iterator e, e_end;\r\n\t\t\tfor ( tie( e, e_end ) = out_edges( vdVec[i][j], g ); e != e_end; ++e ) {\r\n\t\t\t\tGraphType::edge_descriptor ed = *e;\r\n\t\t\t\tGraphType::vertex_descriptor vS = source( ed, g );\r\n\t\t\t\tGraphType::vertex_descriptor vT = target( ed, g );\r\n\t\t\t\tdouble angle = g[ ed ].angle;\r\n\r\n\t\t\t\tif ( g[ vS ].id > g[ vT ].id ) {\r\n\t\t\t\t\tif ( angle > 0 ) angle = -M_PI + g[ ed ].angle;\r\n\t\t\t\t\telse angle = M_PI + g[ ed ].angle;\r\n\t\t\t\t}\r\n\t\t\t\tcircM.insert( pair< double, GraphType::edge_descriptor >( angle, ed ) );\r\n\t\t\t\t//cerr << \"eID = \" << edgeID[ ed ] << \" angle = \" << angle << \" curAngle = \" << edgeCurAngle[ ed ] << endl;\r\n\t\t\t\t// cerr << \"sID = \" << vertexID[ vS ] << \" tID = \" << vertexID[ vT ] << endl;\r\n\t\t\t}\r\n\r\n\t\t\t// assign the sector\r\n\t\t\tint index = 0;\r\n\t\t\tfor ( map< double, GraphType::edge_descriptor >::iterator it = circM.begin();\r\n\t\t\t\t  it != circM.end(); it++ ) {\r\n\r\n\t\t\t\tGraphType::edge_descriptor ed = it->second;\r\n\t\t\t\tGraphType::vertex_descriptor vS = source( ed, g );\r\n\t\t\t\tGraphType::vertex_descriptor vT = target( ed, g );\r\n\r\n\t\t\t\tif( g[ ed ].targetAngle == 2.0*M_PI ){\r\n\t\t\t\t\tdouble angle = g[ ed ].angle;\r\n\t\t\t\t\tif ( g[ vS ].id > g[ vT ].id ) {\r\n\t\t\t\t\t\tif ( angle > 0 ) angle = -M_PI + g[ ed ].angle;\r\n\t\t\t\t\t\telse angle = M_PI + g[ ed ].angle;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdouble target = 0.0, minDist = M_PI;\r\n\r\n\t\t\t\t\tfor ( int k = index; k < 9 ; k++ ) {\r\n\r\n\t\t\t\t\t\tdouble dist = fabs( sector[ k ] - angle );\r\n\t\t\t\t\t\tif( minDist > dist ) {\r\n\t\t\t\t\t\t\tminDist = dist;\r\n\t\t\t\t\t\t\ttarget = sector[ k ];\r\n\t\t\t\t\t\t\tindex = k+1;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( g[ vS ].id > g[ vT ].id ) {\r\n\t\t\t\t\t\tif ( target > 0 ) g[ ed ].targetAngle = -M_PI + target;\r\n\t\t\t\t\t\telse g[ ed ].targetAngle = M_PI + target;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse{\r\n\t\t\t\t\t\tg[ ed ].targetAngle = target;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//cerr << \"EID = \" << edgeID[ ed ] << \", index = \" << index << \", target = \" << edgeTarget[ ed ] << endl;\r\n\t\t\t\t\t//cerr << \"EID = \" << edgeID[ ed ] << \", angle = \" << edgeCurAngle[ ed ] << \", target = \" << edgeTarget[ ed ] << endl;\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tdouble target = g[ ed ].targetAngle;\r\n\r\n\t\t\t\t\tif ( g[ vS ].id > g[ vT ].id ) {\r\n\t\t\t\t\t\tif ( target > 0 ) target = -M_PI + g[ ed ].targetAngle;\r\n\t\t\t\t\t\telse target = M_PI + g[ ed ].targetAngle;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor( int k = index; k < 9; k++ ){\r\n\t\t\t\t\t\tif( target == sector[ k ] ) index = k+1;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//cerr << \"EID = \" << edgeID[ ed ] << \" skipping... \" << index << endl;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n#ifdef  DEBUG\r\n\tBGL_FORALL_EDGES( edge, g, GraphType ){\r\n\t\tcerr << \"eid = \"<< edgeID[ edge ] << \" angle = \" << edgeCurAngle[ edge ]\r\n\t\t\t << \" target = \" << edgeTarget[ edge ] + edgeCurAngle[ edge ]\r\n\t\t\t << \" rotate = \" << edgeTarget[ edge ] << endl;\r\n\t}\r\n#endif  // DEBUG\r\n}\r\n#endif // SKIP\r\n\r\n#ifdef  SKIP\r\ndouble Schematization::_findRotateAngle( double input )\r\n{\r\n\tdouble target = 0.0, minDist = M_PI;\r\n\tdouble sector[ 9 ] = { -M_PI, -3.0*M_PI/4.0, -M_PI/2.0, -M_PI/4.0, 0.0,\r\n\t\t\t\t\t\t   M_PI/4.0, M_PI/2.0, 3.0*M_PI/4.0, M_PI };\r\n\r\n\tfor ( int i = 0; i < 9 ; i++ ) {\r\n\r\n\t\tdouble dist = fabs( sector[ i ] - input );\r\n\t\tif( minDist > dist ) {\r\n\t\t\tminDist = dist;\r\n\t\t\ttarget = sector[ i ];\r\n\t\t}\r\n\t}\r\n\r\n#ifdef  DEBUG\r\n\tcerr << \"inputAngle = \" << input << \" targetAngle = \" << target << \" rotate = \" << target-input << endl;\r\n#endif  // DEBUG\r\n\treturn target - input;\r\n}\r\n#endif  // SKIP\r\n\r\n//\r\n//  Schematization::_initOutputs --        initialize the output\r\n//\r\n//  Inputs\r\n//      none\r\n//\r\n//  Outputs\r\n//      none\r\n//\r\ntemplate <typename GraphType>\r\nvoid Schematization<GraphType>::_initOutputs( void ) {\r\n\t\r\n\tGraphType &g = _graph;\r\n\t\r\n\t// initialization\r\n\tunsigned int nRows = 0;\r\n\t_output.resize( _nConstrs );\r\n\t_output << Eigen::VectorXd::Zero( _nConstrs );\r\n\t\r\n\t_updateEdgeCurAngle();\r\n\t_setTargetAngle();\r\n\t\r\n\t// Regular edge Orthogonalty\r\n\tBGL_FORALL_EDGES_T( edge, g, GraphType ) {\r\n\t\t\ttypename GraphType::vertex_descriptor vdS = source( edge, g );\r\n\t\t\ttypename GraphType::vertex_descriptor vdT = target( edge, g );\r\n\t\t\tKeiRo::Base::Coord2 vi, vj;\r\n\t\t\tif( g[ vdS ].id < g[ vdT ].id ) {\r\n\t\t\t\tvi = *g[ vdS ].smoothPtr;\r\n\t\t\t\tvj = *g[ vdT ].smoothPtr;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvi = *g[ vdT ].smoothPtr;\r\n\t\t\t\tvj = *g[ vdS ].smoothPtr;\r\n\t\t\t}\r\n\t\t\tKeiRo::Base::Coord2 vji = vi - vj;\r\n#ifdef  DEBUG\r\n\t\t\tcerr << \"vji = \" << vji;\r\n#endif  // DEBUG\r\n\t\t\tdouble angle = g[ edge ].angle;\r\n\t\t\tdouble theta = g[ edge ].targetAngle - angle;\r\n#ifdef  DEBUG\r\n\t\t\tcerr << \"e( \" << g[vdS].id << \",\" << g[vdT].id << \" )\"\r\n\t\t\t\t << \" targetAngle = \" << g[ edge ].targetAngle\r\n\t\t\t\t << \" angle = \" << g[ edge ].angle << endl;\r\n\t\t\tcerr << \"eid = \" << edgeID[ edge ] << \" \";\r\n#endif  // DEBUG\r\n\t\t\tdouble cosTheta = cos( theta ), sinTheta = sin( theta );\r\n\t\t\t// double s = _d_Beta * g[ edge ].weight / vji.norm();\r\n\t\t\tdouble s = g[ edge ].weight;\r\n\t\t\t\r\n\t\t\t// x\r\n\t\t\t_output( nRows, 0 ) = _w_schematization * s * ( cosTheta * vji.x() - sinTheta * vji.y() );\r\n\t\t\tnRows++;\r\n\t\t\t\r\n\t\t\t// y\r\n\t\t\t_output( nRows, 0 ) = _w_schematization * s * ( sinTheta * vji.x() + cosTheta * vji.y() );\r\n\t\t\tnRows++;\r\n\t\t}\r\n\t\r\n\t\r\n\t// Positional constraints\r\n\tBGL_FORALL_VERTICES_T( vertex, g, GraphType ) {\r\n\t\t\t\r\n\t\t\tbool fix = false;\r\n\t\t\t\r\n\t\t\t// collect fixed vertices\r\n\t\t\tvector< typename GraphType::vertex_descriptor > vdVec;\r\n\t\t\ttypename GraphType::out_edge_iterator eo, eo_end;\r\n\t\t\tfor( tie( eo, eo_end ) = out_edges( vertex, g ); eo != eo_end; ++eo ) {\r\n\t\t\t\t\r\n\t\t\t\ttypename GraphType::edge_descriptor ed = *eo;\r\n\t\t\t\ttypename GraphType::vertex_descriptor vdT = target( ed, g );\r\n\t\t\t\t\r\n\t\t\t\tif( g[ vertex ].isFixed == true ) {\r\n\t\t\t\t\tvdVec.push_back( vdT );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// check if on a line\r\n\t\t\tif( vdVec.size() == 2 ) {\r\n\t\t\t\t\r\n\t\t\t\t//fix = true;\r\n\t\t\t\tfix = ! KeiRo::Base::Line2::isOnLine( *g[ vertex ].coordPtr,\r\n\t\t\t\t                                      *g[ vdVec[ 0 ] ].coordPtr, *g[ vdVec[ 1 ] ].coordPtr );\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif( fix == true ) {\r\n\t\t\t\t\r\n\t\t\t\t_output( nRows, 0 ) = _w_fixposition * g[ vertex ].smoothPtr->x();\r\n\t\t\t\tnRows++;\r\n\t\t\t\t_output( nRows, 0 ) = _w_fixposition * g[ vertex ].smoothPtr->y();\r\n\t\t\t\tnRows++;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t_output( nRows, 0 ) = _w_position * g[ vertex ].smoothPtr->x();\r\n\t\t\t\tnRows++;\r\n\t\t\t\t_output( nRows, 0 ) = _w_position * g[ vertex ].smoothPtr->y();\r\n\t\t\t\tnRows++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n#ifdef  DEBUG\r\n\tcerr << \"_initOutput:\" << endl;\r\n\tcerr << _output << endl;\r\n#endif  // DEBUG\r\n}\r\n\r\n\r\n//\r\n//  Schematization::_updateCoefs --        update the coefs\r\n//\r\n//  Inputs\r\n//      none\r\n//\r\n//  Outputs\r\n//      none\r\n//\r\ntemplate <typename GraphType>\r\nvoid Schematization<GraphType>::_updateCoefs( void ) {\r\n\t\r\n\tGraphType &g = _graph;\r\n\tunsigned int nVertices = num_vertices( g );\r\n\tunsigned int nVE = 0;\r\n\tunsigned int nB = 0;\r\n\t//vector< double > ratioR = _OrthogonalBoundaryVec->ratioR();\r\n\t\r\n\tEigen::MatrixXd oldCoef;\r\n\toldCoef = _coef.block( 0, 0, _nConstrs, _nVars );\r\n\r\n#ifdef Orthogonal_CONFLICT\r\n\tnVE = _OrthogonalBoundaryVec->VEconflict().size();\r\n#endif // Orthogonal_CONFLICT\r\n#ifdef Orthogonal_BOUNDARY\r\n\tBGL_FORALL_VERTICES( vd, g, GraphType )\r\n\t{\r\n\t\tdouble minD = _d_Beta/2.0;\r\n\t\t//if( vertexIsStation[ vd ] == false )\r\n\t\t//    minD = vertexExternal[ vd ].leaderWeight() * _d_Beta/2.0;\r\n\t\tif ( g[ vd ].coordPtr->x() <= -( _half_width - minD ) ) nB++;\r\n\t\tif ( g[ vd ].coordPtr->x() >= ( _half_width - minD ) ) nB++;\r\n\t\tif ( g[ vd ].coordPtr->y() <= -( _half_height - minD ) ) nB++;\r\n\t\tif ( g[ vd ].coordPtr->y() >= ( _half_height - minD ) ) nB++;\r\n\t}\r\n#endif // Orthogonal_BOUNDARY\r\n\t_coef.resize( _nConstrs + nB + 2 * nVE, _nVars );\r\n\t// _coef << Eigen::MatrixXd::Zero( _nConstrs + 2*nVE, _nVars );\r\n\t\r\n\t// copy old coefficient\r\n\t_coef << oldCoef, Eigen::MatrixXd::Zero( nB + 2 * nVE, _nVars );\r\n\t\r\n\t// cerr << \"nVE = \" << nVE << endl;\r\n\tunsigned int nRows = _nConstrs;\r\n\r\n#ifdef  Orthogonal_BOUNDARY\r\n\t// add boundary coefficient\r\n\tBGL_FORALL_VERTICES( vd, g, GraphType ){\r\n\r\n\t\tunsigned int id = g[ vd ].id;\r\n\t\tdouble minD = _d_Beta/2.0;\r\n\t\t//if( vertexIsStation[ vd ] == false )\r\n\t\t//    minD = vertexExternal[ vd ].leaderWeight() * _d_Beta/2.0;\r\n\r\n\t\tif ( g[ vd ].coordPtr->x() <= -( _half_width - minD ) ) {\r\n\t\t\t_coef( nRows, id ) = _w_boundary;\r\n\t\t\tnRows++;\r\n\t\t}\r\n\t\tif ( g[ vd ].coordPtr->x() >= ( _half_width - minD ) ) {\r\n\t\t\t_coef( nRows, id ) = _w_boundary;\r\n\t\t\tnRows++;\r\n\t\t}\r\n\t\tif ( g[ vd ].coordPtr->y() <= -( _half_height - minD ) ) {\r\n\t\t\t_coef( nRows, id + nVertices ) = _w_boundary;\r\n\t\t\tnRows++;\r\n\t\t}\r\n\t\tif ( g[ vd ].coordPtr->y() >= ( _half_height - minD ) ) {\r\n\t\t\t_coef( nRows, id + nVertices ) = _w_boundary;\r\n\t\t\tnRows++;\r\n\t\t}\r\n\t}\r\n#endif  // Orthogonal_BOUNDARY\r\n\r\n#ifdef  Orthogonal_CONFLICT\r\n\t// copy conflict coefficient\r\n\tunsigned int countVE = 0;\r\n\tfor ( VEMap::iterator it = _OrthogonalBoundaryVec->VEconflict().begin();\r\n\t\t  it != _OrthogonalBoundaryVec->VEconflict().end(); ++it ) {\r\n\t\tGraphType::vertex_descriptor vdV = it->second.first;\r\n\t\tGraphType::edge_descriptor ed = it->second.second;\r\n\t\tGraphType::vertex_descriptor vdS = source( ed, g );\r\n\t\tGraphType::vertex_descriptor vdT = target( ed, g );\r\n\t\tunsigned int idV = g[ vdV ].id;\r\n\t\tunsigned int idS = g[ vdS ].id;\r\n\t\tunsigned int idT = g[ vdT ].id;\r\n\t\tdouble r = ratioR[ countVE ];\r\n\r\n\t\t// x\r\n\t\t_coef( nRows, idV ) = 1.0 * _w_crossing;\r\n\t\t_coef( nRows, idS ) = -r * _w_crossing;\r\n\t\t_coef( nRows, idT ) = ( r - 1.0 ) * _w_crossing;\r\n\t\tnRows++;\r\n\r\n\t\t// y\r\n\t\t_coef( nRows, idV + nVertices ) = 1.0 * _w_crossing;\r\n\t\t_coef( nRows, idS + nVertices ) = -r * _w_crossing;\r\n\t\t_coef( nRows, idT + nVertices ) = ( r - 1.0 ) * _w_crossing;\r\n\t\tnRows++;\r\n\t\t\r\n\t\tcountVE++;\r\n\t}\r\n#endif  // Orthogonal_CONFLICT\r\n\r\n#ifdef  DEBUG\r\n\tcerr << \"###############\" << endl;\r\n\tcerr << \"newCoef:\" << endl;\r\n\tcerr << _coef << endl;\r\n\tcerr << \"###############\" << endl;\r\n#endif  // DEBUG\r\n}\r\n\r\n//\r\n//  Schematization::_updateOutputs --        update the output\r\n//\r\n//  Inputs\r\n//      none\r\n//\r\n//  Outputs\r\n//      none\r\n//\r\ntemplate <typename GraphType>\r\nvoid Schematization<GraphType>::_updateOutputs( void ) {\r\n\t\r\n\tGraphType &g = _graph;\r\n\tunsigned int nVE = 0;\r\n\tunsigned int nB = 0;\r\n\t//vector< double > ratioR = _OrthogonalBoundaryVec->ratioR();\r\n\t\r\n\tunsigned int nRows = 0;\r\n\tEigen::VectorXd oldOutput;\r\n\toldOutput = _output;\r\n#ifdef  Orthogonal_CONFLICT\r\n\tnVE = _OrthogonalBoundaryVec->VEconflict().size();\r\n#endif  // Orthogonal_CONFLICT\r\n#ifdef  Orthogonal_BOUNDARY\r\n\tBGL_FORALL_VERTICES( vd, g, GraphType )\r\n\t{\r\n\t\tdouble minD = _d_Beta/2.0;\r\n\t\t//if( vertexIsStation[ vd ] == false )\r\n\t\t//    minD = vertexExternal[ vd ].leaderWeight() * _d_Beta/2.0;\r\n\t\tif ( g[ vd ].coordPtr->x() <= -( _half_width - minD ) ) nB++;\r\n\t\tif ( g[ vd ].coordPtr->x() >= ( _half_width - minD ) ) nB++;\r\n\t\tif ( g[ vd ].coordPtr->y() <= -( _half_height - minD ) ) nB++;\r\n\t\tif ( g[ vd ].coordPtr->y() >= ( _half_height - minD ) ) nB++;\r\n\t}\r\n#endif  // Orthogonal_BOUNDARY\r\n\t_output.resize( _nConstrs + nB + 2 * nVE );\r\n\t_output << Eigen::VectorXd::Zero( _nConstrs + nB + 2 * nVE );\r\n\t\r\n\t_updateEdgeCurAngle();\r\n\t//_setTargetAngle();\r\n\t\r\n\t// Regular edge Orthogonalty\r\n\tBGL_FORALL_EDGES_T( edge, g, GraphType ) {\r\n\t\t\t\r\n\t\t\ttypename GraphType::vertex_descriptor vdS = source( edge, g );\r\n\t\t\ttypename GraphType::vertex_descriptor vdT = target( edge, g );\r\n\t\t\t//Coord2 vi = vertexSmooth[ vdS ];\r\n\t\t\t//Coord2 vj = vertexSmooth[ vdT ];\r\n\t\t\tKeiRo::Base::Coord2 vi, vj;\r\n\t\t\tif( g[ vdS ].id < g[ vdT ].id ) {\r\n\t\t\t\tvi = *g[ vdS ].coordPtr;\r\n\t\t\t\tvj = *g[ vdT ].coordPtr;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvi = *g[ vdT ].coordPtr;\r\n\t\t\t\tvj = *g[ vdS ].coordPtr;\r\n\t\t\t}\r\n\t\t\tKeiRo::Base::Coord2 vji = vi - vj;\r\n\t\t\tdouble angle = g[ edge ].angle;\r\n\t\t\tdouble theta = g[ edge ].targetAngle - angle;\r\n\t\t\tdouble cosTheta = cos( theta ), sinTheta = sin( theta );\r\n\t\t\t// double s = _d_Beta * g[ edge ].weight / vji.norm();\r\n\t\t\tdouble s = g[ edge ].weight;\r\n\r\n#ifdef  DEBUG\r\n\t\t\tcerr << \"vji = \" << vji;\r\n\t\t\tif( vertexID[ vdS ] == 4 && vertexID[ vdT ] == 5 )\r\n\t\t\t\tcerr << \"( \" << vertexID[ vdS ] << \", \" << vertexID[ vdT ] << \") angle = \" << angle << \" theta = \" << theta << endl;\r\n#endif  // DEBUG\r\n\t\t\t\r\n\t\t\t// x\r\n\t\t\t_output( nRows, 0 ) = _w_schematization * s * ( cosTheta * vji.x() - sinTheta * vji.y() );\r\n\t\t\tnRows++;\r\n\t\t\t\r\n\t\t\t// y\r\n\t\t\t_output( nRows, 0 ) = _w_schematization * s * ( sinTheta * vji.x() + cosTheta * vji.y() );\r\n\t\t\tnRows++;\r\n\t\t}\r\n\t\r\n\t// Positional constraints\r\n\tBGL_FORALL_VERTICES_T( vertex, g, GraphType ) {\r\n\t\t\t\r\n\t\t\t// x\r\n\t\t\t_output( nRows, 0 ) = oldOutput( nRows, 0 );\r\n\t\t\tnRows++;\r\n\t\t\t\r\n\t\t\t// y\r\n\t\t\t_output( nRows, 0 ) = oldOutput( nRows, 0 );\r\n\t\t\tnRows++;\r\n\t\t}\r\n\r\n#ifdef  Orthogonal_BOUNDARY\r\n\t// boundary constraints\r\n\tBGL_FORALL_VERTICES( vd, g, GraphType ){\r\n\r\n\t\tdouble minD = _d_Beta/2.0;\r\n\t\t//if( vertexIsStation[ vd ] == false )\r\n\t\t//    minD = vertexExternal[ vd ].leaderWeight() * _d_Beta/2.0;\r\n\r\n\t\tif ( g[ vd ].coordPtr->x() <= -( _half_width - minD ) ) {\r\n\t\t\t_output( nRows, 0 ) = _w_boundary * -( _half_width - minD );\r\n\t\t\tnRows++;\r\n\t\t}\r\n\t\tif ( g[ vd ].coordPtr->x() >= ( _half_width - minD ) ) {\r\n\t\t\t_output( nRows, 0 ) = _w_boundary * ( _half_width - minD );\r\n\t\t\tnRows++;\r\n\t\t}\r\n\t\tif ( g[ vd ].coordPtr->y() <= -( _half_height - minD ) ) {\r\n\t\t\t_output( nRows, 0 ) = _w_boundary * -( _half_height - minD );\r\n\t\t\tnRows++;\r\n\t\t}\r\n\t\tif ( g[ vd ].coordPtr->y() >= ( _half_height - minD ) ) {\r\n\t\t\t_output( nRows, 0 ) = _w_boundary * ( _half_height - minD );\r\n\t\t\tnRows++;\r\n\t\t}\r\n\t}\r\n#endif  // Orthogonal_BOUNDARY\r\n\r\n#ifdef  Orthogonal_CONFLICT\r\n\t// copy conflict coefficient\r\n\tunsigned int countVE = 0;\r\n\tfor ( VEMap::iterator it = _OrthogonalBoundaryVec->VEconflict().begin();\r\n\t\t  it != _OrthogonalBoundaryVec->VEconflict().end(); ++it ) {\r\n\t\tGraphType::vertex_descriptor vdV = it->second.first;\r\n\t\tGraphType::edge_descriptor ed = it->second.second;\r\n\t\tGraphType::vertex_descriptor vdS = source( ed, g );\r\n\t\tGraphType::vertex_descriptor vdT = target( ed, g );\r\n\t\tunsigned int idV = g[ vdV ].id;\r\n\t\tunsigned int idS = g[ vdS ].id;\r\n\t\tunsigned int idT = g[ vdT ].id;\r\n\t\tdouble r = ratioR[ countVE ];\r\n\r\n\t\tCoord2 v = *g[ vdV ].geoPtr;\r\n\t\tCoord2 p = r * *g[ vdS ].geoPtr + ( 1.0-r ) * *g[ vdT ].geoPtr;\r\n\t\tdouble minD = _d_Beta/2.0;\r\n\t\t//if( vertexIsStation[ vdV ] == false )\r\n\t\t//    minD = vertexExternal[ vdV ].leaderWeight() * _d_Beta/2.0;\r\n\t\tdouble delta = minD / ( v - p ).norm();\r\n\r\n\t\t// x\r\n\t\t_output( nRows, 0 ) = _w_crossing * delta * ( v - p ).x();\r\n\t\tnRows++;\r\n\r\n\t\t// y\r\n\t\t_output( nRows, 0 ) = _w_crossing * delta * ( v - p ).y();\r\n\t\tnRows++;\r\n\t}\r\n#endif  // Orthogonal_CONFLICT\r\n\r\n#ifdef  DEBUG\r\n\tcerr << \"_updatedOutput:\" << endl;\r\n\tcerr << _output << endl;\r\n#endif  // DEBUG\r\n}\r\n\r\n//\r\n//  Schematization::retrieve --        retrieve the result\r\n//\r\n//  Inputs\r\n//      none\r\n//\r\n//  Outputs\r\n//      none\r\n//\r\ntemplate <typename GraphType>\r\nvoid Schematization<GraphType>::retrieve( void ) {\r\n\t\r\n\tGraphType &g = _graph;\r\n\tconst unsigned int nVertices = num_vertices( g );\r\n\t\r\n\t// find the vertex that is too close to an edge\r\n\tvector< typename GraphType::vertex_descriptor > vdVec;\r\n#ifdef  Orthogonal_CONFLICT\r\n\tfor( VEMap::iterator it = _OrthogonalBoundaryVec->VEconflict().begin();\r\n\t     it != _OrthogonalBoundaryVec->VEconflict().end(); ++it ) {\r\n\t\tGraphType::vertex_descriptor vdV = it->second.first;\r\n\t\tvdVec.push_back( vdV );\r\n\t}\r\n#endif  // Orthogonal_CONFLICT\r\n\t\r\n\tunsigned int nRows = 0;\r\n\t// update coordinates\r\n\t// but freeze the vertex that is too close to an edge\r\n\tBGL_FORALL_VERTICES_T( vertex, g, GraphType ) {\r\n\t\t\t\r\n\t\t\tbool doClose = false;\r\n\t\t\tfor( unsigned int i = 0; i < vdVec.size(); i++ ) {\r\n\t\t\t\tif( vertex == vdVec[ i ] ) doClose = true;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tdouble x = _var( nRows, 0 );\r\n\t\t\tdouble y = _var( nRows + nVertices, 0 );\r\n\t\t\tif( !isnan( x ) && !isnan( y ) ) {\r\n\t\t\t\tif( false ) {\r\n\t\t\t\t\t//if( _OrthogonalBoundaryVec->VEconflict().size() > 0 ) {\r\n\t\t\t\t\tKeiRo::Base::Coord2 downscale;\r\n\t\t\t\t\tdownscale.x() = ( x - g[ vertex ].coordPtr->x() ) / 2.0 + g[ vertex ].coordPtr->x();\r\n\t\t\t\t\tdownscale.y() = ( y - g[ vertex ].coordPtr->y() ) / 2.0 + g[ vertex ].coordPtr->y();\r\n\t\t\t\t\t//if( g[ vertex ].isFixed != true ){\r\n\t\t\t\t\tg[ vertex ].coordPtr->x() = downscale.x();\r\n\t\t\t\t\tg[ vertex ].coordPtr->y() = downscale.y();\r\n\t\t\t\t\t//}\r\n\t\t\t\t\t//cerr << \"x = \" << x << \" y = \" << y << endl;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t\r\n\t\t\t\t\tbool fix = false;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// collect fixed vertices\r\n\t\t\t\t\tvector< typename GraphType::vertex_descriptor > vdVec;\r\n\t\t\t\t\ttypename GraphType::out_edge_iterator eo, eo_end;\r\n\t\t\t\t\tfor( tie( eo, eo_end ) = out_edges( vertex, g ); eo != eo_end; ++eo ) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\ttypename GraphType::edge_descriptor ed = *eo;\r\n\t\t\t\t\t\ttypename GraphType::vertex_descriptor vdT = target( ed, g );\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif( g[ vertex ].isFixed == true ) {\r\n\t\t\t\t\t\t\tvdVec.push_back( vdT );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// check if on a line\r\n\t\t\t\t\tif( vdVec.size() == 2 ) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tfix = ! KeiRo::Base::Line2::isOnLine( *g[ vertex ].coordPtr,\r\n\t\t\t\t\t\t                                      *g[ vdVec[ 0 ] ].coordPtr, *g[ vdVec[ 1 ] ].coordPtr );\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// cerr << \"vid = \" << g[ vertex ].id << endl;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t//if( fix != true ){\r\n\t\t\t\t\t//if( g[ vertex ].isFixed != true ){\r\n\t\t\t\t\tg[ vertex ].coordPtr->x() = x;\r\n\t\t\t\t\tg[ vertex ].coordPtr->y() = y;\r\n\t\t\t\t\t//}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tnRows++;\r\n\t\t}\r\n\r\n#ifdef  Orthogonal_CONFLICT\r\n\t// check possible conflict\r\n\t_OrthogonalBoundaryVec->checkVEConflicts();\r\n#endif  // Orthogonal_CONFLICT\r\n\r\n#ifdef  DEBUG\r\n\tcerr << \"retrieve:\" << endl;\r\n\tBGL_FORALL_VERTICES( vertex, g, GraphType ){\r\n\t\tcerr << \"V(\" << g[ vertex ].id << \") = \" << *g[ vertex ].smoothPtr;\r\n\t}\r\n\tBGL_FORALL_EDGES( edge, g, GraphType ){\r\n\t\tcerr << \"E(\" << g[ edge ].id << \") : smoAngle= \" << edgeSmoAngle[ edge ] << endl;\r\n\t}\r\n#endif  // DEBUG\r\n}\r\n\r\n#endif // _Schematization_H\r\n\r\n// end of header file\r\n// Do not add any stuff under this line.\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Optimization/src/Schematization.h b/Optimization/src/Schematization.h
--- a/Optimization/src/Schematization.h	(revision 4a35761f5b87843b741881c1c83339857f9dbed8)
+++ b/Optimization/src/Schematization.h	(date 1729410605530)
@@ -1,1115 +1,0 @@
-//==============================================================================
-// Schematization.h
-//  : header file for the optimization
-//
-//==============================================================================
-
-#ifndef _Schematization_H        // begining of header file
-#define _Schematization_H        // notifying that this file is included
-
-//----------------------------------------------------------------------
-//  Including header files
-//----------------------------------------------------------------------
-
-#include <iostream>
-#include <iomanip>
-#include <eigen3/Eigen/Core>
-#include <eigen3/Eigen/Dense>
-
-using namespace std;
-
-#include "Config.h"
-#include "SchematicGraph.h"
-#include "LaplacianOptimization.h"
-
-//------------------------------------------------------------------------------
-//	Defining data types
-//------------------------------------------------------------------------------
-//#define Schematization_CONFLICT
-//#define Schematization_BOUNDARY
-
-//------------------------------------------------------------------------------
-//	Defining macros
-//------------------------------------------------------------------------------
-template <typename GraphType>
-class Schematization : public LaplacianOptimization
-	{
-private:
-	
-	GraphType _graph;               // inner + outer boundary
-	
-	double _half_width;             // half_window_width
-	double _half_height;            // half_window_height
-	
-	unsigned int _schematization_degree;    // othogonal, octilinear, or others
-	double _w_schematization, _w_position, _w_fixposition;
-	double _w_boundary, _w_crossing;
-	//double _d_Alpha;
-	double _d_Beta;
-	vector< double > _theta;         // closest Schematization theta
-
-protected:
-	
-	void _initCoefs( void ) override;
-	
-	void _setConstraints( unsigned int &nRows ) override;
-	
-	void _initVars( void ) override;
-	
-	void _setVars( unsigned int &nRows ) override;
-	
-	void _initOutputs( void ) override;
-	
-	void _updateCoefs( void ) override;
-	
-	void _updateOutputs( void ) override;
-	
-	void _init( string confFileName ) override;
-
-	void _reset( void );
-
-	void _setTargetAngle( void );
-	
-	void _updateEdgeCurAngle( void );
-	
-	bool _isOnLine( KeiRo::Base::Coord2 &a, KeiRo::Base::Coord2 &b, KeiRo::Base::Coord2 &c );
-
-public:
-	
-	// default constructor
-	Schematization ( void ) {
-		_reset();
-	}
-	// Copy constructor
-	Schematization( const Schematization<GraphType> &obj );
-	// Destructor
-	~Schematization( void );
-
-//------------------------------------------------------------------------------
-//  Reference to members
-//------------------------------------------------------------------------------
-	const GraphType &graph( void ) const { return _graph; }
-	
-	GraphType &graph( void ) { return _graph; }
-
-//------------------------------------------------------------------------------
-//  Specific functions
-//------------------------------------------------------------------------------
-	double LeastSquare( void ){
-		_LeastSquare();
-	};
-	
-	double ConjugateGradient( void ){
-		_ConjugateGradient();
-	};
-
-//------------------------------------------------------------------------------
-//      Initialization functions
-//------------------------------------------------------------------------------
-//	void prepare( string confFileName ) {
-//		_init( confFileName );
-//	}
-
-//------------------------------------------------------------------------------
-//  File I/O
-//------------------------------------------------------------------------------
-	void clear( void );
-	
-	void retrieve( void );
-
-//------------------------------------------------------------------------------
-//      I/O
-//------------------------------------------------------------------------------
-	friend ostream &operator<<( ostream &stream, const Schematization<GraphType> &obj );
-	// Output
-	
-	friend istream &operator>>( istream &stream, Schematization<GraphType> &obj );
-	// Input
-	
-	virtual const char *className( void ) const { return "Schematization"; }
-	// Class name
-};
-
-//------------------------------------------------------------------------------
-//	Protected functions
-//------------------------------------------------------------------------------
-//
-//  Schematization::_reset --        reset the class
-//
-//  Inputs
-//      none
-//
-//  Outputs
-//      none
-//
-template <typename GraphType>
-void Schematization<GraphType>::_reset( void ) {
-	
-	_optType = LEAST_SQUARE;
-	
-	_graph = NULL;
-	_half_width = 0.0;    // window_width
-	_half_height = 0.0;   // window_height
-	
-	_nVars = 0;
-	_nConstrs = 0;
-	_w_schematization = 0.0;
-	_w_position = 0.0;
-	_w_fixposition = 0.0;
-	_w_boundary = 0.0;
-	_w_crossing = 0.0;
-	//_d_Alpha = 0.0;
-	_d_Beta = 0.0;
-	_theta.clear();
-}
-
-//
-//  Schematization::_init --        initialize the constrained optimization problem
-//
-//  Inputs
-//      __boundary : pointer to boundary
-//
-//  Outputs
-//      none
-//
-template <typename GraphType>
-void Schematization<GraphType>::_init( string confFileName ) {
-	
-	GraphType &g = _graph;
-	unsigned int nVertices = num_vertices( g );
-	unsigned int nEdges = num_edges( g );
-	
-	// initialization
-	_nVars = _nConstrs = 0;
-	_half_width = KeiRo::Base::Common::getMainwidgetWidth() / 2.0;
-	_half_height = KeiRo::Base::Common::getMainwidgetHeight() / 2.0;
-	
-	//_d_Alpha = _OrthogonalBoundaryVec->dAlpha();
-	_d_Beta = 1.0;
-	
-	// read config file
-	string configFilePath = qApp->applicationDirPath().toStdString() + confFileName;
-	// string configFilePath = qApp->applicationDirPath().toStdString() + "/../../ResponsiveLens/config/Orthogonal.conf";
-	
-	KeiRo::Base::Config conf( configFilePath );
-	
-	if( conf.has( "schematization_degree" ) ) {
-		string paramDegree = conf.gets( "schematization_degree" );
-		_schematization_degree = KeiRo::Base::Common::stringToDouble( paramDegree );
-	}
-	
-	if( conf.has( "iteration" ) ) {
-		string paramIteration = conf.gets( "iteration" );
-		_iteration = KeiRo::Base::Common::stringToDouble( paramIteration );
-	}
-	
-	if( conf.has( "w_schematization" ) ) {
-		string paramSchematization = conf.gets( "w_schematization" );
-		_w_schematization = sqrt( KeiRo::Base::Common::stringToDouble( paramSchematization ) );
-	}
-	
-	if( conf.has( "w_position" ) ) {
-		string paramPosition = conf.gets( "w_position" );
-		_w_position = sqrt( KeiRo::Base::Common::stringToDouble( paramPosition ) );
-	}
-	
-	if( conf.has( "w_fixposition" ) ) {
-		string paramFixPosition = conf.gets( "w_fixposition" );
-		_w_fixposition = sqrt( KeiRo::Base::Common::stringToDouble( paramFixPosition ) );
-	}
-	
-	if( conf.has( "w_boundary" ) ) {
-		string paramBoundary = conf.gets( "w_boundary" );
-		_w_boundary = sqrt( KeiRo::Base::Common::stringToDouble( paramBoundary ) );
-	}
-	
-	if( conf.has( "w_crossing" ) ) {
-		string paramCrossing = conf.gets( "w_crossing" );
-		_w_crossing = sqrt( KeiRo::Base::Common::stringToDouble( paramCrossing ) );
-	}
-	
-	if( conf.has( "opttype" ) ) {
-		string paramType = conf.gets( "opttype" );
-		if( paramType == "LEAST_SQUARE" )
-			_optType = LEAST_SQUARE;
-		else if( paramType == "CONJUGATE_GRADIENT" )
-			_optType = CONJUGATE_GRADIENT;
-		else {
-			assert( false );
-		}
-	}
-
-// #ifdef DEBUG
-	//cerr << "nAlpha = " << nAlpha << " nBeta = " << nBeta << " nVertices = " << nEdges << endl;
-	//cerr << "_d_Alpha = " << _d_Alpha << endl;
-	//cerr << " _d_Beta = " << _d_Beta << endl;
-	cerr << " w_schematization = " << _w_schematization << endl;
-	cerr << " schematization_degree = " << _schematization_degree << endl;
-	cerr << " iteration = " << _iteration << endl;
-// #endif  // DEBUG
-
-//------------------------------------------------------------------------------
-//      Total number of linear variables
-//------------------------------------------------------------------------------
-	_nVars = 2 * nVertices;
-
-//------------------------------------------------------------------------------
-//      Total number of linear constraints
-//------------------------------------------------------------------------------
-	// Regular edge length
-	_nConstrs += 2 * nEdges;
-	
-	// Positional constraints
-	_nConstrs += 2 * nVertices;
-	
-	_initCoefs();
-	_initVars();
-	_initOutputs();
-	_updateCoefs();
-	_updateOutputs();
-
-#ifdef  DEBUG
-	//printGraph( g );
-	cerr << " nVertices = " << nVertices << " nEdges = " << nEdges << endl;
-	cerr << " nVars = " << _nVars << " nConstrs = " << _nConstrs << endl;
-	cerr << "Finished initializing the linear system" << endl;
-	cerr << "_opttype = " << _opttype << endl;
-#endif  // DEBUG
-}
-
-//
-//  Schematization::_initCoefs --        initialize the coefficient
-//
-//  Inputs
-//      none
-//
-//  Outputs
-//      none
-//
-template <typename GraphType>
-void Schematization<GraphType>::_initCoefs( void ) {
-	
-	GraphType &g = _graph;
-	unsigned int nVertices = num_vertices( g );
-	
-	// initialization
-	unsigned int nRows = 0;
-	_coef.resize( _nConstrs, _nVars );
-	_coef << Eigen::MatrixXd::Zero( _nConstrs, _nVars );
-	
-	// Regular edge schematization
-	BGL_FORALL_EDGES_T( edge, g, GraphType) {
-			
-			typename GraphType::vertex_descriptor vdS = source( edge, g );
-			typename GraphType::vertex_descriptor vdT = target( edge, g );
-			unsigned int idS = MIN2( g[ vdS ].id, g[ vdT ].id );
-			unsigned int idT = MAX2( g[ vdS ].id, g[ vdT ].id );
-			
-			// x
-			_coef( nRows, idS ) = _w_schematization;
-			_coef( nRows, idT ) = -_w_schematization;
-			nRows++;
-			
-			// y
-			_coef( nRows, idS + nVertices ) = _w_schematization;
-			_coef( nRows, idT + nVertices ) = -_w_schematization;
-			nRows++;
-		}
-	
-	// Positional constraints
-	BGL_FORALL_VERTICES_T( vertex, g, GraphType ) {
-			
-			unsigned int id = g[ vertex ].id;
-			bool fix = false;
-			
-			// collect fixed vertices
-			vector< typename GraphType::vertex_descriptor > vdVec;
-			typename GraphType::out_edge_iterator eo, eo_end;
-			for( tie( eo, eo_end ) = out_edges( vertex, g ); eo != eo_end; ++eo ) {
-				
-				typename GraphType::edge_descriptor ed = *eo;
-				typename GraphType::vertex_descriptor vdT = target( ed, g );
-				
-				if( g[ vertex ].isFixed == true ) {
-					vdVec.push_back( vdT );
-				}
-			}
-			
-			// check if on a line
-			if( vdVec.size() == 2 ) {
-				
-				fix = ! KeiRo::Base::Line2::isOnLine( *g[ vertex ].coordPtr,
-				                                      *g[ vdVec[ 0 ] ].coordPtr, *g[ vdVec[ 1 ] ].coordPtr );
-				
-				// cerr << "vid = " << g[ vertex ].id << endl;
-			}
-			
-			if( fix == true ) {
-				
-				// cerr << "vid = " << g[ vertex ].id << " node = " << *g[ vertex ].coordPtr;
-				
-				// x
-				_coef( nRows, id ) = _w_fixposition;
-				nRows++;
-				
-				// y
-				_coef( nRows, id + nVertices ) = _w_fixposition;
-			}
-			else {
-				// x
-				_coef( nRows, id ) = _w_position;
-				nRows++;
-				
-				// y
-				_coef( nRows, id + nVertices ) = _w_position;
-			}
-			nRows++;
-		}
-
-#ifdef  DEBUG
-	cerr << "_coef:" << endl;
-	cerr << _coef << endl;
-#endif  // DEBUG
-}
-
-//
-//  Schematization::_setConstraints --        set the Constraints
-//
-//  Inputs
-//      none
-//
-//  Outputs
-//      none
-//
-template <typename GraphType>
-void Schematization<GraphType>::_setConstraints( unsigned int &nRow ) {
-
-}
-
-//
-//  Schematization::_initVars --        initialize the variables
-//
-//  Inputs
-//      none
-//
-//  Outputs
-//      none
-//
-template <typename GraphType>
-void Schematization<GraphType>::_initVars( void ) {
-	
-	GraphType &g = _graph;
-	unsigned int nVertices = num_vertices( g );
-	
-	// initialization
-	_var.resize( _nVars );
-	
-	unsigned int nRows = 0;
-	BGL_FORALL_VERTICES_T( vertex, g, GraphType ) {
-			
-			_var( nRows, 0 ) = g[ vertex ].coordPtr->x();
-			_var( nRows + nVertices, 0 ) = g[ vertex ].coordPtr->y();
-			nRows++;
-		}
-
-#ifdef  DEBUG
-	cerr << "_initvar:" << endl;
-	cerr << _var << endl;
-#endif  // DEBUG
-}
-
-//
-//  Schematization::_setVars --        set the variables
-//
-//  Inputs
-//      none
-//
-//  Outputs
-//      none
-//
-template <typename GraphType>
-void Schematization<GraphType>::_setVars( unsigned int &nRow ) {
-
-}
-
-template <typename GraphType>
-void Schematization<GraphType>::_updateEdgeCurAngle( void ) {
-	
-	GraphType &g = _graph;
-	
-	// initialization
-	BGL_FORALL_EDGES_T( edge, g, GraphType ) {
-			
-			typename GraphType::vertex_descriptor vS = source( edge, g );
-			typename GraphType::vertex_descriptor vT = target( edge, g );
-			KeiRo::Base::Coord2 vi, vj;
-			if( g[ vS ].id < g[ vT ].id ) {
-				vi = *g[ vS ].coordPtr;
-				vj = *g[ vT ].coordPtr;
-			}
-			else {
-				vi = *g[ vT ].coordPtr;
-				vj = *g[ vS ].coordPtr;
-			}
-			KeiRo::Base::Coord2 vji = vj - vi;
-			
-			double angle = atan2( vji.y(), vji.x() );
-			g[ edge ].angle = angle;
-		}
-
-#ifdef  DEBUG
-	BGL_FORALL_EDGES( edge, g, GraphType ){
-		cerr << "EID = " << g[ edge ].id
-			 << ", edgeCurAngle = " << g[ edge ].angle << endl;
-	}
-#endif  // DEBUG
-}
-
-template <typename GraphType>
-void Schematization<GraphType>::_setTargetAngle( void ) {
-	
-	GraphType &g = _graph;
-	
-	unsigned int axis = _schematization_degree + 1;
-	vector< double > sector;
-	for( unsigned int i = 0; i < axis; i++ ){
-		double m = (axis - 1.0) / 2.0;
-		double angle = ( 0 + (double)i * 1.0/m ) * M_PI -M_PI;
-		// cerr << "i = " << angle << endl;
-		sector.push_back( angle );
-	}
-//	double sector[9] = {-M_PI, -3.0 * M_PI / 4.0, -M_PI / 2.0, -M_PI / 4.0, 0.0,
-//	                    M_PI / 4.0, M_PI / 2.0, 3.0 * M_PI / 4.0, M_PI};
-	
-	// initialization
-	BGL_FORALL_EDGES_T( edge, g, GraphType ) {
-			
-			double targetAngle = 2.0 * M_PI;
-			double minDist = 2.0 * M_PI + 1.0;
-			for( unsigned int i = 0; i < axis; i++ ) {
-				double dist = fabs( g[ edge ].geoAngle - sector[ i ] );
-				if( dist < minDist ) {
-					minDist = dist;
-					targetAngle = sector[ i ];
-				}
-			}
-			g[ edge ].targetAngle = targetAngle;
-		}
-}
-
-#ifdef  SKIP
-void Schematization::_setTargetAngle( void )
-{
-	GraphType        & g            = _OrthogonalBoundaryVec->boundary();
-
-	double sector[ 9 ] = { -M_PI, -3.0*M_PI/4.0, -M_PI/2.0, -M_PI/4.0, 0.0,
-						   M_PI/4.0, M_PI/2.0, 3.0*M_PI/4.0, M_PI };
-
-	vector< vector< GraphType::vertex_descriptor > > vdVec( Orthogonal_SECTOR );
-	BGL_FORALL_VERTICES( vertex, g, GraphType ){
-		GraphType::degree_size_type degrees = out_degree( vertex, g );
-		vdVec[ Orthogonal_SECTOR - degrees ].push_back( vertex );
-	}
-
-#ifdef  DEBUG
-	for( int i = 0; i < vdVec.size(); i++ ){
-		cerr << " i = " << Orthogonal_SECTOR-i << " ";
-		for( int j = 0; j < vdVec[ i ].size(); j++ ){
-			cerr << vertexCoord[ vdVec[i][j] ] <<  " ";
-		}
-		cerr << endl;
-	}
-#endif  // DEBUG
-
-	// initialization
-	BGL_FORALL_EDGES( edge, g, GraphType ){
-		g[ edge ].targetAngle = 2.0*M_PI;
-	}
-
-	// set target angles
-	for( int i = 0; i < vdVec.size(); i++ ){
-		for( int j = 0; j < vdVec[ i ].size(); j++ ){
-
-			map< double, GraphType::edge_descriptor > circM;
-			// sort the angle
-			GraphType::out_edge_iterator e, e_end;
-			for ( tie( e, e_end ) = out_edges( vdVec[i][j], g ); e != e_end; ++e ) {
-				GraphType::edge_descriptor ed = *e;
-				GraphType::vertex_descriptor vS = source( ed, g );
-				GraphType::vertex_descriptor vT = target( ed, g );
-				double angle = g[ ed ].angle;
-
-				if ( g[ vS ].id > g[ vT ].id ) {
-					if ( angle > 0 ) angle = -M_PI + g[ ed ].angle;
-					else angle = M_PI + g[ ed ].angle;
-				}
-				circM.insert( pair< double, GraphType::edge_descriptor >( angle, ed ) );
-				//cerr << "eID = " << edgeID[ ed ] << " angle = " << angle << " curAngle = " << edgeCurAngle[ ed ] << endl;
-				// cerr << "sID = " << vertexID[ vS ] << " tID = " << vertexID[ vT ] << endl;
-			}
-
-			// assign the sector
-			int index = 0;
-			for ( map< double, GraphType::edge_descriptor >::iterator it = circM.begin();
-				  it != circM.end(); it++ ) {
-
-				GraphType::edge_descriptor ed = it->second;
-				GraphType::vertex_descriptor vS = source( ed, g );
-				GraphType::vertex_descriptor vT = target( ed, g );
-
-				if( g[ ed ].targetAngle == 2.0*M_PI ){
-					double angle = g[ ed ].angle;
-					if ( g[ vS ].id > g[ vT ].id ) {
-						if ( angle > 0 ) angle = -M_PI + g[ ed ].angle;
-						else angle = M_PI + g[ ed ].angle;
-					}
-					double target = 0.0, minDist = M_PI;
-
-					for ( int k = index; k < 9 ; k++ ) {
-
-						double dist = fabs( sector[ k ] - angle );
-						if( minDist > dist ) {
-							minDist = dist;
-							target = sector[ k ];
-							index = k+1;
-						}
-					}
-					if ( g[ vS ].id > g[ vT ].id ) {
-						if ( target > 0 ) g[ ed ].targetAngle = -M_PI + target;
-						else g[ ed ].targetAngle = M_PI + target;
-					}
-					else{
-						g[ ed ].targetAngle = target;
-					}
-					//cerr << "EID = " << edgeID[ ed ] << ", index = " << index << ", target = " << edgeTarget[ ed ] << endl;
-					//cerr << "EID = " << edgeID[ ed ] << ", angle = " << edgeCurAngle[ ed ] << ", target = " << edgeTarget[ ed ] << endl;
-				}
-				else{
-					double target = g[ ed ].targetAngle;
-
-					if ( g[ vS ].id > g[ vT ].id ) {
-						if ( target > 0 ) target = -M_PI + g[ ed ].targetAngle;
-						else target = M_PI + g[ ed ].targetAngle;
-					}
-					for( int k = index; k < 9; k++ ){
-						if( target == sector[ k ] ) index = k+1;
-					}
-					//cerr << "EID = " << edgeID[ ed ] << " skipping... " << index << endl;
-				}
-			}
-		}
-	}
-
-#ifdef  DEBUG
-	BGL_FORALL_EDGES( edge, g, GraphType ){
-		cerr << "eid = "<< edgeID[ edge ] << " angle = " << edgeCurAngle[ edge ]
-			 << " target = " << edgeTarget[ edge ] + edgeCurAngle[ edge ]
-			 << " rotate = " << edgeTarget[ edge ] << endl;
-	}
-#endif  // DEBUG
-}
-#endif // SKIP
-
-#ifdef  SKIP
-double Schematization::_findRotateAngle( double input )
-{
-	double target = 0.0, minDist = M_PI;
-	double sector[ 9 ] = { -M_PI, -3.0*M_PI/4.0, -M_PI/2.0, -M_PI/4.0, 0.0,
-						   M_PI/4.0, M_PI/2.0, 3.0*M_PI/4.0, M_PI };
-
-	for ( int i = 0; i < 9 ; i++ ) {
-
-		double dist = fabs( sector[ i ] - input );
-		if( minDist > dist ) {
-			minDist = dist;
-			target = sector[ i ];
-		}
-	}
-
-#ifdef  DEBUG
-	cerr << "inputAngle = " << input << " targetAngle = " << target << " rotate = " << target-input << endl;
-#endif  // DEBUG
-	return target - input;
-}
-#endif  // SKIP
-
-//
-//  Schematization::_initOutputs --        initialize the output
-//
-//  Inputs
-//      none
-//
-//  Outputs
-//      none
-//
-template <typename GraphType>
-void Schematization<GraphType>::_initOutputs( void ) {
-	
-	GraphType &g = _graph;
-	
-	// initialization
-	unsigned int nRows = 0;
-	_output.resize( _nConstrs );
-	_output << Eigen::VectorXd::Zero( _nConstrs );
-	
-	_updateEdgeCurAngle();
-	_setTargetAngle();
-	
-	// Regular edge Orthogonalty
-	BGL_FORALL_EDGES_T( edge, g, GraphType ) {
-			typename GraphType::vertex_descriptor vdS = source( edge, g );
-			typename GraphType::vertex_descriptor vdT = target( edge, g );
-			KeiRo::Base::Coord2 vi, vj;
-			if( g[ vdS ].id < g[ vdT ].id ) {
-				vi = *g[ vdS ].smoothPtr;
-				vj = *g[ vdT ].smoothPtr;
-			}
-			else {
-				vi = *g[ vdT ].smoothPtr;
-				vj = *g[ vdS ].smoothPtr;
-			}
-			KeiRo::Base::Coord2 vji = vi - vj;
-#ifdef  DEBUG
-			cerr << "vji = " << vji;
-#endif  // DEBUG
-			double angle = g[ edge ].angle;
-			double theta = g[ edge ].targetAngle - angle;
-#ifdef  DEBUG
-			cerr << "e( " << g[vdS].id << "," << g[vdT].id << " )"
-				 << " targetAngle = " << g[ edge ].targetAngle
-				 << " angle = " << g[ edge ].angle << endl;
-			cerr << "eid = " << edgeID[ edge ] << " ";
-#endif  // DEBUG
-			double cosTheta = cos( theta ), sinTheta = sin( theta );
-			// double s = _d_Beta * g[ edge ].weight / vji.norm();
-			double s = g[ edge ].weight;
-			
-			// x
-			_output( nRows, 0 ) = _w_schematization * s * ( cosTheta * vji.x() - sinTheta * vji.y() );
-			nRows++;
-			
-			// y
-			_output( nRows, 0 ) = _w_schematization * s * ( sinTheta * vji.x() + cosTheta * vji.y() );
-			nRows++;
-		}
-	
-	
-	// Positional constraints
-	BGL_FORALL_VERTICES_T( vertex, g, GraphType ) {
-			
-			bool fix = false;
-			
-			// collect fixed vertices
-			vector< typename GraphType::vertex_descriptor > vdVec;
-			typename GraphType::out_edge_iterator eo, eo_end;
-			for( tie( eo, eo_end ) = out_edges( vertex, g ); eo != eo_end; ++eo ) {
-				
-				typename GraphType::edge_descriptor ed = *eo;
-				typename GraphType::vertex_descriptor vdT = target( ed, g );
-				
-				if( g[ vertex ].isFixed == true ) {
-					vdVec.push_back( vdT );
-				}
-			}
-			
-			// check if on a line
-			if( vdVec.size() == 2 ) {
-				
-				//fix = true;
-				fix = ! KeiRo::Base::Line2::isOnLine( *g[ vertex ].coordPtr,
-				                                      *g[ vdVec[ 0 ] ].coordPtr, *g[ vdVec[ 1 ] ].coordPtr );
-			}
-			
-			if( fix == true ) {
-				
-				_output( nRows, 0 ) = _w_fixposition * g[ vertex ].smoothPtr->x();
-				nRows++;
-				_output( nRows, 0 ) = _w_fixposition * g[ vertex ].smoothPtr->y();
-				nRows++;
-			}
-			else {
-				_output( nRows, 0 ) = _w_position * g[ vertex ].smoothPtr->x();
-				nRows++;
-				_output( nRows, 0 ) = _w_position * g[ vertex ].smoothPtr->y();
-				nRows++;
-			}
-		}
-
-#ifdef  DEBUG
-	cerr << "_initOutput:" << endl;
-	cerr << _output << endl;
-#endif  // DEBUG
-}
-
-
-//
-//  Schematization::_updateCoefs --        update the coefs
-//
-//  Inputs
-//      none
-//
-//  Outputs
-//      none
-//
-template <typename GraphType>
-void Schematization<GraphType>::_updateCoefs( void ) {
-	
-	GraphType &g = _graph;
-	unsigned int nVertices = num_vertices( g );
-	unsigned int nVE = 0;
-	unsigned int nB = 0;
-	//vector< double > ratioR = _OrthogonalBoundaryVec->ratioR();
-	
-	Eigen::MatrixXd oldCoef;
-	oldCoef = _coef.block( 0, 0, _nConstrs, _nVars );
-
-#ifdef Orthogonal_CONFLICT
-	nVE = _OrthogonalBoundaryVec->VEconflict().size();
-#endif // Orthogonal_CONFLICT
-#ifdef Orthogonal_BOUNDARY
-	BGL_FORALL_VERTICES( vd, g, GraphType )
-	{
-		double minD = _d_Beta/2.0;
-		//if( vertexIsStation[ vd ] == false )
-		//    minD = vertexExternal[ vd ].leaderWeight() * _d_Beta/2.0;
-		if ( g[ vd ].coordPtr->x() <= -( _half_width - minD ) ) nB++;
-		if ( g[ vd ].coordPtr->x() >= ( _half_width - minD ) ) nB++;
-		if ( g[ vd ].coordPtr->y() <= -( _half_height - minD ) ) nB++;
-		if ( g[ vd ].coordPtr->y() >= ( _half_height - minD ) ) nB++;
-	}
-#endif // Orthogonal_BOUNDARY
-	_coef.resize( _nConstrs + nB + 2 * nVE, _nVars );
-	// _coef << Eigen::MatrixXd::Zero( _nConstrs + 2*nVE, _nVars );
-	
-	// copy old coefficient
-	_coef << oldCoef, Eigen::MatrixXd::Zero( nB + 2 * nVE, _nVars );
-	
-	// cerr << "nVE = " << nVE << endl;
-	unsigned int nRows = _nConstrs;
-
-#ifdef  Orthogonal_BOUNDARY
-	// add boundary coefficient
-	BGL_FORALL_VERTICES( vd, g, GraphType ){
-
-		unsigned int id = g[ vd ].id;
-		double minD = _d_Beta/2.0;
-		//if( vertexIsStation[ vd ] == false )
-		//    minD = vertexExternal[ vd ].leaderWeight() * _d_Beta/2.0;
-
-		if ( g[ vd ].coordPtr->x() <= -( _half_width - minD ) ) {
-			_coef( nRows, id ) = _w_boundary;
-			nRows++;
-		}
-		if ( g[ vd ].coordPtr->x() >= ( _half_width - minD ) ) {
-			_coef( nRows, id ) = _w_boundary;
-			nRows++;
-		}
-		if ( g[ vd ].coordPtr->y() <= -( _half_height - minD ) ) {
-			_coef( nRows, id + nVertices ) = _w_boundary;
-			nRows++;
-		}
-		if ( g[ vd ].coordPtr->y() >= ( _half_height - minD ) ) {
-			_coef( nRows, id + nVertices ) = _w_boundary;
-			nRows++;
-		}
-	}
-#endif  // Orthogonal_BOUNDARY
-
-#ifdef  Orthogonal_CONFLICT
-	// copy conflict coefficient
-	unsigned int countVE = 0;
-	for ( VEMap::iterator it = _OrthogonalBoundaryVec->VEconflict().begin();
-		  it != _OrthogonalBoundaryVec->VEconflict().end(); ++it ) {
-		GraphType::vertex_descriptor vdV = it->second.first;
-		GraphType::edge_descriptor ed = it->second.second;
-		GraphType::vertex_descriptor vdS = source( ed, g );
-		GraphType::vertex_descriptor vdT = target( ed, g );
-		unsigned int idV = g[ vdV ].id;
-		unsigned int idS = g[ vdS ].id;
-		unsigned int idT = g[ vdT ].id;
-		double r = ratioR[ countVE ];
-
-		// x
-		_coef( nRows, idV ) = 1.0 * _w_crossing;
-		_coef( nRows, idS ) = -r * _w_crossing;
-		_coef( nRows, idT ) = ( r - 1.0 ) * _w_crossing;
-		nRows++;
-
-		// y
-		_coef( nRows, idV + nVertices ) = 1.0 * _w_crossing;
-		_coef( nRows, idS + nVertices ) = -r * _w_crossing;
-		_coef( nRows, idT + nVertices ) = ( r - 1.0 ) * _w_crossing;
-		nRows++;
-		
-		countVE++;
-	}
-#endif  // Orthogonal_CONFLICT
-
-#ifdef  DEBUG
-	cerr << "###############" << endl;
-	cerr << "newCoef:" << endl;
-	cerr << _coef << endl;
-	cerr << "###############" << endl;
-#endif  // DEBUG
-}
-
-//
-//  Schematization::_updateOutputs --        update the output
-//
-//  Inputs
-//      none
-//
-//  Outputs
-//      none
-//
-template <typename GraphType>
-void Schematization<GraphType>::_updateOutputs( void ) {
-	
-	GraphType &g = _graph;
-	unsigned int nVE = 0;
-	unsigned int nB = 0;
-	//vector< double > ratioR = _OrthogonalBoundaryVec->ratioR();
-	
-	unsigned int nRows = 0;
-	Eigen::VectorXd oldOutput;
-	oldOutput = _output;
-#ifdef  Orthogonal_CONFLICT
-	nVE = _OrthogonalBoundaryVec->VEconflict().size();
-#endif  // Orthogonal_CONFLICT
-#ifdef  Orthogonal_BOUNDARY
-	BGL_FORALL_VERTICES( vd, g, GraphType )
-	{
-		double minD = _d_Beta/2.0;
-		//if( vertexIsStation[ vd ] == false )
-		//    minD = vertexExternal[ vd ].leaderWeight() * _d_Beta/2.0;
-		if ( g[ vd ].coordPtr->x() <= -( _half_width - minD ) ) nB++;
-		if ( g[ vd ].coordPtr->x() >= ( _half_width - minD ) ) nB++;
-		if ( g[ vd ].coordPtr->y() <= -( _half_height - minD ) ) nB++;
-		if ( g[ vd ].coordPtr->y() >= ( _half_height - minD ) ) nB++;
-	}
-#endif  // Orthogonal_BOUNDARY
-	_output.resize( _nConstrs + nB + 2 * nVE );
-	_output << Eigen::VectorXd::Zero( _nConstrs + nB + 2 * nVE );
-	
-	_updateEdgeCurAngle();
-	//_setTargetAngle();
-	
-	// Regular edge Orthogonalty
-	BGL_FORALL_EDGES_T( edge, g, GraphType ) {
-			
-			typename GraphType::vertex_descriptor vdS = source( edge, g );
-			typename GraphType::vertex_descriptor vdT = target( edge, g );
-			//Coord2 vi = vertexSmooth[ vdS ];
-			//Coord2 vj = vertexSmooth[ vdT ];
-			KeiRo::Base::Coord2 vi, vj;
-			if( g[ vdS ].id < g[ vdT ].id ) {
-				vi = *g[ vdS ].coordPtr;
-				vj = *g[ vdT ].coordPtr;
-			}
-			else {
-				vi = *g[ vdT ].coordPtr;
-				vj = *g[ vdS ].coordPtr;
-			}
-			KeiRo::Base::Coord2 vji = vi - vj;
-			double angle = g[ edge ].angle;
-			double theta = g[ edge ].targetAngle - angle;
-			double cosTheta = cos( theta ), sinTheta = sin( theta );
-			// double s = _d_Beta * g[ edge ].weight / vji.norm();
-			double s = g[ edge ].weight;
-
-#ifdef  DEBUG
-			cerr << "vji = " << vji;
-			if( vertexID[ vdS ] == 4 && vertexID[ vdT ] == 5 )
-				cerr << "( " << vertexID[ vdS ] << ", " << vertexID[ vdT ] << ") angle = " << angle << " theta = " << theta << endl;
-#endif  // DEBUG
-			
-			// x
-			_output( nRows, 0 ) = _w_schematization * s * ( cosTheta * vji.x() - sinTheta * vji.y() );
-			nRows++;
-			
-			// y
-			_output( nRows, 0 ) = _w_schematization * s * ( sinTheta * vji.x() + cosTheta * vji.y() );
-			nRows++;
-		}
-	
-	// Positional constraints
-	BGL_FORALL_VERTICES_T( vertex, g, GraphType ) {
-			
-			// x
-			_output( nRows, 0 ) = oldOutput( nRows, 0 );
-			nRows++;
-			
-			// y
-			_output( nRows, 0 ) = oldOutput( nRows, 0 );
-			nRows++;
-		}
-
-#ifdef  Orthogonal_BOUNDARY
-	// boundary constraints
-	BGL_FORALL_VERTICES( vd, g, GraphType ){
-
-		double minD = _d_Beta/2.0;
-		//if( vertexIsStation[ vd ] == false )
-		//    minD = vertexExternal[ vd ].leaderWeight() * _d_Beta/2.0;
-
-		if ( g[ vd ].coordPtr->x() <= -( _half_width - minD ) ) {
-			_output( nRows, 0 ) = _w_boundary * -( _half_width - minD );
-			nRows++;
-		}
-		if ( g[ vd ].coordPtr->x() >= ( _half_width - minD ) ) {
-			_output( nRows, 0 ) = _w_boundary * ( _half_width - minD );
-			nRows++;
-		}
-		if ( g[ vd ].coordPtr->y() <= -( _half_height - minD ) ) {
-			_output( nRows, 0 ) = _w_boundary * -( _half_height - minD );
-			nRows++;
-		}
-		if ( g[ vd ].coordPtr->y() >= ( _half_height - minD ) ) {
-			_output( nRows, 0 ) = _w_boundary * ( _half_height - minD );
-			nRows++;
-		}
-	}
-#endif  // Orthogonal_BOUNDARY
-
-#ifdef  Orthogonal_CONFLICT
-	// copy conflict coefficient
-	unsigned int countVE = 0;
-	for ( VEMap::iterator it = _OrthogonalBoundaryVec->VEconflict().begin();
-		  it != _OrthogonalBoundaryVec->VEconflict().end(); ++it ) {
-		GraphType::vertex_descriptor vdV = it->second.first;
-		GraphType::edge_descriptor ed = it->second.second;
-		GraphType::vertex_descriptor vdS = source( ed, g );
-		GraphType::vertex_descriptor vdT = target( ed, g );
-		unsigned int idV = g[ vdV ].id;
-		unsigned int idS = g[ vdS ].id;
-		unsigned int idT = g[ vdT ].id;
-		double r = ratioR[ countVE ];
-
-		Coord2 v = *g[ vdV ].geoPtr;
-		Coord2 p = r * *g[ vdS ].geoPtr + ( 1.0-r ) * *g[ vdT ].geoPtr;
-		double minD = _d_Beta/2.0;
-		//if( vertexIsStation[ vdV ] == false )
-		//    minD = vertexExternal[ vdV ].leaderWeight() * _d_Beta/2.0;
-		double delta = minD / ( v - p ).norm();
-
-		// x
-		_output( nRows, 0 ) = _w_crossing * delta * ( v - p ).x();
-		nRows++;
-
-		// y
-		_output( nRows, 0 ) = _w_crossing * delta * ( v - p ).y();
-		nRows++;
-	}
-#endif  // Orthogonal_CONFLICT
-
-#ifdef  DEBUG
-	cerr << "_updatedOutput:" << endl;
-	cerr << _output << endl;
-#endif  // DEBUG
-}
-
-//
-//  Schematization::retrieve --        retrieve the result
-//
-//  Inputs
-//      none
-//
-//  Outputs
-//      none
-//
-template <typename GraphType>
-void Schematization<GraphType>::retrieve( void ) {
-	
-	GraphType &g = _graph;
-	const unsigned int nVertices = num_vertices( g );
-	
-	// find the vertex that is too close to an edge
-	vector< typename GraphType::vertex_descriptor > vdVec;
-#ifdef  Orthogonal_CONFLICT
-	for( VEMap::iterator it = _OrthogonalBoundaryVec->VEconflict().begin();
-	     it != _OrthogonalBoundaryVec->VEconflict().end(); ++it ) {
-		GraphType::vertex_descriptor vdV = it->second.first;
-		vdVec.push_back( vdV );
-	}
-#endif  // Orthogonal_CONFLICT
-	
-	unsigned int nRows = 0;
-	// update coordinates
-	// but freeze the vertex that is too close to an edge
-	BGL_FORALL_VERTICES_T( vertex, g, GraphType ) {
-			
-			bool doClose = false;
-			for( unsigned int i = 0; i < vdVec.size(); i++ ) {
-				if( vertex == vdVec[ i ] ) doClose = true;
-			}
-			
-			double x = _var( nRows, 0 );
-			double y = _var( nRows + nVertices, 0 );
-			if( !isnan( x ) && !isnan( y ) ) {
-				if( false ) {
-					//if( _OrthogonalBoundaryVec->VEconflict().size() > 0 ) {
-					KeiRo::Base::Coord2 downscale;
-					downscale.x() = ( x - g[ vertex ].coordPtr->x() ) / 2.0 + g[ vertex ].coordPtr->x();
-					downscale.y() = ( y - g[ vertex ].coordPtr->y() ) / 2.0 + g[ vertex ].coordPtr->y();
-					//if( g[ vertex ].isFixed != true ){
-					g[ vertex ].coordPtr->x() = downscale.x();
-					g[ vertex ].coordPtr->y() = downscale.y();
-					//}
-					//cerr << "x = " << x << " y = " << y << endl;
-				}
-				else {
-					
-					bool fix = false;
-					
-					// collect fixed vertices
-					vector< typename GraphType::vertex_descriptor > vdVec;
-					typename GraphType::out_edge_iterator eo, eo_end;
-					for( tie( eo, eo_end ) = out_edges( vertex, g ); eo != eo_end; ++eo ) {
-						
-						typename GraphType::edge_descriptor ed = *eo;
-						typename GraphType::vertex_descriptor vdT = target( ed, g );
-						
-						if( g[ vertex ].isFixed == true ) {
-							vdVec.push_back( vdT );
-						}
-					}
-					
-					// check if on a line
-					if( vdVec.size() == 2 ) {
-						
-						fix = ! KeiRo::Base::Line2::isOnLine( *g[ vertex ].coordPtr,
-						                                      *g[ vdVec[ 0 ] ].coordPtr, *g[ vdVec[ 1 ] ].coordPtr );
-						
-						// cerr << "vid = " << g[ vertex ].id << endl;
-					}
-					
-					//if( fix != true ){
-					//if( g[ vertex ].isFixed != true ){
-					g[ vertex ].coordPtr->x() = x;
-					g[ vertex ].coordPtr->y() = y;
-					//}
-				}
-			}
-			nRows++;
-		}
-
-#ifdef  Orthogonal_CONFLICT
-	// check possible conflict
-	_OrthogonalBoundaryVec->checkVEConflicts();
-#endif  // Orthogonal_CONFLICT
-
-#ifdef  DEBUG
-	cerr << "retrieve:" << endl;
-	BGL_FORALL_VERTICES( vertex, g, GraphType ){
-		cerr << "V(" << g[ vertex ].id << ") = " << *g[ vertex ].smoothPtr;
-	}
-	BGL_FORALL_EDGES( edge, g, GraphType ){
-		cerr << "E(" << g[ edge ].id << ") : smoAngle= " << edgeSmoAngle[ edge ] << endl;
-	}
-#endif  // DEBUG
-}
-
-#endif // _Schematization_H
-
-// end of header file
-// Do not add any stuff under this line.

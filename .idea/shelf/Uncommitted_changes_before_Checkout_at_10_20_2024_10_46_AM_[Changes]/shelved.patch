Index: ResponsiveLens/core/HierarchicalTreemap.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// HierarchicalTreemap.cpp\r\n//\t: program file for HierarchicalTreemap\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Mon Mar 16 07:58:23 2020\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include \"core/HierarchicalTreemap.h\"\r\n\r\nnamespace Lens {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPrivate Functions\r\n    //------------------------------------------------------------------------------\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tProtected Functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  HierarchicalTreemap::_init -- initialize the graph.\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void HierarchicalTreemap::_init( MetaData *__metadataPtr,\r\n                     map< unsigned int, unsigned int > *__selectSceneItemMapPtr,\r\n\t\t   \t\t     double *__increaseRatioPtr, double *__siblingRatioPtr, double *__minSizePtr )\r\n    {\r\n\t    // initialization\r\n\t    _clear();\r\n\t    \r\n\t    _widthPtr               = &KeiRo::Base::Common::mainwidgetWidth();\r\n\t    _heightPtr              = &KeiRo::Base::Common::mainwidgetHeight();\r\n\t    _metadataPtr            = __metadataPtr;\r\n\t    _selectSceneItemMapPtr  = __selectSceneItemMapPtr;\r\n\t    _increaseRatioPtr\t    = __increaseRatioPtr;\r\n\t    _siblingRatioPtr\t    = __siblingRatioPtr;\r\n\t    _minSizePtr\t\t        = __minSizePtr;\r\n\r\n\t    _buildSortedLevel();\r\n\r\n#ifdef HierarchicalTreemap_DEBUG\r\n\t    cerr << \"_widthPtr = \" << *_widthPtr << \" _heightPtr = \" << *_heightPtr << endl;\r\n\t    cerr << \"num_vertices( _svgTree ) = \" << num_vertices( _metadataPtr->svgTree() ) << endl;\r\n\t    cerr << \"num_edges( _svgTree ) = \" << num_edges( _metadataPtr->svgTree() ) << endl;\r\n\t    cerr << \"num_vertices( _graphmlTree ) = \" << num_vertices( _metadataPtr->graphmlTree() ) << endl;\r\n\t    cerr << \"num_edges( _graphmlTree ) = \" << num_edges( _metadataPtr->graphmlTree() ) << endl;\r\n#endif // HierarchicalTreemap_DEBUG\r\n\t\t\r\n\t    //------------------------------------------------------------------------------\r\n        // configuration file\r\n        //------------------------------------------------------------------------------\r\n    }\r\n\r\n    //\r\n    //  HierarchicalTreemap::_init -- initialize the graph.\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void HierarchicalTreemap::_clear( void )\r\n    {\r\n\t    _treemapVec.clear();\r\n\t    _sortedLevel.clear();\r\n\t    \r\n//        int nV = num_vertices( _treemapTree );\r\n//\r\n//        if( nV != 0 ){\r\n//            _treemapTree.clear();\r\n//        }\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPublic functions\r\n    //------------------------------------------------------------------------------\r\n    //------------------------------------------------------------------------------\r\n    //\tConstructors & Destructors\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  HierarchicalTreemap::HierarchicalTreemap --\tdefault constructor\r\n    //\r\n    //  Inputs\r\n    //\tnone\r\n    //\r\n    //  Outputs\r\n    //\tnone\r\n    //\r\n    HierarchicalTreemap::HierarchicalTreemap()\r\n    {\r\n\t    // create tmp folder for stable treemap command\r\n\t    QString filePath = qApp->applicationDirPath() + QString( \"/tmp\" );\r\n\t\r\n\t    // create the temporary folder\r\n\t    QString inputFolder = filePath + QString( \"/input\" );\r\n\t    QString outputFolder = filePath + QString( \"/output\" );\r\n\t    if( QDir( filePath ).exists() ){\r\n\t\t    QDir( filePath ).removeRecursively();\r\n\t\t    cerr << \"Remove existing tmp folders!\" << endl;\r\n\t    }\r\n\t    QDir().mkdir( filePath );\r\n\t    cerr << \"create a tmp folder: \" << filePath.toStdString() << endl;\r\n\t\r\n\t    if( !QDir( inputFolder ).exists() ){\r\n\t\t    QDir().mkdir( inputFolder );\r\n\t\t    cerr << \"create a tmp folder!\" << endl;\r\n\t    }\r\n\t    if( !QDir( outputFolder ).exists() ){\r\n\t\t    QDir().mkdir( outputFolder );\r\n\t\t    cerr << \"create a tmp folder!\" << endl;\r\n\t    }\r\n\t\r\n\t    _sizeAssignmentType = ABSOLUTE_TYPE;\r\n    }\r\n\r\n    //\r\n    //  HierarchicalTreemap::~HierarchicalTreemap --\tdestructor\r\n    //\r\n    //  Inputs\r\n    //\tnone\r\n    //\r\n    //  Outputs\r\n    //\tnone\r\n    //\r\n    HierarchicalTreemap::~HierarchicalTreemap()\r\n    {\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tAssignment operators\r\n    //------------------------------------------------------------------------------\r\n\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tSpecial functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  HierarchicalTreemap::createHierarchicalTreemap --\tcreate a HierarchicalTreemap from the samples\r\n    //\r\n    //  Inputs\r\n    //\tnone\r\n    //\r\n    //  Outputs\r\n    //\tnone\r\n    //\r\n    void HierarchicalTreemap::createHierarchicalTreemap( void )\r\n    {\r\n\t    double ww = KeiRo::Base::Common::getMainwidgetWidth();\r\n\t    double wh = KeiRo::Base::Common::getMainwidgetHeight();\r\n\t\r\n\t    Graph::TreeDirectedGraph &graphmlTree = _metadataPtr->graphmlTree();\r\n\t    map< unsigned int, Graph::BaseUndirectedGraph > &graphmlGraphMap = _metadataPtr->graphmlGraphMap();\r\n\t    Graph::TreeDirectedGraph::vertex_descriptor parentVD;\r\n\t    KeiRo::Base::Rectangle2 *boundingBoxPtr =  NULL;\r\n\t\t\r\n\t\t// initialize graphmlTree\r\n\t    _treemapVec.resize( num_vertices( graphmlTree ) );\r\n\t    BGL_FORALL_VERTICES( vd, graphmlTree, Graph::TreeDirectedGraph ) {\r\n\t\t\tcerr << \"vd : \"<< graphmlTree[ vd ].id <<endl;\r\n\t\t\tboundingBoxPtr = graphmlTree[ vd ].boundingBoxPtr;\r\n\t\t\tif( graphmlTree[ vd ].id == 0 ) {\r\n\t\t\t\t// root, extend to the entire screen space\r\n\t\t\t\tboundingBoxPtr->leftBottom().x() = -0.5*ww;\r\n\t\t\t\tboundingBoxPtr->leftBottom().y() = -0.5*wh;\r\n\t\t\t\tboundingBoxPtr->width() = *_widthPtr;\r\n\t\t\t\tboundingBoxPtr->height() = *_heightPtr;\r\n\t\t    }\r\n\t\t    else {\r\n\t\t\t\t// non-root node, extend to the entire size of the parent\r\n\t\t\t\tboundingBoxPtr = graphmlTree[ vd ].boundingBoxPtr;\r\n\t\t    }\r\n\r\n\t\t    unsigned int id = graphmlTree[ vd ].id;\r\n\t\t    graphmlTree[ vd ].aspectRatio = boundingBoxPtr->width() / boundingBoxPtr->height();\r\n\t\t\tgraphmlTree[ vd ].coordPtr->x() = boundingBoxPtr->leftBottom().x() + 0.5* boundingBoxPtr->width();\r\n\t\t\tgraphmlTree[ vd ].coordPtr->x() = boundingBoxPtr->leftBottom().y() + 0.5* boundingBoxPtr->height();\r\n\t\t\t\r\n\t\t    // create a treemap\r\n\t\t    Treemap treemap;\r\n\t\t    treemap.id() = id;\r\n\t\t    treemap.level() = graphmlTree[vd].level;\r\n\t\t    _treemapVec[ id ] = treemap;\r\n        }\r\n\t\t\r\n#ifdef HierarchicalTreemap_DEBUG\r\n\t    BGL_FORALL_VERTICES( vd, _treemapTree, Graph::TreeDirectedGraph ) {\r\n\r\n\t\t\tcerr << \"_treemapTree[vd].boundingBox = \" << endl << *_treemapTree[vd].boundingBoxPtr;\r\n\t\t}\r\n\t\tcerr << endl;\r\n#endif // HierarchicalTreemap_DEBUG\r\n\t\t\r\n\t    // initialize treemaps by ordered levels\r\n\t    for( unsigned int i = 0; i < _sortedLevel.size(); i++ ){\r\n\t\t    for( unsigned int j = 0; j < _sortedLevel[i].size(); j++ ) {\r\n\t\t\t\r\n\t\t\t    unsigned int id = _sortedLevel[ i ][ j ];\r\n\t\t\t    Graph::BaseUndirectedGraph &graphmlGraph = graphmlGraphMap.find( id )->second;\r\n\t\t\t    Graph::TreeDirectedGraph::vertex_descriptor vd = vertex( id, graphmlTree );\r\n\t\t\t\r\n\t\t\t\t_treemapVec[id].init( _metadataPtr, graphmlTree[ vd ].boundingBoxPtr );\r\n\r\n\t\t\t    if( i != _metadataPtr->maxLevel()-1 ) {\r\n\t\t\t\t    _treemapVec[id].initNonLeafTreemap();\r\n\t\t\t\t    _treemapVec[id].prepareTreemap();\r\n\t\t\t\t    _treemapVec[id].createTreemap();\r\n\t\t\t    }\r\n\t\t\t    else{\r\n\t\t\t\t    _treemapVec[id].initLeafTreemap();\r\n\t\t\t    }\r\n\t\t    }\r\n\t    }\r\n\t\r\n\t    // normalize the size\r\n\t    for( int i = _sortedLevel.size()-2; i >= 0; i-- ){\r\n\t\t\r\n\t\t    // collect total size\r\n\t\t    if( i == _sortedLevel.size()-2 ){\r\n\t\t\t    for( unsigned int j = 0; j < _sortedLevel[i].size(); j++ ) {\r\n\t\t\t\t    unsigned int id = _sortedLevel[ i ][ j ];\r\n\t\t\t\t    double total = 0.0;\r\n\t\t\t\t    Graph::TreeDirectedGraph::vertex_descriptor vd = vertex( id, graphmlTree );\r\n\t\t\t\t    graphmlTree[vd].size = 0.0;\r\n\t\t\t\t    for( unsigned int k = 0; k < _treemapVec[id].treemapSizeMap().size(); k++ ){\r\n\t\t\t\t\t    map< unsigned int, pair< double, double > >::iterator it = _treemapVec[id].treemapSizeMap().begin();\r\n\t\t\t\t\t    std::advance( it, k );\r\n\t\t\t\t\t    graphmlTree[vd].size += it->second.second;\r\n\t\t\t\t\t    total += it->second.second;\r\n\t\t\t\t    }\r\n#ifdef HierarchicalTreemap_DEBUG\r\n\t\t\t\t    cerr << \"total = \" << total << endl;\r\n#endif // HierarchicalTreemap_DEBUG\r\n\t\t\t\t}\r\n\t\t    }\r\n\t\t    else{\r\n\t\t\t    for( unsigned int j = 0; j < _sortedLevel[i].size(); j++ ) {\r\n\t\t\t\t    unsigned int id = _sortedLevel[ i ][ j ];\r\n\t\t\t\t    Graph::TreeDirectedGraph::vertex_descriptor vd = vertex( id, graphmlTree );\r\n\t\t\t\t    for( unsigned int k = 0; k < graphmlTree[vd].childMap.size(); k++ ){\r\n\t\t\t\t\t    map< unsigned int, unsigned int >::iterator itC = graphmlTree[vd].childMap.begin();\r\n\t\t\t\t\t    map< unsigned int, pair< double, double > >::iterator it = _treemapVec[id].treemapSizeMap().begin();\r\n\t\t\t\t\t    map< unsigned int, pair< double, double > >::iterator itF = _treemapVec[id].treemapFixedSizeMap().begin();\r\n\t\t\t\t\t    std::advance( itC, k );\r\n\t\t\t\t\t    std::advance( it, k );\r\n\t\t\t\t\t    std::advance( itF, k );\r\n\t\t\t\t\t    unsigned int idC = itC->second;\r\n\t\t\t\t\t    Graph::TreeDirectedGraph::vertex_descriptor vdC = vertex( idC, graphmlTree );\r\n\t\t\t\t\t    it->second.first = it->second.second = itF->second.first = itF->second.second = graphmlTree[vdC].size;\r\n\t\t\t\t    }\r\n\t\t\t    }\r\n\t\t    }\r\n\t    }\r\n\t\r\n\t    // initialize the old coordinate for animation\r\n\t    for( unsigned int i = 0; i < _treemapVec.size(); i++ ){\r\n\t\t    map< unsigned int, KeiRo::Base::Rectangle2 > &targetMap = _treemapVec[i].treemapTargetMap();\r\n\t\t    for( map< unsigned int, KeiRo::Base::Rectangle2 >::iterator it = targetMap.begin();\r\n\t\t         it != targetMap.end(); it++ ){\r\n\t\t\t    it->second.updateOldElement();\r\n\t\t    }\r\n\t    }\r\n\t\t\r\n#ifdef HierarchicalTreemap_DEBUG\r\n\t    cerr << \"no. of treemapVec = \" << _treemapVec.size() << endl;\r\n\t    int sum = 1;\r\n\t    for( unsigned int i = 0; i < _treemapVec.size(); i++ ){\r\n\t\t    map< string, KeiRo::Base::Rectangle2 > &targetMap = _treemapVec[i].treemapTargetMap();\r\n\t\t    if( _treemapVec[i].level() < 1 ) sum += targetMap.size();\r\n\t    }\r\n\t    cerr << \"sum = \" << sum << endl;\r\n\r\n\t    BGL_FORALL_VERTICES( vd, svgTree, Graph::TreeDirectedGraph ) {\r\n\t\t\t    cerr << \"sid = \" << svgTree[vd] << endl;\r\n\t\t\t    for( unsigned int i = 0; i < svgTree[vd].childMap.size(); i++ ){\r\n\t\t\t\t    map< unsigned int, unsigned int >::iterator it = svgTree[vd].childMap.begin();\r\n\t\t\t\t    std::advance( it, i );\r\n\t\t\t\t    cerr << it->second << endl;\r\n\t\t\t    }\r\n\t\t\t    cerr << endl;\r\n\t\t    }\r\n\t    \r\n\t    BGL_FORALL_VERTICES( vd, _treemapTree, Graph::TreeDirectedGraph ) {\r\n\t    \tcerr << \"tid = \" << _treemapTree[vd] << endl;\r\n\t    \tfor( unsigned int i = 0; i < _treemapTree[vd].childMap.size(); i++ ){\r\n\t\t\t    map< unsigned int, unsigned int >::iterator it = _treemapTree[vd].childMap.begin();\r\n\t    \t\tstd::advance( it, i );\r\n\t    \t\tcerr << it->second << endl;\r\n\t    \t}\r\n\t    \tcerr << endl;\r\n\t    }\r\n\r\n\t    for( unsigned int i = 0; i < _treemapVec.size(); i++ ){\r\n\t    \t\r\n\t\t    map< string, KeiRo::Base::Rectangle2 > &sourceMap = _treemapVec[i].treemapSourceMap();\r\n\t\t    map< string, KeiRo::Base::Rectangle2 > &targetMap = _treemapVec[i].treemapTargetMap();\r\n\t\t    map< string, KeiRo::Base::Rectangle2 >::iterator itS = sourceMap.begin();\r\n\t\t    map< string, KeiRo::Base::Rectangle2 >::iterator itT = targetMap.begin();\r\n\r\n\t\t    if( sourceMap.size() > 0 ){\r\n\t\t\t    cerr << \"i = \" << i << \" == \" << _treemapVec[i].id() << endl;\r\n\t\t\t    cerr << \"level = \" << _treemapVec[i].level() << endl;\r\n\t\t    }\r\n\t\t    for( ; itS != sourceMap.end(); itS++ ) {\r\n\t\t\t\tcerr << \"nameS = \" << itS->first << \" rs = \" << itS->second << endl;\r\n\t\t\t}\r\n\t\t    for( ; itT != targetMap.end(); itT++ ) {\r\n\t\t\t    cerr << \"nameT = \" << itT->first << \" rt = \" << itT->second << endl;\r\n\t\t    }\r\n\t    }\r\n#endif // HierarchicalTreemap_DEBUG\r\n    }\r\n\t\r\n\t//\r\n\t//  HierarchicalTreemap::resetHierarchicalTreemap --\treset HierarchicalTreemap to inital stage\r\n\t//\r\n\t//  Inputs\r\n\t//\tnone\r\n\t//\r\n\t//  Outputs\r\n\t//\tnone\r\n\t//\r\n\tvoid HierarchicalTreemap::resetHierarchicalTreemap( void )\r\n\t{\r\n#ifdef REWRITE\r\n\t\tvector< FileIO::SVG* > &svgPtrVec = _metadataPtr->svgPtrVec();\r\n\t\t\r\n\t\tfor( unsigned int i = 0; i < svgPtrVec.size(); i++ ){\r\n\t\t\t\r\n\t\t\tFileIO::SVG* svgPtr = svgPtrVec[i];\r\n\t\t\tvector< KeiRo::Base::Coord2 > &samples = svgPtrVec[ i ]->compressionGrid().samples();\r\n\t\t\tvector< KeiRo::Base::Polygon2 > &polygonVec = svgPtrVec[ i ]->polygonVec();\r\n\t\t\tvector< KeiRo::Base::Line2 > &polylineVec = svgPtrVec[ i ]->polylineVec();\r\n\t\t\tmap< string, pair< double, double > > &treemapFixedSizeMap = _treemapVec[ i ].treemapFixedSizeMap();\r\n\t\t\tmap< string, pair< double, double > > &treemapSizeMap = _treemapVec[ i ].treemapSizeMap();\r\n\t\t\tmap< string, KeiRo::Base::Rectangle2 > &treemapSourceMap = _treemapVec[ i ].treemapSourceMap();\r\n\t\t\tmap< string, KeiRo::Base::Rectangle2 > &treemapTargetMap = _treemapVec[ i ].treemapTargetMap();\r\n\t\t\t\r\n\t\t\tfor( unsigned int j = 0; j < polygonVec.size(); j++ ){\r\n\t\t\t\tpolygonVec[j].elements() = polygonVec[j].fixedElements();\r\n\r\n//\t\t\t\tif( i == 7 ) {\r\n//\t\t\t\t\tfor( unsigned int k = 0; k < polygonVec[ j ].fixedElements().size(); k++ ) {\r\n//\t\t\t\t\t\tcerr << \"polygonVec[j].s = \" << samples[ polygonVec[ j ].idElements()[ k ] ];\r\n//\t\t\t\t\t\tcerr << \"polygonVec[j].f = \" << polygonVec[ j ].fixedElements()[ k ];\r\n//\t\t\t\t\t\tcerr << \"polygonVec[j].e = \" << polygonVec[ j ].elements()[ k ];\r\n//\t\t\t\t\t}\r\n//\t\t\t\t}\r\n\t\t\t\tfor( unsigned int k = 0; k < polygonVec[j].elements().size(); k++ ){\r\n\t\t\t\t\tsamples[ polygonVec[ j ].idElements()[ k ] ].updateOldElement();\r\n\t\t\t\t\tsamples[ polygonVec[ j ].idElements()[ k ] ].setX( polygonVec[j].elements()[k].x() );\r\n\t\t\t\t\tsamples[ polygonVec[ j ].idElements()[ k ] ].setY( polygonVec[j].elements()[k].y() );\r\n\t\t\t\t}\r\n\t\t\t\tpolygonVec[j].boundingBox().updateOldElement();\r\n\t\t\t\tpolygonVec[j].update();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor( unsigned int j = 0; j < polylineVec.size(); j++ ){\r\n\t\t\t\t\r\n\t\t\t\tpolylineVec[j].elements() = polylineVec[j].fixedElements();\r\n\t\t\t\t\r\n\t\t\t\tfor( unsigned int k = 0; k < polylineVec[j].elements().size(); k++ ){\r\n\t\t\t\t\tsamples[ polylineVec[ j ].idElements()[ k ] ].updateOldElement();\r\n\t\t\t\t\tsamples[ polylineVec[ j ].idElements()[ k ] ].setX( polylineVec[j].elements()[k].x() );\r\n\t\t\t\t\tsamples[ polylineVec[ j ].idElements()[ k ] ].setY( polylineVec[j].elements()[k].y() );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tunsigned int mapSize = treemapFixedSizeMap.size();\r\n\t\t\t treemapSizeMap = treemapFixedSizeMap;\r\n\t\t\tfor( unsigned int j = 0; j < mapSize; j++ ) {\r\n\t\t\t\tmap< string, KeiRo::Base::Rectangle2 >::iterator itS = treemapSourceMap.begin();\r\n\t\t\t\tmap< string, KeiRo::Base::Rectangle2 >::iterator itT = treemapTargetMap.begin();\r\n\t\t\t\tstd::advance( itS, j );\r\n\t\t\t\tstd::advance( itT, j );\r\n\t\t\t\t\r\n\t\t\t\titS->second.oldLeftBottom() = itS->second.leftBottom();\r\n\t\t\t\titS->second.oldWidth() = itS->second.width();\r\n\t\t\t\titS->second.oldHeight() = itS->second.height();\r\n\t\t\t\titT->second.oldLeftBottom() = itT->second.leftBottom();\r\n\t\t\t\titT->second.oldWidth() = itT->second.width();\r\n\t\t\t\titT->second.oldHeight() = itT->second.height();\r\n\t\t\t\t\r\n\t\t\t\titS->second.leftBottom() = itS->second.fixedLeftBottom();\r\n\t\t\t\titS->second.width() = itS->second.fixedWidth();\r\n\t\t\t\titS->second.height() = itS->second.fixedHeight();\r\n\t\t\t\titT->second.leftBottom() = itT->second.fixedLeftBottom();\r\n\t\t\t\titT->second.width() = itT->second.fixedWidth();\r\n\t\t\t\titT->second.height() = itT->second.fixedHeight();\r\n\t\t\t}\r\n    \t}\r\n#endif // REWRITE\r\n\t}\r\n\t\r\n\t//\r\n\t//  HierarchicalTreemap::_buildSortedLevel --\tbuild sorted level\r\n\t//\r\n\t//  Inputs\r\n\t//\tnone\r\n\t//\r\n\t//  Outputs\r\n\t//\tnone\r\n\t//\r\n\tvoid HierarchicalTreemap::_buildSortedLevel( void )\r\n\t{\r\n    \t// initialization\r\n    \t_sortedLevel.resize( _metadataPtr->maxLevel() );\r\n\t\tGraph::TreeDirectedGraph &graphmlTree = _metadataPtr->graphmlTree();\r\n\r\n\t\tBGL_FORALL_VERTICES( vd, graphmlTree, Graph::TreeDirectedGraph ) {\r\n\t\t\tunsigned int id = graphmlTree[vd].id;\r\n\t\t\tunsigned int level = graphmlTree[vd].level;\r\n\t\t\t_sortedLevel[ level ].push_back( id );\r\n\t\t}\r\n  \r\n#ifdef HierarchicalTreemap_DEBUG\r\n        cerr << \"_metadataPtr->maxLevel() = \" << _metadataPtr->maxLevel() << endl;\r\n\t\tfor( unsigned int i = 0; i < _sortedLevel.size(); i++ ){\r\n\t\t\tcerr << \"i = \" << i << \": \";\r\n\t\t\tfor( unsigned int j = 0; j < _sortedLevel[ i ].size(); j++ ) {\r\n\t\t\t\tcerr << _sortedLevel[ i ][ j ] << \", \";\r\n\t\t\t}\r\n\t\t\tcerr << endl;\r\n\t\t}\r\n#endif // HierarchicalTreemap_DEBUG\r\n\t}\r\n\t\r\n\t//\r\n\t//  HierarchicalTreemap::updateHierarchicalTreemap --\tupdate a HierarchicalTreemap from the samples\r\n\t//\r\n\t//  Inputs\r\n\t//\tnone\r\n\t//\r\n\t//  Outputs\r\n\t//\tnone\r\n\t//\r\n\tvector<LocalMove> HierarchicalTreemap::updateHierarchicalTreemap( bool isInitialized ) {\r\n\t\r\n#ifdef HierarchicalTreemap_DEBUG\r\n\t\tfor( unsigned int i = 0; i < _treemapVec.size(); i++ ){\r\n\t\t\tcerr << \"i = \" << i << \", id = \" << _treemapVec[i].id() << endl;\r\n\t\t}\r\n#endif // HierarchicalTreemap_DEBUG\r\n\t\t\r\n\t\tGraph::TreeDirectedGraph &graphmlTree = _metadataPtr->graphmlTree();\r\n\t\tmap< unsigned int, Graph::BaseUndirectedGraph > &graphmlGraphMap = _metadataPtr->graphmlGraphMap();\r\n\r\n\t\t// store the old coordinates for animation\r\n\t\tBGL_FORALL_VERTICES( vd, graphmlTree, Graph::TreeDirectedGraph ) {\r\n\t\t\tgraphmlTree[ vd ].boundingBoxPtr->updateOldElement();\r\n\t\t}\r\n\t\t\r\n\t\t// store the old coordinates for animation\r\n\t\tfor( unsigned int i = 0; i < _treemapVec.size(); i++ ) {\r\n\t\t\tmap< unsigned int, KeiRo::Base::Rectangle2 > &targetMap = _treemapVec[ i ].treemapTargetMap();\r\n\t\t\tfor( map< unsigned int, KeiRo::Base::Rectangle2 >::iterator it = targetMap.begin();\r\n\t\t\t     it != targetMap.end(); it++ ) {\r\n//\t\t\t\tcerr << \"it->first = \" << it->first << endl;\r\n//\t\t\t\tcerr << \"it->second = \" << it->second.id() << endl;\r\n\t\t\t\tit->second.updateOldElement();\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// store old coordinate for animation purpose\r\n\t\tfor( unsigned int i = 0; i < _treemapVec.size(); i++ ){\r\n\t\t\t_treemapVec[i].updateOldWidthHeight();\r\n\t\t}\r\n\t\t\r\n\t\tvector<LocalMove> localMoves;\r\n\r\n\t\t// update the layout through stable treemap approach, starting from the top of the hierarchy towards the leaves\r\n\t\tfor( unsigned int i = 0; i < _sortedLevel.size() - 1; i++ ) {\r\n\t\t\t\r\n\t\t\tvector<LocalMove> tempMoves;\r\n\t\t\t\r\n\t\t\tfor( unsigned int j = 0; j < _sortedLevel[ i ].size(); j++ ) {\r\n\t\t\t\tunsigned int id = _sortedLevel[ i ][ j ];\r\n#ifdef HierarchicalTreemap_DEBUG\r\n\t\t\t\tcerr << \"i = \" << i << \", j = \" << j << \", id = \" << id << endl;\r\n#endif // HierarchicalTreemap_DEBUG\r\n\r\n\t\t\t\tcerr << \"Pointer points to address \" << &tempMoves << endl;\r\n\r\n\t\t\t\t_treemapVec[ id ].prepareTreemap();\r\n\t\t\t\ttempMoves = _treemapVec[ id ].updateTreemap();\r\n\t\t\t\t//cerr << \"tempMOVES \" << tempMoves.size()<<endl;\r\n\t\t\t\tcerr << \"Updated a treemap with address \" << &tempMoves << endl;\r\n\r\n\t\t\t\ttempMoves = _validateMoves(tempMoves, i+1); //check whether local moves work on level i+1 of treemap, remove if not\r\n\t\t\t\tcerr << \"tempMOVES \" << tempMoves.size()<<endl;\r\n\t\t\t\tcerr << \"Validated moves at address\" << &tempMoves << endl;\r\n\r\n\t\t\t\t// first scale treemap cells otherwise we cannot use newly computed sizes for intermediate coordinates\r\n\t\t\t\t_scaleTreemapCells( i, j );\r\n\t\t\t\t// update the intermediate coordinates for the validated localMoves\r\n\t\t                _updateIntermediateCells(tempMoves, id);\r\n\t\t\t\tcerr <<\" _localMoves inside update treemap\"<<localMoves.size() <<endl;\r\n\t\t\t\tlocalMoves.insert(localMoves.end(), tempMoves.begin(), tempMoves.end());\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// update detailed sub graphs\r\n\t\t\tif( i == _metadataPtr->maxLevel() - 2 ){\r\n\t\t\t\t_updateSubGraphs( i+1, tempMoves );\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\t\r\n#ifdef HierarchicalTreemap_DEBUG\r\n\t\tfor( unsigned int i=0; i < _treemapVec.size(); i++ ){\r\n\t\t\tcerr << \"After: \" << endl\r\n\t\t\t     << \" lt = \" << *_treemapVec[i].leftBottomCoordPtr()\r\n\t\t\t     << \" w = \" << *_treemapVec[i].widthPtr()\r\n\t\t\t     << \" h = \" << *_treemapVec[i].heightPtr()\r\n\t\t\t     << endl;\r\n\t\t}\r\n\t\tcerr << \"isInitialized = \" << isInitialized << endl;\r\n#endif // HierarchicalTreemap_DEBUG\r\n\t\t\r\n\t\t// remove empty cells, only need to do it once after initialization\r\n\t\tif( _metadataPtr->dataType() == DATA_GRAPHML && isInitialized == false ) {\r\n\t\t\t\r\n\t\t\tGraph::TreeDirectedGraph &graphmlTree   = _metadataPtr->graphmlTree();\r\n\t\t\t\r\n\t\t\tfor( unsigned int i = 0; i < _treemapVec.size(); i++ ) {\r\n\t\t\t\t\r\n\t\t\t\tmap< unsigned int, pair< double, double > > &treemapFixedSizeMap = _treemapVec[ i ].treemapFixedSizeMap();\r\n\t\t\t\tmap< unsigned int, pair< double, double > > &treemapSizeMap = _treemapVec[ i ].treemapSizeMap();\r\n\t\t\t\tmap< unsigned int, KeiRo::Base::Rectangle2 > &treemapSourceMap = _treemapVec[ i ].treemapSourceMap();\r\n\t\t\t\tmap< unsigned int, KeiRo::Base::Rectangle2 > &treemapTargetMap = _treemapVec[ i ].treemapTargetMap();\r\n\t\t\t\t\r\n\t\t\t\tunsigned int id = _treemapVec[ i ].id();\r\n\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd = vertex( id, graphmlTree );\r\n\t\t\t\tGraph::TreeDirectedGraph::degree_size_type degrees = out_degree( vd, graphmlTree );\r\n\r\n#ifdef HierarchicalTreemap_DEBUG\r\n\t\t\t\tcerr << \"id = \" << id << endl;\r\n\t\t\t\tcerr << \"treemapFixedSizeMap.size() = \" << treemapFixedSizeMap.size() << endl;\r\n\t\t\t\tcerr << \"treemapSizeMap.size() = \" << treemapSizeMap.size() << endl;\r\n\t\t\t\tcerr << \"treemapSourceMap.size() = \" << treemapSourceMap.size() << endl;\r\n\t\t\t\tcerr << \"treemapTargetMap.size() = \" << treemapTargetMap.size() << endl;\r\n#endif // HierarchicalTreemap_DEBUG\r\n\r\n\t\t\t\tunsigned int diffSize = treemapFixedSizeMap.size() - degrees;\r\n\t\t\t\t// pop from the back\r\n\t\t\t\tfor( unsigned int j = 0; j < diffSize; j++ ) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tmap< unsigned int, pair< double, double > >::iterator itF = treemapFixedSizeMap.end();\r\n\t\t\t\t\tmap< unsigned int, pair< double, double > >::iterator itM = treemapSizeMap.end();\r\n\t\t\t\t\tmap< unsigned int, KeiRo::Base::Rectangle2 >::iterator itS = treemapSourceMap.end();\r\n\t\t\t\t\tmap< unsigned int, KeiRo::Base::Rectangle2 >::iterator itT = treemapTargetMap.end();\r\n\t\t\t\t\titF--;\r\n\t\t\t\t\titM--;\r\n\t\t\t\t\titS--;\r\n\t\t\t\t\titT--;\r\n\t\t\t\t\t\r\n\t\t\t\t\ttreemapFixedSizeMap.erase( itF );\r\n\t\t\t\t\ttreemapSizeMap.erase( itM );\r\n\t\t\t\t\ttreemapSourceMap.erase( itS );\r\n\t\t\t\t\ttreemapTargetMap.erase( itT );\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// initial treemaps fixed properties\r\n\t\t\t\ttreemapSizeMap = treemapFixedSizeMap;\r\n\t\t\t\tfor( unsigned int j = 0; j < treemapSizeMap.size(); j++ ) {\r\n\r\n\t\t\t\t\tmap< unsigned int, KeiRo::Base::Rectangle2 >::iterator itS = treemapSourceMap.begin();\r\n\t\t\t\t\tmap< unsigned int, KeiRo::Base::Rectangle2 >::iterator itT = treemapTargetMap.begin();\r\n\r\n\t\t\t\t\tstd::advance( itS, j );\r\n\t\t\t\t\tstd::advance( itT, j );\r\n\t\t\t\t\titS->second.fixedLeftBottom() = itS->second.leftBottom();\r\n\t\t\t\t\titS->second.fixedWidth() = itS->second.width();\r\n\t\t\t\t\titS->second.fixedHeight() = itS->second.height();\r\n\r\n\t\t\t\t\titT->second.fixedLeftBottom() = itT->second.leftBottom();\r\n\t\t\t\t\titT->second.fixedWidth() = itT->second.width();\r\n\t\t\t\t\titT->second.fixedHeight() = itT->second.height();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn localMoves;\r\n\t}\r\n\r\n\tvector<LocalMove> HierarchicalTreemap::_validateMoves( vector<LocalMove>& localMoves, unsigned int level )\r\n\t{\r\n\t\tvector<LocalMove> validatedMoves;\r\n\r\n\t\tfor( unsigned int i = 0; i < localMoves.size(); i++ ) {\r\n\t\t\tif(_treemapVec[localMoves[i].beforeLeftBottomID()].level() == level) {\r\n\t\t\t\tvalidatedMoves.push_back(localMoves[i]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn validatedMoves;\r\n\t}\r\n\r\n\tvoid HierarchicalTreemap::_updateIntermediateCells( vector<LocalMove>& localMoves, unsigned int id )\r\n\t{\r\n    \t//\r\n\t\tTreemap parent = _treemapVec[ id ];\r\n\t\tmap< unsigned int, KeiRo::Base::Rectangle2 > &treemapIntermediateMap = parent.treemapIntermediateMap();\r\n\t\tGraph::TreeDirectedGraph &graphmlTree   = _metadataPtr->graphmlTree();\r\n\t\t\r\n\t\tGraph::TreeDirectedGraph::vertex_descriptor vdParent = vertex( id , graphmlTree );\r\n\t\tKeiRo::Base::Rectangle2 intParent = *graphmlTree[ vdParent ].boundingBoxPtr;\r\n\t\t\r\n\t\tcerr << \"updateIntermediateCells is called\" << endl;\r\n\t\t\r\n\t\tif( localMoves.size() > 0 && !parent.boundingBoxPtr()->inLocalMove() ) { // intermediate parent rectangle not yet computed\r\n\t\t\r\n\t\t\tcerr << \"Parent cell is updated\" << endl;\r\n\t\t\tKeiRo::Base::Coord2 intLeftBottom;\r\n\t\t\t// compute coordinates to be halfway between new and old coordinates\r\n\t\t\tintLeftBottom.set( (intParent.leftBottom().x() + intParent.oldLeftBottom().x())/2, (intParent.leftBottom().y() + intParent.oldLeftBottom().y())/2 );\r\n\t\t\t// create intermediate parent rectangle halfway between new and old rectangle\r\n\t\t\tintParent.updateIntermediateElement( intLeftBottom, (intParent.width() + intParent.oldWidth())/2, (intParent.height() + intParent.oldHeight())/2);\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tfor( unsigned int i = 0; i < localMoves.size(); i++ ) { // TO TURN OFF SET CONDITION TO i < MIN2(1, localMoves.size()) INSTEAD OF i < localMoves.size()\r\n\r\n\t\t\tLocalMove m = localMoves[i];\r\n\t\t\t\r\n\t\t\tcerr << \"Intermediate cell for local move \" << i << \" is updated, with LB \" << m.beforeLeftBottomID() << \" and RT \" << m.beforeRightTopID() << endl;\r\n\t\t\t\r\n\t\t\tmap< unsigned int, KeiRo::Base::Rectangle2 >::iterator itLB = treemapIntermediateMap.find( m.beforeLeftBottomID() );\r\n\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdPLB = vertex( m.beforeLeftBottomID() , graphmlTree );\r\n\t\t\tKeiRo::Base::Rectangle2 &bboxLB = *graphmlTree[ vdPLB ].boundingBoxPtr;\r\n\t\t\t\r\n\t\t\tmap< unsigned int, KeiRo::Base::Rectangle2 >::iterator itRT = treemapIntermediateMap.find( m.beforeRightTopID() );\r\n\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdPRT = vertex( m.beforeRightTopID() , graphmlTree );\r\n\t\t\tKeiRo::Base::Rectangle2 &bboxRT = *graphmlTree[ vdPRT ].boundingBoxPtr;\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t// find bounding box of intermediate rectangles in local move using following variables\r\n\t\t\tKeiRo::Base::Coord2 intLeftBottomLB, intLeftBottomRT;\r\n\t\t\tdouble intWidthLB, intHeightLB, intWidthRT, intHeightRT, totalHeight, totalWidth;\r\n\t\t\t\r\n\t\t\t// make sure unshrunk rectangles are set\r\n\t\t\tif(!bboxLB.inLocalMove()) {\r\n\t\t\t\tcerr << \"bboxLB is not in local move yet\" << endl;\r\n\t\t\t\tbboxLB.unshrunkLeftBottom().set( ( bboxLB.oldLeftBottom().x() + bboxLB.leftBottom().x() ) / 2,\r\n\t\t\t\t\t\t( bboxLB.oldLeftBottom().y() + bboxLB.leftBottom().y() ) / 2 );\r\n\t\t\t\tbboxLB.unshrunkWidth() = ( bboxLB.oldWidth() + bboxLB.width() ) / 2;\r\n\t\t\t\tbboxLB.unshrunkHeight() = ( bboxLB.oldHeight() + bboxLB.height() ) / 2;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(!bboxRT.inLocalMove()) {\r\n\t\t\t\tcerr << \"bboxLB is not in local move yet\" << endl;\r\n\t\t\t\tbboxRT.unshrunkLeftBottom().set( ( bboxRT.oldLeftBottom().x() + bboxRT.leftBottom().x() ) / 2,\r\n\t\t\t\t\t\t( bboxRT.oldLeftBottom().y() + bboxRT.leftBottom().y() ) / 2 );\r\n\t\t\t\tbboxRT.unshrunkWidth() = ( bboxRT.oldWidth() + bboxRT.width() ) / 2;\r\n\t\t\t\tbboxRT.unshrunkHeight() = ( bboxRT.oldHeight() + bboxRT.height() ) / 2;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// compute naive intermediate rectangles\r\n\t\t\tintLeftBottomLB.set( \tbboxLB.unshrunkLeftBottom().x(),\r\n\t\t\t\t\t\tbboxLB.unshrunkLeftBottom().y() );\r\n\t\t\tintWidthLB = bboxLB.unshrunkWidth();\r\n\t\t\tintHeightLB = bboxLB.unshrunkHeight();\r\n\t\t\t\r\n\t\t\tintLeftBottomRT.set(\tbboxRT.unshrunkLeftBottom().x(),\r\n\t\t\t\t\t\tbboxRT.unshrunkLeftBottom().y() );\r\n\t\t\tintWidthRT = bboxRT.unshrunkWidth();\r\n\t\t\tintHeightRT = bboxRT.unshrunkHeight();\r\n\t\t\t\r\n\t\t\t// find the bottom left corners and widht/height of intermediate rectangles in local move\r\n\t\t\t// this is doen by shrinking the rectangles to remove overlap\r\n\t\t\tif(m.beforeLeftBottomID() == m.afterLeftBottomID() && m.beforeSegmentHorizontal()) { // this rectangle is bottom left intermediate\r\n\t\t\t\r\n\t\t\t\tcerr << \"bottom left stays bottom left\" << endl;\r\n\t\t\t\t// shrink LB to the left corner\r\n\t\t\t\tintWidthLB = intLeftBottomRT.x() - intLeftBottomLB.x();\r\n\t\t\t\t// shrink RT to the bottom corner (WHICH IS TOP NOW)\r\n\t\t\t\tintHeightRT = intLeftBottomLB.y() - intLeftBottomRT.y();\r\n\t\t\t\t\r\n\t\t\t\t// set unshrunk heights for next local move\r\n\t\t\t\ttotalHeight = intHeightLB + intHeightRT;\r\n\t\t\t\tif(!m.stretchMove()) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tbboxLB.unshrunkLeftBottom().y() = intLeftBottomRT.y();\r\n\t\t\t\t\tbboxLB.unshrunkHeight() = totalHeight;\r\n\t\t\t\t\tbboxRT.unshrunkHeight() = totalHeight;\t\r\n\t\t\t\t\t\r\n\t\t\t\t} else if(m.stretchedID() == m.beforeLeftBottomID()) {\r\n\t\t\t\t\r\n\t\t\t\t\tbboxLB.unshrunkLeftBottom().y() = intLeftBottomRT.y();\r\n\t\t\t\t\tbboxLB.unshrunkHeight() = totalHeight;\r\n\t\t\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t\tbboxRT.unshrunkHeight() = totalHeight;\r\n\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\r\n\t\t\t} else if(m.beforeLeftBottomID() == m.afterLeftBottomID() && !m.beforeSegmentHorizontal()) { // this rectangle is bottom left intermediate\r\n\t\t\t\t\r\n\t\t\t\tcerr << \"bottom left stays bottom left\" << endl;\r\n\t\t\t\t// shrink LB to the left corner\r\n\t\t\t\tintWidthLB = intLeftBottomRT.x() - intLeftBottomLB.x();\r\n\t\t\t\t// shrink RT to the bottom corner (WHICH IS TOP NOW)\r\n\t\t\t\tintHeightRT = intLeftBottomLB.y() - intLeftBottomRT.y();\r\n\t\t\t\t\r\n\t\t\t\t// set unshrunk heights for next local move\r\n\t\t\t\ttotalWidth = intWidthLB + intWidthRT;\r\n\t\t\t\tif(!m.stretchMove()) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tbboxLB.unshrunkWidth() = totalWidth;\r\n\t\t\t\t\tbboxRT.unshrunkLeftBottom().x() = intLeftBottomLB.x();\r\n\t\t\t\t\tbboxRT.unshrunkWidth() = totalWidth;\t\r\n\t\t\t\t\t\r\n\t\t\t\t} else if(m.stretchedID() == m.beforeLeftBottomID()) {\r\n\t\t\t\t\r\n\t\t\t\t\tbboxRT.unshrunkLeftBottom().x() = intLeftBottomLB.x();\r\n\t\t\t\t\tbboxLB.unshrunkWidth() = totalWidth;\r\n\t\t\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t\tbboxRT.unshrunkWidth() = totalWidth;\r\n\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} else if(m.beforeSegmentHorizontal()) { // && m.beforeLeftBottomID() == m.afterRightTop() this rectangle is bottom right intermediate\r\n\r\n\t\t\t\tcerr << \"bottom left becomes right top, bottom right intermediate\" << endl;\r\n\t\t\t\t// shrink LB to the right corner\r\n\t\t\t\tintWidthLB = intWidthLB - (intWidthRT - ( intLeftBottomLB.x() - intLeftBottomRT.x() ));\r\n\t\t\t\tintLeftBottomLB.set( intLeftBottomRT.x() + intWidthRT, intLeftBottomLB.y() );\r\n\t\t\t\t// shrink RT to the bottom corner (WHICH IS TOP NOW)\r\n\t\t\t\tintHeightRT = intLeftBottomLB.y() - intLeftBottomRT.y();\r\n\t\t\t\t\r\n\t\t\t\t// set unshrunk heights for next local move\r\n\t\t\t\ttotalHeight = intHeightLB + intHeightRT;\r\n\t\t\t\tif(!m.stretchMove()) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tbboxLB.unshrunkLeftBottom().y() = intLeftBottomRT.y();\r\n\t\t\t\t\tbboxLB.unshrunkHeight() = totalHeight;\r\n\t\t\t\t\tbboxRT.unshrunkHeight() = totalHeight;\t\r\n\t\t\t\t\t\r\n\t\t\t\t} else if(m.stretchedID() == m.beforeLeftBottomID()) {\r\n\t\t\t\t\r\n\t\t\t\t\tbboxLB.unshrunkLeftBottom().y() = intLeftBottomRT.y();\r\n\t\t\t\t\tbboxLB.unshrunkHeight() = totalHeight;\r\n\t\t\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t\tbboxRT.unshrunkHeight() = totalHeight;\r\n\t\t\t\t\r\n\t\t\t\t}\r\n\r\n\t\t\t} else { // vertical && m.beforeLeftBottomID() == m.afterRightTop() this rectangle is top left intermediate\r\n\t\t\t\t\r\n\t\t\t\tcerr << \"bottom left becomes right top, top left intermediate\" << endl;\r\n\t\t\t\t// shirnk LB to the top corner (WHICH IS BOTTOM NOW)\r\n\t\t\t\tintHeightLB = intLeftBottomRT.y() - intLeftBottomLB.y();\r\n\t\t\t\t// shrink RT to the right corner\r\n\t\t\t\tintWidthRT = intWidthRT - (intWidthLB - ( intLeftBottomRT.x() - intLeftBottomLB.x() ));\r\n\t\t\t\tintLeftBottomRT.set( intLeftBottomLB.x() + intWidthLB, intLeftBottomRT.y() );\r\n\t\t\t\t\r\n\t\t\t\t// set unshrunk heights for next local move\r\n\t\t\t\ttotalWidth = intWidthLB + intWidthRT;\r\n\t\t\t\tif(!m.stretchMove()) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tbboxLB.unshrunkWidth() = totalWidth;\r\n\t\t\t\t\tbboxRT.unshrunkLeftBottom().x() = intLeftBottomLB.x();\r\n\t\t\t\t\tbboxRT.unshrunkWidth() = totalWidth;\t\r\n\t\t\t\t\t\r\n\t\t\t\t} else if(m.stretchedID() == m.beforeLeftBottomID()) {\r\n\t\t\t\t\r\n\t\t\t\t\tbboxLB.unshrunkWidth() = totalWidth;\r\n\t\t\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t\tbboxRT.unshrunkLeftBottom().x() = intLeftBottomLB.x();\r\n\t\t\t\t\tbboxRT.unshrunkWidth() = totalWidth;\r\n\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// use update methods to ensure that _inLocalMove will be set\r\n\t\t\titLB->second.updateIntermediateElement( intLeftBottomLB, intWidthLB, intHeightLB );\r\n\t\t\tbboxLB.updateIntermediateElement( intLeftBottomLB, intWidthLB, intHeightLB );\r\n\t\t\titLB->second.updateIntermediateElement( intLeftBottomRT, intWidthRT, intHeightRT );\r\n\t\t\tbboxRT.updateIntermediateElement( intLeftBottomRT, intWidthRT, intHeightRT );\r\n\t\t}\r\n\t}\r\n\t\r\n\t//\r\n\t//  HierarchicalTreemap::_scaleTreemapCells --\tscale polygons at the corresponding levels\r\n\t//\r\n\t//  Inputs\r\n\t//\tlevel: target level\r\n\t//\r\n\t//  Outputs\r\n\t//\tnone\r\n\t//\r\n\tvoid HierarchicalTreemap::_scaleTreemapCells( unsigned int level, unsigned int i )\r\n\t{\r\n\t\tGraph::TreeDirectedGraph &graphmlTree   = _metadataPtr->graphmlTree();\r\n\t\t\t\r\n\t\t\tunsigned int id = _sortedLevel[ level ][ i ];\r\n\t\t\tLens::Treemap &treemap = _treemapVec[ id ];\r\n\t\t\t\r\n\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd = vertex( id, graphmlTree );\r\n\t\t\tGraph::TreeDirectedGraph::out_edge_iterator e, e_end;\r\n\t\t\t\r\n\t\t\tfor( tie( e, e_end ) = out_edges( vd, graphmlTree ); e != e_end; ++e ) {\r\n\t\t\t\t\r\n\t\t\t\tGraph::TreeDirectedGraph::edge_descriptor ed = *e;\r\n\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdT = target( ed, graphmlTree );\r\n\t\t\t\t\r\n\t\t\t\tmap< unsigned int, KeiRo::Base::Rectangle2 >::iterator itS = treemap.treemapSourceMap().find( graphmlTree[vdT].id );\r\n\t\t\t\tKeiRo::Base::Rectangle2 &source = itS->second;\r\n\t\t\t\tmap< unsigned int, KeiRo::Base::Rectangle2 >::iterator itT = treemap.treemapTargetMap().find( graphmlTree[vdT].id );\r\n\t\t\t\tKeiRo::Base::Rectangle2 &target = itT->second;\r\n#ifdef HierarchicalTreemap_DEBUG\r\n\t\t\t\tcerr << \"index = \" << index << \", label = \" << itT->first << endl;\r\n#endif // HierarchicalTreemap_DEBUG\r\n\t\t\t\t\r\n\t\t\t\t// normalization\r\n\t\t\t\tdouble sx = source.leftBottom().x();\r\n\t\t\t\tdouble sy = source.leftBottom().y();\r\n\t\t\t\tdouble sw = source.width();\r\n\t\t\t\tdouble sh = source.height();\r\n\t\t\t\tdouble tx = target.leftBottom().x();\r\n\t\t\t\tdouble ty = target.leftBottom().y();\r\n\t\t\t\tdouble tw = target.width();\r\n\t\t\t\tdouble th = target.height();\r\n\t\t\t\t\r\n\t\t\t\tdouble &x = graphmlTree[ vdT ].boundingBoxPtr->leftBottom().x();\r\n\t\t\t\tdouble &y = graphmlTree[ vdT ].boundingBoxPtr->leftBottom().y();\r\n#ifdef HierarchicalTreemap_DEBUG\r\n\t\t\t\tcerr << \"A: (x,y) = (\" << x << \", \" << y << \")\" << endl;\r\n\t\t\t\tcerr << \"B: (tx,ty) = (\" << tx << \", \" << ty << \")\" << endl;\r\n#endif // HierarchicalTreemap_DEBUG\r\n\t\t\t\tx = ( x - sx ) * tw / sw + tx;\r\n\t\t\t\ty = ( y - sy ) * th / sh + ty;\r\n\t\t\t\tgraphmlTree[ vdT ].boundingBoxPtr->width() = tw;\r\n\t\t\t\tgraphmlTree[ vdT ].boundingBoxPtr->height() = th;\r\n\t\t\t}\r\n\t}\r\n\t\r\n\t//\r\n\t//  HierarchicalTreemap::_updateSubGraphs --\tscale polygons at the corresponding levels\r\n\t//\r\n\t//  Inputs\r\n\t//\tlevel: target level\r\n\t//\r\n\t//  Outputs\r\n\t//\tnone\r\n\t//\r\n\tvoid HierarchicalTreemap::_updateSubGraphs( unsigned int level, vector<LocalMove>& localmoves )\r\n\t{\r\n\t\tGraph::TreeDirectedGraph &graphmlTree   = _metadataPtr->graphmlTree();\r\n\t\tmap< unsigned int, Graph::BaseUndirectedGraph > &graphmlGraphMap = _metadataPtr->graphmlGraphMap();\r\n\r\n\t\tfor( map< unsigned int, Graph::BaseUndirectedGraph >::iterator it = graphmlGraphMap.begin();\r\n\t\t\t it != graphmlGraphMap.end(); it++ ){\r\n\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdP = vertex( it->first , graphmlTree );\r\n\t\t\tKeiRo::Base::Rectangle2 &bbox = *graphmlTree[ vdP ].boundingBoxPtr; // this bounding box has already been updated and hence can be used to define new coordinates\r\n\t\t\tGraph::BaseUndirectedGraph &subGraph = it->second;\r\n\r\n\t\t\t// iterate edges\r\n\t\t\tBGL_FORALL_EDGES( ed, subGraph, Graph::BaseUndirectedGraph ) {\r\n\t\t\t\tKeiRo::Base::Edge2 &edge = subGraph[ed].edge;\r\n\t\t\t\tfor( unsigned int i = 0; i < edge.elements().size(); i++ ){\r\n\t\t\t\t\t\r\n\t\t\t\t\tKeiRo::Base::Coord2 &coord = edge.elements()[i];\r\n\t\t\t\t\tcoord.updateOldElement();\r\n\t\t\t\t\tcoord.x() = ( coord.x() - bbox.oldLeftBottom().x() ) * bbox.width()/bbox.oldWidth() + bbox.leftBottom().x();\r\n\t\t\t\t\tcoord.y() = ( coord.y() - bbox.oldLeftBottom().y() ) * bbox.height()/bbox.oldHeight() + bbox.leftBottom().y();\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(bbox.inLocalMove()) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t\tcerr << \"Subgraph edge is updated\" << endl;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tdouble intermediateX = ( coord.oldElement()[0] - bbox.oldLeftBottom().x() ) * bbox.intermediateWidth()/bbox.oldWidth() + bbox.intermediateLeftBottom().x();\r\n\t\t\t\t\t\tdouble intermediateY = ( coord.oldElement()[1] - bbox.oldLeftBottom().y() ) * bbox.intermediateHeight()/bbox.oldHeight() + bbox.intermediateLeftBottom().y();\r\n\t\t\t\t\t\tcoord.updateIntermediateElement( intermediateX, intermediateY );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// iterate vertices\r\n\t\t\tBGL_FORALL_VERTICES( vd, subGraph, Graph::TreeDirectedGraph ) {\r\n\r\n\t\t\t\tsubGraph[vd].coordPtr->updateOldElement();\r\n\t\t\t\tsubGraph[vd].coordPtr->x() = ( subGraph[vd].coordPtr->x() - bbox.oldLeftBottom().x() ) * bbox.width()/bbox.oldWidth() + bbox.leftBottom().x();\r\n\t\t\t\tsubGraph[vd].coordPtr->y() = ( subGraph[vd].coordPtr->y() - bbox.oldLeftBottom().y() ) * bbox.height()/bbox.oldHeight() + bbox.leftBottom().y();\r\n\t\t\t\t\r\n\t\t\t\tif(bbox.inLocalMove()) {\r\n\r\n\t\t\t\t\tcerr << \"Subgraph vertex is updated\" << endl;\r\n\t\t\t\t\r\n\t\t\t\t\tdouble intermediateX = ( subGraph[vd].coordPtr->oldElement()[0] - bbox.oldLeftBottom().x() ) * bbox.intermediateWidth()/bbox.oldWidth() + bbox.intermediateLeftBottom().x();\r\n\t\t\t\t\tdouble intermediateY = ( subGraph[vd].coordPtr->oldElement()[1] - bbox.oldLeftBottom().y() ) * bbox.intermediateHeight()/bbox.oldHeight() + bbox.intermediateLeftBottom().y();\r\n\t\t\t\t\tsubGraph[vd].coordPtr->updateIntermediateElement( intermediateX, intermediateY );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\tvoid HierarchicalTreemap::_assignTreemapSizeAbsolute( void )\r\n\t{\r\n\t\tGraph::TreeDirectedGraph    &graphmlTree    = _metadataPtr->graphmlTree();\r\n\r\n\t\tdouble increaseAreaSum = 0.0;\r\n\t\tdouble increaseRatio = 0.5;\r\n\t\t\r\n\t\t// update selected polygons\r\n\t\tfor( map< unsigned int, unsigned int >::iterator it = _selectSceneItemMapPtr->begin();\r\n\t\t\t it != _selectSceneItemMapPtr->end(); it++ ){\r\n\t\t\r\n\t\t\tunsigned int id = it->second;\r\n//    \t\tunsigned int level = 0;//std::get<0>( it->second );\r\n//\t\t    unsigned int member = 0;//std::get<1>( it->second );\r\n//\t\t    unsigned int polygonMember = 0;//std::get<2>( it->second );\r\n//\t\t    unsigned int id = _sortedLevel[level][member];\r\n\t\t    Graph::TreeDirectedGraph::vertex_descriptor vd = vertex( id, graphmlTree );\r\n\t\t    unsigned int idP = graphmlTree[ vd ].parentID;\r\n//\t\t    map< unsigned int, unsigned int > &childMap = graphmlTree[ vd ].childMap;\r\n\t\t    \r\n\t\t    map< unsigned int, pair< double, double > > &treemapFixedSizeMap = _treemapVec[ idP ].treemapFixedSizeMap();\r\n\t\t    map< unsigned int, pair< double, double > > &treemapSizeMap = _treemapVec[ idP ].treemapSizeMap();\r\n\t\t    map< unsigned int, pair< double, double > >::iterator itF = treemapFixedSizeMap.find( id );\r\n\t\t    map< unsigned int, pair< double, double > >::iterator itS = treemapSizeMap.find( id );\r\n//\t\t    std::advance( itF, polygonMember );\r\n//\t\t    std::advance( itS, polygonMember );\r\n\t\t    double increaseNewArea = itF->second.first * increaseRatio;\r\n\t\t    increaseAreaSum += increaseNewArea;\r\n\t\t    itS->second.second = itF->second.first + increaseNewArea;\r\n\r\n\t\t    // bottom up\r\n\t\t    while( true ){\r\n\t\t\r\n//\t\t\t    unsigned int parentFileID1 = svgPtrVec[ id ]->polygonVec()[ polygonMember ].parentFileID().first;\r\n//\t\t\t    unsigned int parentFileID2 = svgPtrVec[ id ]->polygonVec()[ polygonMember ].parentFileID().second;\r\n//\t\t\t    unsigned int parentPolygonID = svgPtrVec[ id ]->polygonVec()[ polygonMember ].parentPolygonID();\r\n//\t\t\t    parentID = _sortedLevel[parentFileID1][parentFileID2];\r\n\t\t\t    Graph::TreeDirectedGraph::vertex_descriptor vdP = vertex( idP, graphmlTree );\r\n\t\t\t    map< unsigned int, pair< double, double > > &parentTreemapSizeMap = _treemapVec[ idP ].treemapSizeMap();\r\n\t\t\t    map< unsigned int, pair< double, double > >::iterator itP = parentTreemapSizeMap.find( id );\r\n\t\t\t    itP->second.second += increaseNewArea;\r\n\t\t\t\t\r\n#ifdef HierarchicalTreemap_DEBUG\r\n\t\t\t\tcerr << \"id = \" << id << \", pid = \" << parentID << endl;\r\n\t\t\t    cerr << \" _treemapTree[ _treemapRoot ].id = \" <<  _treemapTree[ _treemapRoot ].id\r\n\t\t\t         << \" ?= parentID = \" << parentID\r\n\t\t\t         << endl;\r\n#endif // HierarchicalTreemap_DEBUG\r\n\t\t\t\tif( idP == 0 ) { // root\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tid = idP;\r\n\t\t\t\t\tidP = graphmlTree[ vdP ].parentID;\r\n\t\t\t\t}\r\n\t\t    }\r\n#ifdef HierarchicalTreemap_DEBUG\r\n\t\t    cerr << \"tuples: \" << endl;\r\n    \t\tcerr << \" it->first = \" << it->first << endl\r\n\t\t\t     << \" it->second.0 = \" << level\r\n\t\t\t     << \" it->second.1 = \" << member\r\n\t\t\t     << \" it->second.2 = \" << polygonMember\r\n\t\t\t     << endl;\r\n    \t\tcerr << \"oldArea = \" << itF->second.first << \", newArea = \" << increaseNewArea << endl;\r\n#endif // HierarchicalTreemap_DEBUG\r\n    \t}\r\n\r\n    \t// normalize\r\n    \tdouble ww = KeiRo::Base::Common::getMainwidgetWidth();\r\n\t\tdouble wh = KeiRo::Base::Common::getMainwidgetHeight();\r\n    \tdouble totalArea = ww * wh + increaseAreaSum;\r\n        for( unsigned i = 0; i < _sortedLevel.size(); i++ ){\r\n\t        for( unsigned j = 0; j < _sortedLevel[i].size(); j++ ) {\r\n\t        \tunsigned int id = _sortedLevel[i][j];\r\n\t\t        map< unsigned int, pair< double, double > > &treemapSizeMap = _treemapVec[ id ].treemapSizeMap();\r\n\t\t        for( unsigned int k = 0; k < treemapSizeMap.size(); k++ ){\r\n\t\t\t        map< unsigned int, pair< double, double > >::iterator it = treemapSizeMap.begin();\r\n\t\t\t        std::advance( it, k );\r\n\t\t\t        it->second.second = it->second.second/(totalArea);\r\n\t\t        }\r\n\t        }\r\n        }\r\n    }\r\n    \r\n\tvoid HierarchicalTreemap::_assignTreemapSizeExact( void )\r\n\t{\r\n\t\tdouble ww = KeiRo::Base::Common::getMainwidgetWidth();\r\n\t\tdouble wh = KeiRo::Base::Common::getMainwidgetHeight();\r\n\r\n\t\tGraph::TreeDirectedGraph    &graphmlTree    = _metadataPtr->graphmlTree();\r\n//\t\tvector< FileIO::SVG* > &svgPtrVec       = _metadataPtr->svgPtrVec();\r\n//\t\tGraph::TreeDirectedGraph svgTree        = _metadataPtr->svgTree();\r\n\t\tdouble increaseAreaSum = 0.0;\r\n\t\tdouble increaseRatio = 0.4;\r\n\t\t\r\n\t\t// printGraph( graphmlTree );\r\n\t\t// reset area\r\n\t\tfor( map< unsigned int, unsigned int >::iterator it = _selectSceneItemMapPtr->begin();\r\n\t\t     it != _selectSceneItemMapPtr->end(); it++ ) {\r\n\r\n//\t\t\tunsigned int level = 0;//std::get< 0 >( it->second );\r\n//\t\t\tunsigned int member = 0;//std::get< 1 >( it->second );\r\n//\t\t\tunsigned int polygonMember = 0;//std::get< 2 >( it->second );\r\n//\t\t\tunsigned int id = _sortedLevel[ level ][ member ];\r\n\t\t\tunsigned int id = it->second;\r\n\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd = vertex( id, graphmlTree );\r\n\t\t\tunsigned int level = graphmlTree[ vd ].level;\r\n\t\t\tunsigned int idP = graphmlTree[ vd ].parentID;\r\n\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdP = vertex( idP, graphmlTree );\r\n\t\t\t\r\n\t\t\tmap< unsigned int, pair< double, double > > &treemapFixedSizeMap = _treemapVec[ idP ].treemapFixedSizeMap();\r\n\t\t\tmap< unsigned int, pair< double, double > > &treemapSizeMap = _treemapVec[ idP ].treemapSizeMap();\r\n\t\t\tmap< unsigned int, pair< double, double > >::iterator itF = treemapFixedSizeMap.find( id );\r\n\t\t\tmap< unsigned int, pair< double, double > >::iterator itS = treemapSizeMap.find( id );\r\n//\t\t\tstd::advance( itF, polygonMember );\r\n//\t\t\tstd::advance( itS, polygonMember );\r\n\t\t\tdouble increaseNewArea =\r\n\t\t\t\t\tMIN2( ww * wh - MIN_TREEMAPCELL_AREA, itF->second.first * ( 1.0 + increaseRatio ) ) -\r\n\t\t\t\t\titF->second.first;\r\n\t\t\tincreaseAreaSum += increaseNewArea;\r\n\t\t\titS->second.second = itF->second.first + increaseNewArea;\r\n\t\t\t\r\n\t\t\tdouble decreaseArea = increaseNewArea / ( double ) ( treemapSizeMap.size() - 1 );\r\n\t\t\tfor( map< unsigned int, pair< double, double > >::iterator it = treemapSizeMap.begin();\r\n\t\t\t     it != treemapSizeMap.end(); it++ ) {\r\n\t\t\t\tif( id != it->first ) {\r\n\t\t\t\t\tit->second.second = MAX2( MIN_TREEMAPCELL_AREA, it->second.second - decreaseArea );\r\n\t\t\t\t}\r\n\t\t\t}\r\n#ifdef HierarchicalTreemap_DEBUG\r\n\t\t\tcerr << \"HERE! _selectSceneItemsPtr->size() = \" << _selectSceneItemsPtr->size() << endl;\r\n\t\t\tcerr << \"increaseArea = \" << increaseNewArea << endl;\r\n\t\t\tcerr << \"decreaseArea = \" << decreaseArea << endl;\r\n\t\t\tfor( unsigned int i = 0; i < treemapSizeMap.size(); i++ ) {\r\n\t\t\t\tmap< string, pair< double, double > >::iterator itN = treemapSizeMap.begin();\r\n\t\t\t\tstd::advance( itN, i );\r\n\t\t\t\tcerr << itN->second.second << \", \" << endl;\r\n\t\t\t}\r\n\t\t\tcerr << endl;\r\n#endif // HierarchicalTreemap_DEBUG\r\n\t\t\t\r\n\t\t\t// normalization\r\n\t\t\tfor( unsigned int i = level + 1; i < _sortedLevel.size(); i++ ) {\r\n\t\t\t\tfor( unsigned int j = 0; j < _sortedLevel[ i ].size(); j++ ) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tunsigned int idSibling = _sortedLevel[ i ][ j ];\r\n\t\t\t\t\t\r\n\t\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdS = vertex( idSibling, graphmlTree );\r\n//\t\t\t\t\tvector< KeiRo::Base::Polygon2 > &polygonVec = svgPtrVec[ idSibling ]->polygonVec();\r\n\t\t\t\t\t\r\n\t\t\t\t\tif( graphmlTree[ vdS ].size > 0 ) {\r\n//\r\n//\t\t\t\t\t\tunsigned int parentFileID1 = polygonVec[ 0 ].parentFileID().first;\r\n//\t\t\t\t\t\tunsigned int parentFileID2 = polygonVec[ 0 ].parentFileID().second;\r\n//\t\t\t\t\t\tunsigned int parentPolygonID = polygonVec[ 0 ].parentPolygonID();\r\n//\r\n//\t\t\t\t\t\tcerr << \"parentFileID1 = \" << parentFileID1 << \" , parentFileID2 = \" << parentFileID2\r\n//\t\t\t\t\t\t     << \", parentPolygonID = \" << parentPolygonID << endl;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tunsigned int idP = graphmlTree[ vdS ].parentID;\r\n\t\t\t\t\t\tmap< unsigned int, pair< double, double > > &parentTreemapFixedSizeMap = _treemapVec[ idP ].treemapFixedSizeMap();\r\n\t\t\t\t\t\tmap< unsigned int, pair< double, double > > &parentTreemapSizeMap = _treemapVec[ idP ].treemapSizeMap();\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcerr << \"idP = \" << idP << endl;\r\n\t\t\t\t\t\tcerr << \"idSibling = \" << idSibling << endl;\r\n\t\t\t\t\t\tcerr << \"parentTreemapFixedSizeMap.size() = \" << parentTreemapFixedSizeMap.size() << endl;\r\n\t\t\t\t\t\tcerr << \"parentTreemapSizeMap.size() = \" << parentTreemapSizeMap.size() << endl;\r\n\t\t\t\t\t\tmap< unsigned int, pair< double, double > >::iterator itF = parentTreemapFixedSizeMap.find( idSibling );\r\n\t\t\t\t\t\tmap< unsigned int, pair< double, double > >::iterator itP = parentTreemapSizeMap.find( idSibling );\r\n//\t\t\t\t\t\tstd::advance( itF, parentPolygonID );\r\n//\t\t\t\t\t\tstd::advance( itP, parentPolygonID );\r\n\t\t\t\t\t\tdouble fixSize = itF->second.second;\r\n\t\t\t\t\t\tdouble size = itP->second.second;\r\n\t\t\t\t\t\tdouble scale = size / fixSize;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tmap< unsigned int, pair< double, double > > &siblingTreemapSizeMap = _treemapVec[ idSibling ].treemapSizeMap();\r\n\t\t\t\t\t\tfor( unsigned int k = 0; k < siblingTreemapSizeMap.size(); k++ ) {\r\n\t\t\t\t\t\t\tmap< unsigned int, pair< double, double > >::iterator itN = siblingTreemapSizeMap.begin();\r\n\t\t\t\t\t\t\tstd::advance( itN, k );\r\n\t\t\t\t\t\t\titN->second.second *= scale;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n    }\r\n    \r\n\tdouble HierarchicalTreemap::maxIncreaseRatio( double minSize )\r\n\t{\r\n\t\tvector< double > originalSizeVec( _treemapVec.size() );\r\n        vector< bool > isSelectedVec( _treemapVec.size() );\r\n\t\tvector< bool > alreadySelectedVec( _treemapVec.size() );\r\n\r\n\t\tGraph::TreeDirectedGraph    &graphmlTree    = _metadataPtr->graphmlTree();\r\n\t\t\r\n\t\t// initialization\r\n        for( unsigned int i = 0; i < _treemapVec.size(); i++ ){\r\n            Graph::TreeDirectedGraph::vertex_descriptor vd = vertex( i, graphmlTree );\r\n            originalSizeVec[ i ] = _treemapVec[ i ].boundingBoxPtr()->width() * _treemapVec[ i ].boundingBoxPtr()->height();\r\n#ifdef HierarchicalTreemap_DEBUG\r\n                        cerr << \"Size of \" << i << \" is \" << *_treemapVec[ i ].widthPtr() * *_treemapVec[ i ].heightPtr() << endl;\r\n#endif // HierarchicalTreemap_DEBUG\r\n\t\t\tisSelectedVec[ i ] = false;\r\n\t\t\talreadySelectedVec[ i ] = false;\r\n        }\r\n\r\n\t\t// mark the selected objects\r\n\t\tfor( map< unsigned int, unsigned int >::iterator it = _selectSceneItemMapPtr->begin();\r\n\t\t     it != _selectSceneItemMapPtr->end(); it++ ){\r\n\r\n//            unsigned int level = 0;//std::get<0>( it->second );\r\n//            unsigned int member = 0;//std::get<1>( it->second );\r\n//            unsigned int polygonMember = 0;//std::get<2>( it->second );\r\n//            unsigned int idP = _sortedLevel[level][member];\r\n\t\t\tunsigned int id = it->second;\r\n\r\n//            Graph::TreeDirectedGraph::vertex_descriptor vdP = vertex( id, graphmlTree );\r\n//\t\t\tGraph::TreeDirectedGraph::out_edge_iterator e, e_end;\r\n//\t\t\tfor( tie( e, e_end ) = out_edges( vdP, graphmlTree ); e != e_end; ++e ) {\r\n//\r\n//\t\t\t\tGraph::TreeDirectedGraph::edge_descriptor ed = *e;\r\n//\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdT = target( ed, graphmlTree );\r\n//\t\t\t}\r\n//\r\n//\t\t\tmap< unsigned int, unsigned int > &childMap = graphmlTree[ vdP ].childMap;\r\n//            map< unsigned int, unsigned int >::iterator itC = childMap.begin();\r\n//\r\n//            std::advance( itC, polygonMember );\r\n//            unsigned int id = itC->second;\r\n//            isSelectedVec[ id ] = true;\r\n\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd = vertex( id, graphmlTree );\r\n\t\t\tgraphmlTree[ vd ].isSelected = isSelectedVec[ id ] = true;\r\n\r\n//\t\t\tcerr << \"level: \" << level << \" member: \" << member << \" polyMember: \" << polygonMember << \" is id \" << id << endl;\r\n        }\r\n\r\n\t\t// find total size\r\n\t\tdouble total = 0.0;\r\n\t   \tBGL_FORALL_VERTICES( vd, graphmlTree, Graph::TreeDirectedGraph ) {\r\n\t\t\tunsigned int id = graphmlTree[vd].id;\r\n\t\t\tif( graphmlTree[vd].parentID == id ){\r\n\t\t\t\ttotal = originalSizeVec[id];\r\n            }\r\n        }\r\n#ifdef HierarchicalTreemap_DEBUG\r\n\t\tcerr << \"Total is \" << total << endl;\r\n#endif // HierarchicalTreemap_DEBUG\r\n\t\t\r\n\t\t// find ratio of selected objects, set ratio of non-selected objects to minimum\r\n\t\tdouble maxRatio = 1.0;\r\n\t\tBGL_FORALL_VERTICES( vd, graphmlTree, Graph::TreeDirectedGraph ) {\r\n\t\t\t\r\n\t\t\tGraph::TreeDirectedGraph::degree_size_type degrees = out_degree( vd, graphmlTree );\r\n\r\n\t\t\t// lead node\r\n\t\t\tif( degrees == 0 ) {\r\n\t\t\t\t\r\n\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor searchVD = vd;\r\n\t\t\t\tbool foundSelected = false;\r\n\t\t\t\tunsigned int id = 0;\r\n\t\t\t\tunsigned int pID = 0;\r\n\t\t\t\tdo {\r\n\t\t\t\t\t\r\n\t\t\t\t\tid = graphmlTree[ searchVD ].id;\r\n\t\t\t\t\tpID = graphmlTree[ searchVD ].parentID;\r\n\t\t\t\t\tif( isSelectedVec[ id ] ) {\r\n\t\t\t\t\t\tfoundSelected = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tsearchVD = vertex( pID, graphmlTree );\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t} while( !foundSelected && pID != graphmlTree[ searchVD ].parentID );\r\n\t\t\t\t\r\n\t\t\t\tif( foundSelected && !alreadySelectedVec[ id ] ) {\r\n#ifdef HierarchicalTreemap_DEBUG\r\n\t\t\t\t\tcerr << \"Found = \" << id << \" with size \" << originalSizeVec[id] << \" divided by \" << total << \" = \" << (originalSizeVec[id] / total) << endl;\r\n#endif // HierarchicalTreemap_DEBUG\r\n\t\t\t\t\tmaxRatio -= ( originalSizeVec[ id ] / total );\r\n\t\t\t\t\talreadySelectedVec[ id ] = true;\r\n\t\t\t\t}\r\n\t\t\t\telse if( !foundSelected ) { // reached root, hence this leaf not selected\r\n#ifdef HierarchicalTreemap_DEBUG\r\n\t\t\t\t\tcerr << \"Not found \" << id << endl;\r\n#endif // HierarchicalTreemap_DEBUG\r\n\t\t\t\t\tmaxRatio -= minSize;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n#ifdef HierarchicalTreemap_DEBUG\r\n\t\tcerr << \"Number of selected is \" << (*_selectSceneItemsPtr).size() << endl;\r\n\t\tcerr << \"Max increaseRatio = \" << maxRatio / (*_selectSceneItemsPtr).size() << endl;\r\n#endif // HierarchicalTreemap_DEBUG\r\n\t\treturn maxRatio / (*_selectSceneItemMapPtr).size();\r\n\t}\r\n\r\n\t// For now assumes that no nexted objects are selected\r\n\tdouble HierarchicalTreemap::maxSiblingRatio( double increaseRatio, double minSize )\r\n\t{\r\n\t\tvector< double > originalSizeVec( _treemapVec.size() );\r\n                vector< bool > isSelectedVec( _treemapVec.size() );\r\n\t\tvector< bool > isSiblingVec( _treemapVec.size() );\r\n                vector< bool > alreadySelectedVec( _treemapVec.size() );\r\n\t\t\r\n\t\tGraph::TreeDirectedGraph    &graphmlTree    = _metadataPtr->graphmlTree();\r\n\r\n        // initialization\r\n        for( unsigned int i = 0; i < _treemapVec.size(); i++ ){\r\n                Graph::TreeDirectedGraph::vertex_descriptor vd = vertex( i, graphmlTree );\r\n                originalSizeVec[ i ] = _treemapVec[ i ].boundingBoxPtr()->width() * _treemapVec[ i ].boundingBoxPtr()->height();\r\n#ifdef HierarchicalTreemap_DEBUG\r\n                cerr << \"Size of \" << i << \" is \" << *_treemapVec[ i ].widthPtr() * *_treemapVec[ i ].heightPtr() << endl;\r\n#endif // HierarchicalTreemap_DEBUG\r\n                isSelectedVec[ i ] = false;\r\n                alreadySelectedVec[ i ] = false;\r\n        }\r\n\r\n        // mark the selected objects and their siblings\r\n\t\tfor( map< unsigned int, unsigned int >::iterator it = _selectSceneItemMapPtr->begin();\r\n\t\t     it != _selectSceneItemMapPtr->end(); it++ ){\r\n\r\n//            unsigned int level = 0;//std::get<0>( it->second );\r\n//            unsigned int member = 0;//std::get<1>( it->second );\r\n//            unsigned int polygonMember = 0;//std::get<2>( it->second );\r\n//            unsigned int idP = _sortedLevel[level][member];\r\n\t\t\tunsigned int id = it->second;\r\n\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd = vertex( id, graphmlTree );\r\n\t\t\tunsigned int level = graphmlTree[ vd ].level;\r\n\t\t\tunsigned int idP = it->second;\r\n            Graph::TreeDirectedGraph::vertex_descriptor vdP = vertex( idP, graphmlTree );\r\n//            map< unsigned int, unsigned int > &childMap = graphmlTree[ vdP ].childMap;\r\n//            map< unsigned int, unsigned int >::iterator itC = childMap.begin();\r\n//            std::advance( itC, polygonMember );\r\n//            unsigned int id = itC->second;\r\n                        \r\n\t\t\tisSelectedVec[id] = true;\r\n\t\t\tisSiblingVec[id] = false; // selected objects are never seen as siblings\r\n\t\t\t\r\n\t\t\tGraph::TreeDirectedGraph::out_edge_iterator e, e_end;\r\n\t\t\tfor( tie( e, e_end ) = out_edges( vdP, graphmlTree ); e != e_end; ++e ) {\r\n\t\t\t\t\r\n\t\t\t\tGraph::TreeDirectedGraph::edge_descriptor ed = *e;\r\n\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdT = target( ed, graphmlTree );\r\n\t\t\t\tunsigned int idT = graphmlTree[ vdT ].id;\r\n\t\t\t\t\r\n//\t\t\t\tfor( itC = childMap.begin(); itC != childMap.end(); itC++ ) {\r\n//\t\t\t\tid = itC->second;\r\n#ifdef HierarchicalTreemap_DEBUG\r\n\t\t\t\tcerr << id << \"is a sibling\" << endl;\r\n#endif // HierarchicalTreemap_DEBUG\r\n\t\t\t\t// selected objects and top level objects are never seen as siblings\r\n\t\t\t\tif( !isSelectedVec[ idT ] && level != 0) {\r\n#ifdef HierarchicalTreemap_DEBUG\r\n\t\t\t\t\tcerr << \"and not selected\" << endl;\r\n#endif // HierarchicalTreemap_DEBUG\r\n\t\t\t\t\tisSiblingVec[ id ] = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n        }\r\n\r\n        // find total size\r\n        double total = 0.0;\r\n        BGL_FORALL_VERTICES( vd, graphmlTree, Graph::TreeDirectedGraph ) {\r\n            unsigned int id = graphmlTree[vd].id;\r\n            if( graphmlTree[vd].parentID == id ){\r\n                    total = originalSizeVec[id];\r\n            }\r\n        }\r\n\r\n\t\t\r\n\t\t// find ratio of selected objects and filter siblings\r\n\t\t// set ratio of remaining objects to minimum\r\n        double maxRatio = 1.0;\r\n\r\n        BGL_FORALL_VERTICES( vd, graphmlTree, Graph::TreeDirectedGraph ) {\r\n\t\t\t\r\n\t        Graph::TreeDirectedGraph::degree_size_type degrees = out_degree( vd, graphmlTree );\r\n\t        if( degrees == 0 ) {\r\n\t\t        Graph::TreeDirectedGraph::vertex_descriptor searchVD = vd;\r\n\t\t        bool stop = false;\r\n\t\t        bool foundSelected = false;\r\n\t\t        bool foundSibling = false;\r\n\t\t        unsigned int id;\r\n\t\t        unsigned int pID;\r\n\t\t        int selected = -1;\r\n\t\t        do {\r\n\t\t\t        id = graphmlTree[ searchVD ].id;\r\n\t\t\t        pID = graphmlTree[ searchVD ].parentID;\r\n\t\t\t\r\n\t\t\t        if( isSelectedVec[ id ] ) { // assumes only one selected on every path from leaf to root\r\n\t\t\t\t        selected = id;\r\n\t\t\t        }\r\n\t\t\t        else if( selected != -1 ) {\r\n\t\t\t\t        // filter siblings: you are only counted as sibling\r\n\t\t\t\t        // if you did not increase size through a descendant\r\n\t\t\t\t        isSiblingVec[ id ] = false;\r\n\t\t\t        }\r\n\t\t\t        else if( isSiblingVec[ id ] ) {\r\n\t\t\t\t        foundSibling = true;\r\n\t\t\t        }\r\n\t\t\t\r\n\t\t\t        searchVD = vertex( pID, graphmlTree );\r\n\t\t\t\r\n\t\t        } while( pID != id );\r\n\t\t\r\n\t\t\r\n\t\t        if( selected != -1 && !alreadySelectedVec[ selected ] ) {\r\n\t\t\t        // ratio of selected objects\r\n#ifdef DEBUG\r\n\t\t\t        cerr << selected << \" is selected\" << endl;\r\n#endif // DEBUG\r\n\t\t\t        maxRatio -= ( ( originalSizeVec[ selected ] / total ) + increaseRatio );\r\n\t\t\t        alreadySelectedVec[ selected ] = true;\r\n\t\t        }\r\n\t\t        else if( selected == -1 && !foundSibling ) {  // reached root, hence this leaf not selected\r\n\t\t\t        // ratio of remaining objects\r\n#ifdef DEBUG\r\n\t\t\t        cerr << graphmlTree[vd].id << \" is not a sibling, nor selected\" << endl;\r\n#endif // DEBUG\r\n\t\t\t        maxRatio -= minSize;\r\n\t\t        }\r\n\t        }\r\n        }\r\n\r\n\t\t// find total ratio of siblings\r\n\t\tdouble siblingSum = 0.0;\r\n\t\tBGL_FORALL_VERTICES( vd, graphmlTree, Graph::TreeDirectedGraph ) {\r\n\t\t\tunsigned int id = graphmlTree[vd].id;\r\n            if( isSiblingVec[id] ){\r\n#ifdef DEBUG\r\n\t\t\t\tcerr << id << \" is a sibling\" << endl;\r\n#endif // DEBUG\r\n\t\t\t\tsiblingSum += originalSizeVec[id] / total;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tmaxRatio = maxRatio / siblingSum;\r\n\r\n\t\t// siblingRatio is a shrink factor and hence cannot be larger than 1.0\r\n\t\tif( maxRatio > 1.0) {\r\n\t\t\tmaxRatio = 1.0;\r\n\t\t}\r\n\t\t\r\n\t\treturn maxRatio;\r\n\t}\r\n\r\n\tdouble HierarchicalTreemap::maxMinSize( void )\r\n\t{\r\n\t\tGraph::TreeDirectedGraph    &graphmlTree    = _metadataPtr->graphmlTree();\r\n\t\t\r\n\t\t// find total size\r\n        double total = 0.0;\r\n        BGL_FORALL_VERTICES( vd, graphmlTree, Graph::TreeDirectedGraph ) {\r\n                unsigned int id = graphmlTree[vd].id;\r\n                if( graphmlTree[vd].parentID == id ){\r\n                        total = _treemapVec[ id ].boundingBoxPtr()->width() * _treemapVec[ id ].boundingBoxPtr()->height();\r\n                }\r\n        }\r\n\t\t\r\n        // find ratio of selected objects and filter siblings\r\n        // set ratio of remaining objects to minimum\r\n        double maxMinRatio = 1.0;\r\n\r\n        BGL_FORALL_VERTICES( vd, graphmlTree, Graph::TreeDirectedGraph ) {\r\n\t        Graph::TreeDirectedGraph::degree_size_type degrees = out_degree( vd, graphmlTree );\r\n\t        if( degrees == 0 ) {\r\n//\t\t\t        if( graphmlTree[ vd ].childMap.size() == 0 ) {\r\n\t\t        unsigned int id = graphmlTree[ vd ].id;\r\n\t\t        double sizeRatio =\r\n\t\t\t\t        _treemapVec[ id ].boundingBoxPtr()->width() * _treemapVec[ id ].boundingBoxPtr()->height() /\r\n\t\t\t\t        total;\r\n\t\t        if( sizeRatio < maxMinRatio ) {\r\n\t\t\t        maxMinRatio = sizeRatio;\r\n\t\t        }\r\n\t        }\r\n        }\r\n\t\t\r\n//\t\tcerr << \"maxMinSize = \" << maxMinRatio << endl;\t\t\r\n\t\treturn maxMinRatio;\r\n\t}\r\n\r\n\tvoid HierarchicalTreemap::_assignTreemapSizeSibling( void )\r\n\t{\r\n\t\tdouble ww = KeiRo::Base::Common::getMainwidgetWidth();\r\n\t\tdouble wh = KeiRo::Base::Common::getMainwidgetHeight();\r\n\t\t\r\n\t\tGraph::TreeDirectedGraph    &graphmlTree    = _metadataPtr->graphmlTree();\r\n//\t\tvector< FileIO::SVG* > &svgPtrVec       = _metadataPtr->svgPtrVec();\r\n//\t\tGraph::TreeDirectedGraph svgTree        = _metadataPtr->svgTree();\r\n\t\tdouble increaseRatio = 0.8;\r\n\t\tvector< double > originalSizeVec( _treemapVec.size() );\r\n\t\tvector< bool > isSelectedVec( _treemapVec.size() );\r\n\t\t\r\n\t\t// initialization\r\n\t\tfor( unsigned int i = 0; i < _treemapVec.size(); i++ ){\r\n\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd = vertex( i, graphmlTree );\r\n\t\t\toriginalSizeVec[ i ] = _treemapVec[ i ].boundingBoxPtr()->width() * _treemapVec[ i ].boundingBoxPtr()->height();\r\n\t\t\tgraphmlTree[vd].size = 0.0;\r\n\t\t\tisSelectedVec[ i ] = false;\r\n\t\t}\r\n\t\t\r\n\t\t// mark the selected objects\r\n\t\tfor( map< unsigned int, unsigned int >::iterator it = _selectSceneItemMapPtr->begin();\r\n\t\t     it != _selectSceneItemMapPtr->end(); it++ ){\r\n\t\t\t\r\n//\t\t\tunsigned int level = 0;//std::get<0>( it->second );\r\n//\t\t\tunsigned int member = 0;//std::get<1>( it->second );\r\n//\t\t\tunsigned int polygonMember = 0;//std::get<2>( it->second );\r\n//\t\t\tunsigned int idP = _sortedLevel[level][member];\r\n\t\t\tunsigned int id = it->second;\r\n\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd = vertex( id, graphmlTree );\r\n\t\t\tunsigned int level = graphmlTree[ vd ].level;\r\n\t\t\tunsigned int idP = graphmlTree[ vd ].parentID;\r\n\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdP = vertex( idP, graphmlTree );\r\n//\t\t\tmap< unsigned int, unsigned int > &childMap = graphmlTree[ vdP ].childMap;\r\n//\t\t\tmap< unsigned int, unsigned int >::iterator itC = childMap.begin();\r\n\t\t\t\r\n#ifdef HierarchicalTreemap_DEBUG\r\n\t\t\tcerr << \"idP = \" << idP << endl;\r\n\t\t\tcerr << \"level = \" << level << \", member = \" << member << \", polygonMember = \" << polygonMember << endl;\r\n\t\t\tcerr << \"child.size() = \" << childMap.size() << endl;\r\n#endif // HierarchicalTreemap_DEBUG\r\n\t\t\t\r\n//\t\t\tstd::advance( itC, polygonMember );\r\n//\t\t\tunsigned int id = itC->second;\r\n\t\t\tisSelectedVec[id] = true;\r\n//\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd = vertex( id, graphmlTree );\r\n\t\t\tgraphmlTree[ vd ].size = originalSizeVec[id] + (originalSizeVec[0] * increaseRatio);\r\n\t\t}\r\n#ifdef HierarchicalTreemap_DEBUG\r\n\t\tfor( unsigned int i = 0; i < originalSizeVec.size(); i++ ){\r\n\t\t\tcerr << \"originalSizeVec[\" << i << \"] = \" << originalSizeVec[i] << endl;\r\n\t\t}\r\n\t\tBGL_FORALL_VERTICES( vd, graphmlTree, Graph::TreeDirectedGraph ) {\r\n\t\t\t\tcerr << \"before id = \" << graphmlTree[vd].id\r\n\t\t\t\t     << \", size = \" << graphmlTree[vd].size << endl;\r\n\t\t\t}\r\n#endif // HierarchicalTreemap_DEBUG\r\n\t\t\r\n\t\t// propogate size changes\r\n\t\tfor( unsigned int i = 0; i < _sortedLevel.size(); i++ ){\r\n\t\t\tfor( unsigned int j = 0; j < _sortedLevel[i].size(); j++ ) {\r\n\t\t\t\tunsigned int id = _sortedLevel[i][j];\r\n\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd = vertex( id, graphmlTree );\r\n\r\n//\t\t\t\tmap< unsigned int, unsigned int > &childMap = graphmlTree[vd].childMap;\r\n\t\t\t\tif( graphmlTree[vd].size != 0 ){\r\n#ifdef HierarchicalTreemap_DEBUG\r\n\t\t\t\t\tcerr << \" id = \" << id\r\n\t\t\t\t\t\t << \", childSize = \" << childMap.size() << endl;\r\n#endif // HierarchicalTreemap_DEBUG\r\n\t\t\t\t\tdouble scale = graphmlTree[vd].size / originalSizeVec[id];\r\n\t\t\t\t\t\r\n\t\t\t\t\tGraph::TreeDirectedGraph::out_edge_iterator e, e_end;\r\n\t\t\t\t\tfor( tie( e, e_end ) = out_edges( vd, graphmlTree ); e != e_end; ++e ) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tGraph::TreeDirectedGraph::edge_descriptor ed = *e;\r\n\t\t\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdT = target( ed, graphmlTree );\r\n\t\t\t\t\t\tunsigned int idT = graphmlTree[ vdT ].id;\r\n\t\t\t\t\t\t\r\n//\t\t\t\t\t\tfor( unsigned int k = 0; k < childMap.size(); k++ ){\r\n//\t\t\t\t\t\tmap< unsigned int, unsigned int >::iterator it = childMap.begin();\r\n//\t\t\t\t\t\tstd::advance( it, k );\r\n//\t\t\t\t\t\tunsigned int idC = it->second;\r\n//\t\t\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdC = vertex( idC, graphmlTree );\r\n\t\t\t\t\t\tgraphmlTree[ vdT ].size = originalSizeVec[ idT ] * scale;\r\n\t\t\t\t\t\tcerr << idT << \" scaled by \" << scale << endl;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n#ifdef HierarchicalTreemap_DEBUG\r\n\t\tBGL_FORALL_VERTICES( vd, graphmlTree, Graph::TreeDirectedGraph ) {\r\n\t\t\tcerr << \"after id = \" << graphmlTree[vd].id\r\n\t\t\t\t << \", size = \" << graphmlTree[vd].size << endl;\r\n\t\t}\r\n#endif // HierarchicalTreemap_DEBUG\r\n\t\t\r\n\t\t// compute shrinking factor\r\n\t\tdouble coefficient = 0.0;\r\n\t\tdouble knownArea = 0.0;\r\n\t\tdouble shrinkFactor = 0.0;\r\n\t\tBGL_FORALL_VERTICES( vd, graphmlTree, Graph::TreeDirectedGraph ) {\r\n\t\t\t\r\n\t\t\tunsigned int id = graphmlTree[ vd ].id;\r\n\t\t\t// add total area of leaves\r\n\t\t\tGraph::TreeDirectedGraph::degree_size_type degrees = out_degree( vd, graphmlTree );\r\n\t\t\tif ( degrees == 0 ){\r\n//\t\t\tif ( graphmlTree[ vd ].childMap.size() == 0 ){\r\n\t\t\t\t\r\n\t\t\t\tcerr << \" leafID = \" << id << endl;\r\n\t\t\t\tif( graphmlTree[ vd ].size == 0 ){\r\n\t\t\t\t\tcoefficient += originalSizeVec[ id ];\r\n\t\t\t\t\tcerr << \"oriCoeff = \" << originalSizeVec[ id ] << endl;\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tknownArea += graphmlTree[vd].size;\r\n\t\t\t\t\tcerr << \"graphmlTree[vd].size = \" << graphmlTree[vd].size << endl;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tshrinkFactor = ( ww * wh - knownArea )/coefficient;\r\n\t\tcerr << \"coefficient = \" << coefficient << endl;\r\n\t\tcerr << \"knownArea = \" << knownArea << endl;\r\n\t\tcerr << \"shrinkFactor = \" << shrinkFactor << endl;\r\n\t\t\r\n\t\t// update size\r\n\t\t// assign unknown leaf size\r\n\t\tfor( unsigned int i = _sortedLevel.size()-1; i < _sortedLevel.size(); i++ ){\r\n\t\t\tfor( unsigned int j = 0; j < _sortedLevel[i].size(); j++ ) {\r\n\t\t\t\tunsigned int id = _sortedLevel[i][j];\r\n\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd = vertex( id, graphmlTree );\r\n\t\t\t\tif( graphmlTree[ vd ].size == 0 )\r\n\t\t\t\t\tgraphmlTree[ vd ].size = shrinkFactor * originalSizeVec[id];\r\n\t\t\t\telse{\r\n\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n#ifdef HierarchicalTreemap_DEBUG\r\n\t\tdouble total = 0.0;\r\n\t\tBGL_FORALL_VERTICES( vd, _treemapTree, Graph::TreeDirectedGraph ) {\r\n\t\t\t\tif( _treemapTree[vd].childMap.size() == 0 ){\r\n\t\t\t\t\tcerr << \"is leaf id = \" << _treemapTree[vd].id\r\n\t\t\t\t\t     << \", size = \" << _treemapTree[vd].size << endl;\r\n\t\t\t\t\ttotal += _treemapTree[ vd ].size;\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tcerr << \"not leaf id = \" << _treemapTree[vd].id\r\n\t\t\t\t\t     << \", size = \" << _treemapTree[vd].size << endl;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\tcerr << \"total = \" << total << endl;\r\n\t\t\r\n#endif // HierarchicalTreemap_DEBUG\r\n\t\t\r\n\t\tfor( int i = _sortedLevel.size()-2; i >= 0; i-- ) {\r\n\t\t\tfor( unsigned int j = 0; j < _sortedLevel[ i ].size(); j++ ) {\r\n\t\t\t\tunsigned int id = _sortedLevel[ i ][ j ];\r\n\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd = vertex( id, graphmlTree );\r\n\t\t\t\tgraphmlTree[ vd ].size = 0;\r\n\t\t\t\t\r\n\t\t\t\tGraph::TreeDirectedGraph::out_edge_iterator e, e_end;\r\n\t\t\t\tfor( tie( e, e_end ) = out_edges( vd, graphmlTree ); e != e_end; ++e ) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tGraph::TreeDirectedGraph::edge_descriptor ed = *e;\r\n\t\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdT = target( ed, graphmlTree );\r\n\t\t\t\t\t\r\n//\t\t\t\tmap< unsigned int, unsigned int > &childMap = graphmlTree[ vd ].childMap;\r\n//\t\t\t\tfor( unsigned int k = 0; k < childMap.size(); k++ ) {\r\n//\t\t\t\t\tmap< unsigned int, unsigned int >::iterator it = childMap.begin();\r\n//\t\t\t\t\tstd::advance( it, k );\r\n//\t\t\t\t\tunsigned int idC = it->second;\r\n//\t\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdC = vertex( idC, graphmlTree );\r\n\t\t\t\t\tgraphmlTree[ vd ].size += graphmlTree[ vdT ].size;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n#ifdef HierarchicalTreemap_DEBUG\r\n\t\tBGL_FORALL_VERTICES( vd, _treemapTree, Graph::TreeDirectedGraph ) {\r\n\t\t\t\tif( _treemapTree[vd].childMap.size() == 0 ){\r\n\t\t\t\t\tcerr << \"is leaf id = \" << _treemapTree[vd].id\r\n\t\t\t\t\t     << \", size = \" << _treemapTree[vd].size << endl;\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tcerr << \"not leaf id = \" << _treemapTree[vd].id\r\n\t\t\t\t\t     << \", size = \" << _treemapTree[vd].size << endl;\r\n\t\t\t\t}\r\n\t\t\t}\r\n#endif // HierarchicalTreemap_DEBUG\r\n\t\tfor( unsigned int i = 0; i < _sortedLevel.size()-1; i++ ) {\r\n\t\t\tfor( unsigned int j = 0; j < _sortedLevel[ i ].size(); j++ ) {\r\n\t\t\t\tunsigned int id = _sortedLevel[i][j];\r\n\r\n\t\t\t\tmap< unsigned int, pair< double, double > > &treemapSizeMap = _treemapVec[ id ].treemapSizeMap();\r\n\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd = vertex( id, graphmlTree );\r\n//\t\t\t\tmap< unsigned int, unsigned int > &childMap = graphmlTree[ vd ].childMap;\r\n\t\t\t\tGraph::TreeDirectedGraph::out_edge_iterator e, e_end;\r\n\t\t\t\tfor( tie( e, e_end ) = out_edges( vd, graphmlTree ); e != e_end; ++e ) {\r\n\r\n\t\t\t\t\tGraph::TreeDirectedGraph::edge_descriptor ed = *e;\r\n\t\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdT = target( ed, graphmlTree );\r\n//\t\t\t\tfor( unsigned int k = 0; k < childMap.size(); k++ ){\r\n\t\t\t\t\tmap< unsigned int, pair< double, double > >::iterator it = treemapSizeMap.begin();\r\n//\t\t\t\t\tmap< unsigned int, unsigned int >::iterator itC = childMap.begin();\r\n//\t\t\t\t\tstd::advance( it, k );\r\n//\t\t\t\t\tstd::advance( itC, k );\r\n//\t\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdC = vertex( itC->second, graphmlTree );\r\n\t\t\t\t\tit->second.second = graphmlTree[ vdT ].size;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n#ifdef HierarchicalTreemap_DEBUG\r\n\t\tfor( unsigned int i = 0; i < _sortedLevel.size()-1; i++ ) {\r\n\t\t\tfor( unsigned int j = 0; j < _sortedLevel[ i ].size(); j++ ) {\r\n\r\n\t\t\t\tunsigned int id = _sortedLevel[i][j];\r\n\t\t\t\tcerr << \"id = \" << id << endl;\r\n\t\t\t\tmap< string, pair< double, double > > &treemapSizeMap = _treemapVec[ id ].treemapSizeMap();\r\n\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd = vertex( id, _treemapTree );\r\n\t\t\t\tmap< unsigned int, unsigned int > &childMap = _treemapTree[ vd ].childMap;\r\n\t\t\t\t\r\n\t\t\t\tfor( unsigned int k = 0; k < treemapSizeMap.size(); k++ ){\r\n\t\t\t\t\tmap< string, pair< double, double > >::iterator it = treemapSizeMap.begin();\r\n\t\t\t\t\tstd::advance( it, k );\r\n\t\t\t\t\tcerr << \"k = \" << k << \", \"\r\n\t\t\t\t\t\t << it->second.second << endl;\r\n\t\t\t\t}\r\n\t\t\t\tcerr << endl;\r\n\t\t\t}\r\n\t\t}\r\n#endif // HierarchicalTreemap_DEBUG\r\n\t}\r\n\r\n\tvoid HierarchicalTreemap::_assignTreemapSizeParameterized( double increaseRatio, double siblingRatio, double minSize )\r\n\t{\r\n\t\tif( increaseRatio > maxIncreaseRatio( minSize ) ) {\r\n\t\t\tcerr << \"increaseRatio too high\" << endl;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\telse if( siblingRatio > maxSiblingRatio( increaseRatio, minSize ) ) {\r\n\t\t\tcerr << \"siblingRatio too high\" << endl;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\telse if( minSize > maxMinSize() ) {\r\n\t\t\tcerr << \"minSize too high\" << endl;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\tdouble ww = KeiRo::Base::Common::getMainwidgetWidth();\r\n\t\tdouble wh = KeiRo::Base::Common::getMainwidgetHeight();\r\n\t\tGraph::TreeDirectedGraph    &graphmlTree    = _metadataPtr->graphmlTree();\r\n\t\t\r\n\t\tvector< double > originalSizeVec( _treemapVec.size() );\r\n\t\tvector< bool > isSelectedVec( _treemapVec.size() );\r\n\t\t\r\n\t\t// initialization\r\n\t\tfor( unsigned int i = 0; i < _treemapVec.size(); i++ ){\r\n\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd = vertex( i, graphmlTree );\r\n\t\t\toriginalSizeVec[ i ] = _treemapVec[ i ].boundingBoxPtr()->width() * _treemapVec[ i ].boundingBoxPtr()->height();\r\n\t\t\tgraphmlTree[ vd ].size = 0.0;\r\n\t\t\tisSelectedVec[ i ] = false;\r\n\t\t}\r\n\t\t\r\n\t\t// find total size\r\n        double total = 0.0;\r\n        BGL_FORALL_VERTICES( vd, graphmlTree, Graph::TreeDirectedGraph ) {\r\n            unsigned int id = graphmlTree[vd].id;\r\n\t\t\ttotal = _treemapVec[ id ].boundingBoxPtr()->width() * _treemapVec[ id ].boundingBoxPtr()->height();\r\n        }\r\n\t\t\r\n\t\t// mark the selected objects and siblings\r\n\t\tfor( map< unsigned int, unsigned int >::iterator it = _selectSceneItemMapPtr->begin();\r\n\t\t     it != _selectSceneItemMapPtr->end(); it++ ){\r\n\r\n\t\t\tunsigned int id = it->second;\r\n\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd = vertex( id, graphmlTree );\r\n\t\t\tunsigned int level = graphmlTree[ vd ].level;\r\n\t\t\tgraphmlTree[ vd ].isSelected = true;\r\n\r\n\t\t\tunsigned int idP = graphmlTree[ vd ].parentID;\r\n\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdP = vertex( idP, graphmlTree );\r\n\t\t\t\r\n#ifdef HierarchicalTreemap_DEBUG\r\n\t\t\tcerr << \"idP = \" << idP << endl;\r\n#endif // HierarchicalTreemap_DEBUG\r\n\t\t\t\r\n\t\t\t// set size of selected object using increaseRatio\r\n\t\t\tisSelectedVec[ id ] = true;\r\n\t\t\tgraphmlTree[ vd ].size = originalSizeVec[id] + (originalSizeVec[0] * increaseRatio);\r\n\r\n\t\t\t// set size of siblings using siblingRatio\r\n\t\t\tdouble siblingSize;\r\n\t\t\tGraph::TreeDirectedGraph::out_edge_iterator e, e_end;\r\n\t\t\tfor( tie( e, e_end ) = out_edges( vdP, graphmlTree ); e != e_end; ++e ) {\r\n\r\n\t\t\t\tGraph::TreeDirectedGraph::edge_descriptor ed = *e;\r\n\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdT = target( ed, graphmlTree );\r\n\t\t\t\tunsigned int idT = graphmlTree[ vdT ].id;\r\n\r\n\t\t\t\tif( ( graphmlTree[vdT].size == 0 ) && ( level != 0 ) && ( id != idT ) ) {\r\n\t\t\t\t\tsiblingSize = originalSizeVec[ idT ] * siblingRatio;\r\n\t\t\t\t\tif( siblingSize >= minSize * total ) {\r\n\t\t\t\t\t\tgraphmlTree[ vdT ].size = siblingSize;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tgraphmlTree[ vdT ].size = minSize * total;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n            }\r\n\t\t}\r\n#ifdef HierarchicalTreemap_DEBUG\r\n\t\tfor( unsigned int i = 0; i < originalSizeVec.size(); i++ ){\r\n\t\t\tcerr << \"originalSizeVec[\" << i << \"] = \" << originalSizeVec[i] << endl;\r\n\t\t}\r\n\t\tBGL_FORALL_VERTICES( vd, _treemapTree, Graph::TreeDirectedGraph ) {\r\n\t\t\t\tcerr << \"before id = \" << _treemapTree[vd].id\r\n\t\t\t\t     << \", size = \" << _treemapTree[vd].size << endl;\r\n\t\t\t}\r\n#endif // HierarchicalTreemap_DEBUG\r\n\r\n\t\t// Reset size of siblings with selected decendant back to zero\r\n\t\t// Such siblings will always go above sibling ratio!\r\n\t\t// Assumes only one selected on each path from leaf to root\r\n\t\tfor( unsigned int i = 0; i < _sortedLevel[ _sortedLevel.size()-1 ].size(); i++ ){\r\n\r\n\t\t\tunsigned int id = _sortedLevel[ _sortedLevel.size()-1 ][ i ];\r\n\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd = vertex( id, graphmlTree );\r\n\r\n\t\t\t// lowest levels\r\n\t\t\tGraph::TreeDirectedGraph::vertex_descriptor searchVD = vd;\r\n\t\t\tunsigned int idP = 0;\r\n\t\t\tint selected = -1;\r\n\t\t\tdo {\r\n\t\t\t\tid = graphmlTree[ searchVD ].id;\r\n\t\t\t\tidP = graphmlTree[ searchVD ].parentID;\r\n\t\t\t\t\r\n\t\t\t\tif( isSelectedVec[ id ] ) {\r\n\t\t\t\t\tselected = id;\r\n\t\t\t\t}\r\n\t\t\t\telse if( selected != -1 ) {\r\n\t\t\t\t\t// filter siblings: you are only counted as sibling\r\n\t\t\t\t\t// if you did not increase size through a descendant\r\n\t\t\t\t\t// by our assumption we do not reset a selected node!\r\n\t\t\t\t\tgraphmlTree[ searchVD ].size = 0;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tsearchVD = vertex( idP, graphmlTree );\r\n\t\t\t\t\r\n\t\t\t} while( idP != id );\r\n\t\t}\r\n\t\t\r\n\t\t// propogate size changes\r\n\t\tfor( unsigned int i = 0; i < _sortedLevel.size(); i++ ){\r\n\t\t\tfor( unsigned int j = 0; j < _sortedLevel[i].size(); j++ ) {\r\n\t\t\t\t\r\n\t\t\t\tunsigned int id = _sortedLevel[i][j];\r\n\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd = vertex( id, graphmlTree );\r\n\r\n\t\t\t\tif( graphmlTree[vd].size != 0 ){\r\n#ifdef HierarchicalTreemap_DEBUG\r\n\t\t\t\t\tcerr << \" id = \" << id\r\n\t\t\t\t\t\t << \", childSize = \" << childMap.size() << endl;\r\n#endif // HierarchicalTreemap_DEBUG\r\n\t\t\t\t\t// propagate to leaves\r\n\t\t\t\t\tdouble scale = graphmlTree[vd].size / originalSizeVec[id];\r\n\t\t\t\t\t\r\n\t\t\t\t\tGraph::TreeDirectedGraph::out_edge_iterator e, e_end;\r\n\t\t\t\t\tfor( tie( e, e_end ) = out_edges( vd, graphmlTree ); e != e_end; ++e ) {\r\n\t\t\t\t\t\tGraph::TreeDirectedGraph::edge_descriptor ed = *e;\r\n\t\t\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdT = target( ed, graphmlTree );\r\n\t\t\t\t\t\tunsigned int idT = graphmlTree[ vdT ].id;\r\n\t\t\t\t\t\tdouble newSize = originalSizeVec[ idT ] * scale;\r\n\r\n                        if( newSize >= minSize * total ) { // prevent size from going below minSize\r\n\t                        graphmlTree[ vdT ].size = newSize;\r\n                        }\r\n\t\t\t\t\t\telse {\r\n                            graphmlTree[ vdT ].size = minSize * total;\r\n                        }\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n#ifdef HierarchicalTreemap_DEBUG\r\n\t\tBGL_FORALL_VERTICES( vd, _treemapTree, Graph::TreeDirectedGraph ) {\r\n\t\t\tcerr << \"after id = \" << _treemapTree[vd].id\r\n\t\t\t\t << \", size = \" << graphmlTree[vd].size << endl;\r\n\t\t\t}\r\n#endif // HierarchicalTreemap_DEBUG\r\n\r\n\t\t// compute shrinking factor\r\n\t\tdouble coefficient = 0.0;\r\n\t\tdouble knownArea = 0.0;\r\n\t\tdouble shrinkFactor = 0.0;\r\n\r\n\t\tbool setMinSize = true;\r\n\t\twhile( setMinSize ) {\r\n\t\t\t\r\n\t\t\tcerr << \"Is this an endless loop?\" << endl;\r\n\t\t\tcoefficient = 0.0;\r\n\t\t\tknownArea = 0.0;\r\n\t\t\tshrinkFactor = 0.0;\r\n\t\t\tsetMinSize = false;\r\n\r\n\t\t\tBGL_FORALL_VERTICES( vd, graphmlTree, Graph::TreeDirectedGraph ) {\r\n\r\n\t\t\t\tunsigned int id = graphmlTree[ vd ].id;\r\n\r\n\t\t\t\t// add total area of leaves\r\n\t\t\t\tGraph::TreeDirectedGraph::degree_size_type degrees = out_degree( vd, graphmlTree );\r\n\t\t\t\tif ( degrees == 0 ){\r\n\t\t\t\t\t\r\n\t\t\t\t\tcerr << \" leafID = \" << id << endl;\r\n\t\t\t\t\tif( graphmlTree[vd].size == 0 ){\r\n\t\t\t\t\t\tcoefficient += originalSizeVec[ id ];\r\n\t\t\t\t\t\tcerr << \"oriCoeff = \" << originalSizeVec[ id ] << endl;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse{\r\n\t\t\t\t\t\tknownArea += graphmlTree[vd].size;\r\n\t\t\t\t\t\tcerr << \"graphmlTree[vd].size = \" << graphmlTree[vd].size << endl;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tshrinkFactor = ( ww * wh - knownArea )/coefficient;\r\n\t\t\tcerr << \"total = ww * wh = \" << ww*wh << endl;\r\n\t\t\tcerr << \"coefficient = \" << coefficient << endl;\r\n\t\t\tcerr << \"knownArea = \" << knownArea << endl;\r\n\t\t\tcerr << \"shrinkFactor = \" << shrinkFactor << endl;\r\n\t\t\t\r\n\t\t\t// update size\r\n            // assign unknown leaf size\r\n            for( unsigned int i = _sortedLevel.size()-1; i < _sortedLevel.size(); i++ ) {\r\n\t            for( unsigned int j = 0; j < _sortedLevel[ i ].size(); j++ ) {\r\n\t\t            unsigned int id = _sortedLevel[ i ][ j ];\r\n\t\t            Graph::TreeDirectedGraph::vertex_descriptor vd = vertex( id, graphmlTree );\r\n\t\t            if( graphmlTree[ vd ].size == 0 ) {\r\n\t\t\t            double newSize = shrinkFactor * originalSizeVec[ id ];\r\n\t\t\t            if( newSize < minSize * total ) { // prevent size from going below minSize\r\n\t\t\t\t            graphmlTree[ vd ].size = minSize * total;\r\n\t\t\t\t            setMinSize = true;\r\n\t\t\t\t            cerr << \"id\" << id << \" set to minSize\" << endl;\r\n\t\t\t            }\r\n\t\t            }\r\n\t            }\r\n            }\r\n\t\t}\r\n\r\n\t\t// since we got out of the loop, we know none of the remaining go below minSize\r\n\t\tfor( unsigned int i = _sortedLevel.size()-1; i < _sortedLevel.size(); i++ ){\r\n\t\t\tfor( unsigned int j = 0; j < _sortedLevel[i].size(); j++ ) {\r\n\t\t\t\tunsigned int id = _sortedLevel[i][j];\r\n\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd = vertex( id, graphmlTree );\r\n\t\t\t\tif( graphmlTree[ vd ].size == 0 ) {\r\n\t\t\t\t\tgraphmlTree[ vd ].size = shrinkFactor * originalSizeVec[id];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n#ifdef HierarchicalTreemap_DEBUG\r\n\t\tdouble total = 0.0;\r\n\t\tBGL_FORALL_VERTICES( vd, _treemapTree, Graph::TreeDirectedGraph ) {\r\n\t\t\t\tif( _treemapTree[vd].childMap.size() == 0 ){\r\n\t\t\t\t\tcerr << \"is leaf id = \" << _treemapTree[vd].id\r\n\t\t\t\t\t     << \", size = \" << _treemapTree[vd].size << endl;\r\n\t\t\t\t\ttotal += _treemapTree[ vd ].size;\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tcerr << \"not leaf id = \" << _treemapTree[vd].id\r\n\t\t\t\t\t     << \", size = \" << _treemapTree[vd].size << endl;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\tcerr << \"total = \" << total << endl;\r\n\t\t\r\n#endif // HierarchicalTreemap_DEBUG\r\n\t\t\r\n\t\t// propagate child size upwards to get consistent sizes\r\n\t\tfor( int i = _sortedLevel.size()-2; i >= 0; i-- ) {\r\n\t\t\tfor( unsigned int j = 0; j < _sortedLevel[ i ].size(); j++ ) {\r\n\t\t\t\tunsigned int id = _sortedLevel[ i ][ j ];\r\n\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd = vertex( id, graphmlTree );\r\n\t\t\t\tgraphmlTree[ vd ].size = 0;\r\n\t\t\t\t\r\n\t\t\t\tGraph::TreeDirectedGraph::out_edge_iterator e, e_end;\r\n\t\t\t\tfor( tie( e, e_end ) = out_edges( vd, graphmlTree ); e != e_end; ++e ) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tGraph::TreeDirectedGraph::edge_descriptor ed = *e;\r\n\t\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdT = target( ed, graphmlTree );\r\n\t\t\t\t\t\r\n\t\t\t\t\tgraphmlTree[ vd ].size += graphmlTree[ vdT ].size;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n#ifdef HierarchicalTreemap_DEBUG\r\n\t\tBGL_FORALL_VERTICES( vd, _treemapTree, Graph::TreeDirectedGraph ) {\r\n\t\t\t\tif( _treemapTree[vd].childMap.size() == 0 ){\r\n\t\t\t\t\tcerr << \"is leaf id = \" << _treemapTree[vd].id\r\n\t\t\t\t\t     << \", size = \" << _treemapTree[vd].size << endl;\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tcerr << \"not leaf id = \" << _treemapTree[vd].id\r\n\t\t\t\t\t     << \", size = \" << _treemapTree[vd].size << endl;\r\n\t\t\t\t}\r\n\t\t\t}\r\n#endif // HierarchicalTreemap_DEBUG\r\n\t\t\r\n\t\t// set up treemapSizeMap data structure\r\n\t\tfor( unsigned int i = 0; i < _treemapVec.size(); i++ ){\r\n\t\t\t\r\n\t\t\tmap< unsigned int, pair< double, double > > &treemapSizeMap = _treemapVec[ i ].treemapSizeMap();\r\n\t\t\tfor( map< unsigned int, pair< double, double > >::iterator it = treemapSizeMap.begin();\r\n\t\t\t\t it != treemapSizeMap.end(); it++ ){\r\n\t\t\t\tunsigned int id = it->first;\r\n\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd = vertex( id, graphmlTree );\r\n\t\t\t\tit->second.second = graphmlTree[ vd ].size;\r\n\t\t\t}\r\n\t\t}\r\n\r\n#ifdef HierarchicalTreemap_DEBUG\r\n\t\tfor( unsigned int i = 0; i < _sortedLevel.size()-1; i++ ) {\r\n\t\t\tfor( unsigned int j = 0; j < _sortedLevel[ i ].size(); j++ ) {\r\n\r\n\t\t\t\tunsigned int id = _sortedLevel[i][j];\r\n\t\t\t\tcerr << \"id = \" << id << endl;\r\n\t\t\t\tmap< string, pair< double, double > > &treemapSizeMap = _treemapVec[ id ].treemapSizeMap();\r\n\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd = vertex( id, _treemapTree );\r\n\t\t\t\tmap< unsigned int, unsigned int > &childMap = _treemapTree[ vd ].childMap;\r\n\t\t\t\t\r\n\t\t\t\tfor( unsigned int k = 0; k < treemapSizeMap.size(); k++ ){\r\n\t\t\t\t\tmap< string, pair< double, double > >::iterator it = treemapSizeMap.begin();\r\n\t\t\t\t\tstd::advance( it, k );\r\n\t\t\t\t\tcerr << \"k = \" << k << \", \"\r\n\t\t\t\t\t\t << it->second.second << endl;\r\n\t\t\t\t}\r\n\t\t\t\tcerr << endl;\r\n\t\t\t}\r\n\t\t}\r\n#endif // HierarchicalTreemap_DEBUG\r\n\t}\r\n\r\n\tvoid HierarchicalTreemap::_resetTreemapSize( void )\r\n\t{\r\n\t\tfor( unsigned i = 0; i < _sortedLevel.size(); i++ ){\r\n\t\t\tfor( unsigned j = 0; j < _sortedLevel[i].size(); j++ ) {\r\n\t\t\t\tunsigned int id = _sortedLevel[i][j];\r\n\t\t\t\tmap< unsigned int, pair< double, double > > &treemapSizeMap = _treemapVec[ id ].treemapSizeMap();\r\n\t\t\t\tmap< unsigned int, pair< double, double > > &treemapFixedSizeMap = _treemapVec[ id ].treemapFixedSizeMap();\r\n\t\t\t\tfor( unsigned int k = 0; k < treemapSizeMap.size(); k++ ){\r\n\t\t\t\t\tmap< unsigned int, pair< double, double > >::iterator it = treemapSizeMap.begin();\r\n\t\t\t\t\tmap< unsigned int, pair< double, double > >::iterator itF = treemapFixedSizeMap.begin();\r\n\t\t\t\t\tstd::advance( it, k );\r\n\t\t\t\t\tstd::advance( itF, k );\r\n\t\t\t\t\tit->second = itF->second;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t}\r\n\r\n\tvoid HierarchicalTreemap::assignTreemapSize( ASSIGNMENTTYPE type = ABSOLUTE_TYPE )\r\n\t{\r\n    \t_sizeAssignmentType = type;\r\n    \t_resetTreemapSize();\r\n\t\t\r\n\t\tif( _selectSceneItemMapPtr->size() == 0 ) return;\r\n\t\t\r\n//\t\tcerr << \"tuple size = \" << _selectSceneItemMapPtr->size() << endl;\r\n\t\tswitch( type ) {\r\n\t\tcase ABSOLUTE_TYPE:\r\n\t\t\t_assignTreemapSizeAbsolute();\r\n\t\t\tbreak;\r\n\t\tcase EXACT_TYPE:\r\n\t\t\t_assignTreemapSizeExact();\r\n\t\t\tbreak;\r\n\t\tcase SIBLINGS_TYPE:\r\n\t\t\t_assignTreemapSizeSibling();\r\n\t\t\tbreak;\r\n\t\tcase PARAMETERIZED_TYPE:\r\n\t\t\tcerr << \"increaseRatio is \" << *_increaseRatioPtr << endl;\r\n\t\t\tcerr << \"siblingRatio is \" << *_siblingRatioPtr << endl;\r\n\t\t\tcerr << \"minSize is\" << *_minSizePtr << endl;\r\n\t\t\t_assignTreemapSizeParameterized(*_increaseRatioPtr, *_siblingRatioPtr, *_minSizePtr);\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\t\r\n\t//------------------------------------------------------------------------------\r\n    //\tFriend functions\r\n    //------------------------------------------------------------------------------\r\n\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tI/O functions\r\n    //------------------------------------------------------------------------------\r\n}\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ResponsiveLens/core/HierarchicalTreemap.cpp b/ResponsiveLens/core/HierarchicalTreemap.cpp
--- a/ResponsiveLens/core/HierarchicalTreemap.cpp	
+++ b/ResponsiveLens/core/HierarchicalTreemap.cpp	
@@ -180,20 +180,21 @@
 		    else {
 				// non-root node, extend to the entire size of the parent
 				boundingBoxPtr = graphmlTree[ vd ].boundingBoxPtr;
+		    	cerr <<"zainab"<< boundingBoxPtr->width()<<"  "<<boundingBoxPtr->height()<<endl;
 		    }
 
 		    unsigned int id = graphmlTree[ vd ].id;
 		    graphmlTree[ vd ].aspectRatio = boundingBoxPtr->width() / boundingBoxPtr->height();
 			graphmlTree[ vd ].coordPtr->x() = boundingBoxPtr->leftBottom().x() + 0.5* boundingBoxPtr->width();
 			graphmlTree[ vd ].coordPtr->x() = boundingBoxPtr->leftBottom().y() + 0.5* boundingBoxPtr->height();
-			
+
 		    // create a treemap
 		    Treemap treemap;
 		    treemap.id() = id;
 		    treemap.level() = graphmlTree[vd].level;
 		    _treemapVec[ id ] = treemap;
         }
-		
+
 #ifdef HierarchicalTreemap_DEBUG
 	    BGL_FORALL_VERTICES( vd, _treemapTree, Graph::TreeDirectedGraph ) {
 
@@ -201,15 +202,15 @@
 		}
 		cerr << endl;
 #endif // HierarchicalTreemap_DEBUG
-		
+
 	    // initialize treemaps by ordered levels
 	    for( unsigned int i = 0; i < _sortedLevel.size(); i++ ){
 		    for( unsigned int j = 0; j < _sortedLevel[i].size(); j++ ) {
-			
+
 			    unsigned int id = _sortedLevel[ i ][ j ];
 			    Graph::BaseUndirectedGraph &graphmlGraph = graphmlGraphMap.find( id )->second;
 			    Graph::TreeDirectedGraph::vertex_descriptor vd = vertex( id, graphmlTree );
-			
+
 				_treemapVec[id].init( _metadataPtr, graphmlTree[ vd ].boundingBoxPtr );
 
 			    if( i != _metadataPtr->maxLevel()-1 ) {
@@ -222,10 +223,10 @@
 			    }
 		    }
 	    }
-	
+
 	    // normalize the size
 	    for( int i = _sortedLevel.size()-2; i >= 0; i-- ){
-		
+
 		    // collect total size
 		    if( i == _sortedLevel.size()-2 ){
 			    for( unsigned int j = 0; j < _sortedLevel[i].size(); j++ ) {
@@ -262,7 +263,7 @@
 			    }
 		    }
 	    }
-	
+
 	    // initialize the old coordinate for animation
 	    for( unsigned int i = 0; i < _treemapVec.size(); i++ ){
 		    map< unsigned int, KeiRo::Base::Rectangle2 > &targetMap = _treemapVec[i].treemapTargetMap();
@@ -271,7 +272,7 @@
 			    it->second.updateOldElement();
 		    }
 	    }
-		
+
 #ifdef HierarchicalTreemap_DEBUG
 	    cerr << "no. of treemapVec = " << _treemapVec.size() << endl;
 	    int sum = 1;
@@ -290,7 +291,7 @@
 			    }
 			    cerr << endl;
 		    }
-	    
+
 	    BGL_FORALL_VERTICES( vd, _treemapTree, Graph::TreeDirectedGraph ) {
 	    	cerr << "tid = " << _treemapTree[vd] << endl;
 	    	for( unsigned int i = 0; i < _treemapTree[vd].childMap.size(); i++ ){
@@ -302,7 +303,7 @@
 	    }
 
 	    for( unsigned int i = 0; i < _treemapVec.size(); i++ ){
-	    	
+
 		    map< string, KeiRo::Base::Rectangle2 > &sourceMap = _treemapVec[i].treemapSourceMap();
 		    map< string, KeiRo::Base::Rectangle2 > &targetMap = _treemapVec[i].treemapTargetMap();
 		    map< string, KeiRo::Base::Rectangle2 >::iterator itS = sourceMap.begin();
@@ -321,7 +322,7 @@
 	    }
 #endif // HierarchicalTreemap_DEBUG
     }
-	
+
 	//
 	//  HierarchicalTreemap::resetHierarchicalTreemap --	reset HierarchicalTreemap to inital stage
 	//
@@ -333,11 +334,117 @@
 	//
 	void HierarchicalTreemap::resetHierarchicalTreemap( void )
 	{
+    	Graph::TreeDirectedGraph &graphmlTree = _metadataPtr->graphmlTree();
+    	map< unsigned int, Graph::BaseUndirectedGraph > &graphmlGraphMap = _metadataPtr->graphmlGraphMap();
+
+    	// // store the old coordinates for animation
+    	// BGL_FORALL_VERTICES( vd, graphmlTree, Graph::TreeDirectedGraph ) {
+    	// 	graphmlTree[ vd ].boundingBoxPtr->updateOldElement();
+    	// }
+	    //
+    	// // store the old coordinates for animation
+    	// for( unsigned int i = 0; i < _treemapVec.size(); i++ ) {
+    	// 	map< unsigned int, KeiRo::Base::Rectangle2 > &targetMap = _treemapVec[ i ].treemapTargetMap();
+    	// 	for( map< unsigned int, KeiRo::Base::Rectangle2 >::iterator it = targetMap.begin();
+				 // it != targetMap.end(); it++ ) {
+    	// 		it->second.updateOldElement();
+				 // }
+    	// }
+	    // //
+    	// // store old coordinate for animation purpose
+    	// for( unsigned int i = 0; i < _treemapVec.size(); i++ ){
+    	// 	_treemapVec[i].updateOldWidthHeight();
+    	// }
+	    //
+    	// for( unsigned int i = 0; i < _treemapVec.size(); i++ ) {
+    	// 	map< unsigned int, pair< double, double > > &treemapFixedSizeMap = _treemapVec[ i ].treemapFixedSizeMap();
+    	// 	map< unsigned int, pair< double, double > > &treemapSizeMap = _treemapVec[ i ].treemapSizeMap();
+    	// 	map< unsigned int, KeiRo::Base::Rectangle2 > &treemapSourceMap = _treemapVec[ i ].treemapSourceMap();
+    	// 	map< unsigned int, KeiRo::Base::Rectangle2 > &treemapTargetMap = _treemapVec[ i ].treemapTargetMap();
+	    //
+    	// 	// initial treemaps fixed properties
+    	// 	treemapSizeMap = treemapFixedSizeMap;
+    	// 	for( unsigned int j = 0; j < treemapSizeMap.size(); j++ ) {
+	    //
+    	// 		map< unsigned int, KeiRo::Base::Rectangle2 >::iterator itS = treemapSourceMap.begin();
+    	// 		map< unsigned int, KeiRo::Base::Rectangle2 >::iterator itT = treemapTargetMap.begin();
+	    //
+    	// 		std::advance( itS, j );
+    	// 		std::advance( itT, j );
+    	// 		itS->second.leftBottom() = itS->second.fixedLeftBottom()  ;
+    	// 		itS->second.width() = itS->second.fixedWidth() ;
+    	// 		itS->second.height() = itS->second.fixedHeight()  ;
+	    //
+    	// 		itT->second.leftBottom() = itT->second.fixedLeftBottom()  ;
+    	// 		itT->second.width() = itT->second.fixedWidth() ;
+    	// 		itT->second.height() = itT->second.fixedHeight() ;
+    	// 	}
+    	// }
+
+
+			//Graph::TreeDirectedGraph    &graphmlTree    = _metadataPtr->graphmlTree();
+			double borderWidth = _metadataPtr->borderWidth();
+
+			BGL_FORALL_VERTICES( vd, graphmlTree, Graph::TreeDirectedGraph ) {
+				KeiRo::Base::Rectangle2 &bbox = *graphmlTree[ vd ].boundingBoxPtr;
+
+				// KeiRo::Base::Coord2 center( bbox.fixedLeftBottom().x() + 0.5*bbox.fixedWidth(),
+				// 							bbox.fixedLeftBottom().y() + 0.5*bbox.fixedHeight() );
+				// KeiRo::Base::Coord2 oldCenter( bbox.fixedLeftBottom().x() + 0.5*bbox.oldWidth(),
+				// 							   bbox.fixedLeftBottom().y() + 0.5*bbox.oldHeight() );
+
+
+				bbox.leftBottom().x() = bbox.oldLeftBottom().x();
+				bbox.leftBottom().y()	= bbox.oldLeftBottom().y();
+				bbox.width() = bbox.oldWidth();
+				bbox.height() =bbox.oldHeight();
+
+
+
+
+			}
+    	//Graph::TreeDirectedGraph &graphmlTree = _metadataPtr->graphmlTree();
+    //map<unsigned int, Graph::BaseUndirectedGraph> &graphmlGraphMap = _metadataPtr->graphmlGraphMap();
+
+    for(auto it = graphmlGraphMap.begin(); it != graphmlGraphMap.end(); ++it) {
+	    Graph::TreeDirectedGraph::vertex_descriptor vdP = vertex(it->first, graphmlTree);
+    	KeiRo::Base::Rectangle2 &bbox = *graphmlTree[vdP].boundingBoxPtr;
+
+    	Graph::BaseUndirectedGraph &subGraph = it->second;
+
+    	// First pass: Calculate initial bounding box and update coordinates
+    	BGL_FORALL_EDGES(ed, subGraph, Graph::BaseUndirectedGraph) {
+    		KeiRo::Base::Edge2 &edge = subGraph[ed].edge;
+    		for(unsigned int i = 0; i < edge.elements().size(); i++) {
+    			//edge.elements()[i]= edge.oldElements()[i];
+    			// edge.elements()[i].x() = edge.oldElements()[i].x();
+    			// edge.elements()[i].y() = edge.oldElements()[i].y();
+    			KeiRo::Base::Coord2 &coord = edge.elements()[i];
+
+    			//coord.updateOldElement();
+    			coord.x() = coord.oldElement()[0];
+    			coord.y() = coord.oldElement()[1];
+    		}
+    	}
+
+    	BGL_FORALL_VERTICES(vd, subGraph, Graph::TreeDirectedGraph) {
+    		subGraph[vd].coordPtr->x()= subGraph[vd].coordPtr->oldElement()[0];
+    		subGraph[vd].coordPtr->y()= subGraph[vd].coordPtr->oldElement()[1];
+
+    	}
+    }
+    	//vector<LocalMove> t = _treemapVec[ 0 ].updateTreemap();
+
+    	//_updateSubGraphs(2, t);
+							//cerr << "Animation 1 Updated" << endl;
+
+
+
 #ifdef REWRITE
 		vector< FileIO::SVG* > &svgPtrVec = _metadataPtr->svgPtrVec();
-		
+
 		for( unsigned int i = 0; i < svgPtrVec.size(); i++ ){
-			
+
 			FileIO::SVG* svgPtr = svgPtrVec[i];
 			vector< KeiRo::Base::Coord2 > &samples = svgPtrVec[ i ]->compressionGrid().samples();
 			vector< KeiRo::Base::Polygon2 > &polygonVec = svgPtrVec[ i ]->polygonVec();
@@ -346,7 +453,7 @@
 			map< string, pair< double, double > > &treemapSizeMap = _treemapVec[ i ].treemapSizeMap();
 			map< string, KeiRo::Base::Rectangle2 > &treemapSourceMap = _treemapVec[ i ].treemapSourceMap();
 			map< string, KeiRo::Base::Rectangle2 > &treemapTargetMap = _treemapVec[ i ].treemapTargetMap();
-			
+
 			for( unsigned int j = 0; j < polygonVec.size(); j++ ){
 				polygonVec[j].elements() = polygonVec[j].fixedElements();
 
@@ -365,18 +472,18 @@
 				polygonVec[j].boundingBox().updateOldElement();
 				polygonVec[j].update();
 			}
-			
+
 			for( unsigned int j = 0; j < polylineVec.size(); j++ ){
-				
+
 				polylineVec[j].elements() = polylineVec[j].fixedElements();
-				
+
 				for( unsigned int k = 0; k < polylineVec[j].elements().size(); k++ ){
 					samples[ polylineVec[ j ].idElements()[ k ] ].updateOldElement();
 					samples[ polylineVec[ j ].idElements()[ k ] ].setX( polylineVec[j].elements()[k].x() );
 					samples[ polylineVec[ j ].idElements()[ k ] ].setY( polylineVec[j].elements()[k].y() );
 				}
 			}
-			
+
 			unsigned int mapSize = treemapFixedSizeMap.size();
 			 treemapSizeMap = treemapFixedSizeMap;
 			for( unsigned int j = 0; j < mapSize; j++ ) {
@@ -384,14 +491,14 @@
 				map< string, KeiRo::Base::Rectangle2 >::iterator itT = treemapTargetMap.begin();
 				std::advance( itS, j );
 				std::advance( itT, j );
-				
+
 				itS->second.oldLeftBottom() = itS->second.leftBottom();
 				itS->second.oldWidth() = itS->second.width();
 				itS->second.oldHeight() = itS->second.height();
 				itT->second.oldLeftBottom() = itT->second.leftBottom();
 				itT->second.oldWidth() = itT->second.width();
 				itT->second.oldHeight() = itT->second.height();
-				
+
 				itS->second.leftBottom() = itS->second.fixedLeftBottom();
 				itS->second.width() = itS->second.fixedWidth();
 				itS->second.height() = itS->second.fixedHeight();
@@ -402,7 +509,7 @@
     	}
 #endif // REWRITE
 	}
-	
+
 	//
 	//  HierarchicalTreemap::_buildSortedLevel --	build sorted level
 	//
@@ -423,7 +530,7 @@
 			unsigned int level = graphmlTree[vd].level;
 			_sortedLevel[ level ].push_back( id );
 		}
-  
+
 #ifdef HierarchicalTreemap_DEBUG
         cerr << "_metadataPtr->maxLevel() = " << _metadataPtr->maxLevel() << endl;
 		for( unsigned int i = 0; i < _sortedLevel.size(); i++ ){
@@ -435,7 +542,7 @@
 		}
 #endif // HierarchicalTreemap_DEBUG
 	}
-	
+
 	//
 	//  HierarchicalTreemap::updateHierarchicalTreemap --	update a HierarchicalTreemap from the samples
 	//
@@ -446,13 +553,13 @@
 	//	none
 	//
 	vector<LocalMove> HierarchicalTreemap::updateHierarchicalTreemap( bool isInitialized ) {
-	
+
 #ifdef HierarchicalTreemap_DEBUG
 		for( unsigned int i = 0; i < _treemapVec.size(); i++ ){
 			cerr << "i = " << i << ", id = " << _treemapVec[i].id() << endl;
 		}
 #endif // HierarchicalTreemap_DEBUG
-		
+
 		Graph::TreeDirectedGraph &graphmlTree = _metadataPtr->graphmlTree();
 		map< unsigned int, Graph::BaseUndirectedGraph > &graphmlGraphMap = _metadataPtr->graphmlGraphMap();
 
@@ -460,7 +567,7 @@
 		BGL_FORALL_VERTICES( vd, graphmlTree, Graph::TreeDirectedGraph ) {
 			graphmlTree[ vd ].boundingBoxPtr->updateOldElement();
 		}
-		
+
 		// store the old coordinates for animation
 		for( unsigned int i = 0; i < _treemapVec.size(); i++ ) {
 			map< unsigned int, KeiRo::Base::Rectangle2 > &targetMap = _treemapVec[ i ].treemapTargetMap();
@@ -471,19 +578,19 @@
 				it->second.updateOldElement();
 			}
 		}
-		
+
 		// store old coordinate for animation purpose
 		for( unsigned int i = 0; i < _treemapVec.size(); i++ ){
 			_treemapVec[i].updateOldWidthHeight();
 		}
-		
+
 		vector<LocalMove> localMoves;
 
 		// update the layout through stable treemap approach, starting from the top of the hierarchy towards the leaves
 		for( unsigned int i = 0; i < _sortedLevel.size() - 1; i++ ) {
-			
+
 			vector<LocalMove> tempMoves;
-			
+
 			for( unsigned int j = 0; j < _sortedLevel[ i ].size(); j++ ) {
 				unsigned int id = _sortedLevel[ i ][ j ];
 #ifdef HierarchicalTreemap_DEBUG
@@ -495,17 +602,17 @@
 				_treemapVec[ id ].prepareTreemap();
 				tempMoves = _treemapVec[ id ].updateTreemap();
 				//cerr << "tempMOVES " << tempMoves.size()<<endl;
-				cerr << "Updated a treemap with address " << &tempMoves << endl;
+				//cerr << "Updated a treemap with address " << &tempMoves << endl;
 
 				tempMoves = _validateMoves(tempMoves, i+1); //check whether local moves work on level i+1 of treemap, remove if not
-				cerr << "tempMOVES " << tempMoves.size()<<endl;
-				cerr << "Validated moves at address" << &tempMoves << endl;
+				// cerr << "tempMOVES " << tempMoves.size()<<endl;
+				// cerr << "Validated moves at address" << &tempMoves << endl;
 
 				// first scale treemap cells otherwise we cannot use newly computed sizes for intermediate coordinates
 				_scaleTreemapCells( i, j );
 				// update the intermediate coordinates for the validated localMoves
 		                _updateIntermediateCells(tempMoves, id);
-				cerr <<" _localMoves inside update treemap"<<localMoves.size() <<endl;
+				//cerr <<" _localMoves inside update treemap"<<localMoves.size() <<endl;
 				localMoves.insert(localMoves.end(), tempMoves.begin(), tempMoves.end());
 
 			}
@@ -516,7 +623,7 @@
 			}
 
 		}
-		
+
 #ifdef HierarchicalTreemap_DEBUG
 		for( unsigned int i=0; i < _treemapVec.size(); i++ ){
 			cerr << "After: " << endl
@@ -527,19 +634,19 @@
 		}
 		cerr << "isInitialized = " << isInitialized << endl;
 #endif // HierarchicalTreemap_DEBUG
-		
+
 		// remove empty cells, only need to do it once after initialization
 		if( _metadataPtr->dataType() == DATA_GRAPHML && isInitialized == false ) {
-			
+
 			Graph::TreeDirectedGraph &graphmlTree   = _metadataPtr->graphmlTree();
-			
+
 			for( unsigned int i = 0; i < _treemapVec.size(); i++ ) {
-				
+
 				map< unsigned int, pair< double, double > > &treemapFixedSizeMap = _treemapVec[ i ].treemapFixedSizeMap();
 				map< unsigned int, pair< double, double > > &treemapSizeMap = _treemapVec[ i ].treemapSizeMap();
 				map< unsigned int, KeiRo::Base::Rectangle2 > &treemapSourceMap = _treemapVec[ i ].treemapSourceMap();
 				map< unsigned int, KeiRo::Base::Rectangle2 > &treemapTargetMap = _treemapVec[ i ].treemapTargetMap();
-				
+
 				unsigned int id = _treemapVec[ i ].id();
 				Graph::TreeDirectedGraph::vertex_descriptor vd = vertex( id, graphmlTree );
 				Graph::TreeDirectedGraph::degree_size_type degrees = out_degree( vd, graphmlTree );
@@ -555,7 +662,7 @@
 				unsigned int diffSize = treemapFixedSizeMap.size() - degrees;
 				// pop from the back
 				for( unsigned int j = 0; j < diffSize; j++ ) {
-					
+
 					map< unsigned int, pair< double, double > >::iterator itF = treemapFixedSizeMap.end();
 					map< unsigned int, pair< double, double > >::iterator itM = treemapSizeMap.end();
 					map< unsigned int, KeiRo::Base::Rectangle2 >::iterator itS = treemapSourceMap.end();
@@ -564,15 +671,15 @@
 					itM--;
 					itS--;
 					itT--;
-					
+
 					treemapFixedSizeMap.erase( itF );
 					treemapSizeMap.erase( itM );
 					treemapSourceMap.erase( itS );
 					treemapTargetMap.erase( itT );
 				}
-				
+
 				// initial treemaps fixed properties
-				treemapSizeMap = treemapFixedSizeMap;
+				 treemapSizeMap = treemapFixedSizeMap;
 				for( unsigned int j = 0; j < treemapSizeMap.size(); j++ ) {
 
 					map< unsigned int, KeiRo::Base::Rectangle2 >::iterator itS = treemapSourceMap.begin();
@@ -590,7 +697,7 @@
 				}
 			}
 		}
-
+    	//printGraph( graphmlTree );
 		return localMoves;
 	}
 
@@ -613,42 +720,42 @@
 		Treemap parent = _treemapVec[ id ];
 		map< unsigned int, KeiRo::Base::Rectangle2 > &treemapIntermediateMap = parent.treemapIntermediateMap();
 		Graph::TreeDirectedGraph &graphmlTree   = _metadataPtr->graphmlTree();
-		
+
 		Graph::TreeDirectedGraph::vertex_descriptor vdParent = vertex( id , graphmlTree );
 		KeiRo::Base::Rectangle2 intParent = *graphmlTree[ vdParent ].boundingBoxPtr;
-		
+
 		cerr << "updateIntermediateCells is called" << endl;
-		
+
 		if( localMoves.size() > 0 && !parent.boundingBoxPtr()->inLocalMove() ) { // intermediate parent rectangle not yet computed
-		
+
 			cerr << "Parent cell is updated" << endl;
 			KeiRo::Base::Coord2 intLeftBottom;
 			// compute coordinates to be halfway between new and old coordinates
 			intLeftBottom.set( (intParent.leftBottom().x() + intParent.oldLeftBottom().x())/2, (intParent.leftBottom().y() + intParent.oldLeftBottom().y())/2 );
 			// create intermediate parent rectangle halfway between new and old rectangle
 			intParent.updateIntermediateElement( intLeftBottom, (intParent.width() + intParent.oldWidth())/2, (intParent.height() + intParent.oldHeight())/2);
-			
+
 		}
-		
+
 		for( unsigned int i = 0; i < localMoves.size(); i++ ) { // TO TURN OFF SET CONDITION TO i < MIN2(1, localMoves.size()) INSTEAD OF i < localMoves.size()
 
 			LocalMove m = localMoves[i];
-			
+
 			cerr << "Intermediate cell for local move " << i << " is updated, with LB " << m.beforeLeftBottomID() << " and RT " << m.beforeRightTopID() << endl;
-			
+
 			map< unsigned int, KeiRo::Base::Rectangle2 >::iterator itLB = treemapIntermediateMap.find( m.beforeLeftBottomID() );
 			Graph::TreeDirectedGraph::vertex_descriptor vdPLB = vertex( m.beforeLeftBottomID() , graphmlTree );
 			KeiRo::Base::Rectangle2 &bboxLB = *graphmlTree[ vdPLB ].boundingBoxPtr;
-			
+
 			map< unsigned int, KeiRo::Base::Rectangle2 >::iterator itRT = treemapIntermediateMap.find( m.beforeRightTopID() );
 			Graph::TreeDirectedGraph::vertex_descriptor vdPRT = vertex( m.beforeRightTopID() , graphmlTree );
 			KeiRo::Base::Rectangle2 &bboxRT = *graphmlTree[ vdPRT ].boundingBoxPtr;
-			
-			
+
+
 			// find bounding box of intermediate rectangles in local move using following variables
 			KeiRo::Base::Coord2 intLeftBottomLB, intLeftBottomRT;
 			double intWidthLB, intHeightLB, intWidthRT, intHeightRT, totalHeight, totalWidth;
-			
+
 			// make sure unshrunk rectangles are set
 			if(!bboxLB.inLocalMove()) {
 				cerr << "bboxLB is not in local move yet" << endl;
@@ -657,7 +764,7 @@
 				bboxLB.unshrunkWidth() = ( bboxLB.oldWidth() + bboxLB.width() ) / 2;
 				bboxLB.unshrunkHeight() = ( bboxLB.oldHeight() + bboxLB.height() ) / 2;
 			}
-			
+
 			if(!bboxRT.inLocalMove()) {
 				cerr << "bboxLB is not in local move yet" << endl;
 				bboxRT.unshrunkLeftBottom().set( ( bboxRT.oldLeftBottom().x() + bboxRT.leftBottom().x() ) / 2,
@@ -665,74 +772,74 @@
 				bboxRT.unshrunkWidth() = ( bboxRT.oldWidth() + bboxRT.width() ) / 2;
 				bboxRT.unshrunkHeight() = ( bboxRT.oldHeight() + bboxRT.height() ) / 2;
 			}
-			
+
 			// compute naive intermediate rectangles
 			intLeftBottomLB.set( 	bboxLB.unshrunkLeftBottom().x(),
 						bboxLB.unshrunkLeftBottom().y() );
 			intWidthLB = bboxLB.unshrunkWidth();
 			intHeightLB = bboxLB.unshrunkHeight();
-			
+
 			intLeftBottomRT.set(	bboxRT.unshrunkLeftBottom().x(),
 						bboxRT.unshrunkLeftBottom().y() );
 			intWidthRT = bboxRT.unshrunkWidth();
 			intHeightRT = bboxRT.unshrunkHeight();
-			
+
 			// find the bottom left corners and widht/height of intermediate rectangles in local move
 			// this is doen by shrinking the rectangles to remove overlap
 			if(m.beforeLeftBottomID() == m.afterLeftBottomID() && m.beforeSegmentHorizontal()) { // this rectangle is bottom left intermediate
-			
+
 				cerr << "bottom left stays bottom left" << endl;
 				// shrink LB to the left corner
 				intWidthLB = intLeftBottomRT.x() - intLeftBottomLB.x();
 				// shrink RT to the bottom corner (WHICH IS TOP NOW)
 				intHeightRT = intLeftBottomLB.y() - intLeftBottomRT.y();
-				
+
 				// set unshrunk heights for next local move
 				totalHeight = intHeightLB + intHeightRT;
 				if(!m.stretchMove()) {
-					
+
 					bboxLB.unshrunkLeftBottom().y() = intLeftBottomRT.y();
 					bboxLB.unshrunkHeight() = totalHeight;
-					bboxRT.unshrunkHeight() = totalHeight;	
-					
+					bboxRT.unshrunkHeight() = totalHeight;
+
 				} else if(m.stretchedID() == m.beforeLeftBottomID()) {
-				
+
 					bboxLB.unshrunkLeftBottom().y() = intLeftBottomRT.y();
 					bboxLB.unshrunkHeight() = totalHeight;
-					
+
 				} else {
-				
+
 					bboxRT.unshrunkHeight() = totalHeight;
-				
+
 				}
-			
+
 			} else if(m.beforeLeftBottomID() == m.afterLeftBottomID() && !m.beforeSegmentHorizontal()) { // this rectangle is bottom left intermediate
-				
+
 				cerr << "bottom left stays bottom left" << endl;
 				// shrink LB to the left corner
 				intWidthLB = intLeftBottomRT.x() - intLeftBottomLB.x();
 				// shrink RT to the bottom corner (WHICH IS TOP NOW)
 				intHeightRT = intLeftBottomLB.y() - intLeftBottomRT.y();
-				
+
 				// set unshrunk heights for next local move
 				totalWidth = intWidthLB + intWidthRT;
 				if(!m.stretchMove()) {
-					
+
 					bboxLB.unshrunkWidth() = totalWidth;
 					bboxRT.unshrunkLeftBottom().x() = intLeftBottomLB.x();
-					bboxRT.unshrunkWidth() = totalWidth;	
-					
+					bboxRT.unshrunkWidth() = totalWidth;
+
 				} else if(m.stretchedID() == m.beforeLeftBottomID()) {
-				
+
 					bboxRT.unshrunkLeftBottom().x() = intLeftBottomLB.x();
 					bboxLB.unshrunkWidth() = totalWidth;
-					
+
 				} else {
-				
+
 					bboxRT.unshrunkWidth() = totalWidth;
-				
+
 				}
-				
+
 			} else if(m.beforeSegmentHorizontal()) { // && m.beforeLeftBottomID() == m.afterRightTop() this rectangle is bottom right intermediate
 
 				cerr << "bottom left becomes right top, bottom right intermediate" << endl;
@@ -741,56 +848,56 @@
 				intLeftBottomLB.set( intLeftBottomRT.x() + intWidthRT, intLeftBottomLB.y() );
 				// shrink RT to the bottom corner (WHICH IS TOP NOW)
 				intHeightRT = intLeftBottomLB.y() - intLeftBottomRT.y();
-				
+
 				// set unshrunk heights for next local move
 				totalHeight = intHeightLB + intHeightRT;
 				if(!m.stretchMove()) {
-					
+
 					bboxLB.unshrunkLeftBottom().y() = intLeftBottomRT.y();
 					bboxLB.unshrunkHeight() = totalHeight;
-					bboxRT.unshrunkHeight() = totalHeight;	
-					
+					bboxRT.unshrunkHeight() = totalHeight;
+
 				} else if(m.stretchedID() == m.beforeLeftBottomID()) {
-				
+
 					bboxLB.unshrunkLeftBottom().y() = intLeftBottomRT.y();
 					bboxLB.unshrunkHeight() = totalHeight;
-					
+
 				} else {
-				
+
 					bboxRT.unshrunkHeight() = totalHeight;
-				
+
 				}
 
 			} else { // vertical && m.beforeLeftBottomID() == m.afterRightTop() this rectangle is top left intermediate
-				
+
 				cerr << "bottom left becomes right top, top left intermediate" << endl;
 				// shirnk LB to the top corner (WHICH IS BOTTOM NOW)
 				intHeightLB = intLeftBottomRT.y() - intLeftBottomLB.y();
 				// shrink RT to the right corner
 				intWidthRT = intWidthRT - (intWidthLB - ( intLeftBottomRT.x() - intLeftBottomLB.x() ));
 				intLeftBottomRT.set( intLeftBottomLB.x() + intWidthLB, intLeftBottomRT.y() );
-				
+
 				// set unshrunk heights for next local move
 				totalWidth = intWidthLB + intWidthRT;
 				if(!m.stretchMove()) {
-					
+
 					bboxLB.unshrunkWidth() = totalWidth;
 					bboxRT.unshrunkLeftBottom().x() = intLeftBottomLB.x();
-					bboxRT.unshrunkWidth() = totalWidth;	
-					
+					bboxRT.unshrunkWidth() = totalWidth;
+
 				} else if(m.stretchedID() == m.beforeLeftBottomID()) {
-				
+
 					bboxLB.unshrunkWidth() = totalWidth;
-					
+
 				} else {
-				
+
 					bboxRT.unshrunkLeftBottom().x() = intLeftBottomLB.x();
 					bboxRT.unshrunkWidth() = totalWidth;
-				
+
 				}
-				
+
 			}
-			
+
 			// use update methods to ensure that _inLocalMove will be set
 			itLB->second.updateIntermediateElement( intLeftBottomLB, intWidthLB, intHeightLB );
 			bboxLB.updateIntermediateElement( intLeftBottomLB, intWidthLB, intHeightLB );
@@ -798,7 +905,7 @@
 			bboxRT.updateIntermediateElement( intLeftBottomRT, intWidthRT, intHeightRT );
 		}
 	}
-	
+
 	//
 	//  HierarchicalTreemap::_scaleTreemapCells --	scale polygons at the corresponding levels
 	//
@@ -811,18 +918,18 @@
 	void HierarchicalTreemap::_scaleTreemapCells( unsigned int level, unsigned int i )
 	{
 		Graph::TreeDirectedGraph &graphmlTree   = _metadataPtr->graphmlTree();
-			
+
 			unsigned int id = _sortedLevel[ level ][ i ];
 			Lens::Treemap &treemap = _treemapVec[ id ];
-			
+
 			Graph::TreeDirectedGraph::vertex_descriptor vd = vertex( id, graphmlTree );
 			Graph::TreeDirectedGraph::out_edge_iterator e, e_end;
-			
+
 			for( tie( e, e_end ) = out_edges( vd, graphmlTree ); e != e_end; ++e ) {
-				
+
 				Graph::TreeDirectedGraph::edge_descriptor ed = *e;
 				Graph::TreeDirectedGraph::vertex_descriptor vdT = target( ed, graphmlTree );
-				
+
 				map< unsigned int, KeiRo::Base::Rectangle2 >::iterator itS = treemap.treemapSourceMap().find( graphmlTree[vdT].id );
 				KeiRo::Base::Rectangle2 &source = itS->second;
 				map< unsigned int, KeiRo::Base::Rectangle2 >::iterator itT = treemap.treemapTargetMap().find( graphmlTree[vdT].id );
@@ -830,7 +937,7 @@
 #ifdef HierarchicalTreemap_DEBUG
 				cerr << "index = " << index << ", label = " << itT->first << endl;
 #endif // HierarchicalTreemap_DEBUG
-				
+
 				// normalization
 				double sx = source.leftBottom().x();
 				double sy = source.leftBottom().y();
@@ -840,7 +947,7 @@
 				double ty = target.leftBottom().y();
 				double tw = target.width();
 				double th = target.height();
-				
+
 				double &x = graphmlTree[ vdT ].boundingBoxPtr->leftBottom().x();
 				double &y = graphmlTree[ vdT ].boundingBoxPtr->leftBottom().y();
 #ifdef HierarchicalTreemap_DEBUG
@@ -853,7 +960,7 @@
 				graphmlTree[ vdT ].boundingBoxPtr->height() = th;
 			}
 	}
-	
+
 	//
 	//  HierarchicalTreemap::_updateSubGraphs --	scale polygons at the corresponding levels
 	//
@@ -865,67 +972,126 @@
 	//
 	void HierarchicalTreemap::_updateSubGraphs( unsigned int level, vector<LocalMove>& localmoves )
 	{
-		Graph::TreeDirectedGraph &graphmlTree   = _metadataPtr->graphmlTree();
-		map< unsigned int, Graph::BaseUndirectedGraph > &graphmlGraphMap = _metadataPtr->graphmlGraphMap();
+		Graph::TreeDirectedGraph &graphmlTree = _metadataPtr->graphmlTree();
+		map<unsigned int, Graph::BaseUndirectedGraph> &graphmlGraphMap = _metadataPtr->graphmlGraphMap();
 
-		for( map< unsigned int, Graph::BaseUndirectedGraph >::iterator it = graphmlGraphMap.begin();
-			 it != graphmlGraphMap.end(); it++ ){
-			Graph::TreeDirectedGraph::vertex_descriptor vdP = vertex( it->first , graphmlTree );
-			KeiRo::Base::Rectangle2 &bbox = *graphmlTree[ vdP ].boundingBoxPtr; // this bounding box has already been updated and hence can be used to define new coordinates
-			Graph::BaseUndirectedGraph &subGraph = it->second;
+    for(auto it = graphmlGraphMap.begin(); it != graphmlGraphMap.end(); ++it) {
+        Graph::TreeDirectedGraph::vertex_descriptor vdP = vertex(it->first, graphmlTree);
+        KeiRo::Base::Rectangle2 &bbox = *graphmlTree[vdP].boundingBoxPtr;
+
+        Graph::BaseUndirectedGraph &subGraph = it->second;
 
-			// iterate edges
-			BGL_FORALL_EDGES( ed, subGraph, Graph::BaseUndirectedGraph ) {
-				KeiRo::Base::Edge2 &edge = subGraph[ed].edge;
-				for( unsigned int i = 0; i < edge.elements().size(); i++ ){
-					
-					KeiRo::Base::Coord2 &coord = edge.elements()[i];
-					coord.updateOldElement();
-					coord.x() = ( coord.x() - bbox.oldLeftBottom().x() ) * bbox.width()/bbox.oldWidth() + bbox.leftBottom().x();
-					coord.y() = ( coord.y() - bbox.oldLeftBottom().y() ) * bbox.height()/bbox.oldHeight() + bbox.leftBottom().y();
-					
-					if(bbox.inLocalMove()) {
-					
-						cerr << "Subgraph edge is updated" << endl;
-						
-						double intermediateX = ( coord.oldElement()[0] - bbox.oldLeftBottom().x() ) * bbox.intermediateWidth()/bbox.oldWidth() + bbox.intermediateLeftBottom().x();
-						double intermediateY = ( coord.oldElement()[1] - bbox.oldLeftBottom().y() ) * bbox.intermediateHeight()/bbox.oldHeight() + bbox.intermediateLeftBottom().y();
-						coord.updateIntermediateElement( intermediateX, intermediateY );
-					}
-				}
-			}
-			
-			// iterate vertices
-			BGL_FORALL_VERTICES( vd, subGraph, Graph::TreeDirectedGraph ) {
-
-				subGraph[vd].coordPtr->updateOldElement();
-				subGraph[vd].coordPtr->x() = ( subGraph[vd].coordPtr->x() - bbox.oldLeftBottom().x() ) * bbox.width()/bbox.oldWidth() + bbox.leftBottom().x();
-				subGraph[vd].coordPtr->y() = ( subGraph[vd].coordPtr->y() - bbox.oldLeftBottom().y() ) * bbox.height()/bbox.oldHeight() + bbox.leftBottom().y();
-				
-				if(bbox.inLocalMove()) {
-
-					cerr << "Subgraph vertex is updated" << endl;
-				
-					double intermediateX = ( subGraph[vd].coordPtr->oldElement()[0] - bbox.oldLeftBottom().x() ) * bbox.intermediateWidth()/bbox.oldWidth() + bbox.intermediateLeftBottom().x();
-					double intermediateY = ( subGraph[vd].coordPtr->oldElement()[1] - bbox.oldLeftBottom().y() ) * bbox.intermediateHeight()/bbox.oldHeight() + bbox.intermediateLeftBottom().y();
-					subGraph[vd].coordPtr->updateIntermediateElement( intermediateX, intermediateY );
-				}
-			}
-		}
+        // Initialize subgraph bounding box
+        double minX = std::numeric_limits<double>::max();
+        double minY = std::numeric_limits<double>::max();
+        double maxX = std::numeric_limits<double>::lowest();
+        double maxY = std::numeric_limits<double>::lowest();
+
+        // First pass: Calculate initial bounding box and update coordinates
+        BGL_FORALL_EDGES(ed, subGraph, Graph::BaseUndirectedGraph) {
+            KeiRo::Base::Edge2 &edge = subGraph[ed].edge;
+            for(unsigned int i = 0; i < edge.elements().size(); i++) {
+                KeiRo::Base::Coord2 &coord = edge.elements()[i];
+                coord.updateOldElement();
+                coord.x() = (coord.x() - bbox.oldLeftBottom().x()) * bbox.width() / bbox.oldWidth() + bbox.leftBottom().x();
+                coord.y() = (coord.y() - bbox.oldLeftBottom().y()) * bbox.height() / bbox.oldHeight() + bbox.leftBottom().y();
+
+                if(bbox.inLocalMove()) {
+                    double intermediateX = (coord.oldElement()[0] - bbox.oldLeftBottom().x()) * bbox.intermediateWidth() / bbox.oldWidth() + bbox.intermediateLeftBottom().x();
+                    double intermediateY = (coord.oldElement()[1] - bbox.oldLeftBottom().y()) * bbox.intermediateHeight() / bbox.oldHeight() + bbox.intermediateLeftBottom().y();
+                    coord.updateIntermediateElement(intermediateX, intermediateY);
+                }
+
+                minX = std::min(minX, coord.x());
+                minY = std::min(minY, coord.y());
+                maxX = std::max(maxX, coord.x());
+                maxY = std::max(maxY, coord.y());
+            }
+        }
+
+        BGL_FORALL_VERTICES(vd, subGraph, Graph::TreeDirectedGraph) {
+            subGraph[vd].coordPtr->updateOldElement();
+            subGraph[vd].coordPtr->x() = (subGraph[vd].coordPtr->x() - bbox.oldLeftBottom().x()) * bbox.width() / bbox.oldWidth() + bbox.leftBottom().x();
+            subGraph[vd].coordPtr->y() = (subGraph[vd].coordPtr->y() - bbox.oldLeftBottom().y()) * bbox.height() / bbox.oldHeight() + bbox.leftBottom().y();
+
+            if(bbox.inLocalMove()) {
+                double intermediateX = (subGraph[vd].coordPtr->oldElement()[0] - bbox.oldLeftBottom().x()) * bbox.intermediateWidth() / bbox.oldWidth() + bbox.intermediateLeftBottom().x();
+                double intermediateY = (subGraph[vd].coordPtr->oldElement()[1] - bbox.oldLeftBottom().y()) * bbox.intermediateHeight() / bbox.oldHeight() + bbox.intermediateLeftBottom().y();
+                subGraph[vd].coordPtr->updateIntermediateElement(intermediateX, intermediateY);
+            }
+
+            minX = std::min(minX, subGraph[vd].coordPtr->x());
+            minY = std::min(minY, subGraph[vd].coordPtr->y());
+            maxX = std::max(maxX, subGraph[vd].coordPtr->x());
+            maxY = std::max(maxY, subGraph[vd].coordPtr->y());
+        }
+
+        // Create initial subgraph bounding box
+        double initialWidth = maxX - minX;
+        double initialHeight = maxY - minY;
+        KeiRo::Base::Rectangle2 subgraphBBox(minX, minY, initialWidth, initialHeight);
+
+        // Calculate the available space
+        double availableWidth = bbox.width();
+        double availableHeight = bbox.height();
+
+        // Define what "enough space" means
+        const double MIN_OCCUPATION_RATIO = 0.8;
+        double widthRatio = initialWidth / availableWidth;
+        double heightRatio = initialHeight / availableHeight;
+
+        // Determine if scaling is needed
+        bool needsScaling = (widthRatio < MIN_OCCUPATION_RATIO) && (heightRatio < MIN_OCCUPATION_RATIO);
+
+        if (needsScaling) {
+            double scaleFactor = std::min(availableWidth * MIN_OCCUPATION_RATIO / initialWidth,
+                                          availableHeight * MIN_OCCUPATION_RATIO / initialHeight);
+
+            // Apply scaling to subgraph bounding box
+            double newWidth = initialWidth * scaleFactor;
+            double newHeight = initialHeight * scaleFactor;
+
+            // Adjust position to keep center fixed
+            double centerX = subgraphBBox.leftBottom().x() + subgraphBBox.width() / 2;
+            double centerY = subgraphBBox.leftBottom().y() + subgraphBBox.height() / 2;
+            double newMinX = centerX - newWidth / 2;
+            double newMinY = centerY - newHeight / 2;
+
+            subgraphBBox = KeiRo::Base::Rectangle2(newMinX, newMinY, newWidth, newHeight);
+
+            // Second pass: Apply scaling to edges and vertices
+            BGL_FORALL_EDGES(ed, subGraph, Graph::BaseUndirectedGraph) {
+                KeiRo::Base::Edge2 &edge = subGraph[ed].edge;
+                for(unsigned int i = 0; i < edge.elements().size(); i++) {
+                    KeiRo::Base::Coord2 &coord = edge.elements()[i];
+                    coord.x() = (coord.x() - minX) * scaleFactor + newMinX;
+                    coord.y() = (coord.y() - minY) * scaleFactor + newMinY;
+                }
+            }
+
+            BGL_FORALL_VERTICES(vd, subGraph, Graph::TreeDirectedGraph) {
+                subGraph[vd].coordPtr->x() = (subGraph[vd].coordPtr->x() - minX) * scaleFactor + newMinX;
+                subGraph[vd].coordPtr->y() = (subGraph[vd].coordPtr->y() - minY) * scaleFactor + newMinY;
+            }
+        }
+
+
+
+    }
 	}
-	
-	
+
+
 	void HierarchicalTreemap::_assignTreemapSizeAbsolute( void )
 	{
 		Graph::TreeDirectedGraph    &graphmlTree    = _metadataPtr->graphmlTree();
 
 		double increaseAreaSum = 0.0;
 		double increaseRatio = 0.5;
-		
+
 		// update selected polygons
 		for( map< unsigned int, unsigned int >::iterator it = _selectSceneItemMapPtr->begin();
 			 it != _selectSceneItemMapPtr->end(); it++ ){
-		
+
 			unsigned int id = it->second;
 //    		unsigned int level = 0;//std::get<0>( it->second );
 //		    unsigned int member = 0;//std::get<1>( it->second );
@@ -934,7 +1100,7 @@
 		    Graph::TreeDirectedGraph::vertex_descriptor vd = vertex( id, graphmlTree );
 		    unsigned int idP = graphmlTree[ vd ].parentID;
 //		    map< unsigned int, unsigned int > &childMap = graphmlTree[ vd ].childMap;
-		    
+
 		    map< unsigned int, pair< double, double > > &treemapFixedSizeMap = _treemapVec[ idP ].treemapFixedSizeMap();
 		    map< unsigned int, pair< double, double > > &treemapSizeMap = _treemapVec[ idP ].treemapSizeMap();
 		    map< unsigned int, pair< double, double > >::iterator itF = treemapFixedSizeMap.find( id );
@@ -947,7 +1113,7 @@
 
 		    // bottom up
 		    while( true ){
-		
+
 //			    unsigned int parentFileID1 = svgPtrVec[ id ]->polygonVec()[ polygonMember ].parentFileID().first;
 //			    unsigned int parentFileID2 = svgPtrVec[ id ]->polygonVec()[ polygonMember ].parentFileID().second;
 //			    unsigned int parentPolygonID = svgPtrVec[ id ]->polygonVec()[ polygonMember ].parentPolygonID();
@@ -956,7 +1122,7 @@
 			    map< unsigned int, pair< double, double > > &parentTreemapSizeMap = _treemapVec[ idP ].treemapSizeMap();
 			    map< unsigned int, pair< double, double > >::iterator itP = parentTreemapSizeMap.find( id );
 			    itP->second.second += increaseNewArea;
-				
+
 #ifdef HierarchicalTreemap_DEBUG
 				cerr << "id = " << id << ", pid = " << parentID << endl;
 			    cerr << " _treemapTree[ _treemapRoot ].id = " <<  _treemapTree[ _treemapRoot ].id
@@ -998,7 +1164,7 @@
 	        }
         }
     }
-    
+
 	void HierarchicalTreemap::_assignTreemapSizeExact( void )
 	{
 		double ww = KeiRo::Base::Common::getMainwidgetWidth();
@@ -1009,8 +1175,8 @@
 //		Graph::TreeDirectedGraph svgTree        = _metadataPtr->svgTree();
 		double increaseAreaSum = 0.0;
 		double increaseRatio = 0.4;
-		
-		// printGraph( graphmlTree );
+
+		 //printGraph( graphmlTree );
 		// reset area
 		for( map< unsigned int, unsigned int >::iterator it = _selectSceneItemMapPtr->begin();
 		     it != _selectSceneItemMapPtr->end(); it++ ) {
@@ -1024,7 +1190,7 @@
 			unsigned int level = graphmlTree[ vd ].level;
 			unsigned int idP = graphmlTree[ vd ].parentID;
 			Graph::TreeDirectedGraph::vertex_descriptor vdP = vertex( idP, graphmlTree );
-			
+
 			map< unsigned int, pair< double, double > > &treemapFixedSizeMap = _treemapVec[ idP ].treemapFixedSizeMap();
 			map< unsigned int, pair< double, double > > &treemapSizeMap = _treemapVec[ idP ].treemapSizeMap();
 			map< unsigned int, pair< double, double > >::iterator itF = treemapFixedSizeMap.find( id );
@@ -1036,7 +1202,7 @@
 					itF->second.first;
 			increaseAreaSum += increaseNewArea;
 			itS->second.second = itF->second.first + increaseNewArea;
-			
+
 			double decreaseArea = increaseNewArea / ( double ) ( treemapSizeMap.size() - 1 );
 			for( map< unsigned int, pair< double, double > >::iterator it = treemapSizeMap.begin();
 			     it != treemapSizeMap.end(); it++ ) {
@@ -1055,16 +1221,16 @@
 			}
 			cerr << endl;
 #endif // HierarchicalTreemap_DEBUG
-			
+
 			// normalization
 			for( unsigned int i = level + 1; i < _sortedLevel.size(); i++ ) {
 				for( unsigned int j = 0; j < _sortedLevel[ i ].size(); j++ ) {
-					
+
 					unsigned int idSibling = _sortedLevel[ i ][ j ];
-					
+
 					Graph::TreeDirectedGraph::vertex_descriptor vdS = vertex( idSibling, graphmlTree );
 //					vector< KeiRo::Base::Polygon2 > &polygonVec = svgPtrVec[ idSibling ]->polygonVec();
-					
+
 					if( graphmlTree[ vdS ].size > 0 ) {
 //
 //						unsigned int parentFileID1 = polygonVec[ 0 ].parentFileID().first;
@@ -1073,15 +1239,15 @@
 //
 //						cerr << "parentFileID1 = " << parentFileID1 << " , parentFileID2 = " << parentFileID2
 //						     << ", parentPolygonID = " << parentPolygonID << endl;
-						
+
 						unsigned int idP = graphmlTree[ vdS ].parentID;
 						map< unsigned int, pair< double, double > > &parentTreemapFixedSizeMap = _treemapVec[ idP ].treemapFixedSizeMap();
 						map< unsigned int, pair< double, double > > &parentTreemapSizeMap = _treemapVec[ idP ].treemapSizeMap();
-						
-						cerr << "idP = " << idP << endl;
-						cerr << "idSibling = " << idSibling << endl;
-						cerr << "parentTreemapFixedSizeMap.size() = " << parentTreemapFixedSizeMap.size() << endl;
-						cerr << "parentTreemapSizeMap.size() = " << parentTreemapSizeMap.size() << endl;
+
+						// cerr << "idP = " << idP << endl;
+						// cerr << "idSibling = " << idSibling << endl;
+						// cerr << "parentTreemapFixedSizeMap.size() = " << parentTreemapFixedSizeMap.size() << endl;
+						// cerr << "parentTreemapSizeMap.size() = " << parentTreemapSizeMap.size() << endl;
 						map< unsigned int, pair< double, double > >::iterator itF = parentTreemapFixedSizeMap.find( idSibling );
 						map< unsigned int, pair< double, double > >::iterator itP = parentTreemapSizeMap.find( idSibling );
 //						std::advance( itF, parentPolygonID );
@@ -1089,7 +1255,7 @@
 						double fixSize = itF->second.second;
 						double size = itP->second.second;
 						double scale = size / fixSize;
-						
+
 						map< unsigned int, pair< double, double > > &siblingTreemapSizeMap = _treemapVec[ idSibling ].treemapSizeMap();
 						for( unsigned int k = 0; k < siblingTreemapSizeMap.size(); k++ ) {
 							map< unsigned int, pair< double, double > >::iterator itN = siblingTreemapSizeMap.begin();
@@ -1101,7 +1267,7 @@
 			}
 		}
     }
-    
+
 	double HierarchicalTreemap::maxIncreaseRatio( double minSize )
 	{
 		vector< double > originalSizeVec( _treemapVec.size() );
@@ -1109,7 +1275,7 @@
 		vector< bool > alreadySelectedVec( _treemapVec.size() );
 
 		Graph::TreeDirectedGraph    &graphmlTree    = _metadataPtr->graphmlTree();
-		
+
 		// initialization
         for( unsigned int i = 0; i < _treemapVec.size(); i++ ){
             Graph::TreeDirectedGraph::vertex_descriptor vd = vertex( i, graphmlTree );
@@ -1162,22 +1328,22 @@
 #ifdef HierarchicalTreemap_DEBUG
 		cerr << "Total is " << total << endl;
 #endif // HierarchicalTreemap_DEBUG
-		
+
 		// find ratio of selected objects, set ratio of non-selected objects to minimum
 		double maxRatio = 1.0;
 		BGL_FORALL_VERTICES( vd, graphmlTree, Graph::TreeDirectedGraph ) {
-			
+
 			Graph::TreeDirectedGraph::degree_size_type degrees = out_degree( vd, graphmlTree );
 
 			// lead node
 			if( degrees == 0 ) {
-				
+
 				Graph::TreeDirectedGraph::vertex_descriptor searchVD = vd;
 				bool foundSelected = false;
 				unsigned int id = 0;
 				unsigned int pID = 0;
 				do {
-					
+
 					id = graphmlTree[ searchVD ].id;
 					pID = graphmlTree[ searchVD ].parentID;
 					if( isSelectedVec[ id ] ) {
@@ -1186,9 +1352,9 @@
 					else {
 						searchVD = vertex( pID, graphmlTree );
 					}
-					
+
 				} while( !foundSelected && pID != graphmlTree[ searchVD ].parentID );
-				
+
 				if( foundSelected && !alreadySelectedVec[ id ] ) {
 #ifdef HierarchicalTreemap_DEBUG
 					cerr << "Found = " << id << " with size " << originalSizeVec[id] << " divided by " << total << " = " << (originalSizeVec[id] / total) << endl;
@@ -1218,7 +1384,7 @@
                 vector< bool > isSelectedVec( _treemapVec.size() );
 		vector< bool > isSiblingVec( _treemapVec.size() );
                 vector< bool > alreadySelectedVec( _treemapVec.size() );
-		
+
 		Graph::TreeDirectedGraph    &graphmlTree    = _metadataPtr->graphmlTree();
 
         // initialization
@@ -1249,17 +1415,17 @@
 //            map< unsigned int, unsigned int >::iterator itC = childMap.begin();
 //            std::advance( itC, polygonMember );
 //            unsigned int id = itC->second;
-                        
+
 			isSelectedVec[id] = true;
 			isSiblingVec[id] = false; // selected objects are never seen as siblings
-			
+
 			Graph::TreeDirectedGraph::out_edge_iterator e, e_end;
 			for( tie( e, e_end ) = out_edges( vdP, graphmlTree ); e != e_end; ++e ) {
-				
+
 				Graph::TreeDirectedGraph::edge_descriptor ed = *e;
 				Graph::TreeDirectedGraph::vertex_descriptor vdT = target( ed, graphmlTree );
 				unsigned int idT = graphmlTree[ vdT ].id;
-				
+
 //				for( itC = childMap.begin(); itC != childMap.end(); itC++ ) {
 //				id = itC->second;
 #ifdef HierarchicalTreemap_DEBUG
@@ -1284,13 +1450,13 @@
             }
         }
 
-		
+
 		// find ratio of selected objects and filter siblings
 		// set ratio of remaining objects to minimum
         double maxRatio = 1.0;
 
         BGL_FORALL_VERTICES( vd, graphmlTree, Graph::TreeDirectedGraph ) {
-			
+
 	        Graph::TreeDirectedGraph::degree_size_type degrees = out_degree( vd, graphmlTree );
 	        if( degrees == 0 ) {
 		        Graph::TreeDirectedGraph::vertex_descriptor searchVD = vd;
@@ -1303,7 +1469,7 @@
 		        do {
 			        id = graphmlTree[ searchVD ].id;
 			        pID = graphmlTree[ searchVD ].parentID;
-			
+
 			        if( isSelectedVec[ id ] ) { // assumes only one selected on every path from leaf to root
 				        selected = id;
 			        }
@@ -1315,12 +1481,12 @@
 			        else if( isSiblingVec[ id ] ) {
 				        foundSibling = true;
 			        }
-			
+
 			        searchVD = vertex( pID, graphmlTree );
-			
+
 		        } while( pID != id );
-		
-		
+
+
 		        if( selected != -1 && !alreadySelectedVec[ selected ] ) {
 			        // ratio of selected objects
 #ifdef DEBUG
@@ -1357,14 +1523,14 @@
 		if( maxRatio > 1.0) {
 			maxRatio = 1.0;
 		}
-		
+
 		return maxRatio;
 	}
 
 	double HierarchicalTreemap::maxMinSize( void )
 	{
 		Graph::TreeDirectedGraph    &graphmlTree    = _metadataPtr->graphmlTree();
-		
+
 		// find total size
         double total = 0.0;
         BGL_FORALL_VERTICES( vd, graphmlTree, Graph::TreeDirectedGraph ) {
@@ -1373,7 +1539,7 @@
                         total = _treemapVec[ id ].boundingBoxPtr()->width() * _treemapVec[ id ].boundingBoxPtr()->height();
                 }
         }
-		
+
         // find ratio of selected objects and filter siblings
         // set ratio of remaining objects to minimum
         double maxMinRatio = 1.0;
@@ -1391,8 +1557,8 @@
 		        }
 	        }
         }
-		
-//		cerr << "maxMinSize = " << maxMinRatio << endl;		
+
+//		cerr << "maxMinSize = " << maxMinRatio << endl;
 		return maxMinRatio;
 	}
 
@@ -1400,14 +1566,14 @@
 	{
 		double ww = KeiRo::Base::Common::getMainwidgetWidth();
 		double wh = KeiRo::Base::Common::getMainwidgetHeight();
-		
+
 		Graph::TreeDirectedGraph    &graphmlTree    = _metadataPtr->graphmlTree();
 //		vector< FileIO::SVG* > &svgPtrVec       = _metadataPtr->svgPtrVec();
 //		Graph::TreeDirectedGraph svgTree        = _metadataPtr->svgTree();
 		double increaseRatio = 0.8;
 		vector< double > originalSizeVec( _treemapVec.size() );
 		vector< bool > isSelectedVec( _treemapVec.size() );
-		
+
 		// initialization
 		for( unsigned int i = 0; i < _treemapVec.size(); i++ ){
 			Graph::TreeDirectedGraph::vertex_descriptor vd = vertex( i, graphmlTree );
@@ -1415,11 +1581,11 @@
 			graphmlTree[vd].size = 0.0;
 			isSelectedVec[ i ] = false;
 		}
-		
+
 		// mark the selected objects
 		for( map< unsigned int, unsigned int >::iterator it = _selectSceneItemMapPtr->begin();
 		     it != _selectSceneItemMapPtr->end(); it++ ){
-			
+
 //			unsigned int level = 0;//std::get<0>( it->second );
 //			unsigned int member = 0;//std::get<1>( it->second );
 //			unsigned int polygonMember = 0;//std::get<2>( it->second );
@@ -1431,13 +1597,13 @@
 			Graph::TreeDirectedGraph::vertex_descriptor vdP = vertex( idP, graphmlTree );
 //			map< unsigned int, unsigned int > &childMap = graphmlTree[ vdP ].childMap;
 //			map< unsigned int, unsigned int >::iterator itC = childMap.begin();
-			
+
 #ifdef HierarchicalTreemap_DEBUG
 			cerr << "idP = " << idP << endl;
 			cerr << "level = " << level << ", member = " << member << ", polygonMember = " << polygonMember << endl;
 			cerr << "child.size() = " << childMap.size() << endl;
 #endif // HierarchicalTreemap_DEBUG
-			
+
 //			std::advance( itC, polygonMember );
 //			unsigned int id = itC->second;
 			isSelectedVec[id] = true;
@@ -1453,7 +1619,7 @@
 				     << ", size = " << graphmlTree[vd].size << endl;
 			}
 #endif // HierarchicalTreemap_DEBUG
-		
+
 		// propogate size changes
 		for( unsigned int i = 0; i < _sortedLevel.size(); i++ ){
 			for( unsigned int j = 0; j < _sortedLevel[i].size(); j++ ) {
@@ -1467,14 +1633,14 @@
 						 << ", childSize = " << childMap.size() << endl;
 #endif // HierarchicalTreemap_DEBUG
 					double scale = graphmlTree[vd].size / originalSizeVec[id];
-					
+
 					Graph::TreeDirectedGraph::out_edge_iterator e, e_end;
 					for( tie( e, e_end ) = out_edges( vd, graphmlTree ); e != e_end; ++e ) {
-						
+
 						Graph::TreeDirectedGraph::edge_descriptor ed = *e;
 						Graph::TreeDirectedGraph::vertex_descriptor vdT = target( ed, graphmlTree );
 						unsigned int idT = graphmlTree[ vdT ].id;
-						
+
 //						for( unsigned int k = 0; k < childMap.size(); k++ ){
 //						map< unsigned int, unsigned int >::iterator it = childMap.begin();
 //						std::advance( it, k );
@@ -1492,19 +1658,19 @@
 				 << ", size = " << graphmlTree[vd].size << endl;
 		}
 #endif // HierarchicalTreemap_DEBUG
-		
+
 		// compute shrinking factor
 		double coefficient = 0.0;
 		double knownArea = 0.0;
 		double shrinkFactor = 0.0;
 		BGL_FORALL_VERTICES( vd, graphmlTree, Graph::TreeDirectedGraph ) {
-			
+
 			unsigned int id = graphmlTree[ vd ].id;
 			// add total area of leaves
 			Graph::TreeDirectedGraph::degree_size_type degrees = out_degree( vd, graphmlTree );
 			if ( degrees == 0 ){
 //			if ( graphmlTree[ vd ].childMap.size() == 0 ){
-				
+
 				cerr << " leafID = " << id << endl;
 				if( graphmlTree[ vd ].size == 0 ){
 					coefficient += originalSizeVec[ id ];
@@ -1520,7 +1686,7 @@
 		cerr << "coefficient = " << coefficient << endl;
 		cerr << "knownArea = " << knownArea << endl;
 		cerr << "shrinkFactor = " << shrinkFactor << endl;
-		
+
 		// update size
 		// assign unknown leaf size
 		for( unsigned int i = _sortedLevel.size()-1; i < _sortedLevel.size(); i++ ){
@@ -1530,11 +1696,11 @@
 				if( graphmlTree[ vd ].size == 0 )
 					graphmlTree[ vd ].size = shrinkFactor * originalSizeVec[id];
 				else{
-				
+
 				}
 			}
 		}
-		
+
 #ifdef HierarchicalTreemap_DEBUG
 		double total = 0.0;
 		BGL_FORALL_VERTICES( vd, _treemapTree, Graph::TreeDirectedGraph ) {
@@ -1549,21 +1715,21 @@
 				}
 			}
 		cerr << "total = " << total << endl;
-		
+
 #endif // HierarchicalTreemap_DEBUG
-		
+
 		for( int i = _sortedLevel.size()-2; i >= 0; i-- ) {
 			for( unsigned int j = 0; j < _sortedLevel[ i ].size(); j++ ) {
 				unsigned int id = _sortedLevel[ i ][ j ];
 				Graph::TreeDirectedGraph::vertex_descriptor vd = vertex( id, graphmlTree );
 				graphmlTree[ vd ].size = 0;
-				
+
 				Graph::TreeDirectedGraph::out_edge_iterator e, e_end;
 				for( tie( e, e_end ) = out_edges( vd, graphmlTree ); e != e_end; ++e ) {
-					
+
 					Graph::TreeDirectedGraph::edge_descriptor ed = *e;
 					Graph::TreeDirectedGraph::vertex_descriptor vdT = target( ed, graphmlTree );
-					
+
 //				map< unsigned int, unsigned int > &childMap = graphmlTree[ vd ].childMap;
 //				for( unsigned int k = 0; k < childMap.size(); k++ ) {
 //					map< unsigned int, unsigned int >::iterator it = childMap.begin();
@@ -1608,7 +1774,7 @@
 				}
 			}
 		}
-		
+
 #ifdef HierarchicalTreemap_DEBUG
 		for( unsigned int i = 0; i < _sortedLevel.size()-1; i++ ) {
 			for( unsigned int j = 0; j < _sortedLevel[ i ].size(); j++ ) {
@@ -1618,7 +1784,7 @@
 				map< string, pair< double, double > > &treemapSizeMap = _treemapVec[ id ].treemapSizeMap();
 				Graph::TreeDirectedGraph::vertex_descriptor vd = vertex( id, _treemapTree );
 				map< unsigned int, unsigned int > &childMap = _treemapTree[ vd ].childMap;
-				
+
 				for( unsigned int k = 0; k < treemapSizeMap.size(); k++ ){
 					map< string, pair< double, double > >::iterator it = treemapSizeMap.begin();
 					std::advance( it, k );
@@ -1645,14 +1811,14 @@
 			cerr << "minSize too high" << endl;
 			return;
 		}
-		
+
 		double ww = KeiRo::Base::Common::getMainwidgetWidth();
 		double wh = KeiRo::Base::Common::getMainwidgetHeight();
 		Graph::TreeDirectedGraph    &graphmlTree    = _metadataPtr->graphmlTree();
-		
+
 		vector< double > originalSizeVec( _treemapVec.size() );
 		vector< bool > isSelectedVec( _treemapVec.size() );
-		
+
 		// initialization
 		for( unsigned int i = 0; i < _treemapVec.size(); i++ ){
 			Graph::TreeDirectedGraph::vertex_descriptor vd = vertex( i, graphmlTree );
@@ -1660,33 +1826,52 @@
 			graphmlTree[ vd ].size = 0.0;
 			isSelectedVec[ i ] = false;
 		}
-		
+
 		// find total size
         double total = 0.0;
         BGL_FORALL_VERTICES( vd, graphmlTree, Graph::TreeDirectedGraph ) {
             unsigned int id = graphmlTree[vd].id;
 			total = _treemapVec[ id ].boundingBoxPtr()->width() * _treemapVec[ id ].boundingBoxPtr()->height();
         }
-		
+
 		// mark the selected objects and siblings
 		for( map< unsigned int, unsigned int >::iterator it = _selectSceneItemMapPtr->begin();
 		     it != _selectSceneItemMapPtr->end(); it++ ){
 
 			unsigned int id = it->second;
 			Graph::TreeDirectedGraph::vertex_descriptor vd = vertex( id, graphmlTree );
+
 			unsigned int level = graphmlTree[ vd ].level;
+			cerr << id << " scalable "<< graphmlTree[ vd ].scalable;
 			graphmlTree[ vd ].isSelected = true;
 
 			unsigned int idP = graphmlTree[ vd ].parentID;
 			Graph::TreeDirectedGraph::vertex_descriptor vdP = vertex( idP, graphmlTree );
-			
+
 #ifdef HierarchicalTreemap_DEBUG
 			cerr << "idP = " << idP << endl;
 #endif // HierarchicalTreemap_DEBUG
-			
+
 			// set size of selected object using increaseRatio
 			isSelectedVec[ id ] = true;
-			graphmlTree[ vd ].size = originalSizeVec[id] + (originalSizeVec[0] * increaseRatio);
+			// if (graphmlTree[ vd ].scale==false) {
+			// 	graphmlTree[ vd ].isSelected = false;
+			// 	isSelectedVec[ id ] = false;
+			// 	cerr <<"here the bug"<<endl;
+			// }
+			if (graphmlTree[ vd ].isSelected ) {
+				 if(!graphmlTree[ vd ].scalable ) {
+					graphmlTree[ vd ].size = originalSizeVec[id];
+					graphmlTree[ vd ].isSelected = false;
+					isSelectedVec[ id ] = false;
+					cerr <<"here the bug"<<endl;
+				}
+				else  {
+
+					graphmlTree[ vd ].size = originalSizeVec[id] + (originalSizeVec[0] * increaseRatio);
+				}
+
+			}
 
 			// set size of siblings using siblingRatio
 			double siblingSize;
@@ -1698,14 +1883,17 @@
 				unsigned int idT = graphmlTree[ vdT ].id;
 
 				if( ( graphmlTree[vdT].size == 0 ) && ( level != 0 ) && ( id != idT ) ) {
-					siblingSize = originalSizeVec[ idT ] * siblingRatio;
-					if( siblingSize >= minSize * total ) {
-						graphmlTree[ vdT ].size = siblingSize;
-					} else {
-						graphmlTree[ vdT ].size = minSize * total;
-					}
+
+						siblingSize = originalSizeVec[ idT ] * siblingRatio;
+						if( siblingSize >= minSize * total ) {
+							graphmlTree[ vdT ].size = siblingSize;
+						} else {
+							graphmlTree[ vdT ].size = minSize * total;
+						}
+
 				}
             }
+
 		}
 #ifdef HierarchicalTreemap_DEBUG
 		for( unsigned int i = 0; i < originalSizeVec.size(); i++ ){
@@ -1732,7 +1920,7 @@
 			do {
 				id = graphmlTree[ searchVD ].id;
 				idP = graphmlTree[ searchVD ].parentID;
-				
+
 				if( isSelectedVec[ id ] ) {
 					selected = id;
 				}
@@ -1742,16 +1930,16 @@
 					// by our assumption we do not reset a selected node!
 					graphmlTree[ searchVD ].size = 0;
 				}
-				
+
 				searchVD = vertex( idP, graphmlTree );
-				
+
 			} while( idP != id );
 		}
-		
+
 		// propogate size changes
 		for( unsigned int i = 0; i < _sortedLevel.size(); i++ ){
 			for( unsigned int j = 0; j < _sortedLevel[i].size(); j++ ) {
-				
+
 				unsigned int id = _sortedLevel[i][j];
 				Graph::TreeDirectedGraph::vertex_descriptor vd = vertex( id, graphmlTree );
 
@@ -1762,7 +1950,7 @@
 #endif // HierarchicalTreemap_DEBUG
 					// propagate to leaves
 					double scale = graphmlTree[vd].size / originalSizeVec[id];
-					
+
 					Graph::TreeDirectedGraph::out_edge_iterator e, e_end;
 					for( tie( e, e_end ) = out_edges( vd, graphmlTree ); e != e_end; ++e ) {
 						Graph::TreeDirectedGraph::edge_descriptor ed = *e;
@@ -1794,7 +1982,7 @@
 
 		bool setMinSize = true;
 		while( setMinSize ) {
-			
+
 			cerr << "Is this an endless loop?" << endl;
 			coefficient = 0.0;
 			knownArea = 0.0;
@@ -1808,7 +1996,7 @@
 				// add total area of leaves
 				Graph::TreeDirectedGraph::degree_size_type degrees = out_degree( vd, graphmlTree );
 				if ( degrees == 0 ){
-					
+
 					cerr << " leafID = " << id << endl;
 					if( graphmlTree[vd].size == 0 ){
 						coefficient += originalSizeVec[ id ];
@@ -1825,7 +2013,7 @@
 			cerr << "coefficient = " << coefficient << endl;
 			cerr << "knownArea = " << knownArea << endl;
 			cerr << "shrinkFactor = " << shrinkFactor << endl;
-			
+
 			// update size
             // assign unknown leaf size
             for( unsigned int i = _sortedLevel.size()-1; i < _sortedLevel.size(); i++ ) {
@@ -1869,22 +2057,22 @@
 				}
 			}
 		cerr << "total = " << total << endl;
-		
+
 #endif // HierarchicalTreemap_DEBUG
-		
+
 		// propagate child size upwards to get consistent sizes
 		for( int i = _sortedLevel.size()-2; i >= 0; i-- ) {
 			for( unsigned int j = 0; j < _sortedLevel[ i ].size(); j++ ) {
 				unsigned int id = _sortedLevel[ i ][ j ];
 				Graph::TreeDirectedGraph::vertex_descriptor vd = vertex( id, graphmlTree );
 				graphmlTree[ vd ].size = 0;
-				
+
 				Graph::TreeDirectedGraph::out_edge_iterator e, e_end;
 				for( tie( e, e_end ) = out_edges( vd, graphmlTree ); e != e_end; ++e ) {
-					
+
 					Graph::TreeDirectedGraph::edge_descriptor ed = *e;
 					Graph::TreeDirectedGraph::vertex_descriptor vdT = target( ed, graphmlTree );
-					
+
 					graphmlTree[ vd ].size += graphmlTree[ vdT ].size;
 				}
 			}
@@ -1901,10 +2089,10 @@
 				}
 			}
 #endif // HierarchicalTreemap_DEBUG
-		
+
 		// set up treemapSizeMap data structure
 		for( unsigned int i = 0; i < _treemapVec.size(); i++ ){
-			
+
 			map< unsigned int, pair< double, double > > &treemapSizeMap = _treemapVec[ i ].treemapSizeMap();
 			for( map< unsigned int, pair< double, double > >::iterator it = treemapSizeMap.begin();
 				 it != treemapSizeMap.end(); it++ ){
@@ -1923,7 +2111,7 @@
 				map< string, pair< double, double > > &treemapSizeMap = _treemapVec[ id ].treemapSizeMap();
 				Graph::TreeDirectedGraph::vertex_descriptor vd = vertex( id, _treemapTree );
 				map< unsigned int, unsigned int > &childMap = _treemapTree[ vd ].childMap;
-				
+
 				for( unsigned int k = 0; k < treemapSizeMap.size(); k++ ){
 					map< string, pair< double, double > >::iterator it = treemapSizeMap.begin();
 					std::advance( it, k );
@@ -1952,16 +2140,16 @@
 				}
 			}
 		}
-		
+
 	}
 
 	void HierarchicalTreemap::assignTreemapSize( ASSIGNMENTTYPE type = ABSOLUTE_TYPE )
 	{
     	_sizeAssignmentType = type;
     	_resetTreemapSize();
-		
+
 		if( _selectSceneItemMapPtr->size() == 0 ) return;
-		
+
 //		cerr << "tuple size = " << _selectSceneItemMapPtr->size() << endl;
 		switch( type ) {
 		case ABSOLUTE_TYPE:
@@ -1978,12 +2166,14 @@
 			cerr << "siblingRatio is " << *_siblingRatioPtr << endl;
 			cerr << "minSize is" << *_minSizePtr << endl;
 			_assignTreemapSizeParameterized(*_increaseRatioPtr, *_siblingRatioPtr, *_minSizePtr);
+
 			break;
 		default:
 			break;
 		}
+
 	}
-	
+
 	//------------------------------------------------------------------------------
     //	Friend functions
     //------------------------------------------------------------------------------
Index: ResponsiveLens/ui/TreemapGraphicsView.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// TreemapGraphicsView.cpp\r\n//\t: program file for graphics view\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Tue Jun 19 02:36:37 2019\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n#include \"TreemapGraphicsView.h\"\r\n#include <QGraphicsOpacityEffect>\r\n#include <QSequentialAnimationGroup>\r\n#include <QPropertyAnimation>\r\n#include <QParallelAnimationGroup>\r\n\r\nQSet<QGraphicsItem*> _itemsBeingAnimated;\r\n\r\nunsigned int selectedPathId = -1;\r\nunsigned int _oldSelectedPathId = -1;\r\nunsigned int oldRectId1 = -1;\r\nunsigned int oldRectId2 = -1;\r\n\r\n#define short\r\n#define ANIMATE_DURATION ( 1000 )\r\n#include <QDateTime>\r\n//#define ACTIVATE_TIMER\r\n\r\n\t\t//------------------------------------------------------------------------------\r\n\t\t//\tPrivate functions\r\n\t\t//------------------------------------------------------------------------------\r\n\t\t//\r\n\t\t//  TreemapGraphicsView::_init -- initialize data\r\n\t\t//\r\n\t\t//  Inputs\r\n\t\t//  none\r\n\t\t//\r\n\t\t//  Outputs\r\n\t\t//  none\r\n\t\t//\r\n\t\tvoid TreemapGraphicsView::_init( void )\r\n\t\t{\r\n\t\t\tif( lensSettings->filePath().isEmpty() ) return;\r\n\t\t\t_readInputData();\r\n\r\n\t\t\t_isInitialized = false;\r\n\t\t\t_isCreated = false;\r\n\r\n\t\t\t// setting initialization\r\n\t\t\tlensSettings->resetFonts( _metadataPtr->maxLevel() );\r\n\t\t}\r\n\r\n\t\t//\r\n\t\t//  TreemapGraphicsView::_clear -- clear data\r\n\t\t//\r\n\t\t//  Inputs\r\n\t\t//  none\r\n\t\t//\r\n\t\t//  Outputs\r\n\t\t//  none\r\n\t\t//\r\n\t\tvoid TreemapGraphicsView::_clear( void )\r\n\t\t{\r\n\t\t\t_selectSceneItemMap.clear();\r\n\t\t}\r\n\r\n\t\t//------------------------------------------------------------------------------\r\n\t\t//\tProtected functions\r\n\t\t//------------------------------------------------------------------------------\r\n\t\t//\r\n\t\t//  TreemapGraphicsView::_initSeed -- init voronoi seeds\r\n\t\t//\r\n\t\t//  Inputs\r\n\t\t//  none\r\n\t\t//\r\n\t\t//  Outputs\r\n\t\t//  none\r\n\t\t//\r\n\t\tvoid TreemapGraphicsView::_initSeed( void ) {\r\n\r\n\t\t\tvector< FileIO::SVG* > &svgPtrVec = _metadataPtr->svgPtrVec();\r\n\t\t\t_seedVec.clear();\r\n\r\n\t\t\tfor( unsigned int m = 0; m < 1; m++ ) {\r\n//\t\t\tfor( unsigned int m = 0; m < _svgPtr.size(); m++ ) {\r\n#ifdef GRAPHICSVIEW_DEBUG\r\n\t\t\t\tcerr << \"name = \" << (*_svgPtr)[m][n].name() << \" isVisible = \" << (*_svgPtr)[m][n].isVisible() << endl;\r\n#endif // GRAPHICSVIEW_DEBUG\r\n\t\t\t\tvector< KeiRo::Base::Coord2 > &samples = svgPtrVec[ m ]->compressionGrid().samples();\r\n\t\t\t\tvector< KeiRo::Base::Polygon2 > &polygonVec = svgPtrVec[ m ]->polygonVec();\r\n\r\n\t\t\t\t// polygons\r\n\t\t\t\t_nGroups = polygonVec.size();\r\n//\t\t\t\t\t_voronoiComplex.resize( polygonVec.size() );\r\n\t\t\t\tfor( unsigned int i = 0; i < polygonVec.size(); i++ ) {\r\n\r\n\t\t\t\t\tQPolygonF polygon;\r\n\t\t\t\t\tunsigned int size = polygonVec[ i ].elements().size();\r\n//\t\t\t\t\t\t_voronoiComplex[i].resize( size );\r\n\t\t\t\t\tfor( unsigned int j = 0; j < size; j++ ) {\r\n\t\t\t\t\t\tunsigned int id = polygonVec[ i ].idElements()[ j ];\r\n\r\n\t\t\t\t\t\tSeed seed;\r\n\t\t\t\t\t\tseed.id = j;\r\n\t\t\t\t\t\tseed.gid = i;\r\n\t\t\t\t\t\tseed.weight = 1.0;\r\n\t\t\t\t\t\tseed.coordPtr = &samples[ id ];\r\n\t\t\t\t\t\tseed.voronoiCellPtr = new KeiRo::Base::Polygon2;\r\n\t\t\t\t\t\t_seedVec.push_back( seed );\r\n//\t\t\t\t\t\t\tpolygon.append( QPoint( samples[ id ].x(), -samples[ id ].y() ) );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//\r\n\t\t//  TreemapGraphicsView::_createVoronoi -- create Voronoi diagram\r\n\t\t//\r\n\t\t//  Inputs\r\n\t\t//  none\r\n\t\t//\r\n\t\t//  Outputs\r\n\t\t//  none\r\n\t\t//\r\n\t\tvoid TreemapGraphicsView::_createVoronoi( void ) {\r\n\r\n\t\t\t// initialization\r\n\t\t\t_initSeed();\r\n\t\t\tKeiRo::Base::Polygon2 contour;\r\n\t\t\tdouble w = KeiRo::Base::Common::getMainwidgetWidth();\r\n\t\t\tdouble h = KeiRo::Base::Common::getMainwidgetHeight();\r\n\t\t\tcontour.elements().push_back( KeiRo::Base::Coord2( -0.5*w, -0.5*h ) );\r\n\t\t\tcontour.elements().push_back( KeiRo::Base::Coord2(  0.5*w, -0.5*h ) );\r\n\t\t\tcontour.elements().push_back( KeiRo::Base::Coord2(  0.5*w,  0.5*h ) );\r\n\t\t\tcontour.elements().push_back( KeiRo::Base::Coord2( -0.5*w,  0.5*h ) );\r\n\r\n\t\t\t_voronoi.id() = 0;\r\n\t\t\t_voronoi.init( _seedVec, contour );\r\n\t\t\t_voronoi.createVoronoiDiagram( false );  // true: weighted, false: uniformed\r\n\r\n\t\t\t// build voronoi complex\r\n\t\t\tvector< vector< KeiRo::Base::Polygon2 > > polygonMat;\r\n\t\t\tpolygonMat.resize( _nGroups );\r\n\t\t\tcerr << \"polygonMat.size() = \" << polygonMat.size() << endl;\r\n\t\t\tfor( unsigned int i = 0; i < _seedVec.size(); i++ ){\r\n\t\t\t\tint gid = _seedVec[i].gid;\r\n\t\t\t\t// cerr << \"gid = \" << gid << endl;\r\n\t\t\t\tpolygonMat[ gid ].push_back( *_seedVec[ i ].voronoiCellPtr );\r\n\t\t\t}\r\n\r\n\t\t\tfor( unsigned int i = 0; i < polygonMat.size(); i++ ) {\r\n\r\n\t\t\t\tint cSize = polygonMat[ i ].size();\r\n\t\t\t\tif( cSize > 1 ) {\r\n\r\n\t\t\t\t\tContour2 contour;\r\n\t\t\t\t\tvector< KeiRo::Base::Polygon2 > pVec;\r\n\t\t\t\t\tfor( unsigned int j = 0; j < polygonMat[ i ].size(); j++ ) {\r\n\t\t\t\t\t\tKeiRo::Base::Polygon2 &p = polygonMat[ i ][ j ];\r\n\t\t\t\t\t\tpVec.push_back( p );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcontour.init( i, pVec );\r\n\t\t\t\t\tcontour.createContour();\r\n\t\t\t\t\t_voronoiComplex.insert( pair< unsigned int, KeiRo::Base::Polygon2 >( i, contour.contour() ) );\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tKeiRo::Base::Polygon2 &p = polygonMat[ i ][ 0 ];\r\n\t\t\t\t\tp.updateOrientation();\r\n\t\t\t\t\t_voronoiComplex.insert( pair< unsigned int, KeiRo::Base::Polygon2 >( i, p ) );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// build background graph\r\n\t\t\t// create boundary graph after the composite graph is lay out\r\n\t\t\t// build polygon complex information\r\n//\t\t\t_regionBase.createPolygonComplex( num_vertices( _skeletonForceGraph ) );\r\n\t\t\t// build vd associated in the boundary graph\r\n//\t\t\t_regionBase.polygonComplexVD().clear();\r\n\r\n\t\t\t// initialization\r\n\t\t\t_schematicLayout = new Schematization < Graph::SchematicGraph >;\r\n\r\n\t\t\tGraph::SchematicGraph &bg = _schematicLayout->graph();\r\n\t\t\tunsigned int nVertices = num_vertices( bg );\r\n\t\t\tunsigned int nEdges = num_edges( bg );\r\n\r\n\t\t\t// create boundary graph\r\n\t\t\tfor( unsigned int i = 0; i < _voronoiComplex.size(); i++ ) {\r\n\r\n\t\t\t\tKeiRo::Base::Polygon2 &polygon = _voronoiComplex[ i ];\r\n//\t\t\t\tvector< ForceGraph::vertex_descriptor > vdVec;\r\n\r\n\t\t\t\tunsigned int size = polygon.elements().size();\r\n\t\t\t\tfor( unsigned int j = 1; j < size + 1; j++ ) {\r\n\r\n\t\t\t\t\t// Check if the station exists or not\r\n\t\t\t\t\tGraph::SchematicGraph::vertex_descriptor curVDS = NULL;\r\n\t\t\t\t\tGraph::SchematicGraph::vertex_descriptor curVDT = NULL;\r\n\r\n\t\t\t\t\t// add vertices\r\n\t\t\t\t\tfor( unsigned int k = 0; k < 2; k++ ) {\r\n\r\n\t\t\t\t\t\tGraph::SchematicGraph::vertex_descriptor curVD = NULL;\r\n\r\n\t\t\t\t\t\t// Check if the station exists or not\r\n\t\t\t\t\t\tBGL_FORALL_VERTICES( vd, bg, Graph::SchematicGraph ) {\r\n\t\t\t\t\t\t\t\tKeiRo::Base::Coord2 &c = *bg[ vd ].coordPtr;\r\n\t\t\t\t\t\t\t\tif( fabs( ( polygon.elements()[ ( j - 1 + k ) % ( int ) size ] - c ).norm() ) < 1e-2 ) {\r\n\r\n#ifdef DEBUG\r\n\t\t\t\t\t\t\t\t\tcerr << \"The node has been in the database.\" << endl;\r\n#endif  // DEBUG\r\n\t\t\t\t\t\t\t\t\tif( k == 0 ) curVD = curVDS = vd;\r\n\t\t\t\t\t\t\t\t\tif( k == 1 ) curVD = curVDT = vd;\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif( curVD == NULL ) {\r\n\r\n\t\t\t\t\t\t\tcurVD = add_vertex( bg );\r\n\t\t\t\t\t\t\t//vector< unsigned int > lineID = bg[ curVD ].lineID;\r\n\t\t\t\t\t\t\t//lineID.push_back( nLines );\r\n\r\n\t\t\t\t\t\t\tdouble x = polygon.elements()[ j - 1 + k ].x();\r\n\t\t\t\t\t\t\tdouble y = polygon.elements()[ j - 1 + k ].y();\r\n\t\t\t\t\t\t\tbg[ curVD ].geoPtr = new KeiRo::Base::Coord2( x, y );\r\n\t\t\t\t\t\t\tbg[ curVD ].smoothPtr = new KeiRo::Base::Coord2( x, y );\r\n\t\t\t\t\t\t\tbg[ curVD ].coordPtr = new KeiRo::Base::Coord2( x, y );\r\n\r\n\t\t\t\t\t\t\tbg[ curVD ].id = bg[ curVD ].initID = nVertices;\r\n\t\t\t\t\t\t\tbg[ curVD ].namePtr = new string( to_string( bg[ curVD ].id ) );\r\n\t\t\t\t\t\t\tbg[ curVD ].weight = 1.0;\r\n\t\t\t\t\t\t\t//bg[ curVD ].lineID.push_back( nLines );\r\n\r\n\t\t\t\t\t\t\tif( k == 0 ) curVDS = curVD;\r\n\t\t\t\t\t\t\tif( k == 1 ) curVDT = curVD;\r\n\t\t\t\t\t\t\tnVertices++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t//bg[ curVD ].lineID.push_back( nLines );\r\n#ifdef DEBUG\r\n\t\t\t\t\t\t\tcerr << \"[Existing] curV : lineID = \" << endl;\r\n\t\t\t\t\t\t\tfor ( unsigned int k = 0; k < vertexLineID[ curVD ].size(); ++k )\r\n\t\t\t\t\t\t\tcerr << \"lineID[ \" << setw( 3 ) << k << \" ] = \" << vertexLineID[ curVD ][ k ] << endl;\r\n#endif  // DEBUG\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n//\t\t\t\t\tvdVec.push_back( curVDS );\r\n\t\t\t\t\t// cerr << _orthogonalBoundary[ curVDS ].id << \" \";\r\n\r\n\t\t\t\t\t//cerr << \"( \" << _orthogonalBoundary[ curVDS ].id << \", \" << _orthogonalBoundary[ curVDT ].id << \" )\" << endl;\r\n\r\n\t\t\t\t\t// add edges\r\n\t\t\t\t\t// search previous edge\r\n\t\t\t\t\tbool found = false;\r\n\t\t\t\t\tGraph::SchematicGraph::edge_descriptor oldED;\r\n\t\t\t\t\t//SchematicGraph::vertex_descriptor oldVS = ptrSta[ origID ];\r\n\t\t\t\t\t//SchematicGraph::vertex_descriptor oldVT = ptrSta[ destID ];\r\n\t\t\t\t\t//unsigned int indexS = _orthogonalBoundary[ curVDS ].initID;\r\n\t\t\t\t\t//unsigned int indexT = _orthogonalBoundary[ curVDT ].initID;\r\n\t\t\t\t\ttie( oldED, found ) = edge( curVDS, curVDT, bg );\r\n\r\n\r\n\t\t\t\t\tif( found == true ) {\r\n\r\n\t\t\t\t\t\t//bg[ oldED ].lineID.push_back( nLines );\r\n\t\t\t\t\t\tbg[ oldED ].visitedTimes += 1;\r\n\t\t\t\t\t\t//eachline.push_back( oldED );\r\n\t\t\t\t\t\t//bool test = false;\r\n\t\t\t\t\t\t//tie( oldED, test ) = edge( oldVT, oldVS, _orthogonalBoundary );\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\r\n\t\t\t\t\t\t//SchematicGraph::vertex_descriptor src = vertex( indexS, _orthogonalBoundary );\r\n\t\t\t\t\t\t//SchematicGraph::vertex_descriptor tar = vertex( indexT, _orthogonalBoundary );\r\n\r\n\t\t\t\t\t\t// handle fore edge\r\n\t\t\t\t\t\tpair< Graph::SchematicGraph::edge_descriptor, unsigned int > foreE = add_edge( curVDS, curVDT, bg );\r\n\t\t\t\t\t\tGraph::SchematicGraph::edge_descriptor foreED = foreE.first;\r\n\r\n\t\t\t\t\t\t// calculate geographical angle\r\n\t\t\t\t\t\tKeiRo::Base::Coord2 coordO;\r\n\t\t\t\t\t\tKeiRo::Base::Coord2 coordD;\r\n\t\t\t\t\t\tif( bg[ curVDS ].initID < bg[ curVDT ].initID ) {\r\n\t\t\t\t\t\t\tcoordO = *bg[ curVDS ].coordPtr;\r\n\t\t\t\t\t\t\tcoordD = *bg[ curVDT ].coordPtr;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tcoordO = *bg[ curVDT ].coordPtr;\r\n\t\t\t\t\t\t\tcoordD = *bg[ curVDS ].coordPtr;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tdouble diffX = coordD.x() - coordO.x();\r\n\t\t\t\t\t\tdouble diffY = coordD.y() - coordO.y();\r\n\t\t\t\t\t\tdouble angle = atan2( diffY, diffX );\r\n\r\n\t\t\t\t\t\tbg[ foreED ].initID = bg[ foreED ].id = nEdges;\r\n\t\t\t\t\t\tbg[ foreED ].weight = 1.0;\r\n\t\t\t\t\t\tbg[ foreED ].geoAngle = angle;\r\n\t\t\t\t\t\tbg[ foreED ].smoothAngle = angle;\r\n\t\t\t\t\t\tbg[ foreED ].angle = angle;\r\n\t\t\t\t\t\t//bg[ foreED ].lineID.push_back( nLines );\r\n\t\t\t\t\t\tbg[ foreED ].visitedTimes = 0;\r\n\r\n\t\t\t\t\t\t//eachline.push_back( foreED );\r\n#ifdef  DEBUG\r\n\t\t\t\t\t\tcout << \"nEdges = \" << _nEdges << \" angle = \" << angle << endl;\r\n#endif  // DEBUG\r\n\t\t\t\t\t\tnEdges++;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n//\t\t\t\t_regionBase.polygonComplexVD().insert(\r\n//\t\t\t\tpair< unsigned int, vector< ForceGraph::vertex_descriptor > >( i, vdVec ) );\r\n\t\t\t}\r\n\r\n\t\t\t_schematicLayout->prepare( \"/../../ResponsiveLens/config/Orthogonal.conf\" );\r\n\t\t\t_schematicLayout->ConjugateGradient();\r\n\t\t}\r\n\r\n\t\t//\r\n\t\t//  TreemapGraphicsView::_item_polygons -- draw polygons\r\n\t\t//\r\n\t\t//  Inputs\r\n\t\t//  none\r\n\t\t//\r\n\t\t//  Outputs\r\n\t\t//  none\r\n\t\t//\r\n\t\tvoid TreemapGraphicsView::_item_XMLPolygons( void ) {\r\n\r\n\t\t\t_rectangleItemMap.clear();\r\n\t\t\tGraph::TreeDirectedGraph    &graphmlTree    = _metadataPtr->graphmlTree();\r\n\t\t\tdouble borderWidth = _metadataPtr->borderWidth();\r\n\r\n\t\t\tBGL_FORALL_VERTICES( vd, graphmlTree, Graph::TreeDirectedGraph ) {\r\n\r\n\t\t\t\tKeiRo::Base::Rectangle2 &bbox = *graphmlTree[ vd ].boundingBoxPtr;\r\n\t\t\t\tKeiRo::Base::Coord2 &c = *graphmlTree[ vd ].coordPtr;\r\n\t\t\t\tunsigned int id = graphmlTree[vd].id;\r\n\t\t\t\tunsigned int level = graphmlTree[vd].level;\r\n//\t\t\t\tdouble borderW = borderWidth;\r\n//\t\t\t\tdouble borderH = borderWidth;\r\n\t\t\t\tdouble borderW = MIN2( borderWidth, _marginRatio*bbox.width() );\r\n\t\t\t\tdouble borderH = MIN2( borderWidth, _marginRatio*bbox.height() );\r\n\r\n//\t\t\t\tcerr << \"borderWidth = \" << borderWidth << \", bw = \" << borderW << \", bh = \" << borderH << endl;\r\n\r\n\t\t\t\tUi::Vector::GraphicsPolygonItem *itemptr = new Ui::Vector::GraphicsPolygonItem;\r\n\t\t\t\t_rectangleItemMap.insert( pair< unsigned int, Ui::Vector::GraphicsPolygonItem * >( id, itemptr ) );\r\n\r\n\t\t\t\t// set polygon color\r\n\t\t\t\tvector< unsigned int > &cs = graphmlTree[vd].attribute.stroke();\r\n\t\t\t\tvector< unsigned int > &cf = graphmlTree[vd].attribute.fill();\r\n\t\t\t\tif( id == 0 ){\r\n\t\t\t\t\titemptr->setPen( QPen( QColor( 255, 255, 255, 255 ), 2 ) );\r\n\t\t\t\t\titemptr->setBrush( QBrush( QColor( 255, 255, 255, 255 ), Qt::SolidPattern ) );\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\titemptr->setPen( QPen( QColor( cs[0], cs[1], cs[2], cs[3] ), 2 ) );\r\n\t\t\t\t\titemptr->setBrush( QBrush( QColor( cf[0], cf[1], cf[2], 150 ), Qt::SolidPattern ) );\r\n\t\t\t\t}\r\n\t\t\t\t// if (id==20) {\r\n\t\t\t\t// \titemptr->setPen( QPen( QColor( 0,255,0, cs[3] ), 2 ) );\r\n\t\t\t\t// \titemptr->setBrush( QBrush( QColor( 0,255,0, 150 ), Qt::SolidPattern ) );\r\n\t\t\t\t// }\r\n\r\n\t\t\t\titemptr->defaultPen() = itemptr->pen();\r\n\t\t\t\titemptr->defaultBrush() = itemptr->brush();\r\n\r\n\t\t\t\t// add selected polygons\r\n\t\t\t\tif( graphmlTree[vd].isSelected ) {\r\n\r\n\t\t\t\t\tQColor color = QColor( 255, 100, 100, 255 );\r\n\t\t\t\t\titemptr->setPen( QPen( QColor( 0, 0, 0, 255 ), 5 ) );\r\n\t\t\t\t\titemptr->setBrush( QBrush( QColor( color.red(), color.green(), color.blue(), 255 ),\r\n\t\t\t\t\t                           Qt::SolidPattern ) );\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tKeiRo::Base::Coord2 center( bbox.leftBottom().x() + 0.5*bbox.width(),\r\n\t\t\t\t                            bbox.leftBottom().y() + 0.5*bbox.height() );\r\n\t\t\t\tKeiRo::Base::Coord2 oldCenter( bbox.oldLeftBottom().x() + 0.5*bbox.oldWidth(),\r\n\t\t\t\t                               bbox.oldLeftBottom().y() + 0.5*bbox.oldHeight() );\r\n\t\t\t\tdouble scaleX = (bbox.width() - (level+1) * borderW)/bbox.width();\r\n\t\t\t\tdouble scaleY = (bbox.height() - (level+1) * borderH)/bbox.height();\r\n\t\t\t\tdouble oldScaleX = (bbox.oldWidth() - (level+1) * borderW)/bbox.oldWidth();\r\n\t\t\t\tdouble oldScaleY = (bbox.oldHeight() - (level+1) * borderH)/bbox.oldHeight();\r\n\t\t\t\titemptr->bbox() = QRect( bbox.leftBottom().x(),\r\n\t\t\t\t                         bbox.leftBottom().y(),\r\n\t\t\t\t                         bbox.width(),\r\n\t\t\t\t                         bbox.height() );\r\n\r\n\t\t\t\t//itemptr->textOn() = true;\r\n\t\t\t\t//itemptr->text() = QString::fromStdString( to_string( _seedVec[ i ].id ) );\r\n\r\n\t\t\t\tQPolygonF polygon, oldPolygon, intermediatePolygon;\r\n\t\t\t\tpolygon.append( QPoint( scaleX * ( bbox.leftBottom().x() - center.x() ) + center.x(),\r\n\t\t\t\t                        -( scaleY * ( bbox.leftBottom().y() - center.y() ) + center.y() )));\r\n\t\t\t\tpolygon.append( QPoint( scaleX * ( bbox.leftBottom().x() + bbox.width() - center.x() ) + center.x(),\r\n\t\t\t\t                        -( scaleY * ( bbox.leftBottom().y() - center.y() ) + center.y() )));\r\n\t\t\t\tpolygon.append( QPoint( scaleX * ( bbox.leftBottom().x() + bbox.width() - center.x() ) + center.x(),\r\n\t\t\t\t                        -( scaleY * ( bbox.leftBottom().y() + bbox.height() - center.y() ) + center.y() )));\r\n\t\t\t\tpolygon.append( QPoint( scaleX * ( bbox.leftBottom().x() - center.x() ) + center.x(),\r\n\t\t\t\t                        -( scaleY * ( bbox.leftBottom().y() + bbox.height() - center.y() ) + center.y() )));\r\n\r\n\t\t\t\toldPolygon.append( QPoint( oldScaleX * ( bbox.oldLeftBottom().x() - oldCenter.x() ) + oldCenter.x(),\r\n\t\t\t\t                           -( oldScaleY * ( bbox.oldLeftBottom().y() - oldCenter.y() ) + oldCenter.y() )));\r\n\t\t\t\toldPolygon.append( QPoint( oldScaleX * ( bbox.oldLeftBottom().x() + bbox.oldWidth() - oldCenter.x() ) + oldCenter.x(),\r\n\t\t\t\t                           -( oldScaleY * ( bbox.oldLeftBottom().y() - oldCenter.y() ) + oldCenter.y() )));\r\n\t\t\t\toldPolygon.append( QPoint( oldScaleX * ( bbox.oldLeftBottom().x() + bbox.oldWidth() - oldCenter.x() ) + oldCenter.x(),\r\n\t\t\t\t                           -( oldScaleY * ( bbox.oldLeftBottom().y() + bbox.oldHeight() - oldCenter.y() ) + oldCenter.y() )));\r\n\t\t\t\toldPolygon.append( QPoint( oldScaleX * ( bbox.oldLeftBottom().x() - oldCenter.x() ) + oldCenter.x(),\r\n\t\t\t\t                           -( oldScaleY * ( bbox.oldLeftBottom().y() + bbox.oldHeight() - oldCenter.y() ) + oldCenter.y() )));\r\n\r\nif (_isPathSelectionMode == false) {\r\n\titemptr->setPolygon( polygon );\r\n\titemptr->setAcceptHoverEvents( true );\r\n\titemptr->setFlag( QGraphicsItem::ItemIsSelectable );\r\n\titemptr->attributeID() = graphmlTree[vd].id;\r\n\titemptr->id() = id;\r\n\titemptr->name() = QString::fromStdString( *graphmlTree[vd].namePtr );\r\n\titemptr->text() = QString::fromStdString( *graphmlTree[vd].namePtr );\r\n}\r\n\r\n\r\n\t\t\t\t_scenePtr->addItem( itemptr );\r\n\r\n\t\t\t\tif(bbox.inLocalMove()) {\r\n\r\n\t\t\t\t\tKeiRo::Base::Coord2 intermediateCenter( bbox.intermediateLeftBottom().x() + 0.5*bbox.intermediateWidth(),\r\n\t\t\t\t                                     \t\tbbox.intermediateLeftBottom().y() + 0.5*bbox.intermediateHeight() );\r\n\r\n\t\t\t\t\tdouble intermediateScaleX = (bbox.intermediateWidth() - (level+1) * borderW)/bbox.intermediateWidth();\r\n\t\t\t\t\tdouble intermediateScaleY = (bbox.intermediateHeight() - (level+1) * borderH)/bbox.intermediateHeight();\r\n\r\n\t\t\t\t\tintermediatePolygon.append( QPoint( intermediateScaleX * ( bbox.intermediateLeftBottom().x() - intermediateCenter.x() ) + intermediateCenter.x(),\r\n\t\t\t\t\t                           -( intermediateScaleY * ( bbox.intermediateLeftBottom().y() - intermediateCenter.y() ) + intermediateCenter.y() )));\r\n\t\t\t\t\tintermediatePolygon.append( QPoint( intermediateScaleX * ( bbox.intermediateLeftBottom().x() + bbox.intermediateWidth() - intermediateCenter.x() ) + intermediateCenter.x(),\r\n\t\t\t\t\t                           -( intermediateScaleY * ( bbox.intermediateLeftBottom().y() - intermediateCenter.y() ) + intermediateCenter.y() )));\r\n\t\t\t\t\tintermediatePolygon.append( QPoint( intermediateScaleX * ( bbox.intermediateLeftBottom().x() + bbox.intermediateWidth() - intermediateCenter.x() ) + intermediateCenter.x(),\r\n\t\t\t\t  \t                         -( intermediateScaleY * ( bbox.intermediateLeftBottom().y() + bbox.intermediateHeight() - intermediateCenter.y() ) + intermediateCenter.y() )));\r\n\t\t\t\t\tintermediatePolygon.append( QPoint( intermediateScaleX * ( bbox.intermediateLeftBottom().x() - intermediateCenter.x() ) + intermediateCenter.x(),\r\n\t\t\t\t   \t                        -( intermediateScaleY * ( bbox.intermediateLeftBottom().y() + bbox.intermediateHeight() - intermediateCenter.y() ) + intermediateCenter.y() )));\r\n\r\n\t\t\t\t\tcerr << \"Animation 1 Updated\" << endl;\r\n\t\t\t\t\t// UPDATED ANIMATION --------------------------------------------------------------------------------------------------------\r\n\t\t\t\t\tQPropertyAnimation *animation1 = new QPropertyAnimation( itemptr, \"polygon\" );\r\n\t\t\t\t\tanimation1->setDuration( ANIMATE_DURATION/2 );\r\n\t\t\t\t\tanimation1->setStartValue( oldPolygon );\r\n\t\t\t\t\tanimation1->setEndValue( intermediatePolygon );\r\n\t\t\t\t\tanimation1->setEasingCurve( QEasingCurve::Linear );\r\n\r\n\t\t\t\t\tQPropertyAnimation *animation2 = new QPropertyAnimation( itemptr, \"polygon\" );\r\n\t\t\t\t\tanimation2->setDuration( ANIMATE_DURATION/2 );\r\n\t\t\t\t\tanimation2->setStartValue( intermediatePolygon );\r\n\t\t\t\t\tanimation2->setEndValue( polygon );\r\n\t\t\t\t\tanimation2->setEasingCurve( QEasingCurve::Linear );\r\n\r\n\t\t\t\t\tQSequentialAnimationGroup *group = new QSequentialAnimationGroup();\r\n\r\n\t\t\t\t\tgroup->addAnimation(animation1);\r\n    \t\t\t\t\tgroup->addAnimation(animation2);\r\n\r\n    \t\t\t\t\tgroup->start( QAbstractAnimation::DeleteWhenStopped );\r\n\r\n    \t\t\t\t} else {\r\n\r\n    \t\t\t\t\tQPropertyAnimation *animation = new QPropertyAnimation( itemptr, \"polygon\" );\r\n\t\t\t\t\tanimation->setDuration( ANIMATE_DURATION );\r\n\t\t\t\t\tanimation->setStartValue( oldPolygon );\r\n\t\t\t\t\tanimation->setEndValue( polygon );\r\n\t\t\t\t\tanimation->setEasingCurve( QEasingCurve::Linear );\r\n\t\t\t\t\tanimation->start( QAbstractAnimation::DeleteWhenStopped );\r\n    \t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//\r\n\t\t//  TreemapGraphicsView::_item_XMLpolylines -- draw polygons\r\n\t\t//\r\n\t\t//  Inputs\r\n\t\t//  none\r\n\t\t//\r\n\t\t//  Outputs\r\n\t\t//  none\r\n\t\t//\r\n\t\tvoid TreemapGraphicsView::_item_XMLPolylines( void ) {\r\n\r\n\t\t\tGraph::TreeDirectedGraph    &graphmlTree    = _metadataPtr->graphmlTree();\r\n\t\t\tmap< unsigned int, Graph::BaseUndirectedGraph >  &graphmlGraphMap   = _metadataPtr->graphmlGraphMap();\r\n\t\t\tmultimap< KeiRo::Base::Common::UIDPair,\r\n\t\t\t\t\tKeiRo::Base::Common::UIDPair > &globalPath = _metadataPtr->graphmlGlobalPath();\r\n\t\t\tGraph::BaseUndirectedGraph &pg = _globalPaths.compressedPathGraph().graph();\r\n\t\t\tvector< vector< unsigned int > > pathVec = _globalPaths.hierarchicalPathVec();\r\n\r\n\t\t\t// polyline rendering\r\n\t\t\tcerr << \"pathVec.size() = \" << pathVec.size() << endl;\r\n\t\t\tfor( unsigned int i = 0; i < pathVec.size(); i++ ){\r\n\r\n\t\t\t\tfor( unsigned int j = 1; j < pathVec[i].size(); j++ ){\r\n\r\n\t\t\t\t\tGraph::BaseUndirectedGraph::vertex_descriptor vdS = vertex( pathVec[i][j-1], pg );\r\n\t\t\t\t\tGraph::BaseUndirectedGraph::vertex_descriptor vdT = vertex( pathVec[i][j], pg );\r\n\t\t\t\t\tKeiRo::Base::Coord2 &cS = *pg[ vdS ].coordPtr;\r\n\t\t\t\t\tKeiRo::Base::Coord2 &cT = *pg[ vdT ].coordPtr;\r\n\r\n\t\t\t\t\tUi::Vector::GraphicsPathItem *itemptr = new Ui::Vector::GraphicsPathItem;\r\n\r\n\t\t\t\t\tQColor color( 150, 0, 0, 255 );\r\n\r\n\t\t\t\t\titemptr->setPen( QPen( color, 5 * (3-pg[ vdS ].level) ) );\r\n\t\t\t\t\titemptr->setBrush( QBrush( color, Qt::SolidPattern ) );\r\n\r\n\t\t\t\t\tQPainterPath path;\r\n\t\t\t\t\tpath.moveTo( QPoint( cS.x(), -cS.y() ) );\r\n\t\t\t\t\tpath.lineTo( QPoint( cT.x(), -cT.y() ) );\r\n\t\t\t\t\titemptr->setPath( path );\r\n\r\n\t\t\t\t\t_scenePtr->addItem( itemptr );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// straight line rendering\r\n//#ifdef TreemapGraphicsView_DEBUG\r\n\t\t\tfor( multimap< KeiRo::Base::Common::UIDPair,\r\n\t\t\t\t\tKeiRo::Base::Common::UIDPair >::iterator it = globalPath.begin();\r\n\t\t\t\t\tit != globalPath.end(); it++ ){\r\n\t\t\t\tKeiRo::Base::Common::UIDPair pairS = it->first;\r\n\t\t\t\tKeiRo::Base::Common::UIDPair pairT = it->second;\r\n\t\t\t\tunsigned int idS = pairS.first;\r\n\t\t\t\tunsigned int idT = pairT.first;\r\n\t\t\t\tunsigned int idGS = pairS.second;\r\n\t\t\t\tunsigned int idGT = pairT.second;\r\n\r\n\t\t\t\tGraph::BaseUndirectedGraph subGS = graphmlGraphMap.find( idS )->second;\r\n\t\t\t\tGraph::BaseUndirectedGraph subGT = graphmlGraphMap.find( idT )->second;\r\n\t\t\t\tGraph::BaseUndirectedGraph::vertex_descriptor vdS = vertex( idGS, subGS );\r\n\t\t\t\tGraph::BaseUndirectedGraph::vertex_descriptor vdT = vertex( idGT, subGT );\r\n\r\n\t\t\t\tKeiRo::Base::Coord2 &cS = *subGS[vdS].coordPtr;\r\n\t\t\t\tKeiRo::Base::Coord2 &cT = *subGS[vdT].coordPtr;\r\n\r\n\t\t\t\tUi::Vector::GraphicsEdgeItem *itemptr = new Ui::Vector::GraphicsEdgeItem;\r\n\r\n\t\t\t\tQColor color( 0, 0, 0, 255 );\r\n\t\t\t\titemptr->setPen( QPen( QColor( 100, 255, 100, 255 ), 5 ) );\r\n\r\n\t\t\t\tQLineF oldLine, line;\r\n\t\t\t\toldLine.setLine( cS.oldElement()[0], -cS.oldElement()[1],\r\n\t\t\t\t                 cT.oldElement()[0], -cT.oldElement()[1] );\r\n\t\t\t\tline.setLine( cS.x(), -cS.y(), cT.x(), -cT.y() );\r\n\t\t\t\titemptr->setLine( line );\r\n\r\n\t\t\t\t_scenePtr->addItem( itemptr );\r\n\r\n\t\t\t\tQPropertyAnimation *animation = new QPropertyAnimation( itemptr, \"line\" );\r\n\t\t\t\tanimation->setDuration( ANIMATE_DURATION );\r\n\t\t\t\tanimation->setStartValue( oldLine );\r\n\t\t\t\tanimation->setEndValue( line );\r\n\t\t\t\tanimation->setEasingCurve( QEasingCurve::Linear );\r\n\t\t\t\tanimation->start( QAbstractAnimation::DeleteWhenStopped );\r\n\t\t\t}\r\n//#endif // TreemapGraphicsView_DEBUG\r\n\t\t}\r\n\r\n\t\t//\r\n\t\t//  TreemapGraphicsView::_item_XMLGraph -- draw graphml\r\n\t\t//\r\n\t\t//  Inputs\r\n\t\t//  none\r\n\t\t//\r\n\t\t//  Outputs\r\n\t\t//  none\r\n\t\t//\r\n\t\tvoid TreemapGraphicsView::_item_XMLGraph ( void ) {\r\n\r\n//\t\t\tGraph::TreeDirectedGraph    &graphmlTree    = _metadataPtr->graphmlTree();\r\n\t\t\tmap< unsigned int, Graph::BaseUndirectedGraph >  &graphmlGraphMap   = _metadataPtr->graphmlGraphMap();\r\n\t\t\tdouble borderWidth = _metadataPtr->borderWidth();\r\n\r\n\t\t\t// draw the lowest level graph\r\n\t\t\tfor( map< unsigned int, Graph::BaseUndirectedGraph >::iterator it = graphmlGraphMap.begin();\r\n\t\t\t\t it != graphmlGraphMap.end(); it++ ){\r\n\r\n\t\t\t\tGraph::BaseUndirectedGraph &graphmlGraph = it->second;\r\n\t\t\t\tbool isLabelVisible = _checkLabelVisibility( graphmlGraph );\r\n\r\n\t\t\t\t// draw edges\r\n\t\t\t\tBGL_FORALL_EDGES( ed, graphmlGraph, Graph::BaseUndirectedGraph ) {\r\n\r\n\t\t\t\t\tGraph::BaseUndirectedGraph::vertex_descriptor vdS = source( ed, graphmlGraph );\r\n\t\t\t\t\tGraph::BaseUndirectedGraph::vertex_descriptor vdT = target( ed, graphmlGraph );\r\n//\t\t\t\t\tKeiRo::Base::Coord2 &cS = *graphmlGraph[ vdS ].coordPtr;\r\n//\t\t\t\t\tKeiRo::Base::Coord2 &cT = *graphmlGraph[ vdT ].coordPtr;\r\n\r\n\t\t\t\t\t// iterate edge samples\r\n\t\t\t\t\tKeiRo::Base::Edge2 &edge = graphmlGraph[ ed ].edge;\r\n\t\t\t\t\tfor( unsigned int i = 1; i < edge.elements().size(); i++ ){\r\n\t\t\t\t\t\tUi::Vector::GraphicsEdgeItem *itemptr = new Ui::Vector::GraphicsEdgeItem;\r\n\r\n\t\t\t\t\t\tKeiRo::Base::Coord2 &cS = edge.elements()[i-1];\r\n\t\t\t\t\t\tKeiRo::Base::Coord2 &cT = edge.elements()[i];\r\n\r\n\t\t\t\t\t\titemptr->setPen( QPen( QColor( edge.stroke()[0], edge.stroke()[1],\r\n\t\t\t\t\t\t\t\t\t\tedge.stroke()[2], edge.stroke()[3] ), 2 ) );\r\n\r\n\t\t\t\t\t\tQLineF oldLine, intermediateLine, line;\r\n\t\t\t\t\t\toldLine.setLine( cS.oldElement()[0], -cS.oldElement()[1],\r\n\t\t\t\t\t\t                 cT.oldElement()[0], -cT.oldElement()[1] );\r\n\t\t\t\t\t\tline.setLine( cS.x(), -cS.y(), cT.x(), -cT.y() );\r\n\t\t\t\t\t\titemptr->setLine( line );\r\n\r\n\t\t\t\t\t\t_scenePtr->addItem( itemptr );\r\n\r\n\t\t\t\t\t\tif(cS.inLocalMove()) {\r\n\r\n\t\t\t\t\t\t\tintermediateLine.setLine( cS.intermediateElement()[0], -cS.intermediateElement()[1],\r\n\t\t\t\t\t\t                 \t\t\tcT.intermediateElement()[0], -cT.intermediateElement()[1] );\r\n\r\n\t\t\t\t\t\t\t// UPDATED ANIMATION --------------------------------------------------------------------------------------------------------\r\n\t\t\t\t\t\t\tQPropertyAnimation *animation1 = new QPropertyAnimation( itemptr, \"line\" );\r\n\t\t\t\t\t\t\tanimation1->setDuration( ANIMATE_DURATION/2 );\r\n\t\t\t\t\t\t\tanimation1->setStartValue( oldLine );\r\n\t\t\t\t\t\t\tanimation1->setEndValue( intermediateLine );\r\n\t\t\t\t\t\t\tanimation1->setEasingCurve( QEasingCurve::Linear );\r\n\r\n\r\n\t\t\t\t\t\t\tQPropertyAnimation *animation2 = new QPropertyAnimation( itemptr, \"line\" );\r\n                                        \t\tanimation2->setDuration( ANIMATE_DURATION/2 );\r\n                                        \t\tanimation2->setStartValue( intermediateLine );\r\n                                        \t\tanimation2->setEndValue( line );\r\n                                        \t\tanimation2->setEasingCurve( QEasingCurve::Linear );\r\n\r\n                                        \t\tQSequentialAnimationGroup *group = new QSequentialAnimationGroup();\r\n\r\n                                        \t\tgroup->addAnimation(animation1);\r\n                                        \t\tgroup->addAnimation(animation2);\r\n\r\n                                        \t\tgroup->start( QAbstractAnimation::DeleteWhenStopped );\r\n\r\n                                        \t} else {\r\n\r\n                                        \t\tQPropertyAnimation *animation = new QPropertyAnimation( itemptr, \"line\" );\r\n\t\t\t\t\t\t\tanimation->setDuration( ANIMATE_DURATION );\r\n\t\t\t\t\t\t\tanimation->setStartValue( oldLine );\r\n\t\t\t\t\t\t\tanimation->setEndValue( line );\r\n\t\t\t\t\t\t\tanimation->setEasingCurve( QEasingCurve::Linear );\r\n\t\t\t\t\t\t\tanimation->start( QAbstractAnimation::DeleteWhenStopped );\r\n                                        \t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tBGL_FORALL_VERTICES( vd, graphmlGraph, Graph::BaseUndirectedGraph ) {\r\n\r\n\t\t\t\t\tKeiRo::Base::Coord2 &c = *graphmlGraph[ vd ].coordPtr;\r\n\r\n\t\t\t\t\tUi::Vector::GraphicsVertexItem *itemptr = new Ui::Vector::GraphicsVertexItem;\r\n\t\t\t\t\titemptr->isSimple() = true;\r\n\t\t\t\t\tQColor stroke = QColor( graphmlGraph[ vd ].attribute.stroke()[0], graphmlGraph[ vd ].attribute.stroke()[1],\r\n\t\t\t\t\t                       graphmlGraph[ vd ].attribute.stroke()[2], graphmlGraph[ vd ].attribute.stroke()[3] );\r\n\t\t\t\t\tQColor fill = QColor( graphmlGraph[ vd ].attribute.fill()[0], graphmlGraph[ vd ].attribute.fill()[1],\r\n\t\t\t\t\t                        graphmlGraph[ vd ].attribute.fill()[2], graphmlGraph[ vd ].attribute.fill()[3] );\r\n\t\t\t\t\titemptr->setPen( QPen( stroke, 2 ) );\r\n\t\t\t\t\titemptr->setBrush( QBrush( fill, Qt::SolidPattern ) );\r\n\r\n\t\t\t\t\tif( fill.red() > 150 )\r\n\t\t\t\t\t\titemptr->textpen() = QPen( QColor( 0, 0, 0, 255 ), 2 );\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\titemptr->textpen() = QPen( QColor( 250, 250, 250, 255 ), 2 );\r\n\r\n\t\t\t\t\t// Set font\r\n\t\t\t\t\titemptr->font() = lensSettings->fonts()[_metadataPtr->maxLevel()-1];\r\n\t\t\t\t\titemptr->text() = QString::fromStdString( to_string( *graphmlGraph[vd].namePtr ) );\r\n\t\t\t\t\tQFontMetrics fm( itemptr->font());\r\n\t\t\t\t\tint pxFntWidth = fm.width( itemptr->text() ),\r\n\t\t\t\t\t\tpxFntHeight = fm.height();\r\n\t\t\t\t\t// cerr << \"pxFntWidth = \" << pxFntWidth << \", pxFntHeight = \" << pxFntHeight << endl;\r\n\t\t\t\t\titemptr->textOn() = true;\r\n\t\t\t\t\tif( isLabelVisible == false ){\r\n\t\t\t\t\t\tpxFntWidth = 10;\r\n\t\t\t\t\t\tpxFntHeight = 10;\r\n\t\t\t\t\t\titemptr->textOn() = false;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Set\r\n\t\t\t\t\tKeiRo::Base::Rectangle2 bbox( c.x(), c.y(), pxFntWidth, pxFntHeight );\r\n\t\t\t\t\tKeiRo::Base::Coord2 center( bbox.leftBottom().x() - 0.5*bbox.width(),\r\n                                                bbox.leftBottom().y() + 0.5*bbox.height() );\r\n\t\t\t\t\tKeiRo::Base::Rectangle2 oldBbox( c.oldElement()[0], c.oldElement()[1], pxFntWidth, pxFntHeight );\r\n\t\t\t\t\tKeiRo::Base::Coord2 oldCenter( oldBbox.leftBottom().x() - 0.5*oldBbox.width(),\r\n                                                   oldBbox.leftBottom().y() + 0.5*oldBbox.height() );\r\n\r\n\t\t\t\t\titemptr->setRect( QRect( oldCenter.x(), -oldCenter.y(), oldBbox.width(), oldBbox.height() ) );\r\n\t\t\t\t\titemptr->setGeometry( QRect( oldCenter.x(), -oldCenter.y(), oldBbox.width(), oldBbox.height() ) );\r\n\t\t\t\t\titemptr->sourceRect() = QRect( oldCenter.x(), -oldCenter.y(), oldBbox.width(), oldBbox.height() );\r\n\t\t\t\t\titemptr->targetRect() = QRect( center.x(), -center.y(), bbox.width(), bbox.height() );\r\n\t\t\t\t\titemptr->radius() = (double)_padding;\r\n\r\n                                       // disable clicking\r\n\t\t\t\t\titemptr->setAcceptHoverEvents( false );\r\n\t\t\t\t\titemptr->setFlag( QGraphicsItem::ItemIsSelectable, false );\r\n\t\t\t\t\titemptr->isSimple() = false;\r\n\t\t\t\t\t_scenePtr->addItem( itemptr );\r\n\r\n\t\t\t\t\tif(c.inLocalMove()) {\r\n\r\n\t\t\t\t\t\tKeiRo::Base::Rectangle2 intermediateBbox( c.intermediateElement()[0], c.intermediateElement()[1], pxFntWidth, pxFntHeight );\r\n\t\t\t\t\t\tKeiRo::Base::Coord2 intermediateCenter( intermediateBbox.leftBottom().x() - 0.5*intermediateBbox.width(),\r\n                                              \t\t\t\t\t  intermediateBbox.leftBottom().y() + 0.5*intermediateBbox.height() );\r\n\r\n\t\t\t\t\t\titemptr->intermediateRect() = QRect( intermediateCenter.x(), -intermediateCenter.y(), intermediateBbox.width(), intermediateBbox.height() );\r\n\r\n\t\t\t\t\t\t// UPDATED ANIMATION --------------------------------------------------------------------------------------------------------\r\n\t\t\t\t\t\tQPropertyAnimation *animation1 = new QPropertyAnimation( itemptr, \"geometry\" );\r\n\t\t\t\t\t\tanimation1->setDuration( ANIMATE_DURATION/2 );\r\n\t\t\t\t\t\tanimation1->setStartValue( itemptr->sourceRect() );\r\n\t\t\t\t\t\tanimation1->setEndValue( itemptr->intermediateRect() );\r\n\t\t\t\t\t\tanimation1->setEasingCurve( QEasingCurve::Linear );\r\n\r\n\t\t\t\t\t\tQPropertyAnimation *animation2 = new QPropertyAnimation( itemptr, \"geometry\" );\r\n\t\t\t\t\t\tanimation2->setDuration( ANIMATE_DURATION/2 );\r\n\t\t\t\t\t\tanimation2->setStartValue( itemptr->intermediateRect() );\r\n\t\t\t\t\t\tanimation2->setEndValue( itemptr->targetRect() );\r\n\t\t\t\t\t\tanimation2->setEasingCurve( QEasingCurve::Linear );\r\n\r\n                                \t\tQSequentialAnimationGroup *group = new QSequentialAnimationGroup();\r\n\r\n\t\t\t\t\t\tgroup->addAnimation(animation1);\r\n\t\t\t\t\t\tgroup->addAnimation(animation2);\r\n\r\n\t\t\t\t\t\tgroup->start( QAbstractAnimation::DeleteWhenStopped );\r\n\r\n\t\t\t\t\t} else { // not in local move\r\n\r\n\t\t\t\t\t\tQPropertyAnimation *animation = new QPropertyAnimation( itemptr, \"geometry\" );\r\n\t\t\t\t\t\tanimation->setDuration( ANIMATE_DURATION );\r\n\t\t\t\t\t\tanimation->setStartValue( itemptr->sourceRect() );\r\n\t\t\t\t\t\tanimation->setEndValue( itemptr->targetRect() );\r\n\t\t\t\t\t\tanimation->setEasingCurve( QEasingCurve::Linear );\r\n\r\n\t\t\t\t\t\tanimation->start( QAbstractAnimation::DeleteWhenStopped );\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\t//\r\n\t\t//  TreemapGraphicsView::_item_polygons -- draw polygons\r\n\t\t//\r\n\t\t//  Inputs\r\n\t\t//  none\r\n\t\t//\r\n\t\t//  Outputs\r\n\t\t//  none\r\n\t\t//\r\n\t\tvoid TreemapGraphicsView::_item_polygons( void ) {\r\n\r\n\t\t\tvector< FileIO::SVG* > &svgPtrVec = _metadataPtr->svgPtrVec();\r\n\t\t\tvector< vector< unsigned int > > &sortedLevel = _hierarchicalTreemap.sortedLevel();\r\n\t\t\t_polygonItemMap.clear();\r\n\t\t\tdouble borderWidth = 0.0;\r\n\t\t\tif( _isInitialized == true ) borderWidth = _metadataPtr->borderWidth();\r\n\r\n\t\t\t// reset selected polygons\r\n\t\t\tfor( unsigned int m = 0; m < sortedLevel.size(); m++ ) {\r\n\t\t\t\tfor( unsigned int n = 0; n < sortedLevel[m].size(); n++ ) {\r\n\r\n\t\t\t\t\tunsigned int id = sortedLevel[m][n];\r\n\t\t\t\t\tvector< KeiRo::Base::Polygon2 > &polygonVec = svgPtrVec[ id ]->polygonVec();\r\n\r\n\t\t\t\t\t// polygons\r\n\t\t\t\t\tfor( unsigned int i = 0; i < polygonVec.size(); i++ ) {\r\n\t\t\t\t\t\tpolygonVec[ i ].isSelected() = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// add selected polygons\r\n\t\t\tfor( map< unsigned int, unsigned int, unsigned int >::iterator it = _selectSceneItemMap.begin();\r\n\t\t\t     it != _selectSceneItemMap.end(); it++ ){\r\n\r\n\t\t\t\tunsigned int level = 0;//std::get<0>( it->second );\r\n\t\t\t\tunsigned int member = 0;//std::get<1>( it->second );\r\n\t\t\t\tunsigned int polygonMember = 0;//std::get<2>( it->second );\r\n\r\n\t\t\t\tunsigned int id = sortedLevel[level][member];\r\n\t\t\t\tvector< KeiRo::Base::Polygon2 > &polygonVec = svgPtrVec[ id ]->polygonVec();\r\n\t\t\t\tpolygonVec[ polygonMember ].isSelected() = true;\r\n\r\n\t\t\t}\r\n\r\n//\t\t\tfor( unsigned int m = 0; m < MAX2( 0, (int)sortedLevel.size() ); m++ ) {\r\n\t\t\tfor( unsigned int m = 0; m < MAX2( 0, (int)sortedLevel.size()-1 ); m++ ) {\r\n\t\t\t\tfor( unsigned int n = 0; n < sortedLevel[m].size(); n++ ) {\r\n\r\n\t\t\t\t\tunsigned int id = sortedLevel[m][n];\r\n\r\n#ifdef GRAPHICSVIEW_DEBUG\r\n\t\t\t\t\tcerr << \"m = \" << m << \", n = \" << n << \" id = \" << id << endl;\r\n\t\t\t\t\tcerr << \"name = \" << svgPtrVec[id]->name() << \" isVisible = \" << svgPtrVec[id]->isVisible() <<\r\n\t\t\t\t\tendl;\r\n\t\t\t\t\tcerr << \"size = \" << svgPtrVec[id]->polygonVec().size() << endl;\r\n#endif // GRAPHICSVIEW_DEBUG\r\n\t\t\t\t\tvector< KeiRo::Base::Coord2 > &samples = svgPtrVec[ id ]->compressionGrid().samples();\r\n\t\t\t\t\tvector< KeiRo::Base::Polygon2 > &polygonVec = svgPtrVec[ id ]->polygonVec();\r\n\r\n\t\t\t\t\t// polygons\r\n\t\t\t\t\tfor( unsigned int i = 0; i < polygonVec.size(); i++ ) {\r\n\r\n\t\t\t\t\t\tunsigned long attributeID = m*1e10 + n*1e5 + i;\r\n\t\t\t\t\t\tbool &isVisible = polygonVec[ i ].isVisible();\r\n\t\t\t\t\t\tUi::Vector::GraphicsPolygonItem *itemptr = new Ui::Vector::GraphicsPolygonItem;\r\n\t\t//\t\t\t\tpolygonVec[ i ].setItemPtr( itemptr );\r\n\t\t\t\t\t\tpolygonVec[ i ].itemID() = _polygonItemMap.size();\r\n\t\t\t\t\t\t_polygonItemMap.insert( pair< unsigned long, Ui::Vector::GraphicsPolygonItem * >( attributeID, itemptr ) );\r\n\t\t\t\t\t\tif( isVisible ) itemptr->show();\r\n\t\t\t\t\t\telse itemptr->hide();\r\n\r\n\t\t\t\t\t\t// set polygon color\r\n\t\t\t\t\t\tvector< unsigned int > &cs = polygonVec[ i ].stroke();\r\n\t\t\t\t\t\tvector< unsigned int > &cf = polygonVec[ i ].fill();\r\n\t\t\t\t\t\t//\t\t\t\t\t\t\tcerr << \"polygonVec[ i ].strokeWidth() = \" << polygonVec[ i ].strokeWidth() << endl;\r\n\t\t\t\t\t\titemptr->setPen( QPen( QColor( cs[0], cs[1], cs[2], cs[3] ), polygonVec[ i ].strokeWidth() ) );\r\n\t\t\t\t\t\titemptr->setBrush( QBrush( QColor( cf[0], cf[1], cf[2], cf[3] ), Qt::SolidPattern ) );\r\n\t\t\t\t\t\titemptr->defaultPen() = itemptr->pen();\r\n\t\t\t\t\t\titemptr->defaultBrush() = itemptr->brush();\r\n\r\n\r\n\r\n\t\t\t\t\t\t// add selected polygons\r\n\t\t\t\t\t\tif( polygonVec[ i ].isSelected() ) {\r\n\r\n\r\n\t\t\t\t\t\t\tQColor color = QColor( 255, 100, 100, 255 );\r\n\t\t\t\t\t\t\titemptr->setPen( QPen( QColor( 0, 0, 0, 255 ), polygonVec[ i ].strokeWidth() ) );\r\n\t\t\t\t\t\t\titemptr->setBrush( QBrush( QColor( color.red(), color.green(), color.blue(), 255 ),\r\n\t\t\t\t\t\t\t                           Qt::SolidPattern ) );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tKeiRo::Base::Rectangle2 &bbox = polygonVec[ i ].boundingBox();\r\n\t\t\t\t\t\tdouble borderWidth = MIN2( borderWidth, _marginRatio*bbox.width() );\r\n\t\t\t\t\t\tdouble borderHeight = MIN2( borderWidth, _marginRatio*bbox.height() );\r\n//\t\t\t\t\t\tKeiRo::Base::Rectangle2 &oldBbox = polygonVec[ i ].oldBoundingBox();\r\n\t\t\t\t\t\tKeiRo::Base::Coord2 center( bbox.leftBottom().x() + 0.5*bbox.width(),\r\n\t\t\t\t\t\t\t\t                    bbox.leftBottom().y() + 0.5*bbox.height() );\r\n\t\t\t\t\t\tKeiRo::Base::Coord2 oldCenter( bbox.oldLeftBottom().x() + 0.5*bbox.oldWidth(),\r\n\t\t\t\t\t\t                               bbox.oldLeftBottom().y() + 0.5*bbox.oldHeight() );\r\n\t\t\t\t\t\tdouble scaleX = (bbox.width() - (m+1)*borderWidth)/bbox.width();\r\n\t\t\t\t\t\tdouble scaleY = (bbox.height() - (m+1)*borderHeight)/bbox.height();\r\n\t\t\t\t\t\tdouble oldScaleX = (bbox.oldWidth() - (m+1)*borderWidth)/bbox.oldWidth();\r\n\t\t\t\t\t\tdouble oldScaleY = (bbox.oldHeight() - (m+1)*borderHeight)/bbox.oldHeight();\r\n\t\t\t\t\t\titemptr->bbox() = QRect( bbox.leftBottom().x(),\r\n\t\t\t\t\t\t                         bbox.leftBottom().y(),\r\n\t\t\t\t\t\t                         bbox.width(),\r\n\t\t\t\t\t\t                         bbox.height() );\r\n\r\n//\t\t\t\t\t\tif( _fonts.size() < m + 1 ) {\r\n//\t\t\t\t\t\t\tQFont qfont;\r\n//\t\t\t\t\t\t\tqfont.setPointSize( 20 );\r\n//\t\t\t\t\t\t\titemptr->font() = qfont;\r\n//\t\t\t\t\t\t}\r\n//\t\t\t\t\t\telse\r\n\t\t\t\t\t\titemptr->font() = lensSettings->fonts()[m];  // font(layer m)\r\n\t\t\t\t\t\titemptr->id() = i;\r\n\r\n//\t\t\t\t\t\titemptr->text() = QString::fromStdString( to_string( i ) );\r\n\t\t\t\t\t\titemptr->text() = QString::fromStdString( polygonVec[ i ].label() );\r\n//\t\t\t\t\t\titemptr->text() = QString::fromStdString( polygonVec[ i ].name() ) + QString( \": \" ) +\r\n//\t\t\t\t\t\t                  QString::fromStdString( to_string( i ) );\r\n//\t\t\t\t\t\tQFontMetrics fm( itemptr->font() );\r\n//\t\t\t\t\t\tdouble sx = fm.width( itemptr->text() );\r\n//\t\t\t\t\t\tdouble sy = fm.height();\r\n//\t\t\t\t\t\tif( ( sx < bbox.width() ) && ( sy < bbox.height() ) ){\r\n//\t\t\t\t\t\t\titemptr->textOn() = true;\r\n//\t\t\t\t\t\t}\r\n//\t\t\t\t\t\telse{\r\n//\t\t\t\t\t\t\titemptr->textOn() = false;\r\n//\t\t\t\t\t\t}\r\n\t\t\t\t\t\titemptr->textOn() = polygonVec[i].isTextVisible();\r\n\r\n\t\t\t\t\t\tQPolygonF oldPolygon, polygon;\r\n\t\t\t\t\t\tunsigned int size = polygonVec[ i ].elements().size();\r\n\t\t\t\t\t\tfor( unsigned int j = 0; j < size; j++ ) {\r\n\t\t\t\t\t\t\tunsigned int elementID = polygonVec[ i ].idElements()[ j ];\r\n\r\n//\t\t\t\t\t\t\tif( m == 1 && n == 0 && i == 0 ){\r\n//\t\t\t\t\t\t\t\tcerr << \"mypoly = \" << polygonVec[ i ] << endl;\r\n//\t\t\t\t\t\t\t}\r\n\r\n//\t\t\t\t\t\t\tpolygon.append( QPoint( samples[ id ].x(), -samples[ id ].y() ) );\r\n//\t\t\t\t\t\t\tpolygon.append( QPoint( scaleX * ( polygonVec[ i ].elements()[j].x() - center.x() ) + center.x(),\r\n//\t\t\t\t\t\t\t                        -( scaleY * ( polygonVec[ i ].elements()[j].y() - center.y() ) + center.y() )));\r\n\t\t\t\t\t\t\tpolygon.append( QPoint( scaleX * ( samples[ elementID ].x() - center.x() ) + center.x(),\r\n\t\t\t\t\t\t\t                           -( scaleY * ( samples[ elementID ].y() - center.y() ) + center.y() )));\r\n\t\t\t\t\t\t\toldPolygon.append( QPoint( oldScaleX * ( samples[ elementID ].oldElement()[0] - oldCenter.x() ) + oldCenter.x(),\r\n\t\t\t\t\t\t\t                           -( oldScaleY * ( samples[ elementID ].oldElement()[1] - oldCenter.y() ) + oldCenter.y() )));\r\n#ifdef DEBUG\r\n\t\t\t\t\t\t\tif( id == 7 ){\r\n\t\t\t\t\t\t\t\tcerr << \"x = \" << samples[ elementID ].element()[0] << \", \";\r\n\t\t\t\t\t\t\t\tcerr << \"y = \" << samples[ elementID ].element()[1] << endl;\r\n\t\t\t\t\t\t\t\tcerr << \"ox = \" << samples[ elementID ].oldElement()[0] << \", \";\r\n\t\t\t\t\t\t\t\tcerr << \"oy = \" << samples[ elementID ].oldElement()[1] << endl;\r\n\t\t\t\t\t\t\t\tcerr << \"px = \" << polygonVec[ i ].elements()[j].x() << \", \";\r\n\t\t\t\t\t\t\t\tcerr << \"py = \" << polygonVec[ i ].elements()[j].y() << endl;\r\n\t\t\t\t\t\t\t}\r\n#endif // DEBUG\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (_isPathSelectionMode == false) {\r\n\t\t\t\t\t\t\titemptr->setPolygon( polygon );\r\n\t\t\t\t\t\t\titemptr->setAcceptHoverEvents( true );\r\n\t\t\t\t\t\t\titemptr->setFlag( QGraphicsItem::ItemIsSelectable );\r\n\t\t\t\t\t\t\titemptr->attributeID() = attributeID;\r\n\t\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\t\t_scenePtr->addItem( itemptr );\r\n\r\n\t\t\t\t\t\tQPropertyAnimation *animation = new QPropertyAnimation( itemptr, \"polygon\" );\r\n\t\t\t\t\t\tanimation->setDuration( ANIMATE_DURATION );\r\n\t\t\t\t\t\tanimation->setStartValue( oldPolygon );\r\n//\t\t\t\t\t\tanimation->setEndValue( oldPolygon );\r\n\t\t\t\t\t\tanimation->setEndValue( polygon );\r\n\t\t\t\t\t\tanimation->setEasingCurve( QEasingCurve::Linear );\r\n\t\t\t\t\t\tanimation->start( QAbstractAnimation::DeleteWhenStopped );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n//\t\t\tfor( unsigned int m = 0; m < MAX2( 0, (int)sortedLevel.size()-1 ); m++ ) {\r\n//\t\t\t\tfor( unsigned int n = 0; n < sortedLevel[m].size(); n++ ) {\r\n//\r\n//\t\t\t\t\tunsigned int id = sortedLevel[ m ][ n ];\r\n//\r\n//\t\t\t\t\tvector <KeiRo::Base::Coord2> &samples = svgPtrVec[ id ]->compressionGrid().samples();\r\n//\t\t\t\t\tvector <KeiRo::Base::Polygon2> &polygonVec = svgPtrVec[ id ]->polygonVec();\r\n//\r\n//\t\t\t\t\tbool isEnough = false;\r\n//\t\t\t\t\tfor( unsigned int i = 0; i < polygonVec.size(); i++ ){\r\n//\t\t\t\t\t\tUi::Vector::GraphicsPolygonItem *itemptr = _polygonItemVec[ polygonVec[i].itemID() ];\r\n//\r\n//\t\t\t\t\t\tQFontMetrics fm( itemptr->font() );\r\n//\t\t\t\t\t\tdouble sx = fm.width( itemptr->text() );\r\n//\t\t\t\t\t\tif( sx < itemptr->bbox().width() ){\r\n//\t\t\t\t\t\t\tisEnough = true;\r\n//\t\t\t\t\t\t}\r\n//\t\t\t\t\t}\r\n//\t\t\t\t\tif( isEnough == false ){\r\n//\t\t\t\t\t\tfor( unsigned int i = 0; i < polygonVec.size(); i++ ) {\r\n//\t\t\t\t\t\t\tUi::Vector::GraphicsPolygonItem *itemptr = _polygonItemVec[ polygonVec[i].itemID() ];\r\n//\t\t\t\t\t\t\titemptr->hide();\r\n//\t\t\t\t\t\t}\r\n//\t\t\t\t\t}\r\n//\t\t\t\t\telse{\r\n//\t\t\t\t\t\tfor( unsigned int i = 0; i < polygonVec.size(); i++ ) {\r\n//\t\t\t\t\t\t\tUi::Vector::GraphicsPolygonItem *itemptr = _polygonItemVec[ polygonVec[i].itemID() ];\r\n//\t\t\t\t\t\t\titemptr->show();\r\n//\t\t\t\t\t\t}\r\n//\t\t\t\t\t}\r\n//\t\t\t\t}\r\n//\t\t\t}\r\n#ifdef GRAPHICVIEW_DEBUG\r\n\t\t\tfor( unsigned int m = 0; m < _svgPtr.size(); m++ ) {\r\n\t\t\t\tfor( unsigned int n = 0; n < _svgPtr[ m ].size(); n++ ) {\r\n\r\n#ifdef GRAPHICSVIEW_DEBUG\r\n\t\t\t\t\tcerr << \"m = \" << m << \", n = \" << n << endl;\r\n\t\t\t\t\tcerr << \"name = \" << (*_svgPtr)[m][n].name() << \" isVisible = \" << (*_svgPtr)[m][n].isVisible() << endl;\r\n\t\t\t\t\tcerr << \"size = \" << (*_svgPtr)[m][n].polygonVec().size() << endl;\r\n#endif // GRAPHICSVIEW_DEBUG\r\n\t\t\t\t\tvector< KeiRo::Base::Coord2 > &samples = _svgPtr[ m ][ n ]->compressionGrid().samples();\r\n\t\t\t\t\tvector< KeiRo::Base::Polygon2 > &polygonVec = _svgPtr[ m ][ n ]->polygonVec();\r\n\r\n\t\t\t\t\t// polygons\r\n\t\t\t\t\tfor( unsigned int i = 0; i < polygonVec.size(); i++ ) {\r\n\r\n\t\t\t\t\t\tQPolygonF polygon;\r\n\t\t\t\t\t\tunsigned int size = polygonVec[ i ].elements().size();\r\n\t\t\t\t\t\tfor( unsigned int j = 0; j < size; j++ ) {\r\n\r\n\t\t\t\t\t\t\tUi::Vector::GraphicsVertexItem *itemptr = new Ui::Vector::GraphicsVertexItem;\r\n\t\t\t\t\t\t\tunsigned int id = polygonVec[ i ].idElements()[ j ];\r\n\r\n\t\t\t\t\t\t\titemptr->show();\r\n\r\n\t\t\t\t\t\t\tvector< unsigned int > &cs = polygonVec[ i ].stroke();\r\n\t\t\t\t\t\t\tvector< unsigned int > &cf = polygonVec[ i ].fill();\r\n\t\t\t\t\t\t\titemptr->setPen( QPen( QColor( cs[ 0 ], cs[ 1 ], cs[ 2 ], 255 ), 5 ) );\r\n\t\t\t\t\t\t\titemptr->setBrush( QBrush( QColor( cf[ 0 ], cf[ 1 ], cf[ 2 ], 255 ), Qt::SolidPattern ) );\r\n\r\n\t\t\t\t\t\t\titemptr->setRect( QRectF( samples[ id ].x(), -samples[ id ].y(), 10, 10 ) );\r\n\r\n\t\t\t\t\t\t\titemptr->textOn() = true;\r\n\t\t\t\t\t\t\titemptr->id() = i;\r\n\t\t\t\t\t\t\titemptr->text() = QString::fromStdString( to_string( j ) );\r\n//\t\t\t\t\t\t\titemptr->text() = QString::fromStdString( polygonVec[ i ].name() ) + QString( \": \" ) +\r\n//\t\t\t\t\t\t\t                  QString::fromStdString( to_string( j ) );\r\n\t\t\t\t\t\t\t_scenePtr->addItem( itemptr );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n#endif // GRAPHICVIEW_DEBUG\r\n\r\n\t\t#ifdef GRAPHICVIEW_DEBUG\r\n\t\t\t// bounding box\r\n\t\t\t\t\tfor( unsigned int i = 0; i < (*_polygonVecPtr).size(); i++ ){\r\n\r\n\t\t\t\t\t\tVector::GraphicsPolygonItem * itemptr = new Ui::Vector::GraphicsPolygonItem;\r\n\t\t\t\t\t\t(*_polygonVecPtr)[i].setItemPtr( itemptr );\r\n\t\t\t\t\t\tQColor color;\r\n\t\t\t\t\t\tif( (*_polygonVecPtr)[i].isSelected() ) {\r\n\t\t\t\t\t\t\tcolor = QColor( 100, 100, 100, 255 );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tcolor = QColor( 200, 200, 200, 255 );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\titemptr->setPen( QPen( QColor( 100, 0, 0, 255 ), 10 ) );\r\n\t\t\t\t\t\titemptr->setBrush( QBrush( QColor( color.red(), color.green(), color.blue(), 255 ), Qt::SolidPattern ) );\r\n\t\t\t\t\t\titemptr->bbox() = QRect( (*_polygonVecPtr)[i].boxLeftTop().x(),\r\n\t\t\t\t\t\t\t\t\t\t\t\t (*_polygonVecPtr)[i].boxLeftTop().y(),\r\n\t\t\t\t\t\t\t\t\t\t\t\t (*_polygonVecPtr)[i].boundingBox().x(),\r\n\t\t\t\t\t\t\t\t\t\t\t\t (*_polygonVecPtr)[i].boundingBox().y() );\r\n\t\t\t\t\t\titemptr->textOn() = true;\r\n\t\t\t\t\t\titemptr->id() = i;\r\n\t\t\t\t\t\titemptr->text() = QString::fromStdString( (*_polygonVecPtr)[i].name() ) + QString( \": \" ) + QString::fromStdString( to_string( i ) );\r\n\r\n\t\t\t\t\t\tQPolygonF polygon;\r\n\r\n\t\t\t\t\t\tpolygon.append( QPoint( (*_polygonVecPtr)[i].boxLeftTop().x(), -(*_polygonVecPtr)[i].boxLeftTop().y() ) );\r\n\t\t\t\t\t\tpolygon.append( QPoint( (*_polygonVecPtr)[i].boxLeftTop().x()+(*_polygonVecPtr)[i].boundingBox().x(),\r\n\t\t\t\t\t\t\t\t\t\t\t   -(*_polygonVecPtr)[i].boxLeftTop().y() ) );\r\n\t\t\t\t\t\tpolygon.append( QPoint( (*_polygonVecPtr)[i].boxLeftTop().x()+(*_polygonVecPtr)[i].boundingBox().x(),\r\n\t\t\t\t\t\t\t\t\t\t\t\t-(*_polygonVecPtr)[i].boxLeftTop().y()-(*_polygonVecPtr)[i].boundingBox().y() ) );\r\n\t\t\t\t\t\tpolygon.append( QPoint( (*_polygonVecPtr)[i].boxLeftTop().x(),\r\n\t\t\t\t\t\t\t\t\t\t\t\t-(*_polygonVecPtr)[i].boxLeftTop().y()-(*_polygonVecPtr)[i].boundingBox().y() ) );\r\n\r\n\t\t\t\t\t\titemptr->setPolygon( polygon );\r\n\t\t\t\t\t\titemptr->setAcceptHoverEvents( true );\r\n\t\t\t\t\t\titemptr->setFlag( QGraphicsItem::ItemIsSelectable );\r\n\t\t\t\t\t\t_scenePtr->addItem( itemptr );\r\n\t\t\t\t\t}\r\n\t\t#endif // GRAPHICVIEW_DEBUG\r\n\r\n\t\t#ifdef GRAPHICVIEW_DEBUG\r\n\t\t\t// picking cursor\r\n\t\t\t\t\t_scenePtr->addPath( _selectionArea );\r\n\t\t#endif // GRAPHICVIEW_DEBUG\r\n\t\t}\r\n\r\n\t\t//\r\n\t\t//  TreemapGraphicsView::_item_polygonVertices -- draw polygons\r\n\t\t//\r\n\t\t//  Inputs\r\n\t\t//  none\r\n\t\t//\r\n\t\t//  Outputs\r\n\t\t//  none\r\n\t\t//\r\n\t\tvoid TreemapGraphicsView::_item_polygonVertices( void ) {\r\n\r\n\t\t\tvector< FileIO::SVG* > &svgPtrVec = _metadataPtr->svgPtrVec();\r\n\t\t\tvector< vector< unsigned int > > &sortedLevel = _hierarchicalTreemap.sortedLevel();\r\n\t\t\tdouble borderWidth = 0.0;\r\n\t\t\tif( _is_interactionFlag == true ) borderWidth = _metadataPtr->borderWidth();\r\n\r\n\t\t\tfor( unsigned int m = sortedLevel.size()-1; m < sortedLevel.size(); m++ ) {\r\n\t\t\t\tfor( unsigned int n = 0; n < sortedLevel[m].size(); n++ ) {\r\n\r\n\t\t\t\t\tunsigned int id = sortedLevel[m][n];\r\n#ifdef GRAPHICSVIEW_DEBUG\r\n\t\t\t\t\tcerr << \"m = \" << m << \", n = \" << n << \" id = \" << id << endl;\r\n\t\t\t\t\tcerr << \"name = \" << svgPtrVec[id]->name() << \" isVisible = \" << svgPtrVec[id]->isVisible() <<\r\n\t\t\t\t\tendl;\r\n\t\t\t\t\tcerr << \"size = \" << svgPtrVec[id]->polygonVec().size() << endl;\r\n#endif // GRAPHICSVIEW_DEBUG\r\n\t\t\t\t\tvector< KeiRo::Base::Coord2 > &samples = svgPtrVec[ id ]->compressionGrid().samples();\r\n\t\t\t\t\tvector< KeiRo::Base::Polygon2 > &polygonVec = svgPtrVec[ id ]->polygonVec();\r\n\r\n\t\t\t\t\t// polygons\r\n\t\t\t\t\tfor( unsigned int i = 0; i < polygonVec.size(); i++ ) {\r\n\r\n\t\t\t\t\t\tunsigned long attributeID = m*1e10 + n*1e5 + i;\r\n\t\t\t\t\t\tbool &isVisible = polygonVec[ i ].isVisible();\r\n\t\t\t\t\t\tUi::Vector::GraphicsVertexItem *itemptr = new Ui::Vector::GraphicsVertexItem;\r\n//\t\t\t\t\t\tpolygonVec[ i ].setItemPtr( itemptr );\r\n//\t\t\t\t\t\tpolygonVec[ i ].itemID() = _polygonItemVec.size();\r\n//\t\t\t\t\t\t_polygonItemVec.push_back( itemptr );\r\n\t\t\t\t\t\tif( isVisible ) itemptr->show();\r\n\t\t\t\t\t\telse itemptr->hide();\r\n\r\n\t\t\t\t\t\t// add selected polygons\r\n\t\t\t\t\t\tif( polygonVec[ i ].isSelected() ) {\r\n\t\t\t\t\t\t\tQColor color = QColor( 255, 100, 100, 255 );\r\n\t\t\t\t\t\t\titemptr->setPen( QPen( QColor( 0, 0, 0, 255 ), 0.5*polygonVec[ i ].strokeWidth() ) );\r\n\t\t\t\t\t\t\titemptr->setBrush( QBrush( QColor( color.red(), color.green(), color.blue(), 255 ),\r\n\t\t\t\t\t\t\t                           Qt::SolidPattern ) );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tvector< unsigned int > &cs = polygonVec[ i ].stroke();\r\n\t\t\t\t\t\t\tvector< unsigned int > &cf = polygonVec[ i ].fill();\r\n//\t\t\t\t\t\t\tcerr << \"polygonVec[ i ].strokeWidth() = \" << polygonVec[ i ].strokeWidth() << endl;\r\n\t\t\t\t\t\t\titemptr->setPen( QPen( QColor( cs[0], cs[1], cs[2], cs[3] ), 0.5*polygonVec[ i ].strokeWidth() ) );\r\n//\t\t\t\t\t\t\titemptr->setPen( QPen( QColor( cs[ 0 ], cs[ 1 ], cs[ 2 ], 255 ), 5 ) );\r\n\t\t\t\t\t\t\titemptr->setBrush( QBrush( QColor( cf[0], cf[1], cf[2], cf[3] ), Qt::SolidPattern ) );\r\n\t\t\t\t\t\t\titemptr->textpen() = QPen( QColor( 0, 0, 0, 255 ), 2 );\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\titemptr->textOn() = true;\r\n\t\t\t\t\t\titemptr->id() = i;\r\n\t\t\t\t\t\titemptr->text() = QString::fromStdString( polygonVec[ i ].label() );\r\n\r\n//\t\t\t\t\t\tif( _fonts.size() < m + 1 ) {\r\n//\t\t\t\t\t\t\tQFont qfont;\r\n//\t\t\t\t\t\t\tqfont.setPointSize(14);\r\n//\t\t\t\t\t\t\titemptr->font() = qfont;\r\n//\t\t\t\t\t\t}\r\n//\t\t\t\t\t\telse\r\n\t\t\t\t\t\titemptr->font() = lensSettings->fonts()[m];  // font(layer m)\r\n\r\n\t\t\t\t\t\t//\t        1. get font: width & height\r\n\t\t\t\t\t\tQFontMetrics fm( itemptr->font());\r\n\t\t\t\t\t\tint pxFntWidth = fm.width( itemptr->text() ),\r\n\t\t\t\t\t\t\tpxFntHeight = fm.height();\r\n\r\n\t\t\t\t\t\t//\t\t\t2. refresh bbox(leftBottom)\r\n\t\t\t\t\t\tKeiRo::Base::Rectangle2 &bbox = polygonVec[ i ].boundingBox();\r\n\t\t\t\t\t\tKeiRo::Base::Rectangle2 oldbbox;\r\n\t\t\t\t\t\toldbbox.leftBottom() = bbox.oldLeftBottom();\r\n\t\t\t\t\t\toldbbox.width() = bbox.oldWidth();\r\n\t\t\t\t\t\toldbbox.height() = bbox.oldHeight();\r\n\t\t\t\t\t\tKeiRo::Base::Coord2 center( bbox.leftBottom().x() + 0.5*bbox.width(),\r\n\t\t\t\t\t\t                            bbox.leftBottom().y() + 0.5*bbox.height() );\r\n\t\t\t\t\t\tKeiRo::Base::Coord2 oldCenter( oldbbox.leftBottom().x() + 0.5*oldbbox.width(),\r\n\t\t\t\t\t\t                               oldbbox.leftBottom().y() + 0.5*oldbbox.height() );\r\n\r\n#ifdef DEBUG\r\n\t\t\t\t\t\tfor( unsigned int m = 0; m < polygonVec.size(); m++ ){\r\n\t\t\t\t\t\t\tcerr << polygonVec[m].elements()[m];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcerr << \"bbox = \" << bbox;\r\n\t\t\t\t\t\tcerr << \"old = \" << bbox.oldLeftBottom();\r\n\t\t\t\t\t\tcerr << \"ow = \" << bbox.oldWidth() << endl;\r\n\t\t\t\t\t\tcerr << \"new = \" << bbox.leftBottom();\r\n\t\t\t\t\t\tcerr << \"nw = \" << bbox.width() << endl;\r\n#endif // DEBUG\r\n\r\n\t\t\t\t\t\tbbox.width() = pxFntWidth + 2*_padding;\r\n\t\t\t\t\t\tbbox.height() = pxFntHeight + 2*_padding;\r\n\t\t\t\t\t\tbbox.leftBottom().x() = center.x() - 0.5*bbox.width();\r\n\t\t\t\t\t\tbbox.leftBottom().y() = center.y() - 0.5*bbox.height();\r\n\t\t\t\t\t\toldbbox.width() = pxFntWidth + 2*_padding;\r\n\t\t\t\t\t\toldbbox.height() = pxFntHeight + 2*_padding;\r\n\t\t\t\t\t\toldbbox.leftBottom().x() = oldCenter.x() - 0.5*oldbbox.width();\r\n\t\t\t\t\t\toldbbox.leftBottom().y() = oldCenter.y() - 0.5*oldbbox.height();\r\n\r\n\r\n\t\t\t\t\t\titemptr->setGeometry(QRect( oldbbox.leftBottom().x(),\r\n\t\t\t\t\t\t                            -oldbbox.leftBottom().y() - oldbbox.height(),\r\n\t\t\t\t\t\t                            oldbbox.width(),\r\n\t\t\t\t\t\t                            oldbbox.height() ) );\r\n\r\n\t\t\t\t\t\titemptr->targetRect() = QRect( bbox.leftBottom().x(),\r\n\t\t\t\t\t\t                               -bbox.leftBottom().y() - bbox.height(),\r\n\t\t\t\t\t\t                               bbox.width(),\r\n\t\t\t\t\t\t                               bbox.height() );\r\n\t\t\t\t\t\titemptr->radius() = (double)_padding;\r\n\r\n\t\t\t\t\t\t// disable clicking\r\n\t\t\t\t\t\titemptr->setAcceptHoverEvents( false );\r\n\t\t\t\t\t\titemptr->setFlag( QGraphicsItem::ItemIsSelectable, false );\r\n\t\t\t\t\t\titemptr->isSimple() = false;\r\n\t\t\t\t\t\t_scenePtr->addItem( itemptr );\r\n\r\n\t\t\t\t\t\tQPropertyAnimation *animation = new QPropertyAnimation( itemptr, \"geometry\" );\r\n\t\t\t\t\t\tanimation->setDuration( ANIMATE_DURATION );\r\n\t\t\t\t\t\tanimation->setStartValue( itemptr->sourceRect() );\r\n\t\t\t\t\t\tanimation->setEndValue( itemptr->targetRect() );\r\n\t\t\t\t\t\tanimation->setEasingCurve( QEasingCurve::Linear );\r\n\t\t\t\t\t\tanimation->start( QAbstractAnimation::DeleteWhenStopped );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//\r\n\t\t//  TreemapGraphicsView::_update_item_polygons -- draw polygons\r\n\t\t//\r\n\t\t//  Inputs\r\n\t\t//  none\r\n\t\t//\r\n\t\t//  Outputs\r\n\t\t//  none\r\n\t\t//\r\n\t\tvoid TreemapGraphicsView::_update_item_polygons( void ) {\r\n#ifdef SKIP\r\n\t\t\tvector< FileIO::SVG* > &svgPtrVec = _metadataPtr->svgPtrVec();\r\n\t\t\tvector< vector< unsigned int > > &sortedLevel = _hierarchicalTreemap.sortedLevel();\r\n\r\n\t\t\tfor( unsigned int m = 0; m < sortedLevel.size()-1; m++ ) {\r\n\t\t\t\tfor( unsigned int n = 0; n < sortedLevel[m].size(); n++ ) {\r\n\r\n\t\t\t\t\tunsigned int id = sortedLevel[ m ][ n ];\r\n\t\t\t\t\t// cerr << \"m = \" << m << \", n = \" << n << \" id = \" << id << endl;\r\n\t\t\t\t\t// cerr << \"name = \" << (*_svgPtr)[m][n].name() << \" isVisible = \" << (*_svgPtr)[m][n].isVisible() << endl;\r\n\t\t\t\t\tvector< KeiRo::Base::Coord2 > &samples = svgPtrVec[ id ]->compressionGrid().samples();\r\n\t\t\t\t\tvector< KeiRo::Base::Polygon2 > &polygonVec = svgPtrVec[ id ]->polygonVec();\r\n\r\n\t\t\t\t\t// polygons\r\n\t\t\t\t\tfor( unsigned int i = 0; i < polygonVec.size(); i++ ) {\r\n\r\n\t\t\t\t\t\tbool &isVisible = polygonVec[ i ].isVisible();\r\n\t\t\t\t\t\t//\t\t\t\tUi::Vector::GraphicsPolygonItem *itemptr = polygonVec[ i ].getItemPtr();\r\n\t\t\t\t\t\tUi::Vector::GraphicsPolygonItem *itemptr = _polygonItemVec[ polygonVec[ i ].itemID() ];\r\n\t\t\t\t\t\t// polygonVec[i].setItemPtr( itemptr );\r\n\t\t\t\t\t\tif( isVisible ) itemptr->show();\r\n\t\t\t\t\t\telse itemptr->hide();\r\n\t\t\t\t\t\t// add selected polygons\r\n\t\t\t\t\t\tif( polygonVec[ i ].isSelected() ) {\r\n\t\t\t\t\t\t\tQColor color = QColor( 255, 100, 100, 255 );\r\n\t\t\t\t\t\t\titemptr->setPen( QPen( QColor( 0, 0, 0, 255 ), polygonVec[ i ].strokeWidth() ) );\r\n\t\t\t\t\t\t\titemptr->setBrush( QBrush( QColor( color.red(), color.green(), color.blue(), 255 ),\r\n\t\t\t\t\t\t\t                           Qt::SolidPattern ) );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tvector< unsigned int > &cs = polygonVec[ i ].stroke();\r\n\t\t\t\t\t\t\tvector< unsigned int > &cf = polygonVec[ i ].fill();\r\n//\t\t\t\t\t\t\tcerr << \"polygonVec[ i ].strokeWidth() = \" << polygonVec[ i ].strokeWidth() << endl;\r\n\t\t\t\t\t\t\titemptr->setPen( QPen( QColor( cs[0], cs[1], cs[2], cs[3] ), polygonVec[ i ].strokeWidth() ) );\r\n//\t\t\t\t\t\t\titemptr->setPen( QPen( QColor( cs[ 0 ], cs[ 1 ], cs[ 2 ], 255 ), 5 ) );\r\n\t\t\t\t\t\t\titemptr->setBrush( QBrush( QColor( cf[0], cf[1], cf[2], cf[3] ), Qt::SolidPattern ) );\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\titemptr->bbox() = QRect( polygonVec[ i ].boundingBox().leftBottom().x(),\r\n\t\t\t\t\t\t                         polygonVec[ i ].boundingBox().leftBottom().y(),\r\n\t\t\t\t\t\t                         polygonVec[ i ].boundingBox().width(),\r\n\t\t\t\t\t\t                         polygonVec[ i ].boundingBox().height() );\r\n\r\n\t\t\t\t\t\titemptr->textOn() = true;\r\n\t\t\t\t\t\titemptr->id() = i;\r\n\t\t\t\t\t\titemptr->text() = QString::fromStdString( polygonVec[ i ].name() ) + QString( \": \" ) +\r\n\t\t\t\t\t\t                  QString::fromStdString( to_string( i ) );\r\n\r\n\t\t\t\t\t\tQPolygonF oldPolygon, polygon;\r\n\t\t\t\t\t\tunsigned int size = polygonVec[ i ].elements().size();\r\n\t\t\t\t\t\tfor( unsigned int j = 0; j < size; j++ ) {\r\n\t\t\t\t\t\t\tunsigned int id = polygonVec[ i ].idElements()[ j ];\r\n//\t\t\t\t\t\tcerr << \"i = \" << i << \", sample = \" << samples[id];\r\n\t\t\t\t\t\t\tpolygon.append( QPoint( samples[ id ].x(), -samples[ id ].y() ) );\r\n\t\t\t\t\t\t\toldPolygon.append( QPoint( polygonVec[ i ].elements()[ j ].oldElement()[0],\r\n\t\t\t\t\t\t\t\t                      -polygonVec[ i ].elements()[ j ].oldElement()[1] ) );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\titemptr->setPolygon( polygon );\r\n\t\t\t\t\t\titemptr->setAcceptHoverEvents( true );\r\n\t\t\t\t\t\titemptr->setFlag( QGraphicsItem::ItemIsSelectable );\r\n\t\t\t\t\t\titemptr->show();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n#endif // SKIP\r\n\t\t}\r\n\r\n\t\t//\r\n\t\t//  TreemapGraphicsView::_item_polylines -- draw polylines\r\n\t\t//\r\n\t\t//  Inputs\r\n\t\t//  none\r\n\t\t//\r\n\t\t//  Outputs\r\n\t\t//  none\r\n\t\t//\r\n\t\tvoid TreemapGraphicsView::_item_polylines( void )\r\n\t\t{\r\n\t\t\tif( _metadataPtr == NULL ) return;\r\n\t\t\tvector< FileIO::SVG* > &svgPtrVec = _metadataPtr->svgPtrVec();\r\n\r\n\t\t\t_polylineItemVec.clear();\r\n\t\t\tfor( unsigned int m = 0; m < svgPtrVec.size(); m++ ) {\r\n\r\n\t\t\t\tvector< KeiRo::Base::Coord2 > &samples = svgPtrVec[ m ]->compressionGrid().samples();\r\n\t\t\t\tvector< KeiRo::Base::Line2 > &polylineVec = svgPtrVec[ m ]->polylineVec();\r\n\r\n\t\t\t\tfor( unsigned int i = 0; i < polylineVec.size(); i++ ) {\r\n\r\n\t\t\t\t\tbool &isVisible = polylineVec[ i ].isVisible();\r\n\r\n\t\t\t\t\tunsigned int size = polylineVec[ i ].elements().size();\r\n\t\t\t\t\tfor( unsigned int j = 1; j < size; j++ ) {\r\n\r\n//\t\t\t\t\t\tunsigned int oidA = polylineVec[ i ].oldElements()[ j-1 ];\r\n//\t\t\t\t\t\tunsigned int oidB = polylineVec[ i ].oldElements()[ j ];\r\n\t\t\t\t\t\tunsigned int idA = polylineVec[ i ].idElements()[ j-1 ];\r\n\t\t\t\t\t\tunsigned int idB = polylineVec[ i ].idElements()[ j ];\r\n\r\n\t\t\t\t\t\tUi::Vector::GraphicsEdgeItem *itemptr = new Ui::Vector::GraphicsEdgeItem;\r\n\t\t\t\t\t\t// _svgPtr[ m ][ n ]->polylineVec()[ i ].setItemPtr( itemptr );\r\n//\t\t\t\t\tsvgPtrVec[ m ]->polylineVec()[ i ].itemID() = _polylineItemVec.size();\r\n//\t\t\t\t\t_polylineItemVec.push_back( itemptr );\r\n\t\t\t\t\t\tif( isVisible ) itemptr->show();\r\n\t\t\t\t\t\telse itemptr->hide();\r\n\r\n\t\t\t\t\t\tQColor color( 0, 0, 0, 255 );\r\n\t\t\t\t\t\titemptr->setPen( QPen( QColor( 100, 100, 100, 255 ), 3 ) ); // normal\r\n\t\t\t\t\t\titemptr->setPen( QPen( QColor( 100, 100, 100, 255 ), 3 ) ); // pan & zoom\r\n\r\n\t\t\t\t\t\tQLineF oldLine, line;\r\n\t\t\t\t\t\toldLine.setLine( samples[ idA ].oldElement()[0], -samples[ idA ].oldElement()[1],\r\n\t\t\t\t\t\t                 samples[ idB ].oldElement()[0], -samples[ idB ].oldElement()[1] );\r\n\t\t\t\t\t\tline.setLine( samples[ idA ].x(), -samples[ idA ].y(), samples[ idB ].x(), -samples[ idB ].y() );\r\n\t\t\t\t\t\titemptr->setLine( line );\r\n\t\t\t\t\t\t_scenePtr->addItem( itemptr );\r\n\r\n\t\t\t\t\t\tQPropertyAnimation *animation = new QPropertyAnimation( itemptr, \"line\" );\r\n\t\t\t\t\t\tanimation->setDuration( ANIMATE_DURATION );\r\n\t\t\t\t\t\tanimation->setStartValue( oldLine );\r\n\t\t\t\t\t\tanimation->setEndValue( line );\r\n\t\t\t\t\t\tanimation->setEasingCurve( QEasingCurve::Linear );\r\n\t\t\t\t\t\tanimation->start( QAbstractAnimation::DeleteWhenStopped );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//\r\n\t\t//  TreemapGraphicsView::_update_item_polylines -- update polylines\r\n\t\t//\r\n\t\t//  Inputs\r\n\t\t//  none\r\n\t\t//\r\n\t\t//  Outputs\r\n\t\t//  none\r\n\t\t//\r\n\t\tvoid TreemapGraphicsView::_update_item_polylines( void ) {\r\n\r\n\t\t\tvector< FileIO::SVG* > &svgPtrVec = _metadataPtr->svgPtrVec();\r\n\r\n\t\t\tfor( unsigned int m = 0; m < svgPtrVec.size(); m++ ) {\r\n\r\n\t\t\t\tvector< KeiRo::Base::Coord2 > &samples = svgPtrVec[ m ]->compressionGrid().samples();\r\n\t\t\t\tvector< KeiRo::Base::Line2 > &polylineVec = svgPtrVec[ m ]->polylineVec();\r\n\r\n\t\t\t\tfor( unsigned int i = 0; i < polylineVec.size(); i++ ) {\r\n\r\n\t\t\t\t\tbool &isVisible = polylineVec[ i ].isVisible();\r\n\t//\t\t\t\tUi::Vector::GraphicsEdgeItem *itemptr = polylineVec[ i ].getItemPtr();\r\n\t\t\t\t\tUi::Vector::GraphicsPathItem *itemptr = _polylineItemVec[ polylineVec[ i ].itemID() ];\r\n\t\t\t\t\t// (*_svgPtr)[m][n].polylineVec()[i].setItemPtr( itemptr );\r\n\t\t\t\t\t// itemptr->visibilityOn() = isVisible;\r\n\t\t\t\t\tif( isVisible ) itemptr->show();\r\n\t\t\t\t\telse itemptr->hide();\r\n\r\n\t\t\t\t\tQColor color( 0, 0, 0, 255 );\r\n\t\t\t\t\titemptr->setPen( QPen( QColor( 100, 100, 100, 255 ), 5 ) );\r\n\t\t\t\t\titemptr->setBrush( QBrush( QColor( 255, 255, 255, 0 ), Qt::SolidPattern ) );\r\n\r\n\t\t\t\t\tQPainterPath path;\r\n\t\t\t\t\tpath.moveTo( QPoint( samples[ polylineVec[ i ].idElements()[ 0 ] ].x(),\r\n\t\t\t\t\t                     -samples[ polylineVec[ i ].idElements()[ 0 ] ].y() ) );\r\n\r\n\t\t\t\t\tunsigned int size = polylineVec[ i ].elements().size();\r\n\t\t\t\t\tfor( unsigned int j = 1; j < size; j++ ) {\r\n\t\t\t\t\t\tunsigned int id = polylineVec[ i ].idElements()[ j ];\r\n\t\t\t\t\t\tpath.lineTo( QPoint( samples[ id ].x(), -samples[ id ].y() ) );\r\n\t\t\t\t\t}\r\n\t\t\t\t\titemptr->setPath( path );\r\n\r\n\t\t\t\t\t// _scenePtr->addItem( itemptr );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//\r\n\t\t//  TreemapGraphicsView::_item_globalPaths -- draw global paths\r\n\t\t//\r\n\t\t//  Inputs\r\n\t\t//  none\r\n\t\t//\r\n\t\t//  Outputs\r\n\t\t//  none\r\n\t\t//\r\nQColor generateDistinctColor(int index, int totalPaths) {\r\n\t\t\tconst double goldenRatioConjugate = 0.618033988749895;\r\n\t\t\tdouble hue = fmod(index * goldenRatioConjugate, 1.0);\r\n\r\n\r\n\t\t\tdouble saturation = 0.6;\r\n\t\t\tdouble value = 0.8;\r\n\r\n\t\t\treturn QColor::fromHsvF(hue, saturation, value);\r\n\t\t}\r\n\r\n\t\tvoid TreemapGraphicsView::_item_globalPaths( void )\r\n\t\t{\r\n\t\t\t_edgeItemMap.clear();\r\n\t\t\tvector< KeiRo::Base::Line2 > &pathVec = _globalPaths.globalPaths();\r\n\t\t\tvector< KeiRo::Base::Line2 > &pathVecShort = _globalPaths.globalPathsShort();\r\n\t\t\tvector< KeiRo::Base::Coord2 > &borderCoordVec = _globalPaths.borderCoordVec();\r\n\t\t\tvector< KeiRo::Base::Edge2 > &edgeAttributeVec = _globalPaths.edgeAttributeVec();\r\n\t\t\tvector< KeiRo::Base::Edge2 > &edgeAttributeVecShort = _globalPaths.edgeAttributeVecShort();\r\n\r\n\r\n\r\n\t\t\tvector<double> &oldLength =_globalPaths.oldLengths();\r\n\t\t\tvector<double> &newLength =_globalPaths.newLengths();\r\n\r\n\r\n\r\n\r\n\t\t\tint numPaths = pathVec.size();\r\n\t\t\t//cerr <<pathVec.size()<<endl;\r\n\t\t\t\tdouble maxThickness = 30.3;\r\n\t\t\t\t//unsigned int idgs =  pair.first;\r\n\r\n\t\t\tfor( unsigned int i = 0; i < pathVec.size(); i++ ) {\r\n\t\t\t\tKeiRo::Base::Line2 &path = pathVec[ i ];\r\n\t\t\t\tKeiRo::Base::Line2 &shortPath = pathVecShort[ 0 ];\r\n\r\n\t\t\t\t//_globalPaths.pathStartIdGS[i] == idgs\r\n\t\t\t\t\tif (  true  ) {\r\n\t\t\t\t\t\tif (maxThickness >0 )\r\n\t\t\t\t\t\t\tmaxThickness -= 0.3;\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tmaxThickness = 30.3;\r\n\r\n\t\t\t\t\t\t//cerr << \"path \"<<i<<endl;\r\n\t\t\t\t\t\t//_globalPaths.print_path(i);\r\n\t\t\t\t\t\tQColor pathColor = generateDistinctColor(i, numPaths);\r\n\r\n\r\n#ifdef DEBUG\r\n\t\t\t\t\t\tcerr << \"path.elementPointers() = \" << path.elementPointers().size() << endl;\r\n\t\t\t\t\t\tcerr << \"path.elements() = \" << path.elements().size() << endl;\r\n\t\t\t\t\t\tcerr << \"path.oldElements() = \" << path.oldElements().size() << endl;\r\n#endif // DEBUG\r\n\r\n\t\t\t\t\t\tfor( unsigned int j = 1; j < path.elementPointers().size(); j++ ) {\r\n\t\t\t\t\t\t\tKeiRo::Base::Coord2 *source = path.elementPointers()[ j - 1 ];\r\n\t\t\t\t\t\t\tKeiRo::Base::Coord2 *target = path.elementPointers()[ j ];\r\n\t\t\t\t\t\t\tQLineF shortLine;\r\n\r\n\t\t\t\t\t\t\t// if (source->x()!= target->x() && source->y()!= target->y())\r\n\t\t\t\t\t\t\t// \tcerr<<\"slant \"<< i<<endl;\r\n\r\n\t\t\t\t\t\t\tauto *itemptr = new Ui::Vector::GraphicsEdgeItem();\r\n\r\n\t\t\t\t\t\t\t_edgeItemMap.insert({i, itemptr});\r\n\r\n\t\t\t\t\t\t\titemptr->show();\r\n\r\n\t\t\t\t\t\t\tdouble strokeWidth = path.strokeWidth();\r\n\r\n\t\t\t\t\t\t\tdouble drakerFactor = 0.6;\r\n\t\t\t\t\t\t\tvector< unsigned int >  stroke = path.stroke();\r\n\t\t\t\t\t\t\titemptr->setPen( QPen( QColor( stroke[0]*drakerFactor,\r\n\t\t\t\t\t\t\tstroke[1]*drakerFactor, stroke[2]*drakerFactor, 255 ), strokeWidth ) );\r\n\t\t\t\t\t\t\tif (isPathSelectionMode()) {\r\n\t\t\t\t\t\t\t\titemptr->setPen(QPen(pathColor, maxThickness));\r\n\t\t\t\t\t\t\t\t//graphmlTree[ vd ].isSelected = true;\r\n\t\t\t\t\t\t\t\tGraph::TreeDirectedGraph    &graphmlTree    = _metadataPtr->graphmlTree();\r\n\t\t\t\t\t\t\t\tunsigned int graphmlTreeID = itemptr->id();\r\n\t\t\t\t\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd = vertex( graphmlTreeID, graphmlTree );\r\n\t\t\t\t\t\t\t\tif (graphmlTree[ vd ].isSelected ) {\r\n\t\t\t\t\t\t\t\t\tQColor currentColor = itemptr->pen().color();\r\n\t\t\t\t\t\t\t\t\tqreal h, s, v, a;\r\n\t\t\t\t\t\t\t\t\tcurrentColor.getHsvF(&h, &s, &v, &a);\r\n\t\t\t\t\t\t\t\t\tQColor newColor = QColor::fromHsvF(h, 0.6, 0.8, a);\r\n\t\t\t\t\t\t\t\t\titemptr->setPen(QPen(newColor, maxThickness));\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\titemptr->setPen( QPen( QColor( edgeAttributeVec[i].stroke()[0]*drakerFactor,\r\n\t\t\t\t\t\t\t\t\t\t\tedgeAttributeVec[i].stroke()[1]*drakerFactor,\r\n\t\t\t\t\t\t\t\t\t\t\tedgeAttributeVec[i].stroke()[2]*drakerFactor, 255 ), 5 ) );\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t//itemptr->setPen( QPen( QColor( 0,255,0, 255 ), 5 ) );\r\n\r\n\r\n\r\n\t\t\t\t\t\t\tQLineF oldLine, intermediateLine, line;\r\n\t\t\t\t\t\t\toldLine.setLine( source->oldElement()[0], -source->oldElement()[1],\r\n\t\t\t\t\t\t\t\t\ttarget->oldElement()[0], -target->oldElement()[1]  );\r\n\t\t\t\t\t\t\t// oldLine.setLine( path.oldElements()[ j - 1 ].x(), -path.oldElements()[ j - 1 ].y(),\r\n\t\t\t\t\t\t\t// \t\tpath.oldElements()[ j ].x(), -path.oldElements()[ j ].y()  );\r\n\t\t\t\t\t\t\tline.setLine( source->x(), -source->y(), target->x(), -target->y() );\r\n\r\n\t\t\t\t\t\t\tif (_isPathSelectionMode) {\r\n\t\t\t\t\t\t\t\t//itemptr->setLine( line );\r\n\t\t\t\t\t\t\t\titemptr->setAcceptHoverEvents( true );\r\n\t\t\t\t\t\t\t\titemptr->setFlag( QGraphicsItem::ItemIsSelectable );\r\n\t\t\t\t\t\t\t\titemptr->setData(0, QVariant(i));\r\n\t\t\t\t\t\t\t\t//itemptr->id()= i;\r\n\r\n\t\t\t\t\t\t\t\t// itemptr->setZValue(1);  // Ensure paths are above other items for easier selection\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t//_edgeItemMap.insert(std::pair<unsigned int, Ui::Vector::GraphicsEdgeItem*>(i, itemptr));\r\n\r\n\t\t\t\t\t\t\t_scenePtr->addItem( itemptr );\r\n\r\n\t\t\t\t\t\t\tif(source->inLocalMove()||target->inLocalMove()) {\r\n\t\t\t\t\t\t\t\tcerr <<\"local moves animation:\"<<endl;\r\n\r\n\t\t\t\t\t\t\t\t// oldLine.setLine( source->intermediateElement()[0], -source->intermediateElement()[1],\r\n\t\t\t\t\t\t\t\t// \t\t\t target->intermediateElement()[0], -target->intermediateElement()[1] );\r\n\t\t\t\t\t\t\t\t//\r\n\t\t\t\t\t\t\t\t// cerr << \"Animation 2 Updated\" << endl;\r\n\t\t\t\t\t\t\t\t// // UPDATED ANIMATION --------------------------------------------------------------------------------------------------------\r\n\t\t\t\t\t\t\t\t// QPropertyAnimation *animation1 = new QPropertyAnimation( itemptr, \"line\" );\r\n\t\t\t\t\t\t\t\t// animation1->setDuration( ANIMATE_DURATION/2 );\r\n\t\t\t\t\t\t\t\t// animation1->setStartValue( oldLine );\r\n\t\t\t\t\t\t\t\t// animation1->setEndValue( intermediateLine );\r\n\t\t\t\t\t\t\t\t// animation1->setEasingCurve( QEasingCurve::Linear );\r\n\t\t\t\t\t\t\t\t//\r\n\t\t\t\t\t\t\t\t// QPropertyAnimation *animation2 = new QPropertyAnimation( itemptr, \"line\" );\r\n\t\t\t\t\t\t\t\t// animation2->setDuration( ANIMATE_DURATION/2 );\r\n\t\t\t\t\t\t\t\t// animation2->setStartValue( intermediateLine );\r\n\t\t\t\t\t\t\t\t// animation2->setEndValue( line );\r\n\t\t\t\t\t\t\t\t// animation2->setEasingCurve( QEasingCurve::Linear );\r\n\t\t\t\t\t\t\t\t//\r\n\t\t\t\t\t\t\t\t// QSequentialAnimationGroup *group = new QSequentialAnimationGroup();\r\n\t\t\t\t\t\t\t\t//\r\n\t\t\t\t\t\t\t\t// group->addAnimation(animation1);\r\n\t\t\t\t\t\t\t\t// group->addAnimation(animation2);\r\n\t\t\t\t\t\t\t\t//\r\n\t\t\t\t\t\t\t\t// group->start( QAbstractAnimation::DeleteWhenStopped );\r\n// Create a new item for the new path\r\n\t\t\t\t\t\t\t\tUi::Vector::GraphicsEdgeItem *newItemptr = new Ui::Vector::GraphicsEdgeItem;\r\n\t\t\t\t\t\t\t    newItemptr->setPen(itemptr->pen());  // Copy the pen from the old item\r\n\t\t\t\t\t\t\t    newItemptr->setLine(line);  // Set the new line\r\n\t\t\t\t\t\t\t    scene()->addItem(newItemptr);\r\n\r\n\t\t\t\t\t\t\t    // Create opacity effects\r\n\t\t\t\t\t\t\t    QGraphicsOpacityEffect *oldOpacityEffect = new QGraphicsOpacityEffect(itemptr);\r\n\t\t\t\t\t\t\t    QGraphicsOpacityEffect *newOpacityEffect = new QGraphicsOpacityEffect(newItemptr);\r\n\t\t\t\t\t\t\t    itemptr->setGraphicsEffect(oldOpacityEffect);\r\n\t\t\t\t\t\t\t    newItemptr->setGraphicsEffect(newOpacityEffect);\r\n\r\n\t\t\t\t\t\t\t    const int FADE_DURATION = 500;\r\n\t\t\t\t\t\t\t    const int OTHER_ANIMATIONS_DURATION = 500; // Adjust this to match your other animations' duration\r\n\r\n\t\t\t\t\t\t\t    // Create fade-out animation for old item\r\n\t\t\t\t\t\t\t    QPropertyAnimation *fadeOutAnimation = new QPropertyAnimation(oldOpacityEffect, \"opacity\");\r\n\t\t\t\t\t\t\t    fadeOutAnimation->setDuration(FADE_DURATION);\r\n\t\t\t\t\t\t\t    fadeOutAnimation->setStartValue(1.0);\r\n\t\t\t\t\t\t\t    fadeOutAnimation->setEndValue(0.0);\r\n\t\t\t\t\t\t\t    fadeOutAnimation->setEasingCurve(QEasingCurve::OutQuad);\r\n\r\n\t\t\t\t\t\t\t    // Create fade-in animation for new item\r\n\t\t\t\t\t\t\t    QPropertyAnimation *fadeInAnimation = new QPropertyAnimation(newOpacityEffect, \"opacity\");\r\n\t\t\t\t\t\t\t    fadeInAnimation->setDuration(FADE_DURATION);\r\n\t\t\t\t\t\t\t    fadeInAnimation->setStartValue(0.0);\r\n\t\t\t\t\t\t\t    fadeInAnimation->setEndValue(1.0);\r\n\t\t\t\t\t\t\t    fadeInAnimation->setEasingCurve(QEasingCurve::InQuad);\r\n\r\n\t\t\t\t\t\t\t    // Set initial opacity for the new item\r\n\t\t\t\t\t\t\t    newOpacityEffect->setOpacity(0.0);\r\n\r\n\t\t\t\t\t\t\t    // Start fade-out animation\r\n\t\t\t\t\t\t\t    fadeOutAnimation->start(QAbstractAnimation::DeleteWhenStopped);\r\n\r\n\t\t\t\t\t\t\t    // Use QTimer for the pause\r\n\t\t\t\t\t\t\t    QTimer::singleShot(FADE_DURATION + OTHER_ANIMATIONS_DURATION, [=]() {\r\n\t\t\t\t\t\t\t       // Start fade-in animation after the pause\r\n\t\t\t\t\t\t\t       fadeInAnimation->start(QAbstractAnimation::KeepWhenStopped);\r\n\t\t\t\t\t\t\t    });\r\n\r\n\t\t\t\t\t\t\t    // Clean up the old item after all animations are done\r\n\t\t\t\t\t\t\t    QTimer::singleShot(FADE_DURATION + OTHER_ANIMATIONS_DURATION + FADE_DURATION, [=]() {\r\n\t\t\t\t\t\t\t       if (itemptr->scene()) {\r\n\t\t\t\t\t\t\t          itemptr->scene()->removeItem(itemptr);\r\n\t\t\t\t\t\t\t       }\r\n\t\t\t\t\t\t\t       itemptr->hide();\r\n\t\t\t\t\t\t\t       itemptr->deleteLater();\r\n\t\t\t\t\t\t\t    });\r\n\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t//original animation:\r\n\t\t\t\t\t\t\t\t cerr << \"animation 0\"<<endl;\r\n\t\t\t\t\t\t\t\t QPropertyAnimation *animation = new QPropertyAnimation( itemptr, \"line\" );\r\n\t\t\t\t\t\t\t\t animation->setDuration( ANIMATE_DURATION );\r\n\t\t\t\t\t\t\t\t animation->setStartValue( oldLine );\r\n\t\t\t\t\t\t\t\t animation->setEndValue( line );\r\n\t\t\t\t\t\t\t\t animation->setEasingCurve( QEasingCurve::Linear );\r\n\t\t\t\t\t\t\t\t animation->start( QAbstractAnimation::DeleteWhenStopped );\r\n\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n#ifdef short\r\n\r\n\r\n\r\n\t\t\t\t\t\t//itemptr->hide();\r\n\t\t\t\t\t\t// if (oldLength[i] > newLength[i])\r\n\t\t\t\t\t\t// \tcerr<<\"here\" <<shortPath.elementPointers().size()<<endl;\r\n\r\n\t\t\t\t\t\tif(&shortPath != nullptr && false ) {\r\n\t\t\t\t\t\t\t//cerr<<\"change to the shortest path \"<<endl;\r\n\t\t\t\t\t\t\t//if (!pathVecShort[ i ].elementPointers().empty())\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t// QList<QGraphicsItem*> items = _scenePtr->items();\r\n\t\t\t\t\t\t\t\t// for (int i = items.size() - 2; i >= 0; i--) {\r\n\t\t\t\t\t\t\t\t// \tif (dynamic_cast<Ui::Vector::GraphicsEdgeItem*>(items[i-1])) {\r\n\t\t\t\t\t\t\t\t// \t\t_scenePtr->removeItem(items[i-1]);\r\n\t\t\t\t\t\t\t\t// \t\tdelete items[i-1];\r\n\t\t\t\t\t\t\t\t// \t\tbreak;\r\n\t\t\t\t\t\t\t\t// \t}\r\n\t\t\t\t\t\t\t\t// }\r\n\r\n\t\t\t\t\t\t\t\t// \t_globalPaths.print_path(i);\r\n\t\t\t\t\t\t\t\t// //_globalPaths.print_path(0);\r\n\t\t\t\t\t\t\t\t// cerr<<\"resize \"<<endl;\r\n\t\t\t\t\t\t\t\t// path.elementPointers().resize(shortPath.elementPointers().size());\r\n\t\t\t\t\t\t\t\t// path.oldElements().resize( shortPath.elementPointers().size() );\r\n\t\t\t\t\t\t\t\t// path.fixedElements().resize( shortPath.elementPointers().size() );\r\n\t\t\t\t\t\t\t\t// path.elements().resize( shortPath.elementPointers().size() );\r\n\t\t\t\t\t\t\t\t// cerr <<\"new size \"<<path.elements().size()<<endl;\r\n\t\t\t\t\t\t\t\t//\r\n\t\t\t\t\t\t\t\t// for( unsigned int js = 0; js < pathVecShort[0].elements().size(); js++ ){\r\n\t\t\t\t\t\t\t\t// \tpath.elements()[js] = *pathVecShort[pathVecShort.size()-1].elementPointers()[js];\r\n\t\t\t\t\t\t\t\t// \tcerr <<\"new size \"<<path.elementPointers().size()<<endl;\r\n\t\t\t\t\t\t\t\t// \tpath.elementPointers()[js]->x() = pathVecShort[pathVecShort.size()-1].elementPointers()[js]->x();\r\n\t\t\t\t\t\t\t\t// \tpath.elementPointers()[js]->y() = pathVecShort[pathVecShort.size()-1].elementPointers()[js]->y();\r\n\t\t\t\t\t\t\t\t// \tpath.oldElements()[js].x() = pathVecShort[pathVecShort.size()-1].elementPointers()[js]->x();\r\n\t\t\t\t\t\t\t\t// \tpath.oldElements()[js].y() = pathVecShort[pathVecShort.size()-1].elementPointers()[js]->y();\r\n\t\t\t\t\t\t\t\t// \tpath.fixedElements()[js].x() = pathVecShort[pathVecShort.size()-1].elementPointers()[js]->x();\r\n\t\t\t\t\t\t\t\t// \tpath.fixedElements()[js].y() = pathVecShort[pathVecShort.size()-1].elementPointers()[js]->y();\r\n\t\t\t\t\t\t\t\t// }\r\n\r\n\t\t\t\t\t\t\t\t//pathVec[i].elements() = pathVecShort[pathVecShort.size()-1].elements();\r\n\t\t\t\t\t\t\t\t//set fixed path\r\n\r\n\r\n\r\n\t\t\t\t\t\t\t\t//TODO: copy everything related to the new shortest path\r\n\t\t\t\t\t\t\t\t//maybe later just remove the path i instead(easier maybe?)\r\n\t\t\t\t\t\t\t\t//edgeAttributeVec[i].elements() = edgeAttributeVecShort[edgeAttributeVecShort.size()-1].elements();\r\n\t\t\t\t\t\t\t\tUi::Vector::GraphicsEdgeItem* currentPathGroup = new Ui::Vector::GraphicsEdgeItem();\r\n\t\t\t\t\t\t\t\tUi::Vector::GraphicsEdgeItem* shortestPathGroup = new Ui::Vector::GraphicsEdgeItem();\r\n\r\n\r\n\r\n\r\n\t\t\t\t\t\t\t\tfor( unsigned int j = 1; j < shortPath.elementPointers().size(); j++ ) {\r\n\r\n\r\n\t\t\t\t\t\t\t\t\tKeiRo::Base::Coord2 *sourceOld = path.elementPointers()[ j - 1 ];\r\n\t\t\t\t\t\t\t\t\tKeiRo::Base::Coord2 *targetOld = path.elementPointers()[ j ];\r\n\r\n\t\t\t\t\t\t\t\t\tKeiRo::Base::Coord2 *sourceNew = shortPath.elementPointers()[ j - 1 ];\r\n\t\t\t\t\t\t\t\t\tKeiRo::Base::Coord2 *targetNew = shortPath.elementPointers()[ j ];\r\n\r\n\r\n\r\n\t\t\t\t\t\t\t\t\tUi::Vector::GraphicsEdgeItem* oldPathSegment = new Ui::Vector::GraphicsEdgeItem();\r\n\t\t\t\t\t\t\t\t\tUi::Vector::GraphicsEdgeItem* newPathSegment = new Ui::Vector::GraphicsEdgeItem();\r\n\r\n\t\t\t\t\t\t\t\t\tdouble strokeWidth = path.strokeWidth();\r\n\t\t\t\t\t\t\t\t\tvector< unsigned int >  stroke = path.stroke();\r\n\t\t\t\t\t\t\t\t\tnewPathSegment->setPen( QPen( QColor( stroke[0], stroke[1], stroke[2], 255 ), strokeWidth ) );\r\n\t\t\t\t\t\t\t\t\tnewPathSegment->setPen( QPen( QColor( edgeAttributeVec[i].stroke()[0],\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tedgeAttributeVec[i].stroke()[1],\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tedgeAttributeVec[i].stroke()[2], 255 ), 5 ) );\r\n\t\t\t\t\t\t\t\t\tnewPathSegment->setPen( QPen( QColor( 0,0,255, 255 ), 5 ) );\r\n\r\n\t\t\t\t\t\t\t\t\toldPathSegment->setLine(sourceOld->oldElement()[0], -sourceOld->oldElement()[1],\r\n\t\t\t\t\t\t\t\t\t\ttargetOld->oldElement()[0], -targetOld->oldElement()[1]);\r\n\t\t\t\t\t\t\t\t\tnewPathSegment->setLine(sourceNew->x(), -sourceNew->y(), targetNew->x(), -targetNew->y());\r\n\r\n\t\t\t\t\t\t\t\t\toldPathSegment->setVisible(false);\r\n\t\t\t\t\t\t\t\t\tnewPathSegment->setVisible(true);\r\n\r\n\t\t\t\t\t\t\t\t\t_scenePtr->addItem(oldPathSegment);\r\n\t\t\t\t\t\t\t\t\t_scenePtr->addItem(newPathSegment);\r\n\r\n\r\n\r\n\t\t\t\t\t\t\t\t\tQPropertyAnimation* oldPathAnimation = new QPropertyAnimation(oldPathSegment, \"line\");\r\n\t\t\t\t\t\t\t\t\toldPathAnimation->setDuration(ANIMATE_DURATION);\r\n\t\t\t\t\t\t\t\t\toldPathAnimation->setStartValue(1.0);\r\n\t\t\t\t\t\t\t\t\toldPathAnimation->setEndValue(0.0);\r\n\r\n\t\t\t\t\t\t\t\t\tQPropertyAnimation* newPathAnimation = new QPropertyAnimation(newPathSegment, \"line\");\r\n\t\t\t\t\t\t\t\t\tnewPathAnimation->setDuration(ANIMATE_DURATION);\r\n\t\t\t\t\t\t\t\t\tnewPathAnimation->setStartValue(0.0);\r\n\t\t\t\t\t\t\t\t\tnewPathAnimation->setEndValue(1.0);\r\n\r\n\t\t\t\t\t\t\t\t\tQSequentialAnimationGroup* animationGroup = new QSequentialAnimationGroup();\r\n\r\n\t\t\t\t\t\t\t\t\tanimationGroup->addAnimation(oldPathAnimation);\r\n\t\t\t\t\t\t\t\t\tanimationGroup->addAnimation(newPathAnimation);\r\n\r\n\t\t\t\t\t\t\t\t\t//animationGroup->start(QAbstractAnimation::DeleteWhenStopped);\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n#endif short\r\n\r\n\r\n\r\n\t\t\t}\r\n#ifdef DEBUG\r\n\t\t\tfor( unsigned int i = 0; i < pathVec.size(); i++ ){\r\n\r\n\t\t\t\tKeiRo::Base::Line2 &path = pathVec[ i ];\r\n\t\t\t\tfor( unsigned int j = 0; j < path.elements().size(); j++ ) {\r\n\r\n\t\t\t\t\tKeiRo::Base::Coord2 *c = path.elementPointers()[ j ];\r\n\t\t\t\t\tKeiRo::Base::Coord2 &o = path.oldElements()[ j ];\r\n\r\n\t\t\t\t\tUi::Vector::GraphicsVertexItem *itemptr = new Ui::Vector::GraphicsVertexItem;\r\n\t\t\t\t\titemptr->show();\r\n\r\n\t\t\t\t\titemptr->setBrush( QBrush( QColor( 100, 100, 100, 100 ), Qt::SolidPattern ) );\r\n\t\t\t\t\titemptr->setPen( QPen( QColor( 100, 100, 100, 100 ), 2 ) );\r\n\t\t\t\t\titemptr->setRect( QRectF( c->x(), -c->y(), 10, 10 ) );\r\n\t\t\t\t\titemptr->isSimple() = true;\r\n\t\t\t\t\titemptr->text() = QString::fromStdString( to_string( j ) );\r\n\t\t\t\t\titemptr->textOn() = true;\r\n\r\n\t\t\t\t\t_scenePtr->addItem( itemptr );\r\n\t\t\t\t}\r\n\t\t\t}\r\n#endif // DEBUG\r\n//\t\t\tFileIO::SVG* svgPtr = _metadataPtr->svgGlobal();\r\n//\r\n//\t\t\tvector< KeiRo::Base::Coord2 > &samples = svgPtr->compressionGrid().samples();\r\n//\t\t\tvector< KeiRo::Base::Line2 > &polylineVec = svgPtr->polylineVec();\r\n//\r\n//\t\t\tfor( unsigned int i = 0; i < polylineVec.size(); i++ ) {\r\n//\r\n//\t\t\t\tunsigned int size = polylineVec[ i ].elements().size();\r\n//\t\t\t\tfor( unsigned int j = 1; j < size; j++ ) {\r\n//\r\n//\t\t\t\t\tunsigned int idA = polylineVec[ i ].idElements()[ j-1 ];\r\n//\t\t\t\t\tunsigned int idB = polylineVec[ i ].idElements()[ j ];\r\n//\r\n//\t\t\t\t\tUi::Vector::GraphicsEdgeItem *itemptr = new Ui::Vector::GraphicsEdgeItem;\r\n//\t\t\t\t\titemptr->show();\r\n//\r\n//\t\t\t\t\tdouble strokeWidth = polylineVec[i].strokeWidth();\r\n//\t\t\t\t\tdouble strokeOpacity = polylineVec[i].strokeOpacity();\r\n//\t\t\t\t\tvector< unsigned int >  stroke = polylineVec[i].stroke();\r\n//\t\t\t\t\titemptr->setPen( QPen( QColor( stroke[0], stroke[1], stroke[2], stroke[3] ), strokeWidth ) );\r\n//\r\n//\t\t\t\t\tQLineF oldLine, line;\r\n//\t\t\t\t\toldLine.setLine( samples[ idA ].oldElement()[0], -samples[ idA ].oldElement()[1],\r\n//\t\t\t\t\t                 samples[ idB ].oldElement()[0], -samples[ idB ].oldElement()[1] );\r\n//\t\t\t\t\tline.setLine( samples[ idA ].x(), -samples[ idA ].y(), samples[ idB ].x(), -samples[ idB ].y() );\r\n//\t\t\t\t\titemptr->setLine( line );\r\n//\t\t\t\t\t_scenePtr->addItem( itemptr );\r\n//\r\n////\t\t\t\t\tQPropertyAnimation *animation = new QPropertyAnimation( itemptr, \"line\" );\r\n////\t\t\t\t\tanimation->setDuration( ANIMATE_DURATION );\r\n////\t\t\t\t\tanimation->setStartValue( oldLine );\r\n////\t\t\t\t\tanimation->setEndValue( line );\r\n////\t\t\t\t\tanimation->setEasingCurve( QEasingCurve::InOutQuart );\r\n////\t\t\t\t\tanimation->start( QAbstractAnimation::DeleteWhenStopped );\r\n//\t\t\t\t}\r\n//\t\t\t}\r\n//\r\n//\t\t\tfor( unsigned int i = 0; i < polylineVec.size(); i++ ) {\r\n//\r\n//\t\t\t\tunsigned int size = polylineVec[ i ].elements().size();\r\n//\t\t\t\tfor( unsigned int j = 0; j < size; j++ ) {\r\n//\r\n//\t\t\t\t\tunsigned int id = polylineVec[ i ].idElements()[ j ];\r\n//\r\n//\t\t\t\t\tUi::Vector::GraphicsVertexItem *itemptr = new Ui::Vector::GraphicsVertexItem;\r\n//\t\t\t\t\titemptr->show();\r\n//\r\n//\t\t\t\t\titemptr->setBrush( QBrush( QColor( 100, 100, 100, 100 ), Qt::SolidPattern ) );\r\n//\t\t\t\t\titemptr->setPen( QPen( QColor( 100, 100, 100, 100 ), 2 ) );\r\n//\t\t\t\t\titemptr->setRect( QRectF( samples[ id ].oldElement()[0], -samples[ id ].oldElement()[1], 10, 10 ) );\r\n//\t\t\t\t\titemptr->textOn() = false;\r\n//\r\n//\t\t\t\t\t_scenePtr->addItem( itemptr );\r\n//\t\t\t\t}\r\n//\t\t\t}\r\n#ifdef DEBUG\r\n\t\t\tfor( unsigned int i = 0; i < borderCoordVec.size(); i++ ){\r\n\r\n\t\t\t\tKeiRo::Base::Coord2 &c =borderCoordVec[i];\r\n\r\n\t\t\t\tUi::Vector::GraphicsVertexItem *itemptr = new Ui::Vector::GraphicsVertexItem;\r\n\t\t\t\titemptr->show();\r\n\r\n\t\t\t\titemptr->setBrush( QBrush( QColor( 255, 100, 100, 100 ), Qt::SolidPattern ) );\r\n\t\t\t\titemptr->setPen( QPen( QColor( 100, 100, 100, 100 ), 2 ) );\r\n\t\t\t\titemptr->setRect( QRectF( c.x(), -c.y(), 10, 10 ) );\r\n\t\t\t\t_scenePtr->addItem( itemptr );\r\n\t\t\t}\r\n#endif // DEBUG\r\n\t\t\t// for (unsigned int i = 0; i < pathVec.size(); i++) {\r\n\t\t\t// \tKeiRo::Base::Line2 &path = pathVec[i];\r\n\t\t\t//\r\n\t\t\t// \tQPainterPath painterPath;\r\n\t\t\t// \tbool firstPoint = true;\r\n\t\t\t//\r\n\t\t\t// \tfor (unsigned int j = 0; j < path.elementPointers().size(); j++) {\r\n\t\t\t// \t\tKeiRo::Base::Coord2 *point = path.elementPointers()[j];\r\n\t\t\t// \t\tif (firstPoint) {\r\n\t\t\t// \t\t\tpainterPath.moveTo(point->x(), -point->y());\r\n\t\t\t// \t\t\tfirstPoint = false;\r\n\t\t\t// \t\t} else {\r\n\t\t\t// \t\t\tpainterPath.lineTo(point->x(), -point->y());\r\n\t\t\t// \t\t}\r\n\t\t\t// \t}\r\n\t\t\t//\r\n\t\t\t// \tQGraphicsPathItem *pathItem = new QGraphicsPathItem(painterPath);\r\n\t\t\t// \tpathItem->setPen(QPen(generateDistinctColor(i, pathVec.size()), 30.0));\r\n\t\t\t// \tpathItem->setData(0, i);  // Store the path index\r\n\t\t\t// \tpathItem->setFlag(QGraphicsItem::ItemIsSelectable);\r\n\t\t\t//\r\n\t\t\t// \t_scenePtr->addItem(pathItem);\r\n\t\t\t// \tm_pathItems.append(pathItem);\r\n\t\t\t//\r\n\t\t\t// }\r\n\t\t}\r\n\r\n\r\n\t\t//\r\n\t\t//  TreemapGraphicsView::_update_item_globalPaths -- update global paths\r\n\t\t//\r\n\t\t//  Inputs\r\n\t\t//  none\r\n\t\t//\r\n\t\t//  Outputs\r\n\t\t//  none\r\n\t\t//\r\n\t\tvoid TreemapGraphicsView::_update_item_globalPaths( void ) {\r\n\t\t}\r\n\r\n\t\t//\r\n\t\t//  TreemapGraphicsView::_item_globalPathGraph -- draw global path graph\r\n\t\t//\r\n\t\t//  Inputs\r\n\t\t//  none\r\n\t\t//\r\n\t\t//  Outputs\r\n\t\t//  none\r\n\t\t//\r\n\t\tvoid TreemapGraphicsView::_item_globalPathGraph( void ) {\r\n\r\n\t\t\tGraph::BaseUndirectedGraph &pg = _globalPaths.compressedPathGraph().graph();\r\n\r\n\t\t\t// draw edges\r\n\t\t\tBGL_FORALL_EDGES( ed, pg, Graph::BaseUndirectedGraph ) {\r\n\r\n\t\t\t\tGraph::BaseUndirectedGraph::vertex_descriptor vdS = source( ed, pg );\r\n\t\t\t\tGraph::BaseUndirectedGraph::vertex_descriptor vdT = target( ed, pg );\r\n\t\t\t\tKeiRo::Base::Coord2 &cS = *pg[ vdS ].coordPtr;\r\n\t\t\t\tKeiRo::Base::Coord2 &cT = *pg[ vdT ].coordPtr;\r\n\r\n\t\t\t\tUi::Vector::GraphicsPathItem *itemptr = new Ui::Vector::GraphicsPathItem;\r\n\r\n\t\t\t\tQColor color( 0, 0, 0, 255 );\r\n\t\t\t\tif( pg[ ed ].level % 3 == 0 ){\r\n\t\t\t\t\tcolor = QColor( 150, 0, 0, 50 );\r\n\t\t\t\t}\r\n\t\t\t\telse if ( pg[ ed ].level % 3 == 1 ){\r\n\t\t\t\t\tcolor = QColor( 0, 0, 150, 50 );\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tcolor = QColor( 0, 150, 0, 50 );\r\n\t\t\t\t}\r\n\r\n\t\t\t\titemptr->setPen( QPen( color, 10 * (pg[ ed ].level+1) ) );\r\n\t\t\t\titemptr->setBrush( QBrush( color, Qt::SolidPattern ) );\r\n\r\n\t\t\t\tQPainterPath path;\r\n\t\t\t\tpath.moveTo( QPoint( cS.x(), -cS.y() ) );\r\n\t\t\t\tpath.lineTo( QPoint( cT.x(), -cT.y() ) );\r\n\t\t\t\titemptr->setPath( path );\r\n\r\n//\t\t\t\tif( pg[ ed ].level == 1 )\r\n\t\t\t\t_scenePtr->addItem( itemptr );\r\n\t\t\t}\r\n\r\n\t\t\t// draw vertices\r\n\t\t\tBGL_FORALL_VERTICES( vd, pg, Graph::BaseUndirectedGraph ) {\r\n\r\n\t\t\t\tKeiRo::Base::Coord2 &c = *pg[ vd ].coordPtr;\r\n\r\n\t\t\t\tUi::Vector::GraphicsVertexItem *itemptr = new Ui::Vector::GraphicsVertexItem;\r\n\t\t\t\titemptr->isSimple() = true;\r\n\r\n\t\t\t\tQColor color( 0, 0, 0, 255 );\r\n\t\t\t\tif( pg[ vd ].level % 3 == 0 ){\r\n\t\t\t\t\tcolor = QColor( 250, 0, 0, 255 );\r\n\t\t\t\t}\r\n\t\t\t\telse if ( pg[ vd ].level % 3 == 1 ){\r\n\t\t\t\t\tcolor = QColor( 0, 0, 150, 255 );\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tcolor = QColor( 0, 150, 0, 255 );\r\n\t\t\t\t}\r\n\r\n\t\t\t\titemptr->setPen( QPen( color, 10 * (pg[ vd ].level+1) ) );\r\n\t\t\t\titemptr->setBrush( QBrush( color, Qt::SolidPattern ) );\r\n//\t\t\t\titemptr->setPen( QPen( QColor( 255, 100, 100, 255 ), 5 ) );\r\n//\t\t\t\titemptr->setBrush( QBrush( QColor( 255, 255, 255, 255 ), Qt::SolidPattern ) );\r\n\t\t\t\titemptr->setRect( QRectF( c.x(), -c.y(), 10, 10 ) );\r\n\t\t\t\titemptr->textOn() = true;\r\n\t\t\t\titemptr->text() = QString::fromStdString( to_string( pg[ vd ].id ) );\r\n\r\n\t\t\t\t_scenePtr->addItem( itemptr );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//\r\n\t\t//  TreemapGraphicsView::_update_item_globalPathGraph -- update global path graph\r\n\t\t//\r\n\t\t//  Inputs\r\n\t\t//  none\r\n\t\t//\r\n\t\t//  Outputs\r\n\t\t//  none\r\n\t\t//\r\n\t\tvoid TreemapGraphicsView::_update_item_globalPathGraph( void )\r\n\t\t{\r\n\t\t}\r\n\r\n\t\t//\r\n\t\t//  TreemapGraphicsView::_item_treemap -- draw treemap\r\n\t\t//\r\n\t\t//  Inputs\r\n\t\t//  none\r\n\t\t//\r\n\t\t//  Outputs\r\n\t\t//  none\r\n\t\t//\r\n\t\tvoid TreemapGraphicsView::_item_treemap( void ) {\r\n\r\n\t\t\tGraph::TreeDirectedGraph    &graphmlTree    = _metadataPtr->graphmlTree();\r\n\r\n\t\t\tBGL_FORALL_VERTICES( vd, graphmlTree, Graph::TreeDirectedGraph ) {\r\n\r\n\t\t\t\tKeiRo::Base::Rectangle2 &bbox = *graphmlTree[ vd ].boundingBoxPtr;\r\n\t\t\t\tKeiRo::Base::Coord2 &c = *graphmlTree[ vd ].coordPtr;\r\n\t\t\t\tunsigned int id = graphmlTree[vd].id;\r\n\t\t\t\tunsigned int level = graphmlTree[vd].level;\r\n\r\n\t\t\t\tUi::Vector::GraphicsPolygonItem *itemptr = new Ui::Vector::GraphicsPolygonItem;\r\n\r\n\t\t\t\t// set polygon color\r\n//\t\t\t\tvector< unsigned int > &cs = polygonVec[ i ].stroke();\r\n//\t\t\t\tvector< unsigned int > &cf = polygonVec[ i ].fill();\r\n\t\t\t\titemptr->setPen( QPen( QColor( 0, 0, 0, 255 ), 2 ) );\r\n\t\t\t\titemptr->setBrush( QBrush( QColor( 0, 0, 0, 0 ), Qt::SolidPattern ) );\r\n\t\t\t\titemptr->defaultPen() = itemptr->pen();\r\n\t\t\t\titemptr->defaultBrush() = itemptr->brush();\r\n\r\n\t\t\t\tKeiRo::Base::Coord2 center( bbox.leftBottom().x() + 0.5*bbox.width(),\r\n\t\t\t\t                            bbox.leftBottom().y() + 0.5*bbox.height() );\r\n\t\t\t\tKeiRo::Base::Coord2 oldCenter( bbox.oldLeftBottom().x() + 0.5*bbox.oldWidth(),\r\n\t\t\t\t                               bbox.oldLeftBottom().y() + 0.5*bbox.oldHeight() );\r\n\t\t\t\titemptr->bbox() = QRect( bbox.leftBottom().x(),\r\n\t\t\t\t                         bbox.leftBottom().y(),\r\n\t\t\t\t                         bbox.width(),\r\n\t\t\t\t                         bbox.height() );\r\n\r\n\t\t\t\t//itemptr->textOn() = true;\r\n\t\t\t\t//itemptr->text() = QString::fromStdString( to_string( _seedVec[ i ].id ) );\r\n\r\n\t\t\t\tQPolygonF oldPolygon, intermediatePolygon, polygon;\r\n\t\t\t\tpolygon.append( QPoint( bbox.leftBottom().x() ,\r\n\t\t\t\t                        -bbox.leftBottom().y() ));\r\n\t\t\t\tpolygon.append( QPoint( bbox.leftBottom().x() + bbox.width(),\r\n\t\t\t\t                        -bbox.leftBottom().y() ));\r\n\t\t\t\tpolygon.append( QPoint( bbox.leftBottom().x() + bbox.width(),\r\n\t\t\t\t                        -( bbox.leftBottom().y() + bbox.height() )));\r\n\t\t\t\tpolygon.append( QPoint( bbox.leftBottom().x(),\r\n\t\t\t\t                        -( bbox.leftBottom().y() + bbox.height() )));\r\n\r\n\t\t\t\toldPolygon.append( QPoint( bbox.oldLeftBottom().x(),\r\n\t\t\t\t                           -bbox.oldLeftBottom().y() ));\r\n\t\t\t\toldPolygon.append( QPoint( bbox.oldLeftBottom().x() + bbox.oldWidth(),\r\n\t\t\t\t                           -bbox.oldLeftBottom().y() ));\r\n\t\t\t\toldPolygon.append( QPoint( bbox.oldLeftBottom().x() + bbox.oldWidth(),\r\n\t\t\t\t                           -( bbox.oldLeftBottom().y() + bbox.oldHeight() )));\r\n\t\t\t\toldPolygon.append( QPoint( bbox.oldLeftBottom().x(),\r\n\t\t\t\t                           -( bbox.oldLeftBottom().y() + bbox.oldHeight() )));\r\n\r\n\t\t\t\titemptr->setPolygon( polygon );\r\n\t\t\t\titemptr->setAcceptHoverEvents( true );\r\n\t\t\t\titemptr->attributeID() = graphmlTree[vd].id;\r\n\t\t\t\titemptr->id() = id;\r\n\t\t\t\titemptr->name() = QString::fromStdString( *graphmlTree[vd].namePtr );\r\n\t\t\t\titemptr->text() = QString::fromStdString( *graphmlTree[vd].namePtr );\r\n\r\n\t\t\t\t_scenePtr->addItem( itemptr );\r\n\r\n\t\t\t\tif(bbox.inLocalMove()) {\r\n\r\n\t\t\t\t\tintermediatePolygon.append( QPoint( bbox.intermediateLeftBottom().x(),\r\n\t\t\t\t                   \t        -bbox.intermediateLeftBottom().y() ));\r\n\t\t\t\t\tintermediatePolygon.append( QPoint( bbox.intermediateLeftBottom().x() + bbox.intermediateWidth(),\r\n\t\t\t\t         \t                  -bbox.intermediateLeftBottom().y() ));\r\n\t\t\t\t\tintermediatePolygon.append( QPoint( bbox.intermediateLeftBottom().x() + bbox.intermediateWidth(),\r\n\t\t\t\t\t                           -( bbox.intermediateLeftBottom().y() + bbox.intermediateHeight() )));\r\n\t\t\t\t\tintermediatePolygon.append( QPoint( bbox.intermediateLeftBottom().x(),\r\n\t\t\t\t\t                           -( bbox.intermediateLeftBottom().y() + bbox.intermediateHeight() )));\r\n\r\n\t\t\t\t\tcerr << \"Animation 4 Updated\" << endl;\r\n\t\t\t\t\t// UPDATED ANIMATION --------------------------------------------------------------------------------------------------------\r\n\t\t\t\t\tQPropertyAnimation *animation1 = new QPropertyAnimation( itemptr, \"polygon\" );\r\n\t\t\t\t\tanimation1->setDuration( ANIMATE_DURATION/2 );\r\n\t\t\t\t\tanimation1->setStartValue( oldPolygon );\r\n\t\t\t\t\tanimation1->setEndValue( intermediatePolygon );\r\n\t\t\t\t\tanimation1->setEasingCurve( QEasingCurve::Linear );\r\n\r\n\t\t\t\t\tQPropertyAnimation *animation2 = new QPropertyAnimation( itemptr, \"polygon\" );\r\n\t\t\t\t\tanimation2->setDuration( ANIMATE_DURATION/2 );\r\n\t\t\t\t\tanimation2->setStartValue( intermediatePolygon );\r\n\t\t\t\t\tanimation2->setEndValue( polygon );\r\n\t\t\t\t\tanimation2->setEasingCurve( QEasingCurve::Linear );\r\n\r\n\t\t\t\t\tQSequentialAnimationGroup *group = new QSequentialAnimationGroup();\r\n\r\n\t\t\t\t\tgroup->addAnimation(animation1);\r\n\t\t\t\t\tgroup->addAnimation(animation2);\r\n\r\n\t\t\t\t\tgroup->start( QAbstractAnimation::DeleteWhenStopped );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tQPropertyAnimation *animation = new QPropertyAnimation( itemptr, \"polygon\" );\r\n\t\t\t\t\tanimation->setDuration( ANIMATE_DURATION );\r\n\t\t\t\t\tanimation->setStartValue( oldPolygon );\r\n\t\t\t\t\tanimation->setEndValue( polygon );\r\n\t\t\t\t\tanimation->setEasingCurve( QEasingCurve::Linear );\r\n\t\t\t\t\tanimation->start( QAbstractAnimation::DeleteWhenStopped );\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//\r\n\t\t//  TreemapGraphicsView::_update_item_treemap -- update treemap\r\n\t\t//\r\n\t\t//  Inputs\r\n\t\t//  none\r\n\t\t//\r\n\t\t//  Outputs\r\n\t\t//  none\r\n\t\t//\r\n\t\tvoid TreemapGraphicsView::_update_item_treemap( void ) {\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\t\t//  TreemapGraphicsView::_item_voronoi -- draw voronoi\r\n\t\t//\r\n\t\t//  Inputs\r\n\t\t//  none\r\n\t\t//\r\n\t\t//  Outputs\r\n\t\t//  none\r\n\t\t//\r\n\t\tvoid TreemapGraphicsView::_item_voronoi( void ) {\r\n\r\n\t\t\t// draw voronoi\r\n\t\t\tfor( unsigned int i = 0; i < _seedVec.size(); i++ ){\r\n\r\n\t\t\t\tKeiRo::Base::Polygon2 &p = *_seedVec[ i ].voronoiCellPtr;\r\n#ifdef DEBUG\r\n\t\t\t\tcerr << \"p.size() = \" << p.elements().size() << endl;\r\n\t\t\t\tcerr << \"c.size() = \" << _seedVec[ i ].voronoiCellPtr->elements().size() << endl;\r\n#endif // DEBUG\r\n\t\t\t\tQPolygonF polygon;\r\n\t\t\t\tfor( unsigned int j = 0; j < p.elements().size(); j++ ) {\r\n\t\t\t\t\tpolygon.append( QPointF( p.elements()[ j ].x(), -p.elements()[ j ].y() ) );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tUi::Vector::GraphicsPolygonItem *itemptr = new Ui::Vector::GraphicsPolygonItem;\r\n\t\t\t\t// p.setItemPtr( itemptr );\r\n\t\t\t\titemptr->setPolygon( polygon );\r\n\r\n\t\t\t\tvector< double > rgb;\r\n\t\t\t\tKeiRo::Base::Color::pickBrewerColor( _seedVec[i].gid, rgb );\r\n\r\n\t\t\t\tQColor color( rgb[ 0 ], rgb[ 1 ], rgb[ 2 ], 100 );\r\n\t\t\t\titemptr->setPen( QPen( QColor( color.red(), color.green(), color.blue(), 255 ), 2 ) );\r\n\t\t\t\titemptr->setBrush( QBrush( QColor( color.red(), color.green(), color.blue(), 100 ), Qt::SolidPattern ) );\r\n\r\n\t\t\t\t_scenePtr->addItem( itemptr );\r\n\t\t\t}\r\n\r\n\t\t\t// draw contours\r\n\t\t\tfor( map< unsigned int, KeiRo::Base::Polygon2 >::iterator it = _voronoiComplex.begin();\r\n\t\t\t\t it != _voronoiComplex.end(); it++ ){\r\n\t\t\t\tKeiRo::Base::Polygon2 &p = it->second;\r\n\r\n\t\t\t\tQPolygonF polygon;\r\n\t\t\t\tfor( unsigned int j = 0; j < p.elements().size(); j++ ) {\r\n\t\t\t\t\tpolygon.append( QPointF( p.elements()[ j ].x(), -p.elements()[ j ].y() ) );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tUi::Vector::GraphicsPolygonItem *itemptr = new Ui::Vector::GraphicsPolygonItem;\r\n\t\t\t\titemptr->setPolygon( polygon );\r\n\r\n\t\t\t\tQColor color( 100, 100, 100, 255 );\r\n\t\t\t\titemptr->setPen( QPen( QColor( color.red(), color.green(), color.blue(), 255 ), 5 ) );\r\n\t\t\t\titemptr->setBrush( QBrush( QColor( color.red(), color.green(), color.blue(), 0 ), Qt::SolidPattern ) );\r\n\r\n\t\t\t\t_scenePtr->addItem( itemptr );\r\n\t\t\t}\r\n\r\n\t\t\t// draw seeds\r\n\t\t\t// cerr << \"_seedVec.size() = \" << _seedVec.size() << endl;\r\n\t\t\tfor( unsigned int i = 0; i < _seedVec.size(); i++ ){\r\n\r\n\t\t\t\tUi::Vector::GraphicsVertexItem *itemptr = new Ui::Vector::GraphicsVertexItem;\r\n\t\t\t\titemptr->isSimple() = true;\r\n\t\t\t\titemptr->setPen( QPen( QColor( 100, 100, 100, 255 ), 5 ) );\r\n\t\t\t\titemptr->setBrush( QBrush( QColor( 255, 255, 255, 255 ), Qt::SolidPattern ) );\r\n\t\t\t\titemptr->setRect( QRectF( _seedVec[i].coordPtr->x(), -_seedVec[i].coordPtr->y(), 10, 10 ) );\r\n\t\t\t\t//itemptr->textOn() = true;\r\n\t\t\t\titemptr->text() = QString::fromStdString( to_string( _seedVec[ i ].id ) );\r\n\t\t\t\t//itemptr->setPath( path );\r\n\r\n\t\t\t\t_scenePtr->addItem( itemptr );\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\t\t//  TreemapGraphicsView::_update_item_voronoi -- update voronoi\r\n\t\t//\r\n\t\t//  Inputs\r\n\t\t//  none\r\n\t\t//\r\n\t\t//  Outputs\r\n\t\t//  none\r\n\t\t//\r\n\t\tvoid TreemapGraphicsView::_update_item_voronoi( void ) {\r\n\t\t}\r\n\r\n\t\t//\r\n\t\t//  TreemapGraphicsView::_item_boundary -- draw boundary\r\n\t\t//\r\n\t\t//  Inputs\r\n\t\t//  none\r\n\t\t//\r\n\t\t//  Outputs\r\n\t\t//  none\r\n\t\t//\r\n\t\tvoid TreemapGraphicsView::_item_boundary( void )\r\n\t\t{\r\n\t\t\t// initialization\r\n\t\t\tGraph::SchematicGraph &bg = _schematicLayout->graph();\r\n\r\n\t\t\t// draw edges\r\n\t\t\tBGL_FORALL_EDGES( ed, bg, Graph::SchematicGraph ) {\r\n\r\n\t\t\t\t\tGraph::SchematicGraph::vertex_descriptor vdS = source( ed, bg );\r\n\t\t\t\t\tGraph::SchematicGraph::vertex_descriptor vdT = target( ed, bg );\r\n\t\t\t\t\tKeiRo::Base::Coord2 &cS = *bg[ vdS ].coordPtr;\r\n\t\t\t\t\tKeiRo::Base::Coord2 &cT = *bg[ vdT ].coordPtr;\r\n\r\n\t\t\t\t\tUi::Vector::GraphicsPathItem *itemptr = new Ui::Vector::GraphicsPathItem;\r\n\r\n\t\t\t\t\tQColor color( 0, 0, 0, 255 );\r\n\t\t\t\t\titemptr->setPen( QPen( QColor( 255, 100, 100, 255 ), 5 ) );\r\n\t\t\t\t\titemptr->setBrush( QBrush( QColor( 255, 255, 255, 0 ), Qt::SolidPattern ) );\r\n\r\n\t\t\t\t\tQPainterPath path;\r\n\t\t\t\t\tpath.moveTo( QPoint( cS.x(), -cS.y() ) );\r\n\t\t\t\t\tpath.lineTo( QPoint( cT.x(), -cT.y() ) );\r\n\t\t\t\t\titemptr->setPath( path );\r\n\r\n\t\t\t\t\t_scenePtr->addItem( itemptr );\r\n\t\t\t\t}\r\n\r\n\t\t\t// draw vertices\r\n\t\t\tBGL_FORALL_VERTICES( vd, bg, Graph::SchematicGraph ) {\r\n\r\n\t\t\t\t\tKeiRo::Base::Coord2 &c = *bg[ vd ].coordPtr;\r\n\r\n\t\t\t\t\tUi::Vector::GraphicsVertexItem *itemptr = new Ui::Vector::GraphicsVertexItem;\r\n\t\t\t\t\titemptr->isSimple() = true;\r\n\t\t\t\t\titemptr->setPen( QPen( QColor( 255, 100, 100, 255 ), 5 ) );\r\n\t\t\t\t\titemptr->setBrush( QBrush( QColor( 255, 255, 255, 255 ), Qt::SolidPattern ) );\r\n\t\t\t\t\titemptr->setRect( QRectF( c.x(), -c.y(), 10, 10 ) );\r\n\t\t\t\t\t//itemptr->textOn() = true;\r\n\t\t\t\t\t//itemptr->text() = QString::fromStdString( to_string( _seedVec[ i ].id ) );\r\n\r\n\t\t\t\t\t_scenePtr->addItem( itemptr );\r\n\t\t\t\t}\r\n\t\t}\r\n\r\n\t\t//\r\n\t\t//  TreemapGraphicsView::_item_boundary -- update boundary\r\n\t\t//\r\n\t\t//  Inputs\r\n\t\t//  none\r\n\t\t//\r\n\t\t//  Outputs\r\n\t\t//  none\r\n\t\t//\r\n\t\tvoid TreemapGraphicsView::_update_item_boundary( void )\r\n\t\t{\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\t\t//  TreemapGraphicsView::_activateChildVisibility -- update object child visibility\r\n\t\t//\r\n\t\t//  Inputs\r\n\t\t//  none\r\n\t\t//\r\n\t\t//  Outputs\r\n\t\t//  none\r\n\t\t//\r\n\t\tvoid TreemapGraphicsView::_activateChildVisibility( unsigned int idP )\r\n\t\t{\r\n\t\t\tvector< FileIO::SVG* > &svgPtrVec = _metadataPtr->svgPtrVec();\r\n\t\t\tvector< vector< unsigned int > > &sortedLevel = _hierarchicalTreemap.sortedLevel();\r\n\t\t\tGraph::TreeDirectedGraph &graphmlTree    = _hierarchicalTreemap.metadataPtr()->graphmlTree();\r\n\r\n\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdP = vertex( idP, graphmlTree );\r\n\t\t\tmap< unsigned int, unsigned int > &childMap = graphmlTree[ vdP ].childMap;\r\n\r\n\t\t\tfor( unsigned int i = 0; i < childMap.size(); i++ ){\r\n\r\n\t\t\t\tmap< unsigned int, unsigned int >::iterator itC = childMap.begin();\r\n\t\t\t\tstd::advance( itC, i );\r\n\t\t\t\tunsigned int idC = itC->second;\r\n\r\n\t\t\t\tvector< KeiRo::Base::Polygon2 > &childPolygonVec = svgPtrVec[ idC ]->polygonVec();\r\n\t\t\t\tvector< KeiRo::Base::Line2 > &childPolylineVec = svgPtrVec[ idC ]->polylineVec();\r\n\r\n\t\t\t\tfor( unsigned int j = 0; j < childPolygonVec.size(); j++ ) {\r\n\t\t\t\t\tchildPolygonVec[ j ].isVisible() = true;\r\n\t\t\t\t}\r\n\t\t\t\tfor( unsigned int j = 0; j < childPolylineVec.size(); j++ ) {\r\n\t\t\t\t\tchildPolylineVec[ j ].isVisible() = true;\r\n\t\t\t\t}\r\n\t\t\t\t_activateChildVisibility( idC );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//\r\n\t\t//  TreemapGraphicsView::_checkLabelVisibility -- check if showing name labels\r\n\t\t//\r\n\t\t//  Inputs\r\n\t\t//  none\r\n\t\t//\r\n\t\t//  Outputs\r\n\t\t//  none\r\n\t\t//\r\n\t\tbool TreemapGraphicsView::_checkLabelVisibility( Graph::BaseUndirectedGraph &graphmlGraph )\r\n\t\t{\r\n\t\t\tbool isVisible = true;\r\n\t\t\tQFont font = lensSettings->fonts()[_metadataPtr->maxLevel()-1];\r\n\t\t\tQFontMetrics fm( font );\r\n\r\n\t\t\tBGL_FORALL_VERTICES( vdO, graphmlGraph, Graph::BaseUndirectedGraph ) {\r\n\r\n\t\t\t\tKeiRo::Base::Rectangle2 bboxO;\r\n\t\t\t\tbboxO.leftBottom().x() = graphmlGraph[vdO].coordPtr->x();\r\n\t\t\t\tbboxO.leftBottom().y() = graphmlGraph[vdO].coordPtr->y();\r\n\t\t\t\tbboxO.width() = fm.width( QString::fromStdString( to_string( *graphmlGraph[vdO].namePtr ) ) );\r\n\t\t\t\tbboxO.height() = fm.height();\r\n\r\n\t\t\t\tBGL_FORALL_VERTICES( vdI, graphmlGraph, Graph::BaseUndirectedGraph ) {\r\n\r\n\t\t\t\t\tif( graphmlGraph[vdI].id < graphmlGraph[vdO].id ){\r\n\t\t\t\t\t\tKeiRo::Base::Rectangle2 bboxI;\r\n\t\t\t\t\t\tbboxI.leftBottom().x() = graphmlGraph[vdI].coordPtr->x();\r\n\t\t\t\t\t\tbboxI.leftBottom().y() = graphmlGraph[vdI].coordPtr->y();\r\n\t\t\t\t\t\tbboxI.width() = fm.width( QString::fromStdString( to_string( *graphmlGraph[vdI].namePtr ) ) );\r\n\t\t\t\t\t\tbboxI.height() = fm.height();\r\n\r\n\t\t\t\t\t\tdouble area = 0.0;\r\n\t\t\t\t\t\tisVisible = !bboxO.isOverlap( bboxI, area );\r\n\t\t\t\t\t\tif(area > 0.0){\r\n\t\t\t\t\t\t\treturn isVisible;\r\n\t\t\t\t\t\t\tcerr << \"isVisible = \" << isVisible << \", area = \" << area << endl;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tcerr << \"isVisible flag = \" << isVisible << endl;\r\n\t\t\treturn isVisible;\r\n\t\t}\r\n\r\n\t\t//\r\n\t\t//  TreemapGraphicsView::_updateVisibility -- update object visibility\r\n\t\t//\r\n\t\t//  Inputs\r\n\t\t//  none\r\n\t\t//\r\n\t\t//  Outputs\r\n\t\t//  none\r\n\t\t//\r\n\t\tvoid TreemapGraphicsView::_updateVisibility( void )\r\n\t\t{\r\n\t\t\tvector< FileIO::SVG* > &svgPtrVec = _metadataPtr->svgPtrVec();\r\n\t\t\tvector< vector< unsigned int > > &sortedLevel = _hierarchicalTreemap.sortedLevel();\r\n\t\t\tGraph::TreeDirectedGraph &graphmlTree    = _hierarchicalTreemap.metadataPtr()->graphmlTree();\r\n\r\n\t\t\t// reset\r\n\t\t\tfor( unsigned int i = 1; i < svgPtrVec.size(); i++ ){\r\n\t\t\t\tvector< KeiRo::Base::Polygon2 > &polygonVec = svgPtrVec[ i ]->polygonVec();\r\n\t\t\t\tvector< KeiRo::Base::Line2 > &polylineVec = svgPtrVec[ i ]->polylineVec();\r\n\t\t\t\tfor( unsigned int j = 0; j < polygonVec.size(); j++ ) {\r\n\t\t\t\t\tpolygonVec[ j ].isVisible() = false;\r\n\t\t\t\t\tpolygonVec[ j ].isTextVisible() = false;\r\n\t\t\t\t}\r\n\t\t\t\tfor( unsigned int j = 0; j < polylineVec.size(); j++ ) {\r\n\t\t\t\t\tpolylineVec[ j ].isVisible() = false;\r\n\t\t\t\t\tpolylineVec[ j ].isTextVisible() = false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// set visible objects\r\n\t\t\tfor( map< unsigned int, unsigned int >::iterator it = _selectSceneItemMap.begin();\r\n\t\t\t     it != _selectSceneItemMap.end(); it++ ) {\r\n\r\n\t\t\t\tunsigned int level = 0;//std::get<0>( it->second );\r\n\t\t\t\tunsigned int member = 0;//std::get<1>( it->second );\r\n\t\t\t\tunsigned int polygonMember = 0;//std::get<2>( it->second );\r\n\r\n\t\t\t\tunsigned int idP = sortedLevel[level][member];\r\n\r\n\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdP = vertex( idP, graphmlTree );\r\n\t\t\t\tvector< KeiRo::Base::Polygon2 > &polygonVec = svgPtrVec[ idP ]->polygonVec();\r\n\t\t\t\tmap< unsigned int, unsigned int > &childMap = graphmlTree[ vdP ].childMap;\r\n\r\n\t\t\t\tpolygonVec[ polygonMember ].isVisible() = true;\r\n\t\t\t\tpolygonVec[ polygonMember ].isTextVisible() = false;\r\n\t\t\t\tpolygonVec[ polygonMember ].isSelected() = true;\r\n\r\n\t\t\t\tmap< unsigned int, unsigned int >::iterator itC = childMap.begin();\r\n\t\t\t\tstd::advance( itC, polygonMember );\r\n\t\t\t\tunsigned int idC = itC->second;\r\n\r\n\t\t\t\tvector< KeiRo::Base::Polygon2 > &childPolygonVec = svgPtrVec[ idC ]->polygonVec();\r\n\t\t\t\tvector< KeiRo::Base::Line2 > &childPolylineVec = svgPtrVec[ idC ]->polylineVec();\r\n\r\n\t\t\t\tcerr << \"childPolygonVec.size() = \" << childPolygonVec.size() << endl;\r\n\t\t\t\tfor( unsigned int j = 0; j < childPolygonVec.size(); j++ ) {\r\n\t\t\t\t\tchildPolygonVec[ j ].isVisible() = true;\r\n\t\t\t\t\tchildPolygonVec[ j ].isTextVisible() = true;\r\n\t\t\t\t\tchildPolygonVec[ j ].isSelected() = true;\r\n\t\t\t\t}\r\n\t\t\t\tfor( unsigned int j = 0; j < childPolylineVec.size(); j++ ) {\r\n\t\t\t\t\tchildPolylineVec[ j ].isVisible() = true;\r\n\t\t\t\t\tchildPolylineVec[ j ].isTextVisible() = true;\r\n\t\t\t\t\tchildPolylineVec[ j ].isSelected() = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_activateChildVisibility( idC );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor( int i = sortedLevel.size()-2; i >= 0; i-- )\r\n\t\t\t{\r\n\t\t\t\tQFont font;\r\n//\t\t\t\tfont.setPointSize( _fonts[i].pointSize() );\r\n//\t\t\t\tif( _fonts.size() > i ) font = _fonts[i];\r\n\r\n\t\t\t\tif( i == 1 ){\r\n\r\n\t\t\t\t\tfor( unsigned int j = 0; j < sortedLevel[i].size(); j++ ) {\r\n\r\n\t\t\t\t\t\tunsigned int id = sortedLevel[i][j];\r\n\t\t\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd = vertex( id, graphmlTree );\r\n\t\t\t\t\t\tmap< unsigned int, unsigned int > &childMap = graphmlTree[ vd ].childMap;\r\n\t\t\t\t\t\tvector< KeiRo::Base::Polygon2 > &polygonVec = svgPtrVec[ id ]->polygonVec();\r\n\r\n\r\n\t\t\t\t\t\tbool isEnable = true;\r\n\t\t\t\t\t\tfor( unsigned int m = 0; m < childMap.size(); m++ ) {\r\n\r\n\t\t\t\t\t\t\tmap< unsigned int, unsigned int >::iterator itC = childMap.begin();\r\n\t\t\t\t\t\t\tstd::advance( itC, m );\r\n\t\t\t\t\t\t\tunsigned int idC = itC->second;\r\n\r\n\t\t\t\t\t\t\tvector< KeiRo::Base::Polygon2 > &childPolygonVec = svgPtrVec[ idC ]->polygonVec();\r\n\t\t\t\t\t\t\tvector< KeiRo::Base::Line2 > &childPolylineVec = svgPtrVec[ idC ]->polylineVec();\r\n\t\t\t\t\t\t\tfor( unsigned int j = 0; j < childPolygonVec.size(); j++ ) {\r\n\t\t\t\t\t\t\t\tif( childPolygonVec[ j ].isVisible() == true )\r\n\t\t\t\t\t\t\t\t\tisEnable = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif( isEnable == true ) {\r\n\t\t\t\t\t\t\t\tpolygonVec[m].isVisible() = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse{\r\n\t\t\t\t\t\t\t\tpolygonVec[m].isVisible() = false;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tKeiRo::Base::Rectangle2 &bbox = polygonVec[m].boundingBox();\r\n\t\t\t\t\t\t\tfont.setPointSize( lensSettings->fonts()[i].pointSize() );\r\n\t\t\t\t\t\t\tQFontMetrics fm( font );\r\n\t\t\t\t\t\t\tdouble sx = fm.width( QString::fromStdString( polygonVec[m].label() ) );\r\n\t\t\t\t\t\t\tdouble sy = fm.height();\r\n#ifdef DEBUG\r\n\t\t\t\t\t\t\tcerr << polygonVec[ i ].label() << \" sx = \" << sx << \" sy = \" << sy\r\n\t\t\t\t\t\t\t\t << \" w = \" << bbox.width() << \" h = \" << bbox.height()\r\n\t\t\t\t\t\t\t\t << \" selected = \" << polygonVec[m].isSelected() << endl;\r\n#endif // DEBUG\r\n\t\t\t\t\t\t\tif( ( sx < 0.95*bbox.width() ) && ( sy < 0.95*bbox.height() ) ){\r\n\t\t\t\t\t\t\t\tif( isEnable == true )\r\n\t\t\t\t\t\t\t\t\tpolygonVec[m].isTextVisible() = true;\r\n\t\t\t\t\t\t\t\telse{\r\n\t\t\t\t\t\t\t\t\tpolygonVec[m].isTextVisible() = false;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse{\r\n\t\t\t\t\t\t\t\tpolygonVec[m].isTextVisible() = false;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n#ifdef DEBUG\r\n\t\t\t\t\t\tfor( unsigned int m = 0; m < childMap.size(); m++ ) {\r\n\t\t\t\t\t\t\tcerr << \"m = \" << m << \" on = \" << polygonVec[m].isVisible() << \" texton = \" << polygonVec[m].isTextVisible() << endl;\r\n\t\t\t\t\t\t}\r\n#endif // DEBUG\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif( i == 0 ){\r\n\r\n\t\t\t\t\tfor( unsigned int j = 0; j < sortedLevel[i].size(); j++ ) {\r\n\r\n\t\t\t\t\t\tunsigned int id = sortedLevel[i][j];\r\n\t\t\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd = vertex( id, graphmlTree );\r\n\t\t\t\t\t\tmap< unsigned int, unsigned int > &childMap = graphmlTree[ vd ].childMap;\r\n\t\t\t\t\t\tvector< KeiRo::Base::Polygon2 > &polygonVec = svgPtrVec[ id ]->polygonVec();\r\n\r\n\t\t\t\t\t\tfor( unsigned int m = 0; m < childMap.size(); m++ ) {\r\n\r\n\t\t\t\t\t\t\tmap< unsigned int, unsigned int >::iterator itC = childMap.begin();\r\n\t\t\t\t\t\t\tstd::advance( itC, m );\r\n\t\t\t\t\t\t\tunsigned int idC = itC->second;\r\n\r\n\t\t\t\t\t\t\tvector< KeiRo::Base::Polygon2 > &childPolygonVec = svgPtrVec[ idC ]->polygonVec();\r\n\t\t\t\t\t\t\tvector< KeiRo::Base::Line2 > &childPolylineVec = svgPtrVec[ idC ]->polylineVec();\r\n\r\n\t\t\t\t\t\t\tbool isEnable = true;\r\n\t\t\t\t\t\t\tfor( unsigned int n = 0; n < childPolygonVec.size(); n++ ) {\r\n\t\t\t\t\t\t\t\tif( childPolygonVec[ n ].isTextVisible() == true && childPolygonVec[ n ].isVisible() == true ){\r\n\t\t\t\t\t\t\t\t\tisEnable = false;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif( isEnable == true ) {\r\n\t\t\t\t\t\t\t\tpolygonVec[m].isTextVisible() = true;\r\n//\t\t\t\t\t\t\t\tcerr << \"j = \" << j << endl;\r\n\t\t\t\t\t\t\t\tfor( unsigned int n = 0; n < childPolygonVec.size(); n++ ) {\r\n\t\t\t\t\t\t\t\t\tchildPolygonVec[ n ].isVisible() = false;\r\n\t\t\t\t\t\t\t\t\tchildPolygonVec[ n ].isTextVisible() = false;\r\n//\t\t\t\t\t\t\t\t\tcerr << \" on = \" << childPolygonVec[ n ].isVisible() << endl;\r\n//\t\t\t\t\t\t\t\t\tcerr << \" texton = \" << childPolygonVec[ n ].isTextVisible() << endl;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse{\r\n\t\t\t\t\t\t\t\tpolygonVec[m].isTextVisible() = false;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tpolygonVec[m].isVisible() = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\r\n\t\t\tfor( unsigned int i = sortedLevel.size()-1; i < sortedLevel.size(); i++ )\r\n\t\t\t{\r\n\t\t\t\tQFont font;\r\n\t\t\t\tfont.setPointSize( lensSettings->fonts()[i].pointSize() );\r\n\r\n\t\t\t\tfor( unsigned int j = 0; j < sortedLevel[i].size(); j++ ) {\r\n\r\n\t\t\t\t\tunsigned int id = sortedLevel[i][j];\r\n\t\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd = vertex( id, graphmlTree );\r\n\t\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdP = vertex( graphmlTree[vd].parentID, graphmlTree );\r\n\t\t\t\t\tvector< KeiRo::Base::Polygon2 > &polygonVec = svgPtrVec[ id ]->polygonVec();\r\n\r\n\t\t\t\t\tKeiRo::Base::Polygon2 &ParentPolygon = svgPtrVec[ polygonVec[0].parentFileID().second ]->polygonVec()[ polygonVec[0].parentPolygonID() ];\r\n\t\t\t\t\tif( ParentPolygon.isTextVisible() ){\r\n\r\n\t\t\t\t\t\tvector< KeiRo::Base::Rectangle2 > visitedRectVec;\r\n\r\n\t\t\t\t\t\tfor( unsigned int k = 0; k < polygonVec.size(); k++ ){\r\n\r\n\t\t\t\t\t\t\tif( polygonVec[k].stroke()[0] == 0 &&\r\n\t\t\t\t\t\t\t    polygonVec[k].stroke()[1] == 0 &&\r\n\t\t\t\t\t\t\t    polygonVec[k].stroke()[2] == 100 ){\r\n\r\n\t\t\t\t\t\t\t\tQFontMetrics fm( font );\r\n\t\t\t\t\t\t\t\tint pxFntWidth = fm.width( QString::fromStdString( polygonVec[k].label() ) ),\r\n\t\t\t\t\t\t\t\t\t\tpxFntHeight = fm.height();\r\n\r\n\t\t\t\t\t\t\t\tKeiRo::Base::Rectangle2 bbox = polygonVec[k].boundingBox();\r\n\t\t\t\t\t\t\t\tKeiRo::Base::Coord2 center( bbox.leftBottom().x() + 0.5*bbox.width(),\r\n\t\t\t\t\t\t\t\t                            bbox.leftBottom().y() + 0.5*bbox.height() );\r\n\t\t\t\t\t\t\t\tbbox.width() = pxFntWidth + 2*_padding;\r\n\t\t\t\t\t\t\t\tbbox.height() = pxFntHeight + 2*_padding;\r\n\t\t\t\t\t\t\t\tbbox.leftBottom().x() = center.x() - 0.5*bbox.width();\r\n\t\t\t\t\t\t\t\tbbox.leftBottom().y() = center.y() - 0.5*bbox.height();\r\n#ifdef DEBUG\r\n\t\t\t\t\t\t\t\tif( polygonVec[k].label() == \"RE3469C\" ){\r\n\t\t\t\t\t\t\t\t\t\tcerr << \"RE3469C bbox = \" << bbox;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif( polygonVec[k].label() == \"RE3514C\" ){\r\n\t\t\t\t\t\t\t\t\t\tcerr << \"RE3514C bbox = \" << bbox;\r\n\t\t\t\t\t\t\t\t\t}\r\n#endif // DEBUG\r\n\t\t\t\t\t\t\t\tbool isOverlapped = false;\r\n\t\t\t\t\t\t\t\tfor( unsigned int m = 0; m < visitedRectVec.size(); m++ ){\r\n\t\t\t\t\t\t\t\t\tdouble area = 0.0;\r\n\t\t\t\t\t\t\t\t\tKeiRo::Base::Rectangle2 rect = visitedRectVec[m];\r\n\t\t\t\t\t\t\t\t\tif ( bbox.isOverlap( rect, area ) ){\r\n\t\t\t\t\t\t\t\t\t\tisOverlapped = true;\r\n\t\t\t\t\t\t\t\t\t}\r\n#ifdef DEBUG\r\n\t\t\t\t\t\t\t\t\tif( polygonVec[k].label() == \"RE3514C\" ) {\r\n\t\t\t\t\t\t\t\t\t\tcerr << \"rect = \" << rect;\r\n\t\t\t\t\t\t\t\t\t\tcerr << \"isOcerlapped = \" << isOverlapped << endl;\r\n\t\t\t\t\t\t\t\t\t}\r\n#endif // DEBUG\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tif( isOverlapped == false ){\r\n\t\t\t\t\t\t\t\t\tpolygonVec[k].isVisible() = true;\r\n\t\t\t\t\t\t\t\t\tvisitedRectVec.push_back( bbox );\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\tpolygonVec[k].isVisible() = false;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n//\t\t\tfor( int m = sortedLevel.size() - 1 ; m >= 0; m-- ) {\r\n//\t\t\t\tfor( unsigned int n = 0; n < sortedLevel[m].size(); n++ ) {\r\n//\r\n//\t\t\t\t\tunsigned int id = sortedLevel[m][n];\r\n//\t\t\t\t\tvector< KeiRo::Base::Coord2 > &compressedSamples = svgPtrVec[ id ]->compressionGrid().samples();\r\n//\t\t\t\t\tvector< KeiRo::Base::Polygon2 > &polygonVec = svgPtrVec[ id ]->polygonVec();\r\n//\t\t\t\t\tvector< KeiRo::Base::Line2 > &polylineVec = svgPtrVec[ id ]->polylineVec();\r\n//\r\n//\t\t\t\t\t// reset polygon visibility to false\r\n//\t\t\t\t\tbool isLarge = false;\r\n//\r\n//\t\t\t\t\tcerr << \"id = \" << id << endl;\r\n//\t\t\t\t\tcerr << \"polygonVec.size() = \" << polygonVec.size() << endl;\r\n//\t\t\t\t\tfor( unsigned int i = 0; i < MIN2( 1, polygonVec.size()); i++ ) {\r\n//\r\n//\t\t\t\t\t\t// KeiRo::Base::Coord2 & bbox = (*_svgPtr)[m][n].polygonVec()[i].boundingBox();\r\n//\t\t\t\t\t\tstring label = polygonVec[ i ].label();\r\n//\t\t\t\t\t\tdouble namePixelWidth = fm.width( QString::fromStdString( label ) );\r\n//\t\t\t\t\t\tdouble namePixelHeight = fm.height();\r\n//\t\t\t\t\t\tdouble boxWidth = polygonVec[ i ].boundingBox().width();\r\n//\t\t\t\t\t\tdouble boxHeight = polygonVec[ i ].boundingBox().height();\r\n//\r\n//#ifdef GRAPHICSVIEW_DEBUG\r\n//\t\t\t\t\t\tif( id == 1 ) {\r\n//\t\t\t\t\t\t\tcerr << \"label = \" << label\r\n//\t\t\t\t\t\t\t     << \", bbox.x() = \" << polygonVec[ i ].boundingBox().leftBottom().x()\r\n//\t\t\t\t\t\t\t     << \", bbox.y() = \" << polygonVec[ i ].boundingBox().leftBottom().y()\r\n//\t\t\t\t\t\t\t     << \", bbox.width() = \" << polygonVec[ i ].boundingBox().width()\r\n//\t\t\t\t\t\t\t     << \", bbox.height() = \" << polygonVec[ i ].boundingBox().height()\r\n//\t\t\t\t\t\t\t     << \", namePixelWidth = \" << namePixelWidth\r\n//\t\t\t\t\t\t\t     << \", namePixelHeight = \" << namePixelHeight\r\n//\t\t\t\t\t\t\t     << endl;\r\n//\t\t\t\t\t\t}\r\n//#endif // GRAPHICSVIEW_DEBUG\r\n//\t\t\t\t\t\tif( (boxWidth >= 0.8*namePixelWidth) && (boxHeight >= 0.4*namePixelHeight) ) {\r\n//\t\t\t\t\t\t\tisLarge = true;\r\n//\t\t\t\t\t\t}\r\n//\t\t\t\t\t}\r\n//\r\n////\t\t\t\t\tcerr << \"id = \" << id << \", isLarge = \" << isLarge << endl;\r\n//\t\t\t\t\tif( isLarge == true ){\r\n//\t\t\t\t\t\tfor( unsigned int i = 0; i < polygonVec.size(); i++ ) {\r\n//\t\t\t\t\t\t\tpolygonVec[ i ].isVisible() = true;\r\n//\t\t\t\t\t\t}\r\n//\t\t\t\t\t\tfor( unsigned int i = 0; i < polylineVec.size(); i++ ) {\r\n//\t\t\t\t\t\t\tpolylineVec[ i ].isVisible() = true;\r\n//\t\t\t\t\t\t}\r\n//\t\t\t\t\t}\r\n//\t\t\t\t\telse{\r\n//\t\t\t\t\t\tfor( unsigned int i = 0; i < polygonVec.size(); i++ ) {\r\n//\t\t\t\t\t\t\tpolygonVec[ i ].isVisible() = false;\r\n//\t\t\t\t\t\t}\r\n//\t\t\t\t\t\tfor( unsigned int i = 0; i < polylineVec.size(); i++ ) {\r\n//\t\t\t\t\t\t\tpolylineVec[ i ].isVisible() = false;\r\n//\t\t\t\t\t\t}\r\n//\t\t\t\t\t}\r\n//\t\t\t\t}\r\n//\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\tvoid TreemapGraphicsView::_readInputData( void )\r\n\t\t{\r\n//\t\t\t// grid\r\n//\t\t\t_gridPtr = new Grid2;\r\n//\t\t\t_gridPtr->init( &KeiRo::Base::Common::getMainwidgetWidth(), &KeiRo::Base::Common::getMainwidgetHeight() );\r\n//\t\t\t_gridPtr->createDefaultGrid();\r\n\r\n#ifdef DEBUG\r\n\t\t\tcerr << \"fileNum = \" << fileNum << endl;\r\n#endif // DEBUG\r\n\r\n\t\t\t_metadataPtr = new Lens::MetaData;\r\n\t\t\t_metadataPtr->readMetaData( lensSettings->filePath(), _gridPtr );\r\n\r\n\t\t\t// load graphml\r\n\t\t\t_hierarchicalTreemap.init( _metadataPtr, &_selectSceneItemMap,\r\n\t\t\t\t\t\t\t\t\t   &_increaseRatio, &_siblingRatio, &_minSize );\r\n\r\n\t\t\t// load edges\r\n\t\t\t_globalPaths.init( _metadataPtr, &_hierarchicalTreemap );\r\n\t\t}\r\n\r\n\t\t//------------------------------------------------------------------------------\r\n\t\t//\tPublic functions\r\n\t\t//------------------------------------------------------------------------------\r\n\r\n\t\t//------------------------------------------------------------------------------\r\n\t\t//\tConstructors & Destructors\r\n\t\t//------------------------------------------------------------------------------\r\n\t\t//\r\n\t\t//  TreemapGraphicsView::GraphicsView -- constructor\r\n\t\t//\r\n\t\t//  Inputs\r\n\t\t//  none\r\n\t\t//\r\n\t\t//  Outputs\r\n\t\t//  none\r\n\t\t//\r\n\t\tTreemapGraphicsView::TreemapGraphicsView( QWidget *parent )\r\n\t\t\t\t: Ui::GraphicsView( parent ) {\r\n\r\n\t\t\t_scenePtr = new QGraphicsScene;\r\n            _scenePtr->setSceneRect( -KeiRo::Base::Common::getMainwidgetWidth() / 2.0, -KeiRo::Base::Common::getMainwidgetHeight() / 2.0,\r\n                                     KeiRo::Base::Common::getMainwidgetWidth(),\r\n                                     KeiRo::Base::Common::getMainwidgetHeight() );  // x, y, w, h\r\n#ifdef DEBUG\r\n\t\t\tcerr << \"w = \" << width() << \", h = \" << height() << endl;\r\n\t\t\tcerr << \"mainwidget_width = \" << KeiRo::Base::Common::getMainwidgetWidth() << endl;\r\n\t\t\tcerr << \"mainwidget_height = \" << KeiRo::Base::Common::getMainwidgetHeight() << endl;\r\n\t\t\tcerr << \"dockwidget_width = \" << KeiRo::Base::Common::getDockWidgetWidth() << endl;\r\n#endif // DEBUG\r\n\r\n\t\t\t// initialize variables\r\n\t\t\t_metadataPtr = NULL;\r\n\t\t\t_increaseRatio = 0.0;\r\n\t\t\t_siblingRatio = 0.0;\r\n\t\t\t_minSize = 0.0;\r\n//\t\t\t_padding = 1;\r\n\t\t\t_padding = 2;\r\n\t\t\t_marginRatio = 0.1;\r\n\t\t\t_isInitialized = false;\r\n\t\t\t_isCreated = false;\r\n\t\t\t_is_polygonFlag = _is_polylineFlag = true;\r\n\t\t\t_is_treemapFlag = true;\r\n\t\t\t_is_interactionFlag = false;\r\n\t\t\t_is_voronoiFlag = false;\r\n\t\t\t_left_button_pressed = _middle_button_pressed = _right_button_pressed = false;\r\n\r\n\t\t\tsetHorizontalScrollBarPolicy( Qt::ScrollBarAlwaysOff );\r\n\t\t\tsetVerticalScrollBarPolicy( Qt::ScrollBarAlwaysOff );\r\n\r\n//\t\t\t_sbgnPtr = new File::SBGN();\r\n\r\n\t\t\tthis->setScene( _scenePtr );\r\n\t\t}\r\n\r\n\r\n\t\t//------------------------------------------------------------------------------\r\n\t\t//\tEvent handlers\r\n\t\t//------------------------------------------------------------------------------\r\n\t\t//\r\n\t\t//  TreemapGraphicsView::keyPressEvent -- key press event\r\n\t\t//\r\n\t\t//  Inputs\r\n\t\t//  event: key event\r\n\t\t//\r\n\t\t//  Outputs\r\n\t\t//  none\r\n\t\t//\r\n\t\tvoid TreemapGraphicsView::keyPressEvent( QKeyEvent *event ) {\r\n\r\n\t\t\tswitch( event->key() ) {\r\n\r\n\t\t\tcase Qt::Key_L: {\r\n\r\n//\t\t\t\t// Take file path and name that will create\r\n//\t\t\t\tQString filename = QFileDialog::getOpenFileName(\r\n//\t\t\t\t\t\tthis, \"Open Document\",\r\n//\t\t\t\t\t\tQDir::currentPath() + QString( \"/data/\" ), \"SBGN files (*.sbgn)\" );\r\n//\t\t\t\tcerr << \"filename = \" << ( QDir::currentPath() + QString( \"/data/\" ) ).toStdString() << endl;\r\n//\r\n//\t\t\t\t// _init( filename.toStdString() );\r\n//\t\t\t\tinitSceneItems();\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase Qt::Key_T: {\r\n\r\n#ifdef  ACTIVATE_TIMER\r\n\t\t\t\tclock_t start_time = 0, end_time = 0;\r\n#endif // ACTIVATE_TIMER\r\n\r\n\t\t\t\t_hierarchicalTreemap.createHierarchicalTreemap();\r\n\r\n#ifdef  ACTIVATE_TIMER\r\n\t\t\t\tend_time = clock();\r\n//\t\t        cerr << \"Key_T time = \" << (float)(end_time - start_time) << endl;\r\n                cerr << \"Key_T time = \" << (float)(end_time - start_time)/(float)CLOCKS_PER_SEC << endl;\r\n#endif // ACTIVATE_TIMER\r\n\r\n\t\t\t\t_isCreated = true;\r\n\t\t\t\t_is_interactionFlag = true;\r\n\t\t\t\t_is_treemapFlag = true;\r\n// rewrite\t\t\t\t_updateVisibility();\r\n\t\t\t\tinitSceneItems();\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase Qt::Key_R: {\r\n\t\t\t\tif (_isPathSelectionMode) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n#ifdef  ACTIVATE_TIMER\r\n\t\t\t\tclock_t start_time = 0, treemap_end_time = 0, route_end_time = 0;\r\n#endif // ACTIVATE_TIMER\r\n//\t\t\t\tcerr << \"maxIncreaseRatio = \" << _hierarchicalTreemap.maxIncreaseRatio() << endl;\r\n//\t\t\t\tcerr << \"maxSiblingRatio for increaseRatio 0.1 = \" << _hierarchicalTreemap.maxSiblingRatio(0.1) << endl;\r\n//\t\t\t\t_hierarchicalTreemap.assignTreemapSize( ABSOLUTE_TYPE );\r\n//\t\t\t\t_hierarchicalTreemap.assignTreemapSize( EXACT_TYPE );\r\n//                              _hierarchicalTreemap.assignTreemapSize( SIBLINGS_TYPE );\r\n                _hierarchicalTreemap.assignTreemapSize( PARAMETERIZED_TYPE );\r\n\r\n\t\t\t\t_localMoves = _hierarchicalTreemap.updateHierarchicalTreemap( _isInitialized );\r\n\r\n#ifdef  ACTIVATE_TIMER\r\n\t\t\t\ttreemap_end_time = clock();\r\n//\t\t        cerr << \"Key_R treemap time = \" << (float)(end_time - start_time) << endl;\r\n\t\t\t\tcerr << \"Key_R treemap time = \" << (float)(treemap_end_time - start_time)/(float)CLOCKS_PER_SEC << endl;\r\n#endif // ACTIVATE_TIMER\r\n\r\n#ifdef  ACTIVATE_TIMER\r\n\t\t\t\troute_end_time = clock();\r\n//\t\t        cerr << \"Key_R routing time = \" << (float)(end_time - start_time) << endl;\r\n\t\t\t\tcerr << \"Key_R routing time = \" << (float)(route_end_time - treemap_end_time)/(float)CLOCKS_PER_SEC << endl;\r\n#endif // ACTIVATE_TIMER\r\n \t\t\t\tif( _isInitialized == false ) {\r\n\r\n\t\t\t\t    // path initialization\r\n\t\t\t\t    _globalPaths.buildPathGraph();\r\n\t\t\t\t    _globalPaths.buildHierarchicalPaths();\r\n\t\t\t\t    _globalPaths.setFixedPaths();\r\n//\t\t\t\t\t _globalPaths.buildTreemapRelationship();\r\n\t\t\t\t    _isInitialized = true;\r\n\t\t\t    }\r\n\t\t\t\telse{\r\n\r\n\r\n\t\t\t\t\t_globalPaths.update( _localMoves );\r\n\t\t\t\t\tcerr <<\"update finish!!\"<<endl;\r\n\t\t\t\t}\r\n\r\n// rewrite\t\t\t\t_updateVisibility();\r\n\t\t\t\tinitSceneItems();\r\n\t\t\t\tcerr <<\"initsce!!\"<<endl;\r\n\r\n\t\t\t\temit sendSelectedNodesInfo( getSelectedInfo(), _hierarchicalTreemap.maxMinSize() );\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase Qt::Key_E: {\r\n\r\n//\t\t\t\tsimulateKey( Qt::Key_R );\r\n\t\t\t\t_hierarchicalTreemap.resetHierarchicalTreemap();\r\n\t\t\t\t_globalPaths.resetGlobalPaths();\r\n\t\t\t\tinitSceneItems();\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase Qt::Key_A: {\r\n//\r\n//\t\t\t\tstatic KeiRo::Base::Coord2 c( _cursor.x(), _cursor.y() );\r\n//\t\t\t\tc.x() = _cursor.x();\r\n//\t\t\t\tc.y() = _cursor.y();\r\n//\r\n//\t\t\t\tBase::Timer< chrono::milliseconds > timer( \"ms\" );\r\n//\t\t\t\ttimer.begin();\r\n//\r\n//\t\t\t\t// adjustment\r\n//\t\t\t\tfor( unsigned int i = 0; i < 5; i++ ) {\r\n//\t\t\t\t\tfor( unsigned int m = 0; m < _svgPtr.size(); m++ ) {\r\n//\t\t\t\t\t\tfor( unsigned int n = 0; n < _svgPtr[ m ].size(); n++ ) {\r\n//\r\n//\t\t\t\t\t\t\tif( m == 0 ) {\r\n//\t\t\t\t\t\t\t\t( *_adjustmentPtr )[ m ][ n ].parentFlag() = false;\r\n//\t\t\t\t\t\t\t\t( *_adjustmentPtr )[ m ][ n ].init( &_svgPtr[ m ][ n ]->compressionGrid(), c,\r\n//\t\t\t\t\t\t\t\t                                    KeiRo::Base::Common::getMainwidgetWidth(), KeiRo::Base::Common::getMainwidgetHeight() );\r\n//\t\t\t\t\t\t\t\t( *_adjustmentPtr )[ m ][ n ].run();\r\n//\t\t\t\t\t\t\t}\r\n//\t\t\t\t\t\t\telse {\r\n//\t\t\t\t\t\t\t\tKeiRo::Base::Common::UIDPair pFileID = _svgPtr[ m ][ n ]->polygonVec()[ 0 ].parentFileID();\r\n//\t\t\t\t\t\t\t\tunsigned int parentPolygonID = _svgPtr[ m ][ n ]->polygonVec()[ 0 ].parentPolygonID();\r\n//\t\t\t\t\t\t\t\t// cerr << \"pFileID = \" << pFileID.first << \", \" << pFileID.second << endl;\r\n//\t\t\t\t\t\t\t\t// cerr << \"parentPolygonID = \" << parentPolygonID << endl;\r\n//\t\t\t\t\t\t\t\t( *_adjustmentPtr )[ m ][ n ].parentFlag() = true;\r\n//\t\t\t\t\t\t\t\t( *_adjustmentPtr )[ m ][ n ].setParent(\r\n//\t\t\t\t\t\t\t\t\t\t&( *_svgPtr )[ pFileID.first ][ pFileID.second ].compressionGrid(),\r\n//\t\t\t\t\t\t\t\t\t\tparentPolygonID );\r\n//\t\t\t\t\t\t\t\t( *_adjustmentPtr )[ m ][ n ].init( &_svgPtr[ m ][ n ]->compressionGrid(), c,\r\n//\t\t\t\t\t\t\t\t                                    KeiRo::Base::Common::getMainwidgetWidth(), KeiRo::Base::Common::getMainwidgetHeight() );\r\n//\t\t\t\t\t\t\t\t( *_adjustmentPtr )[ m ][ n ].run();\r\n//\t\t\t\t\t\t\t}\r\n//\t\t\t\t\t\t}\r\n//\t\t\t\t\t}\r\n//\t\t\t\t}\r\n#ifdef DEBUG\r\n\t\t\t\ttimer.end();\r\n\t\t\t\tcerr << \"Per A press: \";\r\n\t\t\t\ttimer.elapsed();\r\n#endif // DEBUG\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase Qt::Key_Z: {\r\n\r\n\t\t\t\tstatic KeiRo::Base::Coord2 c( _cursor.x(), _cursor.y() );\r\n\t\t\t\tc.x() = _cursor.x();\r\n\t\t\t\tc.y() = _cursor.y();\r\n\r\n\t\t\t\tBase::Timer< chrono::milliseconds > timer( \"ms\" );\r\n\t\t\t\ttimer.begin();\r\n\t\t\t\tfor( unsigned int i = 0; i < ( *_lensPtr ).size(); i++ ) {\r\n\r\n\t\t\t\t\t( *_lensPtr )[ i ].init( _nestedGridPtr->nestedGrid()[ i ][ 0 ], c, _doiMap,\r\n\t\t\t\t\t                         KeiRo::Base::Common::getMainwidgetWidth(), KeiRo::Base::Common::getMainwidgetHeight() );\r\n\t\t\t\t\t( *_lensPtr )[ i ].run();\r\n\t\t\t\t}\r\n\r\n\r\n#ifdef DEBUG\r\n\t\t\t\ttimer.end();\r\n\t\t\t\tcerr << \"Per Z press: \";\r\n\t\t\t\ttimer.elapsed();\r\n#endif // DEBUG\r\n\r\n\r\n//\t\t\t\t_updatePolygons();\r\n//\t\t\t\t_updatePolylines();\r\n//\t\t\t\tsimulateKey( Qt::Key_A );\r\n\t\t\t\t_updateVisibility();\r\n\r\n\t\t#ifdef GRAPHICVIEW_DEBUG\r\n\t\t\t\tcerr << \"Press Key Z\" << endl;\r\n\t\t\t\t\t\tcerr << c;\r\n\t\t\t\t\t\tcerr << \"(*_lensPtr).size() = \" << (*_lensPtr).size() << endl;\r\n\t\t#endif // GRAPHICVIEW_DEBUG\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tcase Qt::Key_S: {\r\n\t\t\t\tQRectF totalBoundingRect;\r\n\t\t\t\tforeach (QGraphicsItem *item, _scenePtr->items()) {\r\n\t\t\t\t\ttotalBoundingRect = totalBoundingRect.united(item->sceneBoundingRect());\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tint margin = 200;  // Significantly increased margin\r\n\t\t\t\tQSize originalSize = totalBoundingRect.size().toSize();\r\n\t\t\t\tQSize newSize(originalSize.width() + 2*margin, originalSize.height() + 2*margin);\r\n\r\n\t\t\t\t// Generate a unique filename based on current date and time\r\n\t\t\t\tQString baseDir = QDir::currentPath() + QString(\"/../../ResponsiveLens/data/exports/\");\r\n\t\t\t\tQDir().mkpath(baseDir);  // Create the directory if it doesn't exist\r\n\t\t\t\tQString filename = QDateTime::currentDateTime().toString(\"yyyy-MM-dd_hh-mm-ss\") + \"_treemap_export.png\";\r\n\t\t\t\tQString filePath = baseDir + filename;\r\n\r\n\t\t\t\tQPixmap pixmap(newSize);\r\n\t\t\t\tpixmap.fill(Qt::white);\r\n\r\n\t\t\t\tQPainter painter(&pixmap);\r\n\t\t\t\tpainter.setRenderHint(QPainter::Antialiasing);\r\n\r\n\t\t\t\t_scenePtr->render(&painter, QRectF(), totalBoundingRect);\r\n\r\n\t\t\t\tif (pixmap.save(filePath)) {\r\n\t\t\t\t\tqDebug() << \"Image saved successfully to:\" << filePath;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tqDebug() << \"Failed to save image to:\" << filePath;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase Qt::Key_P: {\r\n\t\t\t\t_selectSceneItemMap.clear();\r\n\t\t\t_isPathSelectionMode = true;\r\n\t\t\tinitSceneItems();\r\n\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase Qt::Key_C: {\r\n\t\t\t\t//_selectSceneItemMap.clear();\r\n\t\t\t\tGraph::TreeDirectedGraph &graphmlTree    = _hierarchicalTreemap.metadataPtr()->graphmlTree();\r\n\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd = vertex( 0, graphmlTree );\r\n\t\t\t\tgraphmlTree[ vd ].isSelected = false;\r\n\t\t\t_isPathSelectionMode = false;\r\n\t\t\tinitSceneItems();\r\n\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tdefault: {\r\n\t\t\t\t// QWidget::keyPressEvent( event );\r\n\t\t\t\t// QGraphicsView::keyPressEvent( event );\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tQGraphicsView::keyPressEvent( event );\r\n\t\t\tupdateSceneItems();\r\n\t\t}\r\n\r\n\r\n\t\t//\r\n\t\t//  TreemapGraphicsView::wheelEvent -- mouse wheel event\r\n\t\t//\r\n\t\t//  Inputs\r\n\t\t//  event: wheel event\r\n\t\t//\r\n\t\t//  Outputs\r\n\t\t//  none\r\n\t\t//\r\n\t\tvoid TreemapGraphicsView::wheelEvent( QWheelEvent *event ){\r\n\r\n\t\t\t// cerr << \"wheel event\" << endl;\r\n\t\t\t//setTransformationAnchor( QGraphicsView::AnchorUnderMouse );\r\n\r\n\t\t#ifdef DEBUG\r\n\t\t\tcerr << \"scene()->itemsBoundingRect(): x = \" << scene()->itemsBoundingRect().x()\r\n\t\t         << \", y = \" << scene()->itemsBoundingRect().y()\r\n\t\t         << \", w = \" << scene()->itemsBoundingRect().width()\r\n\t\t         << \", h = \" << scene()->itemsBoundingRect().height() << endl;\r\n\t\t    QPointF coord = mapToScene( event->pos() );\r\n\t\t    cerr << \"mouse zooming...\"\r\n\t\t         << \" x = \" << coord.x() << \" y = \" << coord.y() << endl;\r\n\t\t    // centerOn( coord.x()*_wheelScale, coord.y()*_wheelScale );\r\n\t\t#endif // DEBUG\r\n\r\n\t\t\tQPointF coord = mapToScene( event->pos() );\r\n\t\t\t//cerr << \"mouse zooming...\"\r\n\t\t\t//     << \" x = \" << coord.x() << \" y = \" << coord.y() << endl;\r\n\t\t\t//centerOn( 2000, 1500 );\r\n\r\n\t\t\t// Scale the view / do the zoom\r\n\t\t\tdouble scaleFactor = 1.15;\r\n\t\t\tif( event->delta() > 0) {\r\n\t\t\t\t// Zoom in\r\n\t\t\t\t// cerr << \"zooming in...\" << endl;\r\n\t\t\t\tscale( scaleFactor, scaleFactor );\r\n\t\t\t\t_wheel_scale *= scaleFactor;\r\n//\t\t\t\tcenterOn( coord.x(), coord.y() );\r\n\t\t\t} else {\r\n\t\t\t\t// Zooming out\r\n\t\t\t\t// cerr << \"zooming out...\" << endl;\r\n\t\t\t\tscale( 1.0 / scaleFactor, 1.0 / scaleFactor );\r\n\t\t\t\t_wheel_scale /= scaleFactor;\r\n\t\t\t}\r\n\t\t\t//centerOn( coord.x(), coord.y() );\r\n\r\n\t\t//\t\t\t_updateNameItems();\r\n\r\n\t\t\t//cerr << \"_wheelScale = \" << _wheelScale << endl;\r\n\t\t}\r\n\r\n\r\n\t\t//\r\n\t\t//  TreemapGraphicsView::mousePressEvent -- mouse press event\r\n\t\t//\r\n\t\t//  Inputs\r\n\t\t//  event: mouse event\r\n\t\t//\r\n\t\t//  Outputs\r\n\t\t//  none\r\n\t\t//\r\nvoid TreemapGraphicsView::handlePathSelection(QGraphicsPathItem *pathItem)\r\n\t\t{\r\n\t\t\tint pathIndex = pathItem->data(0).toInt();\r\n\r\n\t\t\t// Deselect previously selected path\r\n\t\t\tif (m_selectedPathIndex >= 0 && m_selectedPathIndex < m_pathItems.size()) {\r\n\t\t\t\tm_pathItems[m_selectedPathIndex]->setPen(QPen(generateDistinctColor(m_selectedPathIndex, m_pathItems.size()), 20));\r\n\t\t\t}\r\n\r\n\t\t\t// Select new path\r\n\t\t\tm_selectedPathIndex = pathIndex;\r\n\t\t\tpathItem->setPen(QPen(Qt::red, 30 + 2));  // Highlight selected path\r\n\r\n\t\t\temit pathSelected(pathIndex);\r\n\r\n\t\t\t// Update the scene\r\n\t\t\t_scenePtr->update();\r\n\t\t}\r\n\t\tvoid TreemapGraphicsView::mousePressEvent( QMouseEvent *event ) {\r\n\r\n\t\t\tQPointF coord = mapToScene( event->pos() );\r\n\t\t\t// centerOn( coord.x(), coord.y() );\r\n\r\n\t\t\tdouble square = 5.0;\r\n\r\n\t\t\t// only support for newer qt5\r\n\t\t\t// clear the previous selectionArea\r\n#ifdef __APPLE__\r\n\t\t\t if( !_selectionArea.isEmpty() ) _selectionArea.clear();\r\n#endif  // __APPLE__\r\n\r\n\t\t\t\t_selectionArea.addPolygon( mapToScene(\r\n\t\t\t\t\t\tQRect( event->pos().x() - square / 2.0, event->pos().y() - square / 2.0, square, square ) ) );\r\n\t\t\t\t_selectionArea.closeSubpath();\r\n\r\n\t\t\t\t// Set selection area and get selected items\r\n\t\t\t\t_scenePtr->setSelectionArea(_selectionArea, this->rubberBandSelectionMode());\r\n\t\t\t\t_selectedGraphicsItems = _scenePtr->selectedItems();\r\n\r\n\t\t\t\t_scenePtr->setSelectionArea( _selectionArea );\r\n\t\t\t\t//\t\t\tcerr << \"selectedItems = \" << _scenePtr->selectedItems().size() << endl;\r\n\t\t\t\t_scenePtr->setSelectionArea( _selectionArea, this->rubberBandSelectionMode() ); //, viewportTransform() );\r\n\t\t\t\t_selectedGraphicsItems = _scenePtr->selectedItems();\r\n\r\n\r\n\t\t\t\tswitch( event->buttons() ) {\r\n\t\t\t\t\tcase Qt::RightButton: {\r\n\r\n\t\t\t\t\t\t_right_button_pressed = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase Qt::LeftButton: {\r\n\r\n\t\t\t\t\t\t_left_button_pressed = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase Qt::MiddleButton: {\r\n\t\t\t\t\t\t_middle_button_pressed = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault: {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\tQGraphicsView::mousePressEvent( event );\r\n\r\n//#ifdef GRAPHICSVIEW_DEBUG\r\n\t\t\tcerr << \"mouse pressing...\" << endl\r\n\t\t\t\t\t\t << \" x = \" << event->pos().x() << \" y = \" << event->pos().y() << endl\r\n\t\t\t\t\t\t << \" sx = \" << coord.x() << \" sy = \" << coord.y() << endl;\r\n\t\t\tcerr << \"_right_button_pressed = \" << _right_button_pressed << endl\r\n\t\t\t\t << \"_left_button_pressed = \" << _left_button_pressed << endl\r\n\t\t\t\t << \"_middle_button_pressed = \" << _middle_button_pressed << endl;\r\n//#endif // GRAPHICSVIEW_DEBUG\r\n\t\t}\r\n\r\n\t\t//\r\n\t\t//  TreemapGraphicsView::mouseMoveEvent -- mouse move event\r\n\t\t//\r\n\t\t//  Inputs\r\n\t\t//  event: mouse event\r\n\t\t//\r\n\t\t//  Outputs\r\n\t\t//  none\r\n\t\t//\r\n\t\tvoid TreemapGraphicsView::mouseMoveEvent( QMouseEvent *event ) {\r\n\r\n\t\t\t_cursor = QPoint( event->pos().x() - KeiRo::Base::Common::getMainwidgetWidth() / 2,\r\n\t\t\t                  -( event->pos().y() - KeiRo::Base::Common::getMainwidgetHeight() / 2 ) );\r\n\t\t\tdouble norm = QLineF( _cursor, _oldCursor ).length();\r\n\r\n\t\t\tif( norm > 1.0 * _min_point_distance ) {\r\n//\t\t\t\tsimulateKey( Qt::Key_Z );\r\n\r\n\t\t#ifdef GRAPHICSVIEW_DEBUG\r\n\t\t\t\t// sleep( 3 );\r\n\t\t\t\tcerr << \"########################\" << endl;\r\n\t\t\t\tcerr << \"norm = \" << norm << endl;\r\n\t\t\t\tcerr << \"Moving mouse ... \" << endl;\r\n\t\t\t\tcerr << \", className = \" << className() << endl;\r\n\t\t\t\tcerr << \"_oldCursor = \" << _oldCursor.x() << \", \" << _oldCursor.y() << endl;\r\n\t\t\t\tcerr << \"_cursor = \" << _cursor.x() << \", \" << _cursor.y() << endl;\r\n\t\t\t\tcerr << \"norm = \" << norm << endl;\r\n\t\t#endif // GRAPHICSVIEW_DEBUG\r\n\t\t\t\t_oldCursor = _cursor;\r\n\t\t\t}\r\n\t\t\tQGraphicsView::mouseMoveEvent( event );\r\n\t\t}\r\n\r\n\t\t//\r\n\t\t//  TreemapGraphicsView::mouseReleaseEvent -- mouse release event\r\n\t\t//\r\n\t\t//  Inputs\r\n\t\t//  event: mouse event\r\n\t\t//\r\n\t\t//  Outputs\r\n\t\t//  none\r\n\t\t//\r\n\t\tvoid TreemapGraphicsView::mouseReleaseEvent( QMouseEvent *event )\r\n\t\t{\r\n\t\t\tGraph::TreeDirectedGraph &graphmlTree    = _hierarchicalTreemap.metadataPtr()->graphmlTree();\r\n\r\n\t\t\t// proceed only when treemap is created\r\n\t\t\tif( !_isCreated ) {\r\n\t\t\t\t// reset mouse\r\n\t            _right_button_pressed = false;\r\n\t            _left_button_pressed = false;\r\n\t            _middle_button_pressed = false;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tUi::Vector::GraphicsPolygonItem *topItemptr = NULL;\r\n\t\t\tUi::Vector::GraphicsEdgeItem *topItemptr1 = NULL;\r\n\t\t\t // Initialize with an invalid ID\r\n\t\t\tif (selectedPathId != -1)\r\n\t\t\t\t_oldSelectedPathId = selectedPathId;\r\n\r\n\t\t\t// find the selected top polygon\r\n\t\t\tdouble minRegion = INFINITY;\r\n//\t\t\tcerr << \"selectedItem.size() = \" << selectedItems.size() << endl;\r\n\t\t\tif (_isPathSelectionMode ==false) {\r\n\t\t\t\tfor( unsigned int i = 0; i < _selectedGraphicsItems.size(); i++ ){\r\n\r\n\t\t\t\t\tUi::Vector::GraphicsPolygonItem *itemptr = dynamic_cast< Ui::Vector::GraphicsPolygonItem *>(_selectedGraphicsItems[i]);\r\n\t\t\t\t\tunsigned int attributeID = itemptr->attributeID();\r\n\r\n\t\t\t\t\tdouble region = _selectedGraphicsItems[i]->boundingRect().width() * _selectedGraphicsItems[i]->boundingRect().height();\r\n\r\n\t\t\t\t\tif( minRegion > region ){\r\n\t\t\t\t\t\tminRegion = region;\r\n\t\t\t\t\t\ttopItemptr = itemptr;\r\n\r\n\t\t\t\t\t\tcerr << \"label id = \" << topItemptr->id() << endl;\r\n\t\t\t\t\t\tcerr << \"label name = \" << topItemptr->name().toStdString() << endl;\r\n\t\t\t\t\t\tcerr << \"label text = \" << topItemptr->text().toStdString() << endl;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (_isPathSelectionMode) {\r\n\r\n\t\t\t\tQPointF scenePos = mapToScene(event->pos());\r\n\t\t\t\tQGraphicsItem *itemUnderCursor = scene()->itemAt(scenePos, transform());\r\n\t\t\t\ttopItemptr1 = dynamic_cast<Ui::Vector::GraphicsEdgeItem*>(itemUnderCursor);\r\n\t\t\t\tif (topItemptr1 != NULL) {\r\n\r\n\t\t\t\t\tselectedPathId = topItemptr1->data(0).toUInt();\r\n\r\n\t\t\t\t\tcerr << \"Selected path ID: \" << selectedPathId << endl;\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t}\r\n\r\n\r\n\r\n\t\t\tif( _left_button_pressed == true ){\r\n\r\n\t\t\t\tif( topItemptr != NULL ){\r\n\r\n\t\t\t\t\tunsigned int graphmlTreeID = topItemptr->attributeID();\r\n\t\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd = vertex( graphmlTreeID, graphmlTree );\r\n\t\t\t\t\tgraphmlTree[ vd ].isSelected = true;\r\n\r\n\t\t\t\t\t// collect selected items\r\n\t\t\t\t\t_selectSceneItemMap.insert( pair< unsigned int, unsigned int >( graphmlTreeID, graphmlTreeID ) );\r\n\r\n\t\t\t\t\tQColor color = QColor( 255, 100, 100, 255 );\r\n\t\t\t\t\tmap< unsigned int, Ui::Vector::GraphicsPolygonItem * >::iterator it = _rectangleItemMap.find( graphmlTreeID );\r\n\t\t\t\t\tit->second->setBrush( QBrush( QColor( color.red(), color.green(), color.blue(), 255 ),\r\n\t\t\t\t\t                              Qt::SolidPattern ) );\r\n\t\t\t\t}\r\n\t\t\t\telse if (topItemptr1 !=NULL) {\r\n\r\n\t\t\t\t\tunsigned int newSelectedPathId = topItemptr1->data(0).toUInt();\r\n\t\t\t\t\tunsigned int graphmlTreeID = topItemptr1->id();\r\n\t\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd = vertex( graphmlTreeID, graphmlTree );\r\n\t\t\t\t\tgraphmlTree[ vd ].isSelected = true;\r\n\t\t\t\t\tif ( -1 != _oldSelectedPathId) {\r\n\t\t\t\t\t\tcerr <<\"old and new not the same\"<<endl;\r\n\t\t\t\t\t\tauto range = _edgeItemMap.equal_range(_oldSelectedPathId);\r\n\t\t\t\t\t\tif (range.first != _edgeItemMap.end()) {\r\n\t\t\t\t\t\t\tfor (auto it = range.first; it != range.second; ++it) {\r\n\t\t\t\t\t\t\t\tUi::Vector::GraphicsEdgeItem* edgeItem = it->second;\r\n\r\n\t\t\t\t\t\t\t\tQColor currentColor = edgeItem->pen().color();\r\n\t\t\t\t\t\t\t\tqreal h, s, v, a;\r\n\t\t\t\t\t\t\t\tcurrentColor.getHsvF(&h, &s, &v, &a);\r\n\t\t\t\t\t\t\t\tQColor newColor = QColor::fromHsvF(h, 0.6, 0.8, a);  // Less saturated\r\n\r\n\t\t\t\t\t\t\t\tint oldWidth = edgeItem->pen().width();\r\n\t\t\t\t\t\t\t\tQPen newPen(newColor, oldWidth - 2);  // Restore original width\r\n\t\t\t\t\t\t\t\tedgeItem->setPen(newPen);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t_selectSceneItemMap.erase(_oldSelectedPathId);\r\n\r\n\t\t\t\t\t\t\t// Deselect end rectangles\r\n\t\t\t\t\t\t\tauto it1 = _rectangleItemMap.find(oldRectId1 );\r\n\t\t\t\t\t\t\tif (it1 != _rectangleItemMap.end()) {\r\n\t\t\t\t\t\t\t\tit1->second->settoDefaultPen();\r\n\t\t\t\t\t\t\t\tit1->second->settoDefaultBrush();\r\n\r\n\t\t\t\t\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd = vertex(oldRectId1, graphmlTree);\r\n\t\t\t\t\t\t\t\tgraphmlTree[vd].isSelected = false;\r\n\r\n\t\t\t\t\t\t\t\t_selectSceneItemMap.erase(oldRectId1);\r\n\t\t\t\t\t\t\t\t// deselectRectangle(_globalPaths.pathStartIdGS[pathId]);\r\n\t\t\t\t\t\t\t\t// deselectRectangle(_globalPaths.pathStartIdGT[pathId]);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tauto it2 = _rectangleItemMap.find(oldRectId2 );\r\n\t\t\t\t\t\t\tif (it2 != _rectangleItemMap.end()) {\r\n\t\t\t\t\t\t\t\tit2->second->settoDefaultPen();\r\n\t\t\t\t\t\t\t\tit2->second->settoDefaultBrush();\r\n\r\n\t\t\t\t\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd = vertex(oldRectId2, graphmlTree);\r\n\t\t\t\t\t\t\t\tgraphmlTree[vd].isSelected = false;\r\n\r\n\t\t\t\t\t\t\t\t_selectSceneItemMap.erase(oldRectId2);\r\n\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\t// path selection\r\n\t\t\t\t\tauto range = _edgeItemMap.equal_range(selectedPathId);\r\n\t\t\t\t\tif (range.first != _edgeItemMap.end()) {\r\n\t\t\t\t\t\tfor (auto it = range.first; it != range.second; ++it) {\r\n\t\t\t\t\t\t\tUi::Vector::GraphicsEdgeItem* edgeItem = it->second;\r\n\r\n\t\t\t\t\t\t\tQColor oldColor = edgeItem->pen().color();\r\n\t\t\t\t\t\t\tint oldWidth = edgeItem->pen().width();\r\n\t\t\t\t\t\t\tQColor currentColor = edgeItem->pen().color();\r\n\r\n\t\t\t\t\t\t\t// Convert to HSV\r\n\t\t\t\t\t\t\tqreal h, s, v, a;\r\n\t\t\t\t\t\t\tcurrentColor.getHsvF(&h, &s, &v, &a);\r\n\r\n\t\t\t\t\t\t\tQColor newColor = QColor::fromHsvF(h, 0.99, 0.99, a);\r\n\r\n\r\n\t\t\t\t\t\t\tQPen newPen(newColor, oldWidth + 2);  // Red color, slightly thicker\r\n\t\t\t\t\t\t\tedgeItem->setPen(newPen);\r\n\t\t\t\t\t\t\tcerr << \"Edge found. PathID: \" << selectedPathId << endl;\r\n\t\t\t\t\t\t\tedgeItem->update();\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// Add to selection map\r\n\t\t\t\t\t\t_selectSceneItemMap.insert(pair<unsigned int, unsigned int>(selectedPathId, selectedPathId));\r\n\r\n\t\t\t\t\t\tunsigned int graphmlTreeID1 = _globalPaths.pathStartIdGS[selectedPathId];\r\n\r\n\t\t\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd1 = vertex( graphmlTreeID1, graphmlTree );\r\n\t\t\t\t\t\tgraphmlTree[ vd1 ].isSelected = true;\r\n\r\n\t\t\t\t\t\tunsigned int graphmlTreeID2 = _globalPaths.pathStartIdGT[selectedPathId];\r\n\t\t\t\t\t\t;\r\n\t\t\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd2 = vertex( graphmlTreeID2, graphmlTree );\r\n\t\t\t\t\t\tgraphmlTree[ vd2 ].isSelected = true;\r\n\r\n\t\t\t\t\t\t// collect selected items\r\n\t\t\t\t\t\t_selectSceneItemMap.insert( pair< unsigned int, unsigned int >( graphmlTreeID1, graphmlTreeID1 ) );\r\n\t\t\t\t\t\t_selectSceneItemMap.insert( pair< unsigned int, unsigned int >( graphmlTreeID2, graphmlTreeID2 ) );\r\n\r\n\t\t\t\t\t\tQColor color = QColor( 255, 100, 100, 255 );\r\n\t\t\t\t\t\tmap< unsigned int, Ui::Vector::GraphicsPolygonItem * >::iterator it1 = _rectangleItemMap.find( graphmlTreeID1 );\r\n\t\t\t\t\t\tit1->second->setPen( QPen( QColor( 0, 0, 0, 255 ), 5 ) );\r\n\t\t\t\t\t\tit1->second->setBrush( QBrush( QColor( color.red(), color.green(), color.blue(), 255 ),\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t  Qt::SolidPattern ) );\r\n\t\t\t\t\t\tmap< unsigned int, Ui::Vector::GraphicsPolygonItem * >::iterator it2 = _rectangleItemMap.find( graphmlTreeID2 );\r\n\t\t\t\t\t\tit2->second->setPen( QPen( QColor( 0, 0, 0, 255 ), 5 ) );\r\n\t\t\t\t\t\tit2->second->setBrush( QBrush( QColor( color.red(), color.green(), color.blue(), 255 ),\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t  Qt::SolidPattern ) );\r\n\r\n\t\t\t\t\t\toldRectId1 = graphmlTreeID1;\r\n\t\t\t\t\t\toldRectId2 = graphmlTreeID2;\r\n\r\n//simulateKey(Qt::Key_R);\r\n\t\t\t\t\t\tscene()->update();\r\n\r\n\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tcerr <<\"not found\"<<endl;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif( _middle_button_pressed == true ){\r\n\r\n\t\t\t\tfor( map< unsigned int, unsigned int >::iterator it = _selectSceneItemMap.begin();\r\n\t\t\t\t\t it != _selectSceneItemMap.end(); it++ ){\r\n\t\t\t\t\tunsigned int id = it->first;\r\n\t\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd = vertex( id, graphmlTree );\r\n\t\t\t\t\tgraphmlTree[ vd ].isSelected = false;\r\n\t\t\t\t}\r\n\t\t\t\t_selectSceneItemMap.clear();\r\n\t\t\t\tcerr << \"clear selection... \" << endl;\r\n\t\t\t\tsimulateKey( Qt::Key_R );\r\n//\t\t\t\tsimulateKey( Qt::Key_E );\r\n\t\t\t}\r\n\r\n\t\t\tif( _right_button_pressed == true ){\r\n\r\n\t\t\t\tif( topItemptr != NULL ){\r\n\r\n\t\t\t\t\tunsigned int graphmlTreeID = topItemptr->attributeID();\r\n\t\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd = vertex( graphmlTreeID, graphmlTree );\r\n\t\t\t\t\tgraphmlTree[ vd ].isSelected = false;\r\n\r\n\t\t\t\t\tUi::Vector::GraphicsPolygonItem *itemptr = dynamic_cast< Ui::Vector::GraphicsPolygonItem *>( topItemptr );\r\n\t\t\t\t\titemptr->settoDefaultPen();\r\n\t\t\t\t\titemptr->settoDefaultBrush();\r\n\r\n\t\t\t\t\t_selectSceneItemMap.erase( graphmlTreeID );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// reset mouse\r\n\t\t\t_right_button_pressed = false;\r\n\t\t\t_left_button_pressed = false;\r\n\t\t\t_middle_button_pressed = false;\r\n\r\n\t\t\t// emit select info, this seg faults if treemap is not created!\r\n\t\t\temit sendSelectedNodesInfo( getSelectedInfo(),  _hierarchicalTreemap.maxMinSize() );\r\n\r\n\t\t\tQGraphicsView::mouseReleaseEvent( event );\r\n//\t\t\tcerr << \"event->buttons() = \" << event->buttons() << endl;\r\n//\t\t\tupdateSceneItems();\r\n\t\t\tscene()->update();\r\n\t\t\tcerr << \"Releasing mouse ...\" << endl;\r\n\r\n\t\t#ifdef GRAPHICSVIEW_DEBUG0\r\n\t\t\tcerr << \"Releasing mouse ...\" << endl;\r\n\t\t\t\t\tcerr << \"_right_button_pressed = \" << _right_button_pressed << endl\r\n\t\t\t\t\t\t << \"_left_button_pressed = \" << _left_button_pressed << endl\r\n\t\t\t\t\t\t << \"_middle_button_pressed = \" << _middle_button_pressed << endl;\r\n\t\t#endif // GRAPHICSVIEW_DEBUG\r\n\t\t}\r\n\r\n\r\n\r\n\t\t//------------------------------------------------------------------------------\r\n\t\t//\tSpecial functions\r\n\t\t//------------------------------------------------------------------------------\r\n\t\t//\r\n\t\t//  TreemapGraphicsView::init -- initialize the object\r\n\t\t//\r\n\t\t//  Inputs\r\n\t\t//  none\r\n\t\t//\r\n\t\t//  Outputs\r\n\t\t//  none\r\n\t\t//\r\n\t\tvoid TreemapGraphicsView::init( KeiRo::Base::Base *__b_ptr ) {\r\n\r\n\t\t\t_basePtr = __b_ptr;\r\n//\t\t\t_filePath = qApp->applicationDirPath() + QString( \"/../../ResponsiveLens/data/svg/\" ) + \"small\";\r\n//\t\t\t_filePath = qApp->applicationDirPath() + QString( \"/../../ResponsiveLens/data/svg/\" ) + \"A\";\r\n//\t\t\t_filePath = qApp->applicationDirPath() + QString( \"/../../ResponsiveLens/data/svg/\" ) + \"major\";\r\n\r\n\t\t\tif( !lensSettings ) {\r\n\t\t\t\tqDebug() << \"no settings!\" << endl;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tconnect(lensSettings, &LensSetting::sendFilePath,\r\n\t\t\t\t\t\tthis, &TreemapGraphicsView::recvFilePath);\r\n\t\t\t\tconnect(lensSettings, &LensSetting::sendLayerFont,\r\n\t\t\t\t\t\tthis, &TreemapGraphicsView::recvLayerFont);\r\n\t\t\t\tconnect(lensSettings, &LensSetting::sendIncrease,\r\n\t\t\t\t\t\tthis, &TreemapGraphicsView::recvIncrease);\r\n\t\t\t\tconnect(lensSettings, &LensSetting::sendSiblingRatio,\r\n                                                this, &TreemapGraphicsView::recvSiblingRatio);\r\n\t\t\t\tconnect(lensSettings, &LensSetting::sendMinSize,\r\n\t\t\t\t\t\tthis, &TreemapGraphicsView::recvMinSize);\r\n\t\t\t\tconnect(lensSettings, &LensSetting::pressedRButton,\r\n\t\t\t\t\t\tthis, &TreemapGraphicsView::recvRButtonPress);\r\n\t\t\t\tconnect(this, &TreemapGraphicsView::sendSelectedNodesInfo,\r\n\t\t\t\t\t\tlensSettings, &LensSetting::recvSelectedNodesInfo);\r\n\t\t\t\tconnect(this, &TreemapGraphicsView::sendMaxIncrease,\r\n                                                lensSettings, &LensSetting::recvMaxIncrease);\r\n\t\t\t\tconnect(this, &TreemapGraphicsView::sendMaxSiblingRatio,\r\n\t\t\t\t\t\tlensSettings, &LensSetting::recvMaxSiblingRatio);\r\n\t\t\t\tconnect(lensSettings, &LensSetting::exportImageRequested,\r\n\t\t\t\tthis, &TreemapGraphicsView::handleExportRequest);\r\n\t\t\t\tconnect(this, &TreemapGraphicsView::pathSelected,\r\n\t\t\tlensSettings, &LensSetting::onPathSelected);\r\n\r\n\r\n\t\t\t}\r\n\t\t\t_init();\r\n\t\t}\r\n\r\n\t\t//\r\n\t\t//  TreemapGraphicsView::initSceneItems -- initialize SceneItems\r\n\t\t//\r\n\t\t//  Inputs\r\n\t\t//  none\r\n\t\t//\r\n\t\t//  Outputs\r\n\t\t//  none\r\n\t\t//\r\n\t\tvoid TreemapGraphicsView::initSceneItems( void ) {\r\n\r\n\t\t\tif( _metadataPtr == NULL ){\r\n\r\n\t\t\t}\r\n\t\t\telse if( _metadataPtr->dataType() == DATA_SVG ){\r\n\r\n\t\t\t\t// initialization\r\n\t\t\t\t_scenePtr->clear();\r\n#ifdef SKIP\r\n\t\t\t\tif( _is_voronoiFlag == true ) {\r\n\t\t\t\t\t_item_voronoi();\r\n\t\t\t\t\t_item_boundary();\r\n\t\t\t\t}\r\n#endif // SKIP\r\n\t\t\t\tif( _is_polygonFlag == true ) {\r\n\t\t\t\t\t_item_polygons();\r\n\t\t\t\t}\r\n\t\t\t\tif( _is_polylineFlag == true ) {\r\n\t\t\t\t\t_item_globalPaths();\r\n\t\t\t\t\t_item_globalPathGraph();\r\n\t\t\t\t\t_item_polylines();\r\n\t\t\t\t}\r\n\t\t\t\tif( _is_polygonFlag == true ) {\r\n\t\t\t\t\t_item_polygonVertices();\r\n\t\t\t\t}\r\n\t\t\t\tif( _is_treemapFlag == true ) {\r\n\t\t\t\t\t_item_treemap();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdataInitialized();\r\n\t\t\t}\r\n\t\t\telse if ( _metadataPtr->dataType() == DATA_GRAPHML ){\r\n\r\n\t\t\t\t// initialization\r\n\t\t\t\t_scenePtr->clear();\r\n\r\n\t\t\t\tif( _is_polygonFlag == true ) {\r\n\t\t\t\t\t_item_XMLPolygons();\r\n\r\n\t\t\t\t}\r\n\t\t\t\tif( _is_polylineFlag == true ) {\r\n\t\t\t\t\t//_item_globalPathGraph();\r\n\t\t\t\t\t//_item_XMLPolylines();\r\n\t\t\t\t\t_item_globalPaths();\r\n\r\n\t\t\t\t}\r\n\t\t\t\tif( _is_polygonFlag == true ) {\r\n\t\t\t\t\t _item_XMLGraph();\r\n\r\n\t\t\t\t}\r\n\t\t\t\tif( _is_treemapFlag == true ) {\r\n\t\t\t\t\t//_item_treemap();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdataInitialized();\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tcerr << \"sth is wrong here at \" << __LINE__ << \" in \" << __FILE__ << endl;\r\n\t\t\t}\r\n\r\n#ifdef DEBUG\r\n\t\t\tcerr << \"_scenePtr->size = \" << _scenePtr->items().size() << endl;\r\n#endif // DEBUG\r\n\t\t}\r\n\r\n\t\t//\r\n\t\t//  TreemapGraphicsView::updateSceneItems -- initialize SceneItems\r\n\t\t//\r\n\t\t//  Inputs\r\n\t\t//  none\r\n\t\t//\r\n\t\t//  Outputs\r\n\t\t//  none\r\n\t\t//\r\n\t\tvoid TreemapGraphicsView::updateSceneItems( void ) {\r\n\r\n//\t\t\tif( _is_voronoiFlag == true ) {\r\n//\t\t\t\t_update_item_voronoi();\r\n//\t\t\t\t_update_item_boundary();\r\n//\t\t\t}\r\n//\t\t\tif( _is_polylineFlag == true ) {\r\n//\t\t\t\t_update_item_globalPaths();\r\n//\t\t\t\t_update_item_polylines();\r\n//\t\t\t}\r\n//\t\t\tif( _is_polygonFlag == true ) {\r\n//\t\t\t\t_update_item_polygons();\r\n//\t\t\t}\r\n//\t\t\tif( _is_treemapFlag == true ) {\r\n//\t\t\t\t_update_item_treemap();\r\n//\t\t\t}\r\n//\t\t\tscene()->update();\r\n\t\t\tdataChanged();\r\n#ifdef DEBUG\r\n\t\t\tcerr << \"_scene.size = \" << _scene->items().size() << endl;\r\n#endif // DEBUG\r\n\t\t}\r\n\r\n\r\n\t\t// slots\r\n\t\tvoid TreemapGraphicsView::recvFilePath( QString filePath ) {\r\n//\t\t\t_filePathPtr = filePath;\r\n\t\t\t_init();\r\n\t\t\tinitSceneItems();\r\n\t\t}\r\n\t\tvoid TreemapGraphicsView::recvLayerFont( vector< QFont > fonts ) {\r\n//\t\t\tlensSettings->fonts().resize( _metadataPtr->maxLevel() );\r\n//\t\t\t_fontsPtr = fonts;\r\n\t\t\tinitSceneItems();\r\n\t\t}\r\n\t\tvoid TreemapGraphicsView::recvIncrease( double increaseRatio ) {\r\n\t\t\t_increaseRatio = increaseRatio;\r\n\t\t\tdouble maxSiblingRatio = _hierarchicalTreemap.maxSiblingRatio( _increaseRatio, _minSize );\r\n\t\t\temit sendMaxSiblingRatio( maxSiblingRatio );\r\n\t\t}\r\n\t\tvoid TreemapGraphicsView::recvSiblingRatio( double siblingRatio ) {\r\n\t\t\t_siblingRatio = siblingRatio;\r\n\t\t}\r\n\t\tvoid TreemapGraphicsView::recvMinSize( double minSize ) {\r\n\t\t\t_minSize = minSize;\r\n\t\t\tdouble maxIncrease = _hierarchicalTreemap.maxIncreaseRatio( _minSize );\r\n\t\t\temit sendMaxIncrease( maxIncrease );\r\n\t\t}\r\n\t\tvoid TreemapGraphicsView::recvRButtonPress( void ) {\r\n\t\t\tsimulateKey( Qt::Key_R );\r\n\t\t}\r\nvoid TreemapGraphicsView::handleExportRequest()\r\n\t\t{\r\n\t\t\tQString baseDir = QDir::currentPath() + QString(\"/../../ResponsiveLens/data/\");\r\n\r\n\t\t\t// Create an \"exports\" subfolder\r\n\t\t\tQString exportDir = baseDir + \"exports/\";\r\n\t\t\tQDir().mkpath(exportDir);  // This will create the directory if it doesn't exist\r\n\r\n\t\t\t// Generate a unique filename based on current date and time\r\n\t\t\tQString defaultFilename = QDateTime::currentDateTime().toString(\"yyyy-MM-dd_hh-mm-ss\") + \"_treemap.png\";\r\n\t\t\tQString defaultPath = exportDir + defaultFilename;\r\n\r\n\t\t\t// Open the save file dialog\r\n\t\t\tQString filePath = QFileDialog::getSaveFileName(\r\n\t\t\t\tthis,\r\n\t\t\t\ttr(\"Save Image\"),\r\n\t\t\t\tdefaultPath,\r\n\t\t\t\ttr(\"Images (*.png *.jpg *.bmp)\")\r\n\t\t\t);\r\n\r\n\t\t\tif (!filePath.isEmpty()) {\r\n\t\t\t\tTreemapGraphicsView::exportImage(filePath);\r\n\t\t\t}\r\n\t\t}\r\nvoid TreemapGraphicsView::exportImage( QString &filePath)\r\n\t\t{\r\n\t\t\tQPixmap pixmap(this->scene()->sceneRect().size().toSize());\r\n\t\t\tpixmap.fill(Qt::white);\r\n\t\t\tQPainter painter(&pixmap);\r\n\t\t\tthis->scene()->render(&painter);\r\n\t\t\tpixmap.save(filePath);\r\n\t\t\tcerr <<\" Image saved!\"<<endl;\r\n\t\t}\r\n\r\n\r\n\t\tvector< pair<unsigned int, QString> > TreemapGraphicsView::getSelectedInfo( void ) {\r\n\r\n\t\t\t// info: svg_file, size(ss.str)\r\n\t\t\tvector< pair<unsigned int, QString> > res;\r\n\r\n\t\t\tdouble ww = KeiRo::Base::Common::getMainwidgetWidth();\r\n\t\t\tdouble wh = KeiRo::Base::Common::getMainwidgetHeight();\r\n\r\n\t\t\tvector< vector< unsigned int > > &sortedLevel   = _hierarchicalTreemap.sortedLevel();\r\n\t\t\tLens::MetaData                   *metadataPtr   = _hierarchicalTreemap.metadataPtr();\r\n\t\t\tGraph::TreeDirectedGraph         &svgTree       = metadataPtr->svgTree();\r\n\t\t\tvector< FileIO::SVG* >           &svgPtrVec     = metadataPtr->svgPtrVec();\r\n\t\t\tGraph::TreeDirectedGraph         &graphmlTree   = _hierarchicalTreemap.metadataPtr()->graphmlTree();\r\n\t\t\tvector< Lens::Treemap >          &treemapVec    = _hierarchicalTreemap.treemapVec();\r\n\r\n\t\t\tif( treemapVec.size() == 0 ) return res;\r\n\r\n//\t\t\tcerr << \"_selectSceneItems.size() = \" << _selectSceneItems.size() << endl;\r\n\t\t\tfor( map< unsigned int, unsigned int >::iterator itItm = _selectSceneItemMap.begin();\r\n\t\t\t\titItm != _selectSceneItemMap.end(); itItm++ ) {\r\n\r\n\t\t\t\t// node info\r\n\t\t\t\tunsigned int level = 0;//std::get<0>( itItm->second );\r\n\t\t\t\tunsigned int member = 0;//std::get<1>( itItm->second );\r\n\t\t\t\tunsigned int polygonMember = 0;//std::get<2>( itItm->second );\r\n\t\t\t\tunsigned int id = sortedLevel[level][member];\r\n#ifdef DEBUG\r\n\t\t\t\tqDebug()<<\" \tid=\"<<id<<\"; level=\"<<level<<\"; member=\"<<member<<\"; poly=\"<<polygonMember<<endl;\r\n\t\t\t\tqDebug()<<\" \ttreemapVec.size()= \"<<treemapVec.size()<<endl;\r\n\t\t\t\tif( id >= treemapVec.size() ) {\r\n\t\t\t\t\tqDebug()<<\" \toverflow!!!\"<<endl;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n//\t\t\t\tcerr << \"id = \" << id << \" level = \" << level << \" member = \" << member << \" polygonMember = \" << polygonMember << endl;\r\n//\t\t\t\tcerr << \" treemapVec[pid].treemapSizeMap().size() = \" << treemapVec[id].treemapSizeMap().size() << endl;\r\n#endif // DEBUG\r\n\t\t\t\tmap< unsigned int, pair< double, double > >::iterator itS = treemapVec[id].treemapSizeMap().begin();\r\n\t\t\t\tstd::advance( itS, polygonMember );\r\n\t\t\t\tdouble size = itS->second.second;\r\n\r\n\t\t\t\tstringstream ss;\r\n\t\t\t\tss << setprecision( 3 ) << size/(ww*wh);\r\n//\t\t\t\tcerr << \"ss = \" << ss.str() << endl;\r\n\t\t\t\tQString sizeStr = QString::fromStdString( ss.str() );\r\n\t\t\t\t// info\r\n\t\t\t\tres.push_back( make_pair(polygonMember, sizeStr) );\r\n\t\t\t}\r\n\r\n\t\t\treturn res;\r\n\t\t}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ResponsiveLens/ui/TreemapGraphicsView.cpp b/ResponsiveLens/ui/TreemapGraphicsView.cpp
--- a/ResponsiveLens/ui/TreemapGraphicsView.cpp	
+++ b/ResponsiveLens/ui/TreemapGraphicsView.cpp	
@@ -43,14 +43,23 @@
 		//
 		void TreemapGraphicsView::_init( void )
 		{
-			if( lensSettings->filePath().isEmpty() ) return;
+			if( _lensSettings->filePath().isEmpty() ) return;
 			_readInputData();
 
 			_isInitialized = false;
 			_isCreated = false;
 
 			// setting initialization
-			lensSettings->resetFonts( _metadataPtr->maxLevel() );
+			_lensSettings->resetFonts( _metadataPtr->maxLevel() );
+
+			Graph::TreeDirectedGraph    &graphmlTree    = _metadataPtr->graphmlTree();
+			for (const auto& id : _metrics.maxIDs()) {
+				Graph::TreeDirectedGraph::vertex_descriptor vd = vertex(id, graphmlTree);
+				//graphmlTree[vd].isSelected = false;
+				graphmlTree[vd].scalable =true;
+				//cerr <<"no more scale allowed !"<<endl;
+			}
+			_metrics.maxIDs().clear();
 		}
 
 		//
@@ -144,7 +153,7 @@
 			// build voronoi complex
 			vector< vector< KeiRo::Base::Polygon2 > > polygonMat;
 			polygonMat.resize( _nGroups );
-			cerr << "polygonMat.size() = " << polygonMat.size() << endl;
+			//cerr << "polygonMat.size() = " << polygonMat.size() << endl;
 			for( unsigned int i = 0; i < _seedVec.size(); i++ ){
 				int gid = _seedVec[i].gid;
 				// cerr << "gid = " << gid << endl;
@@ -337,144 +346,147 @@
 
 			BGL_FORALL_VERTICES( vd, graphmlTree, Graph::TreeDirectedGraph ) {
 
-				KeiRo::Base::Rectangle2 &bbox = *graphmlTree[ vd ].boundingBoxPtr;
-				KeiRo::Base::Coord2 &c = *graphmlTree[ vd ].coordPtr;
-				unsigned int id = graphmlTree[vd].id;
-				unsigned int level = graphmlTree[vd].level;
-//				double borderW = borderWidth;
-//				double borderH = borderWidth;
-				double borderW = MIN2( borderWidth, _marginRatio*bbox.width() );
-				double borderH = MIN2( borderWidth, _marginRatio*bbox.height() );
+					KeiRo::Base::Rectangle2 &bbox = *graphmlTree[ vd ].boundingBoxPtr;
+					KeiRo::Base::Coord2 &c = *graphmlTree[ vd ].coordPtr;
+					unsigned int id = graphmlTree[vd].id;
+					unsigned int level = graphmlTree[vd].level;
+					//				double borderW = borderWidth;
+					//				double borderH = borderWidth;
+					double borderW = MIN2( borderWidth, _marginRatio*bbox.width() );
+					double borderH = MIN2( borderWidth, _marginRatio*bbox.height() );
 
-//				cerr << "borderWidth = " << borderWidth << ", bw = " << borderW << ", bh = " << borderH << endl;
+					//				cerr << "borderWidth = " << borderWidth << ", bw = " << borderW << ", bh = " << borderH << endl;
 
-				Ui::Vector::GraphicsPolygonItem *itemptr = new Ui::Vector::GraphicsPolygonItem;
-				_rectangleItemMap.insert( pair< unsigned int, Ui::Vector::GraphicsPolygonItem * >( id, itemptr ) );
+					Ui::Vector::GraphicsPolygonItem *itemptr = new Ui::Vector::GraphicsPolygonItem;
+					_rectangleItemMap.insert( pair< unsigned int, Ui::Vector::GraphicsPolygonItem * >( id, itemptr ) );
 
-				// set polygon color
-				vector< unsigned int > &cs = graphmlTree[vd].attribute.stroke();
-				vector< unsigned int > &cf = graphmlTree[vd].attribute.fill();
-				if( id == 0 ){
-					itemptr->setPen( QPen( QColor( 255, 255, 255, 255 ), 2 ) );
-					itemptr->setBrush( QBrush( QColor( 255, 255, 255, 255 ), Qt::SolidPattern ) );
-				}
-				else{
-					itemptr->setPen( QPen( QColor( cs[0], cs[1], cs[2], cs[3] ), 2 ) );
-					itemptr->setBrush( QBrush( QColor( cf[0], cf[1], cf[2], 150 ), Qt::SolidPattern ) );
-				}
-				// if (id==20) {
-				// 	itemptr->setPen( QPen( QColor( 0,255,0, cs[3] ), 2 ) );
-				// 	itemptr->setBrush( QBrush( QColor( 0,255,0, 150 ), Qt::SolidPattern ) );
-				// }
+					// set polygon color
+					vector< unsigned int > &cs = graphmlTree[vd].attribute.stroke();
+					vector< unsigned int > &cf = graphmlTree[vd].attribute.fill();
+					if( id == 0 ){
+						itemptr->setPen( QPen( QColor( 255, 255, 255, 255 ), 2 ) );
+						itemptr->setBrush( QBrush( QColor( 255, 255, 255, 255 ), Qt::SolidPattern ) );
+					}
+					else{
+						itemptr->setPen( QPen( QColor( cs[0], cs[1], cs[2], cs[3] ), 2 ) );
+						itemptr->setBrush( QBrush( QColor( cf[0], cf[1], cf[2], 150 ), Qt::SolidPattern ) );
+					}
+					// if (id==20) {
+					// 	itemptr->setPen( QPen( QColor( 0,255,0, cs[3] ), 2 ) );
+					// 	itemptr->setBrush( QBrush( QColor( 0,255,0, 150 ), Qt::SolidPattern ) );
+					// }
 
-				itemptr->defaultPen() = itemptr->pen();
-				itemptr->defaultBrush() = itemptr->brush();
+					itemptr->defaultPen() = itemptr->pen();
+					itemptr->defaultBrush() = itemptr->brush();
 
-				// add selected polygons
-				if( graphmlTree[vd].isSelected ) {
+					// add selected polygons
+					if( graphmlTree[vd].isSelected ) {
 
-					QColor color = QColor( 255, 100, 100, 255 );
-					itemptr->setPen( QPen( QColor( 0, 0, 0, 255 ), 5 ) );
-					itemptr->setBrush( QBrush( QColor( color.red(), color.green(), color.blue(), 255 ),
-					                           Qt::SolidPattern ) );
-				}
+						QColor color = QColor( 255, 100, 100, 255 );
+						itemptr->setPen( QPen( QColor( 0, 0, 0, 255 ), 5 ) );
+						itemptr->setBrush( QBrush( QColor( color.red(), color.green(), color.blue(), 255 ),
+												   Qt::SolidPattern ) );
+					}
 
 
-				KeiRo::Base::Coord2 center( bbox.leftBottom().x() + 0.5*bbox.width(),
-				                            bbox.leftBottom().y() + 0.5*bbox.height() );
-				KeiRo::Base::Coord2 oldCenter( bbox.oldLeftBottom().x() + 0.5*bbox.oldWidth(),
-				                               bbox.oldLeftBottom().y() + 0.5*bbox.oldHeight() );
-				double scaleX = (bbox.width() - (level+1) * borderW)/bbox.width();
-				double scaleY = (bbox.height() - (level+1) * borderH)/bbox.height();
-				double oldScaleX = (bbox.oldWidth() - (level+1) * borderW)/bbox.oldWidth();
-				double oldScaleY = (bbox.oldHeight() - (level+1) * borderH)/bbox.oldHeight();
-				itemptr->bbox() = QRect( bbox.leftBottom().x(),
-				                         bbox.leftBottom().y(),
-				                         bbox.width(),
-				                         bbox.height() );
+					KeiRo::Base::Coord2 center( bbox.leftBottom().x() + 0.5*bbox.width(),
+												bbox.leftBottom().y() + 0.5*bbox.height() );
+					KeiRo::Base::Coord2 oldCenter( bbox.oldLeftBottom().x() + 0.5*bbox.oldWidth(),
+												   bbox.oldLeftBottom().y() + 0.5*bbox.oldHeight() );
+					double scaleX = (bbox.width() - (level+1) * borderW)/bbox.width();
+					double scaleY = (bbox.height() - (level+1) * borderH)/bbox.height();
+					double oldScaleX = (bbox.oldWidth() - (level+1) * borderW)/bbox.oldWidth();
+					double oldScaleY = (bbox.oldHeight() - (level+1) * borderH)/bbox.oldHeight();
+					itemptr->bbox() = QRect( bbox.leftBottom().x(),
+											 bbox.leftBottom().y(),
+											 bbox.width(),
+											 bbox.height() );
 
-				//itemptr->textOn() = true;
-				//itemptr->text() = QString::fromStdString( to_string( _seedVec[ i ].id ) );
-
-				QPolygonF polygon, oldPolygon, intermediatePolygon;
-				polygon.append( QPoint( scaleX * ( bbox.leftBottom().x() - center.x() ) + center.x(),
-				                        -( scaleY * ( bbox.leftBottom().y() - center.y() ) + center.y() )));
-				polygon.append( QPoint( scaleX * ( bbox.leftBottom().x() + bbox.width() - center.x() ) + center.x(),
-				                        -( scaleY * ( bbox.leftBottom().y() - center.y() ) + center.y() )));
-				polygon.append( QPoint( scaleX * ( bbox.leftBottom().x() + bbox.width() - center.x() ) + center.x(),
-				                        -( scaleY * ( bbox.leftBottom().y() + bbox.height() - center.y() ) + center.y() )));
-				polygon.append( QPoint( scaleX * ( bbox.leftBottom().x() - center.x() ) + center.x(),
-				                        -( scaleY * ( bbox.leftBottom().y() + bbox.height() - center.y() ) + center.y() )));
+					if (level ==1 || level ==2) {
+						itemptr->textOn() = true;
+						itemptr->text() = QString::fromStdString( to_string( *graphmlTree[vd].namePtr ) );
+					}
+					QPolygonF polygon, oldPolygon, intermediatePolygon;
+					polygon.append( QPoint( scaleX * ( bbox.leftBottom().x() - center.x() ) + center.x(),
+											-( scaleY * ( bbox.leftBottom().y() - center.y() ) + center.y() )));
+					polygon.append( QPoint( scaleX * ( bbox.leftBottom().x() + bbox.width() - center.x() ) + center.x(),
+											-( scaleY * ( bbox.leftBottom().y() - center.y() ) + center.y() )));
+					polygon.append( QPoint( scaleX * ( bbox.leftBottom().x() + bbox.width() - center.x() ) + center.x(),
+											-( scaleY * ( bbox.leftBottom().y() + bbox.height() - center.y() ) + center.y() )));
+					polygon.append( QPoint( scaleX * ( bbox.leftBottom().x() - center.x() ) + center.x(),
+											-( scaleY * ( bbox.leftBottom().y() + bbox.height() - center.y() ) + center.y() )));
 
-				oldPolygon.append( QPoint( oldScaleX * ( bbox.oldLeftBottom().x() - oldCenter.x() ) + oldCenter.x(),
-				                           -( oldScaleY * ( bbox.oldLeftBottom().y() - oldCenter.y() ) + oldCenter.y() )));
-				oldPolygon.append( QPoint( oldScaleX * ( bbox.oldLeftBottom().x() + bbox.oldWidth() - oldCenter.x() ) + oldCenter.x(),
-				                           -( oldScaleY * ( bbox.oldLeftBottom().y() - oldCenter.y() ) + oldCenter.y() )));
-				oldPolygon.append( QPoint( oldScaleX * ( bbox.oldLeftBottom().x() + bbox.oldWidth() - oldCenter.x() ) + oldCenter.x(),
-				                           -( oldScaleY * ( bbox.oldLeftBottom().y() + bbox.oldHeight() - oldCenter.y() ) + oldCenter.y() )));
-				oldPolygon.append( QPoint( oldScaleX * ( bbox.oldLeftBottom().x() - oldCenter.x() ) + oldCenter.x(),
-				                           -( oldScaleY * ( bbox.oldLeftBottom().y() + bbox.oldHeight() - oldCenter.y() ) + oldCenter.y() )));
+					oldPolygon.append( QPoint( oldScaleX * ( bbox.oldLeftBottom().x() - oldCenter.x() ) + oldCenter.x(),
+											   -( oldScaleY * ( bbox.oldLeftBottom().y() - oldCenter.y() ) + oldCenter.y() )));
+					oldPolygon.append( QPoint( oldScaleX * ( bbox.oldLeftBottom().x() + bbox.oldWidth() - oldCenter.x() ) + oldCenter.x(),
+											   -( oldScaleY * ( bbox.oldLeftBottom().y() - oldCenter.y() ) + oldCenter.y() )));
+					oldPolygon.append( QPoint( oldScaleX * ( bbox.oldLeftBottom().x() + bbox.oldWidth() - oldCenter.x() ) + oldCenter.x(),
+											   -( oldScaleY * ( bbox.oldLeftBottom().y() + bbox.oldHeight() - oldCenter.y() ) + oldCenter.y() )));
+					oldPolygon.append( QPoint( oldScaleX * ( bbox.oldLeftBottom().x() - oldCenter.x() ) + oldCenter.x(),
+											   -( oldScaleY * ( bbox.oldLeftBottom().y() + bbox.oldHeight() - oldCenter.y() ) + oldCenter.y() )));
 
-if (_isPathSelectionMode == false) {
-	itemptr->setPolygon( polygon );
-	itemptr->setAcceptHoverEvents( true );
-	itemptr->setFlag( QGraphicsItem::ItemIsSelectable );
-	itemptr->attributeID() = graphmlTree[vd].id;
-	itemptr->id() = id;
-	itemptr->name() = QString::fromStdString( *graphmlTree[vd].namePtr );
-	itemptr->text() = QString::fromStdString( *graphmlTree[vd].namePtr );
-}
+					if (_isPathSelectionMode == false) {
+						itemptr->setPolygon( polygon );
+						itemptr->setAcceptHoverEvents( true );
+						itemptr->setFlag( QGraphicsItem::ItemIsSelectable );
+						itemptr->attributeID() = graphmlTree[vd].id;
+						itemptr->id() = id;
+						itemptr->name() = QString::fromStdString( *graphmlTree[vd].namePtr );
+						itemptr->text() = QString::fromStdString( *graphmlTree[vd].namePtr );
+					}
 
 
-				_scenePtr->addItem( itemptr );
-
-				if(bbox.inLocalMove()) {
-
-					KeiRo::Base::Coord2 intermediateCenter( bbox.intermediateLeftBottom().x() + 0.5*bbox.intermediateWidth(),
-				                                     		bbox.intermediateLeftBottom().y() + 0.5*bbox.intermediateHeight() );
+					_scenePtr->addItem( itemptr );
+				if (itemptr) {
+					if(bbox.inLocalMove()) {
+						KeiRo::Base::Coord2 intermediateCenter( bbox.intermediateLeftBottom().x() + 0.5*bbox.intermediateWidth(),
+																 bbox.intermediateLeftBottom().y() + 0.5*bbox.intermediateHeight() );
 
-					double intermediateScaleX = (bbox.intermediateWidth() - (level+1) * borderW)/bbox.intermediateWidth();
-					double intermediateScaleY = (bbox.intermediateHeight() - (level+1) * borderH)/bbox.intermediateHeight();
+						double intermediateScaleX = (bbox.intermediateWidth() - (level+1) * borderW)/bbox.intermediateWidth();
+						double intermediateScaleY = (bbox.intermediateHeight() - (level+1) * borderH)/bbox.intermediateHeight();
 
-					intermediatePolygon.append( QPoint( intermediateScaleX * ( bbox.intermediateLeftBottom().x() - intermediateCenter.x() ) + intermediateCenter.x(),
-					                           -( intermediateScaleY * ( bbox.intermediateLeftBottom().y() - intermediateCenter.y() ) + intermediateCenter.y() )));
-					intermediatePolygon.append( QPoint( intermediateScaleX * ( bbox.intermediateLeftBottom().x() + bbox.intermediateWidth() - intermediateCenter.x() ) + intermediateCenter.x(),
-					                           -( intermediateScaleY * ( bbox.intermediateLeftBottom().y() - intermediateCenter.y() ) + intermediateCenter.y() )));
-					intermediatePolygon.append( QPoint( intermediateScaleX * ( bbox.intermediateLeftBottom().x() + bbox.intermediateWidth() - intermediateCenter.x() ) + intermediateCenter.x(),
-				  	                         -( intermediateScaleY * ( bbox.intermediateLeftBottom().y() + bbox.intermediateHeight() - intermediateCenter.y() ) + intermediateCenter.y() )));
-					intermediatePolygon.append( QPoint( intermediateScaleX * ( bbox.intermediateLeftBottom().x() - intermediateCenter.x() ) + intermediateCenter.x(),
-				   	                        -( intermediateScaleY * ( bbox.intermediateLeftBottom().y() + bbox.intermediateHeight() - intermediateCenter.y() ) + intermediateCenter.y() )));
+						intermediatePolygon.append( QPoint( intermediateScaleX * ( bbox.intermediateLeftBottom().x() - intermediateCenter.x() ) + intermediateCenter.x(),
+												   -( intermediateScaleY * ( bbox.intermediateLeftBottom().y() - intermediateCenter.y() ) + intermediateCenter.y() )));
+						intermediatePolygon.append( QPoint( intermediateScaleX * ( bbox.intermediateLeftBottom().x() + bbox.intermediateWidth() - intermediateCenter.x() ) + intermediateCenter.x(),
+												   -( intermediateScaleY * ( bbox.intermediateLeftBottom().y() - intermediateCenter.y() ) + intermediateCenter.y() )));
+						intermediatePolygon.append( QPoint( intermediateScaleX * ( bbox.intermediateLeftBottom().x() + bbox.intermediateWidth() - intermediateCenter.x() ) + intermediateCenter.x(),
+												   -( intermediateScaleY * ( bbox.intermediateLeftBottom().y() + bbox.intermediateHeight() - intermediateCenter.y() ) + intermediateCenter.y() )));
+						intermediatePolygon.append( QPoint( intermediateScaleX * ( bbox.intermediateLeftBottom().x() - intermediateCenter.x() ) + intermediateCenter.x(),
+												   -( intermediateScaleY * ( bbox.intermediateLeftBottom().y() + bbox.intermediateHeight() - intermediateCenter.y() ) + intermediateCenter.y() )));
 
-					cerr << "Animation 1 Updated" << endl;
-					// UPDATED ANIMATION --------------------------------------------------------------------------------------------------------
-					QPropertyAnimation *animation1 = new QPropertyAnimation( itemptr, "polygon" );
-					animation1->setDuration( ANIMATE_DURATION/2 );
-					animation1->setStartValue( oldPolygon );
-					animation1->setEndValue( intermediatePolygon );
-					animation1->setEasingCurve( QEasingCurve::Linear );
+							//cerr << "Animation 1 Updated" << endl;
+
+							// UPDATED ANIMATION --------------------------------------------------------------------------------------------------------
+							QPropertyAnimation *animation1 = new QPropertyAnimation( itemptr, "polygon" );
+							animation1->setDuration( ANIMATE_DURATION/2 );
+							animation1->setStartValue( oldPolygon );
+							animation1->setEndValue( intermediatePolygon );
+							animation1->setEasingCurve( QEasingCurve::Linear );
 
-					QPropertyAnimation *animation2 = new QPropertyAnimation( itemptr, "polygon" );
-					animation2->setDuration( ANIMATE_DURATION/2 );
-					animation2->setStartValue( intermediatePolygon );
-					animation2->setEndValue( polygon );
-					animation2->setEasingCurve( QEasingCurve::Linear );
+							QPropertyAnimation *animation2 = new QPropertyAnimation( itemptr, "polygon" );
+							animation2->setDuration( ANIMATE_DURATION/2 );
+							animation2->setStartValue( intermediatePolygon );
+							animation2->setEndValue( polygon );
+							animation2->setEasingCurve( QEasingCurve::Linear );
 
-					QSequentialAnimationGroup *group = new QSequentialAnimationGroup();
+							QSequentialAnimationGroup *group = new QSequentialAnimationGroup();
 
-					group->addAnimation(animation1);
-    					group->addAnimation(animation2);
+							group->addAnimation(animation1);
+							group->addAnimation(animation2);
 
-    					group->start( QAbstractAnimation::DeleteWhenStopped );
+							group->start( QAbstractAnimation::DeleteWhenStopped );
 
-    				} else {
+						} else {
 
-    					QPropertyAnimation *animation = new QPropertyAnimation( itemptr, "polygon" );
-					animation->setDuration( ANIMATE_DURATION );
-					animation->setStartValue( oldPolygon );
-					animation->setEndValue( polygon );
-					animation->setEasingCurve( QEasingCurve::Linear );
-					animation->start( QAbstractAnimation::DeleteWhenStopped );
-    				}
+							QPropertyAnimation *animation = new QPropertyAnimation( itemptr, "polygon" );
+							animation->setDuration( ANIMATE_DURATION );
+							animation->setStartValue( oldPolygon );
+							animation->setEndValue( polygon );
+							animation->setEasingCurve( QEasingCurve::Linear );
+							animation->start( QAbstractAnimation::DeleteWhenStopped );
+						}
+					}
+
 			}
 		}
 
@@ -497,7 +509,7 @@
 			vector< vector< unsigned int > > pathVec = _globalPaths.hierarchicalPathVec();
 
 			// polyline rendering
-			cerr << "pathVec.size() = " << pathVec.size() << endl;
+			//cerr << "pathVec.size() = " << pathVec.size() << endl;
 			for( unsigned int i = 0; i < pathVec.size(); i++ ){
 
 				for( unsigned int j = 1; j < pathVec[i].size(); j++ ){
@@ -576,6 +588,7 @@
 		//  none
 		//
 		void TreemapGraphicsView::_item_XMLGraph ( void ) {
+			Graph::TreeDirectedGraph    &graphmlTree    = _metadataPtr->graphmlTree();
 
 //			Graph::TreeDirectedGraph    &graphmlTree    = _metadataPtr->graphmlTree();
 			map< unsigned int, Graph::BaseUndirectedGraph >  &graphmlGraphMap   = _metadataPtr->graphmlGraphMap();
@@ -585,8 +598,13 @@
 			for( map< unsigned int, Graph::BaseUndirectedGraph >::iterator it = graphmlGraphMap.begin();
 				 it != graphmlGraphMap.end(); it++ ){
 
+					Graph::TreeDirectedGraph::vertex_descriptor vdP = vertex(it->first, graphmlTree);
 				Graph::BaseUndirectedGraph &graphmlGraph = it->second;
 				bool isLabelVisible = _checkLabelVisibility( graphmlGraph );
+				// if (graphmlTree[vdP].isSelected && _metrics.computeSelectedLabelOverlaps()==0 && _metrics.selectedLabelOverlappedArea()==0) {
+				// 	isLabelVisible = true;
+				// }
+
 
 				// draw edges
 				BGL_FORALL_EDGES( ed, graphmlGraph, Graph::BaseUndirectedGraph ) {
@@ -598,6 +616,7 @@
 
 					// iterate edge samples
 					KeiRo::Base::Edge2 &edge = graphmlGraph[ ed ].edge;
+
 					for( unsigned int i = 1; i < edge.elements().size(); i++ ){
 						Ui::Vector::GraphicsEdgeItem *itemptr = new Ui::Vector::GraphicsEdgeItem;
 
@@ -654,8 +673,20 @@
 				}
 
 				BGL_FORALL_VERTICES( vd, graphmlGraph, Graph::BaseUndirectedGraph ) {
-
+					//isLabelVisible =_checkLabelVisibility(graphmlGraph);
 					KeiRo::Base::Coord2 &c = *graphmlGraph[ vd ].coordPtr;
+					int id ;
+
+
+					//
+					// if (!_selectSceneItemMap.empty()&& graphmlTree[ vdTree ].isSelected) {
+					// 	cerr <<"_metrics.computeSelectedLabelOverlaps()==0"<<_metrics.computeSelectedLabelOverlaps()<<endl;
+					// }
+					// if (!_selectSceneItemMap.empty()&&_metrics.computeSelectedLabelOverlaps()==0 && graphmlGraph[ vd ].isSelected) {
+					// 	isLabelVisible =true;
+					// }
+
+
 
 					Ui::Vector::GraphicsVertexItem *itemptr = new Ui::Vector::GraphicsVertexItem;
 					itemptr->isSimple() = true;
@@ -672,7 +703,7 @@
 						itemptr->textpen() = QPen( QColor( 250, 250, 250, 255 ), 2 );
 
 					// Set font
-					itemptr->font() = lensSettings->fonts()[_metadataPtr->maxLevel()-1];
+					itemptr->font() = _lensSettings->fonts()[_metadataPtr->maxLevel()-1];
 					itemptr->text() = QString::fromStdString( to_string( *graphmlGraph[vd].namePtr ) );
 					QFontMetrics fm( itemptr->font());
 					int pxFntWidth = fm.width( itemptr->text() ),
@@ -866,7 +897,7 @@
 //							itemptr->font() = qfont;
 //						}
 //						else
-						itemptr->font() = lensSettings->fonts()[m];  // font(layer m)
+						itemptr->font() = _lensSettings->fonts()[m];  // font(layer m)
 						itemptr->id() = i;
 
 //						itemptr->text() = QString::fromStdString( to_string( i ) );
@@ -1122,7 +1153,7 @@
 //							itemptr->font() = qfont;
 //						}
 //						else
-						itemptr->font() = lensSettings->fonts()[m];  // font(layer m)
+						itemptr->font() = _lensSettings->fonts()[m];  // font(layer m)
 
 						//	        1. get font: width & height
 						QFontMetrics fm( itemptr->font());
@@ -1395,6 +1426,7 @@
 			return QColor::fromHsvF(hue, saturation, value);
 		}
 
+
 		void TreemapGraphicsView::_item_globalPaths( void )
 		{
 			_edgeItemMap.clear();
@@ -1413,8 +1445,16 @@
 
 
 			int numPaths = pathVec.size();
-			//cerr <<pathVec.size()<<endl;
-				double maxThickness = 30.3;
+			//cerr <<"number of paths " <<pathVec.size()<<endl;
+			//double maxThickness = calculateMaxThickness(numPaths);
+			//for small graph
+			//double maxThickness = 10.3;
+			//for medium
+			//double maxThickness = 20.3;
+			//for major
+			double maxThickness = 25.3;
+
+			double thickness = maxThickness;
 				//unsigned int idgs =  pair.first;
 
 			for( unsigned int i = 0; i < pathVec.size(); i++ ) {
@@ -1423,10 +1463,12 @@
 
 				//_globalPaths.pathStartIdGS[i] == idgs
 					if (  true  ) {
-						if (maxThickness >0 )
-							maxThickness -= 0.3;
+
+						if (thickness >0 )
+							thickness  = thickness - 0.3;
 						else
-							maxThickness = 30.3;
+							thickness = maxThickness/2 ;
+
 
 						//cerr << "path "<<i<<endl;
 						//_globalPaths.print_path(i);
@@ -1460,7 +1502,7 @@
 							itemptr->setPen( QPen( QColor( stroke[0]*drakerFactor,
 							stroke[1]*drakerFactor, stroke[2]*drakerFactor, 255 ), strokeWidth ) );
 							if (isPathSelectionMode()) {
-								itemptr->setPen(QPen(pathColor, maxThickness));
+								itemptr->setPen(QPen(pathColor, thickness));
 								//graphmlTree[ vd ].isSelected = true;
 								Graph::TreeDirectedGraph    &graphmlTree    = _metadataPtr->graphmlTree();
 								unsigned int graphmlTreeID = itemptr->id();
@@ -1469,8 +1511,8 @@
 									QColor currentColor = itemptr->pen().color();
 									qreal h, s, v, a;
 									currentColor.getHsvF(&h, &s, &v, &a);
-									QColor newColor = QColor::fromHsvF(h, 0.6, 0.8, a);
-									itemptr->setPen(QPen(newColor, maxThickness));
+									QColor newColor = QColor::fromHsvF(h, 0.9, 0.9, a);
+									itemptr->setPen(QPen(newColor, thickness));
 								}
 							}
 							else {
@@ -1504,7 +1546,7 @@
 							_scenePtr->addItem( itemptr );
 
 							if(source->inLocalMove()||target->inLocalMove()) {
-								cerr <<"local moves animation:"<<endl;
+								//cerr <<"local moves animation:"<<endl;
 
 								// oldLine.setLine( source->intermediateElement()[0], -source->intermediateElement()[1],
 								// 			 target->intermediateElement()[0], -target->intermediateElement()[1] );
@@ -1582,7 +1624,7 @@
 							}
 							else {
 								//original animation:
-								 cerr << "animation 0"<<endl;
+								 //cerr << "animation 0"<<endl;
 								 QPropertyAnimation *animation = new QPropertyAnimation( itemptr, "line" );
 								 animation->setDuration( ANIMATE_DURATION );
 								 animation->setStartValue( oldLine );
@@ -2012,7 +2054,7 @@
 					intermediatePolygon.append( QPoint( bbox.intermediateLeftBottom().x(),
 					                           -( bbox.intermediateLeftBottom().y() + bbox.intermediateHeight() )));
 
-					cerr << "Animation 4 Updated" << endl;
+					//cerr << "Animation 4 Updated" << endl;
 					// UPDATED ANIMATION --------------------------------------------------------------------------------------------------------
 					QPropertyAnimation *animation1 = new QPropertyAnimation( itemptr, "polygon" );
 					animation1->setDuration( ANIMATE_DURATION/2 );
@@ -2263,7 +2305,7 @@
 		bool TreemapGraphicsView::_checkLabelVisibility( Graph::BaseUndirectedGraph &graphmlGraph )
 		{
 			bool isVisible = true;
-			QFont font = lensSettings->fonts()[_metadataPtr->maxLevel()-1];
+			QFont font = _lensSettings->fonts()[_metadataPtr->maxLevel()-1];
 			QFontMetrics fm( font );
 
 			BGL_FORALL_VERTICES( vdO, graphmlGraph, Graph::BaseUndirectedGraph ) {
@@ -2277,6 +2319,7 @@
 				BGL_FORALL_VERTICES( vdI, graphmlGraph, Graph::BaseUndirectedGraph ) {
 
 					if( graphmlGraph[vdI].id < graphmlGraph[vdO].id ){
+
 						KeiRo::Base::Rectangle2 bboxI;
 						bboxI.leftBottom().x() = graphmlGraph[vdI].coordPtr->x();
 						bboxI.leftBottom().y() = graphmlGraph[vdI].coordPtr->y();
@@ -2284,17 +2327,20 @@
 						bboxI.height() = fm.height();
 
 						double area = 0.0;
+
 						isVisible = !bboxO.isOverlap( bboxI, area );
-						if(area > 0.0){
-							return isVisible;
+						if(area > 0.1){
+							return false;
+							//return true;
 							cerr << "isVisible = " << isVisible << ", area = " << area << endl;
 						}
 					}
 				}
 			}
 
-			cerr << "isVisible flag = " << isVisible << endl;
-			return isVisible;
+			//cerr << "isVisible flag = " << isVisible << endl;
+			//return false;
+			return true;
 		}
 
 		//
@@ -2351,7 +2397,7 @@
 				vector< KeiRo::Base::Polygon2 > &childPolygonVec = svgPtrVec[ idC ]->polygonVec();
 				vector< KeiRo::Base::Line2 > &childPolylineVec = svgPtrVec[ idC ]->polylineVec();
 
-				cerr << "childPolygonVec.size() = " << childPolygonVec.size() << endl;
+				//cerr << "childPolygonVec.size() = " << childPolygonVec.size() << endl;
 				for( unsigned int j = 0; j < childPolygonVec.size(); j++ ) {
 					childPolygonVec[ j ].isVisible() = true;
 					childPolygonVec[ j ].isTextVisible() = true;
@@ -2404,7 +2450,7 @@
 							}
 
 							KeiRo::Base::Rectangle2 &bbox = polygonVec[m].boundingBox();
-							font.setPointSize( lensSettings->fonts()[i].pointSize() );
+							font.setPointSize( _lensSettings->fonts()[i].pointSize() );
 							QFontMetrics fm( font );
 							double sx = fm.width( QString::fromStdString( polygonVec[m].label() ) );
 							double sy = fm.height();
@@ -2482,7 +2528,7 @@
 			for( unsigned int i = sortedLevel.size()-1; i < sortedLevel.size(); i++ )
 			{
 				QFont font;
-				font.setPointSize( lensSettings->fonts()[i].pointSize() );
+				font.setPointSize( _lensSettings->fonts()[i].pointSize() );
 
 				for( unsigned int j = 0; j < sortedLevel[i].size(); j++ ) {
 
@@ -2622,7 +2668,7 @@
 #endif // DEBUG
 
 			_metadataPtr = new Lens::MetaData;
-			_metadataPtr->readMetaData( lensSettings->filePath(), _gridPtr );
+			_metadataPtr->readMetaData( _lensSettings->filePath(), _gridPtr );
 
 			// load graphml
 			_hierarchicalTreemap.init( _metadataPtr, &_selectSceneItemMap,
@@ -2738,6 +2784,11 @@
 			}
 			case Qt::Key_R: {
 				if (_isPathSelectionMode) {
+
+
+					_hierarchicalTreemap.assignTreemapSize( PARAMETERIZED_TYPE );
+
+					_localMoves = _hierarchicalTreemap.updateHierarchicalTreemap( _isInitialized );
 					break;
 				}
 
@@ -2749,6 +2800,13 @@
 //				_hierarchicalTreemap.assignTreemapSize( ABSOLUTE_TYPE );
 //				_hierarchicalTreemap.assignTreemapSize( EXACT_TYPE );
 //                              _hierarchicalTreemap.assignTreemapSize( SIBLINGS_TYPE );
+				//Graph::TreeDirectedGraph &graphmlTree    = _hierarchicalTreemap.metadataPtr()->graphmlTree();
+				//Graph::TreeDirectedGraph::vertex_descriptor vd = vertex( 0, graphmlTree );
+				// BGL_FORALL_VERTICES( vd, graphmlTree, Graph::TreeDirectedGraph ) {
+				// 	if (graphmlTree[ vd ].scale==true) {
+				// 	}
+				// }
+
                 _hierarchicalTreemap.assignTreemapSize( PARAMETERIZED_TYPE );
 
 				_localMoves = _hierarchicalTreemap.updateHierarchicalTreemap( _isInitialized );
@@ -2777,22 +2835,48 @@
 
 
 					_globalPaths.update( _localMoves );
-					cerr <<"update finish!!"<<endl;
+					//cerr <<"update finish!!"<<endl;
 				}
 
 // rewrite				_updateVisibility();
 				initSceneItems();
-				cerr <<"initsce!!"<<endl;
+				_metrics.init( _metadataPtr, _lensSettings );
+				_metrics.computeSelectedLabelOverlaps();
+				Graph::TreeDirectedGraph &graphmlTree    = _hierarchicalTreemap.metadataPtr()->graphmlTree();
+				for (const auto& idt : _metrics.maxIDs()) {
+					//cerr<<"not allowed"<<endl;
+					Graph::TreeDirectedGraph::vertex_descriptor vd = vertex(idt, graphmlTree);
+					//graphmlTree[vd].isSelected = false;
+					graphmlTree[vd].scalable =false;
+					//cerr<<"not allowed"<<endl;
+				}
+
+				//cerr <<"initsce!!"<<endl;
+
 
 				emit sendSelectedNodesInfo( getSelectedInfo(), _hierarchicalTreemap.maxMinSize() );
+
+
+				// for (const auto& id : _metrics.maxIDs()) {
+				// 	Graph::TreeDirectedGraph::vertex_descriptor vd = vertex(id, graphmlTree);
+				// 	//graphmlTree[vd].isSelected = false;
+				// 	graphmlTree[vd].scale =true;
+				// 	cerr <<"no more scale allowed !"<<endl;
+				// }
 				break;
 			}
 			case Qt::Key_E: {
 
 //				simulateKey( Qt::Key_R );
 				_hierarchicalTreemap.resetHierarchicalTreemap();
+				//_hierarchicalTreemap.assignTreemapSize( PARAMETERIZED_TYPE );
+
+				//_localMoves = _hierarchicalTreemap.updateHierarchicalTreemap( _isInitialized );
 				_globalPaths.resetGlobalPaths();
+
+
 				initSceneItems();
+				//scene()->update();
 				break;
 			}
 			case Qt::Key_A: {
@@ -2904,6 +2988,33 @@
 				} else {
 					qDebug() << "Failed to save image to:" << filePath;
 				}
+				_metrics.init( _metadataPtr, _lensSettings );
+				_metrics.computeEdgeLength();
+				cerr << "Total edge length of subgraphs = " << _metrics.edgeLengths() << endl;
+				_metrics.computeLabelOverlaps();
+				cerr << "Total number of overlapped labels = " << _metrics.labelOverlaps() << endl;
+				cerr << "Total number of overlapped labels areas = " << _metrics.labelOverlappedArea()<<endl;
+
+				double selectedEdgeLength = _metrics.computeSelectedEdgeLength();
+				int selectedLabelOverlaps = _metrics.computeSelectedLabelOverlaps();
+				double selectedLabelOverlappedArea = _metrics.selectedLabelOverlappedArea();
+
+				cerr << "Total edge length of selected subgraphs = " <<selectedEdgeLength<<endl;
+				cerr << "Total number of overlapped labels in selected subgraphs = " <<selectedLabelOverlaps<<endl;
+				cerr << "Total number of overlapped labels areas in selected subgraphs = " <<selectedLabelOverlappedArea<<endl;
+
+
+
+				break;
+			}
+				case Qt::Key_M: {
+
+				_metrics.init( _metadataPtr, _lensSettings );
+				_metrics.computeEdgeLength();
+				cerr << "Total edge length of subgraphs = " << _metrics.edgeLengths() << endl;
+				_metrics.computeLabelOverlaps();
+				cerr << "Total number of overlapped labels = " << _metrics.labelOverlaps() << endl;
+				cerr << "Total number of overlapped labels areas = " << _metrics.labelOverlappedArea()<<endl;
 				break;
 			}
 			case Qt::Key_P: {
@@ -3062,12 +3173,12 @@
 			QGraphicsView::mousePressEvent( event );
 
 //#ifdef GRAPHICSVIEW_DEBUG
-			cerr << "mouse pressing..." << endl
-						 << " x = " << event->pos().x() << " y = " << event->pos().y() << endl
-						 << " sx = " << coord.x() << " sy = " << coord.y() << endl;
-			cerr << "_right_button_pressed = " << _right_button_pressed << endl
-				 << "_left_button_pressed = " << _left_button_pressed << endl
-				 << "_middle_button_pressed = " << _middle_button_pressed << endl;
+			// cerr << "mouse pressing..." << endl
+			// 			 << " x = " << event->pos().x() << " y = " << event->pos().y() << endl
+			// 			 << " sx = " << coord.x() << " sy = " << coord.y() << endl;
+			// cerr << "_right_button_pressed = " << _right_button_pressed << endl
+			// 	 << "_left_button_pressed = " << _left_button_pressed << endl
+			// 	 << "_middle_button_pressed = " << _middle_button_pressed << endl;
 //#endif // GRAPHICSVIEW_DEBUG
 		}
 
@@ -3147,9 +3258,9 @@
 						minRegion = region;
 						topItemptr = itemptr;
 
-						cerr << "label id = " << topItemptr->id() << endl;
-						cerr << "label name = " << topItemptr->name().toStdString() << endl;
-						cerr << "label text = " << topItemptr->text().toStdString() << endl;
+						// cerr << "label id = " << topItemptr->id() << endl;
+						// cerr << "label name = " << topItemptr->name().toStdString() << endl;
+						// cerr << "label text = " << topItemptr->text().toStdString() << endl;
 					}
 				}
 			}
@@ -3162,7 +3273,7 @@
 
 					selectedPathId = topItemptr1->data(0).toUInt();
 
-					cerr << "Selected path ID: " << selectedPathId << endl;
+					//cerr << "Selected path ID: " << selectedPathId << endl;
 				}
 
 
@@ -3177,6 +3288,7 @@
 					unsigned int graphmlTreeID = topItemptr->attributeID();
 					Graph::TreeDirectedGraph::vertex_descriptor vd = vertex( graphmlTreeID, graphmlTree );
 					graphmlTree[ vd ].isSelected = true;
+					graphmlTree[ vd ].scalable =true;
 
 					// collect selected items
 					_selectSceneItemMap.insert( pair< unsigned int, unsigned int >( graphmlTreeID, graphmlTreeID ) );
@@ -3185,6 +3297,7 @@
 					map< unsigned int, Ui::Vector::GraphicsPolygonItem * >::iterator it = _rectangleItemMap.find( graphmlTreeID );
 					it->second->setBrush( QBrush( QColor( color.red(), color.green(), color.blue(), 255 ),
 					                              Qt::SolidPattern ) );
+
 				}
 				else if (topItemptr1 !=NULL) {
 
@@ -3192,8 +3305,9 @@
 					unsigned int graphmlTreeID = topItemptr1->id();
 					Graph::TreeDirectedGraph::vertex_descriptor vd = vertex( graphmlTreeID, graphmlTree );
 					graphmlTree[ vd ].isSelected = true;
+
 					if ( -1 != _oldSelectedPathId) {
-						cerr <<"old and new not the same"<<endl;
+						//cerr <<"old and new not the same"<<endl;
 						auto range = _edgeItemMap.equal_range(_oldSelectedPathId);
 						if (range.first != _edgeItemMap.end()) {
 							for (auto it = range.first; it != range.second; ++it) {
@@ -3258,7 +3372,7 @@
 
 							QPen newPen(newColor, oldWidth + 2);  // Red color, slightly thicker
 							edgeItem->setPen(newPen);
-							cerr << "Edge found. PathID: " << selectedPathId << endl;
+							//cerr << "Edge found. PathID: " << selectedPathId << endl;
 							edgeItem->update();
 
 						}
@@ -3292,8 +3406,8 @@
 						oldRectId1 = graphmlTreeID1;
 						oldRectId2 = graphmlTreeID2;
 
-//simulateKey(Qt::Key_R);
-						scene()->update();
+						simulateKey(Qt::Key_R);
+						//scene()->update();
 
 
 
@@ -3312,7 +3426,7 @@
 					graphmlTree[ vd ].isSelected = false;
 				}
 				_selectSceneItemMap.clear();
-				cerr << "clear selection... " << endl;
+				//cerr << "clear selection... " << endl;
 				simulateKey( Qt::Key_R );
 //				simulateKey( Qt::Key_E );
 			}
@@ -3345,7 +3459,7 @@
 //			cerr << "event->buttons() = " << event->buttons() << endl;
 //			updateSceneItems();
 			scene()->update();
-			cerr << "Releasing mouse ..." << endl;
+			//cerr << "Releasing mouse ..." << endl;
 
 		#ifdef GRAPHICSVIEW_DEBUG0
 			cerr << "Releasing mouse ..." << endl;
@@ -3356,7 +3470,10 @@
 		}
 
 
-
+std::map<unsigned int, unsigned int>& TreemapGraphicsView::getSelectSceneItemMap()
+		{
+			return _selectSceneItemMap;
+		}
 		//------------------------------------------------------------------------------
 		//	Special functions
 		//------------------------------------------------------------------------------
@@ -3376,32 +3493,32 @@
 //			_filePath = qApp->applicationDirPath() + QString( "/../../ResponsiveLens/data/svg/" ) + "A";
 //			_filePath = qApp->applicationDirPath() + QString( "/../../ResponsiveLens/data/svg/" ) + "major";
 
-			if( !lensSettings ) {
+			if( !_lensSettings ) {
 				qDebug() << "no settings!" << endl;
 			}
 			else {
-				connect(lensSettings, &LensSetting::sendFilePath,
+				connect(_lensSettings, &LensSetting::sendFilePath,
 						this, &TreemapGraphicsView::recvFilePath);
-				connect(lensSettings, &LensSetting::sendLayerFont,
+				connect(_lensSettings, &LensSetting::sendLayerFont,
 						this, &TreemapGraphicsView::recvLayerFont);
-				connect(lensSettings, &LensSetting::sendIncrease,
+				connect(_lensSettings, &LensSetting::sendIncrease,
 						this, &TreemapGraphicsView::recvIncrease);
-				connect(lensSettings, &LensSetting::sendSiblingRatio,
+				connect(_lensSettings, &LensSetting::sendSiblingRatio,
                                                 this, &TreemapGraphicsView::recvSiblingRatio);
-				connect(lensSettings, &LensSetting::sendMinSize,
+				connect(_lensSettings, &LensSetting::sendMinSize,
 						this, &TreemapGraphicsView::recvMinSize);
-				connect(lensSettings, &LensSetting::pressedRButton,
+				connect(_lensSettings, &LensSetting::pressedRButton,
 						this, &TreemapGraphicsView::recvRButtonPress);
 				connect(this, &TreemapGraphicsView::sendSelectedNodesInfo,
-						lensSettings, &LensSetting::recvSelectedNodesInfo);
+						_lensSettings, &LensSetting::recvSelectedNodesInfo);
 				connect(this, &TreemapGraphicsView::sendMaxIncrease,
-                                                lensSettings, &LensSetting::recvMaxIncrease);
+                                                _lensSettings, &LensSetting::recvMaxIncrease);
 				connect(this, &TreemapGraphicsView::sendMaxSiblingRatio,
-						lensSettings, &LensSetting::recvMaxSiblingRatio);
-				connect(lensSettings, &LensSetting::exportImageRequested,
+						_lensSettings, &LensSetting::recvMaxSiblingRatio);
+				connect(_lensSettings, &LensSetting::exportImageRequested,
 				this, &TreemapGraphicsView::handleExportRequest);
 				connect(this, &TreemapGraphicsView::pathSelected,
-			lensSettings, &LensSetting::onPathSelected);
+			_lensSettings, &LensSetting::onPathSelected);
 
 
 			}
@@ -3465,11 +3582,11 @@
 
 				}
 				if( _is_polygonFlag == true ) {
-					 _item_XMLGraph();
+					 //_item_XMLGraph();
 
 				}
 				if( _is_treemapFlag == true ) {
-					//_item_treemap();
+					_item_treemap();
 
 				}
 
Index: ResponsiveLens/core/HierarchicalPath.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// svg.cpp\r\n//\t: program file svg\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Sat Mar 7 15:02:45 2020\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include \"core/HierarchicalPath.h\"\r\n//#define DEBUG_HIERARCHICALPATH\r\n//#define _USE_MATH_DEFINES\r\n#define z\r\n\r\n//#include <math.h>\r\n\r\nnamespace Lens {\r\n\t//------------------------------------------------------------------------------\r\n\t//\tPrivate Static Variables\r\n\t//------------------------------------------------------------------------------\r\n\r\n\r\n\t//------------------------------------------------------------------------------\r\n\t//\tPrivate Functions\r\n\t//------------------------------------------------------------------------------\r\n\r\n\t//------------------------------------------------------------------------------\r\n\t//\tProtected Functions\r\n\t//------------------------------------------------------------------------------\r\n\r\n\t//------------------------------------------------------------------------------\r\n\t//\tPublic Functions\r\n\t//------------------------------------------------------------------------------\r\n\r\n\t//------------------------------------------------------------------------------\r\n\t//\tConstructors & Destructors\r\n\t//------------------------------------------------------------------------------\r\n\t//\r\n\t//  HierarchicalPath::HierarchicalPath --\tconstructor\r\n\t//\r\n\t//  Inputs\r\n\t//\tnone\r\n\t//\r\n\t//  Outputs\r\n\t//\tnone\r\n\t//\r\n\tHierarchicalPath::HierarchicalPath( void )\r\n\t{\r\n\t\t// _svgPtr = new vector< vector< FileIO::SVG > >;\r\n\r\n\t\t_projectedVertexVec.clear();\r\n\t\t_hierarchicalPathVec.clear();\r\n\t\t_polylineVec.clear();\r\n\t}\r\n\r\n\t//\r\n\t//  HierarchicalPath::HierarchicalPath --\tcopy constructor\r\n\t//\r\n\t//  Input\r\n\t//\tnone\r\n\t//\r\n\t//  Output\r\n\t//\tnone\r\n\t//\r\n\tHierarchicalPath::HierarchicalPath( const HierarchicalPath & v )\r\n\t{\r\n\t\t_polylineVec        = v._polylineVec;\r\n\t}\r\n\r\n\r\n\t//------------------------------------------------------------------------------\r\n\t//\tSpecial functions\r\n\t//------------------------------------------------------------------------------\r\n\tvoid HierarchicalPath::_init( MetaData *__metadataPtr, HierarchicalTreemap *__hierarchicalTreemapPtr )\r\n\t{\r\n\t\t_metadataPtr = __metadataPtr;\r\n\t\t_hierarchicalTreemapPtr = __hierarchicalTreemapPtr;\r\n\t\tdouble ww = KeiRo::Base::Common::getMainwidgetWidth();\r\n\t\tdouble wh = KeiRo::Base::Common::getMainwidgetHeight();\r\n\t\t_screenCanvas = KeiRo::Base::Rectangle2( 0.0, 0.0, ww, wh );\r\n\t}\r\n\r\n\t//\r\n\t//  HierarchicalPath::_repositionPoints --\treposition intermediate points\r\n\t//\r\n\t//  Inputs\r\n\t//\tstring filePath\r\n\t//\r\n\t//  Outputs\r\n\t//\tbool\r\n\t//\r\n\tvoid HierarchicalPath::_repositionPoints( void )\r\n\t{\r\n\t\tvector< vector< unsigned int > > &sortedLevel = _hierarchicalTreemapPtr->sortedLevel();\r\n\t\tunsigned int maxLevel = sortedLevel.size();\r\n\r\n\t\tvector< FileIO::SVG * > &svgPtrVec = _metadataPtr->svgPtrVec();\r\n\t\tGraph::TreeDirectedGraph &svgTree = _metadataPtr->svgTree();\r\n\r\n\t\tGraph::TreeDirectedGraph &graphmlTree    = _hierarchicalTreemapPtr->metadataPtr()->graphmlTree();\r\n\t\t//\t\tmap< unsigned int, Graph::BaseUndirectedGraph >  &graphmlGraphMap   = _metadataPtr->graphmlGraphMap();\r\n\t\tvector< Treemap > &treemapVec = _hierarchicalTreemapPtr->treemapVec();\r\n\t\tdouble smallValue = 1e-5;\r\n\r\n\t\t// TYPE1 collects points in cells\r\n\t\t_conjunctionIDMat.clear();\r\n\t\t_conjunctionIDMat.resize( _polylineVec.size() );\r\n\t\tfor( unsigned int i = 0; i < _polylineVec.size(); i++ ){\r\n\t\t\t_conjunctionIDMat[i].resize( _polylineVec[i].elements().size() );\r\n\r\n\t\t\tfor( unsigned int j = 0; j < _polylineVec[i].elements().size(); j++ ){\r\n\t\t\t\tKeiRo::Base::Coord2 &c = _polylineVec[ i ].elements()[j];\r\n\r\n\t\t\t\tfor( unsigned int m = 0; m < sortedLevel[ maxLevel-2 ].size(); m++ ){\r\n\t\t\t\t\tunsigned int id = sortedLevel[ maxLevel-2 ][ m ];\r\n\t\t\t\t\tFileIO::SVG *svgPtr = svgPtrVec[ id ];\r\n\t\t\t\t\tvector< KeiRo::Base::Polygon2 > &polygonVec = svgPtr->polygonVec();\r\n\t\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd = vertex( id, graphmlTree );\r\n\t\t\t\t\tmap< unsigned int, unsigned int > &childMap = svgTree[ vd ].childMap;\r\n\r\n\t\t\t\t\tfor( unsigned int n = 0; n < polygonVec.size(); n++ ){\r\n\t\t\t\t\t\tKeiRo::Base::Polygon2 p;\r\n\t\t\t\t\t\tunsigned int tid = 1e5 * m + n;\r\n\t\t\t\t\t\tp.elements() = polygonVec[n].fixedElements();\r\n\r\n#ifdef DEBUG\r\n\t\t\t\t\t\tif( p.inPolygon( c ) && (_endpointTreemapID[i].size() == 2) )  {\r\n\t\t\t\t\t\t\tcerr << \"tid = \" << tid << endl;\r\n\t\t\t\t\t\t\tcerr << \"check = \" << ( (_endpointTreemapID[i].size() == 2) && (( _endpointTreemapID[i][0] == tid ) || ( _endpointTreemapID[i][1] == tid ))) << endl;\r\n\t\t\t\t\t\t}\r\n#endif // DEBUG\r\n\t\t\t\t\t\tif( p.inPolygon( c ) &&\r\n\t\t\t\t\t\t\t!( (_endpointTreemapID[i].size() == 2) && !(( _endpointTreemapID[i][0] == tid ) || ( _endpointTreemapID[i][1] == tid )))  ){\r\n#ifdef DEBUG\r\n\t\t\t\t\t\t\tif( j == 4 ){\r\n\t\t\t\t\t\t\t\tcerr << \"j = \" << j << endl;\r\n\t\t\t\t\t\t\t\tcerr << \"p = \" << p;\r\n\t\t\t\t\t\t\t\tcerr << \"id = \" << id << endl;\r\n\t\t\t\t\t\t\t\t//\t\t\t\t\t\t\tcerr << \"size = \" << treemapTargetMap.size() << endl;\r\n\t\t\t\t\t\t\t\tcerr << \"m = \" << m << endl;\r\n\t\t\t\t\t\t\t\tcerr << \"n = \" << n << endl << endl;\r\n\t\t\t\t\t\t\t\tcerr << \"i = \" << i << \" j = \" << j << endl;\r\n\t\t\t\t\t\t\t}\r\n#endif // DEBUG\r\n\r\n\t\t\t\t\t\t\tif( _endpointTreemapID[i].size() == 0 ){\r\n\t\t\t\t\t\t\t\t_endpointTreemapID[i].push_back( tid );\r\n\t\t\t\t\t\t\t\t//\t\t\t\t\t\t\t\tcerr << \"tid1 = \" << tid << endl;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse if( _endpointTreemapID[i].size() == 1 ){\r\n\t\t\t\t\t\t\t\tif( _endpointTreemapID[i][0] != tid ) {\r\n\t\t\t\t\t\t\t\t\t_endpointTreemapID[i].push_back( tid );\r\n\t\t\t\t\t\t\t\t\t//\t\t\t\t\t\t\t\t\tcerr << \"tid2 = \" << tid << endl;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tmap< unsigned int, unsigned int >::iterator itC = childMap.begin();\r\n\t\t\t\t\t\t\tstd::advance( itC, n );\r\n\t\t\t\t\t\t\tunsigned int idC = itC->second;\r\n\t\t\t\t\t\t\tFileIO::SVG *childSvgPtr = svgPtrVec[ idC ];\r\n\t\t\t\t\t\t\tvector< KeiRo::Base::Coord2 > &samples = childSvgPtr->compressionGrid().samples();\r\n\t\t\t\t\t\t\tvector< KeiRo::Base::Line2 > &childPolylineVec = childSvgPtr->polylineVec();\r\n\t\t\t\t\t\t\tKeiRo::Base::Coord2 *closestCentroidPtr = &childPolylineVec[0].fixedElements()[0];\r\n\t\t\t\t\t\t\tunsigned int closestCentroidIDP = 0;\r\n\t\t\t\t\t\t\tunsigned int closestCentroidIDQ = 0;\r\n\t\t\t\t\t\t\tfor( unsigned int p = 0; p < childPolylineVec.size(); p++ ){\r\n\t\t\t\t\t\t\t\tfor( unsigned int q = 0; q < childPolylineVec[p].fixedElements().size(); q++ ){\r\n\t\t\t\t\t\t\t\t\tKeiRo::Base::Coord2 &centroid = childPolylineVec[p].fixedElements()[q];\r\n\t\t\t\t\t\t\t\t\tif( distanceBetween( c, centroid ) < distanceBetween( c, *closestCentroidPtr ) ){\r\n\t\t\t\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[j] = &centroid;\r\n\t\t\t\t\t\t\t\t\t\tclosestCentroidPtr = &centroid;\r\n\t\t\t\t\t\t\t\t\t\tclosestCentroidIDP = p;\r\n\t\t\t\t\t\t\t\t\t\tclosestCentroidIDQ = q;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[j] = &samples[ childPolylineVec[ closestCentroidIDP ].idElements()[ closestCentroidIDQ ] ];\r\n\t\t\t\t\t\t\t_conjunctionIDMat[i][j].level.push_back( maxLevel-2 );\r\n\t\t\t\t\t\t\t_conjunctionIDMat[i][j].member.push_back( m );\r\n\t\t\t\t\t\t\t_conjunctionIDMat[i][j].polygonMember.push_back( n );\r\n\t\t\t\t\t\t\t_conjunctionIDMat[i][j].conjunctionType = CONJUNCTION_INCELLS;\r\n\r\n#ifdef DEBUG\r\n\t\t\t\t\t\t\tcerr << \"oIDP = \" << closestCentroidIDP << endl;\r\n\t\t\t\t\t\t\tcerr << \"oIDQ = \" << closestCentroidIDQ << endl;\r\n\t\t\t\t\t\t\tcerr << \"fix = \" << &childPolylineVec[ closestCentroidIDP ].fixedElements()[ closestCentroidIDQ ] << endl;\r\n\t\t\t\t\t\t\tcerr << \"fixc = \" << childPolylineVec[ closestCentroidIDP ].fixedElements()[ closestCentroidIDQ ];\r\n\t\t\t\t\t\t\tcerr << \"obj = \" << &childPolylineVec[ closestCentroidIDP ].elements()[ closestCentroidIDQ ] << endl;\r\n\t\t\t\t\t\t\tcerr << \"objc = \" << childPolylineVec[ closestCentroidIDP ].elements()[ closestCentroidIDQ ];\r\n\t\t\t\t\t\t\tcerr << \"ptr = \" << _polylineVec[ i ].elementPointers()[j] << endl;\r\n\t\t\t\t\t\t\tcerr << \"ptrc = \" << *_polylineVec[ i ].elementPointers()[j] << endl << endl;\r\n#endif // DEBUG\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// TYPE2 collects points not on outer boundary\r\n\t\tfor( unsigned int i = 0; i < _polylineVec.size(); i++ ){\r\n\t\t\tfor( unsigned int j = 1; j < _polylineVec[i].elements().size()-1; j++ ) {\r\n\r\n\t\t\t\t//notypes is for points that need to be classified\r\n\t\t\t\tif( _conjunctionIDMat[i][j].conjunctionType == CONJUNCTION_NOTYPE ) {\r\n\t\t\t\t\tKeiRo::Base::Coord2 &c = _polylineVec[ i ].elements()[j];\r\n\r\n\t\t\t\t\t//if the preiveous point inside cell means the point is nocorner\r\n\t\t\t\t\tif( _conjunctionIDMat[ i ][ j - 1 ].conjunctionType == CONJUNCTION_INCELLS ) {\r\n\t\t\t\t\t\t// cerr << \"i = \" << i << \" j = \" << j << endl;\r\n\t\t\t\t\t\t_conjunctionIDMat[ i ][ j ].conjunctionType = CONJUNCTION_NONCORNER;\r\n\t\t\t\t\t\t_conjunctionIDMat[i][j].level = _conjunctionIDMat[i][j-1].level;\r\n\t\t\t\t\t\t_conjunctionIDMat[i][j].member = _conjunctionIDMat[i][j-1].member;\r\n\t\t\t\t\t\t_conjunctionIDMat[i][j].polygonMember = _conjunctionIDMat[i][j-1].polygonMember;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//if the next point inside cell means the point is nocorner\r\n\t\t\t\t\tif( _conjunctionIDMat[ i ][ j + 1 ].conjunctionType == CONJUNCTION_INCELLS ) {\r\n\t\t\t\t\t\t// cerr << \"i = \" << i << \" j = \" << j << endl;\r\n\t\t\t\t\t\t_conjunctionIDMat[ i ][ j ].conjunctionType = CONJUNCTION_NONCORNER;\r\n\t\t\t\t\t\t_conjunctionIDMat[i][j].level = _conjunctionIDMat[i][j+1].level;\r\n\t\t\t\t\t\t_conjunctionIDMat[i][j].member = _conjunctionIDMat[i][j+1].member;\r\n\t\t\t\t\t\t_conjunctionIDMat[i][j].polygonMember = _conjunctionIDMat[i][j+1].polygonMember;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// TYPE3 collects points on outer boundary\r\n\t\tfor( unsigned int i = 0; i < _polylineVec.size(); i++ ){\r\n\t\t\tfor( unsigned int j = 0; j < _polylineVec[i].elements().size(); j++ ) {\r\n\r\n\t\t\t\tKeiRo::Base::Coord2 &c = _polylineVec[ i ].elements()[ j ];\r\n\t\t\t\tif( _conjunctionIDMat[i][j].conjunctionType == CONJUNCTION_NOTYPE ){\r\n\r\n\t\t\t\t\t// find the closest corner points\r\n\t\t\t\t\tKeiRo::Base::Coord2 closestP( INFINITY, INFINITY );\r\n\t\t\t\t\tdouble minDist = INFINITY;\r\n\r\n\t\t\t\t\tfor( unsigned int m = 0; m < sortedLevel[ maxLevel-2 ].size(); m++ ){\r\n\t\t\t\t\t\tunsigned int id = sortedLevel[ maxLevel-2 ][ m ];\r\n\r\n\t\t\t\t\t\tFileIO::SVG *svgPtr = svgPtrVec[ id ];\r\n\t\t\t\t\t\tvector< KeiRo::Base::Polygon2 > &polygonVec = svgPtr->polygonVec();\r\n\t\t\t\t\t\tmap< unsigned int, KeiRo::Base::Rectangle2 > &treemapTargetMap = treemapVec[id].treemapTargetMap();\r\n\r\n\t\t\t\t\t\tfor( unsigned int n = 0; n < polygonVec.size(); n++ ){\r\n\t\t\t\t\t\t\tmap< unsigned int, KeiRo::Base::Rectangle2 >::iterator itT = treemapTargetMap.begin();\r\n\t\t\t\t\t\t\tstd::advance( itT, n );\r\n\t\t\t\t\t\t\tKeiRo::Base::Rectangle2 &rect = itT->second;\r\n\r\n\t\t\t\t\t\t\t// POINT_LEFTBOTTOM\r\n\t\t\t\t\t\t\tKeiRo::Base::Coord2 refLB( rect.leftBottom().x(), rect.leftBottom().y() );\r\n\t\t\t\t\t\t\tif( minDist > (refLB-c).norm() ){\r\n\t\t\t\t\t\t\t\tif( _coveredRegion.isInside( c ) == true ){\r\n\t\t\t\t\t\t\t\t\tclosestP = refLB;\r\n\t\t\t\t\t\t\t\t\tminDist = (refLB-c).norm();\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse if( _coveredRegion.isInside( refLB ) == false ){\r\n\t\t\t\t\t\t\t\t\tclosestP = refLB;\r\n\t\t\t\t\t\t\t\t\tminDist = (refLB-c).norm();\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// POINT_RIGHTBOTTOM\r\n\t\t\t\t\t\t\tKeiRo::Base::Coord2 refRB( rect.leftBottom().x() + rect.width(), rect.leftBottom().y() );\r\n\t\t\t\t\t\t\tif( minDist > (refRB-c).norm() ){\r\n\t\t\t\t\t\t\t\tif( _coveredRegion.isInside( c ) == true ){\r\n\t\t\t\t\t\t\t\t\tclosestP = refRB;\r\n\t\t\t\t\t\t\t\t\tminDist = (refRB-c).norm();\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse if( _coveredRegion.isInside( refRB ) == false ){\r\n\t\t\t\t\t\t\t\t\tclosestP = refRB;\r\n\t\t\t\t\t\t\t\t\tminDist = (refRB-c).norm();\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// POINT_RIGHTTOP\r\n\t\t\t\t\t\t\tKeiRo::Base::Coord2 refRT( rect.leftBottom().x() + rect.width(), rect.leftBottom().y() + rect.height() );\r\n\t\t\t\t\t\t\tif( minDist > (refRT-c).norm() ){\r\n\t\t\t\t\t\t\t\tif( _coveredRegion.isInside( c ) == true ) {\r\n\t\t\t\t\t\t\t\t\tclosestP = refRT;\r\n\t\t\t\t\t\t\t\t\tminDist = ( refRT - c ).norm();\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse if( _coveredRegion.isInside( refRT ) == false ){\r\n\t\t\t\t\t\t\t\t\tclosestP = refRT;\r\n\t\t\t\t\t\t\t\t\tminDist = (refRT-c).norm();\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// POINT_LEFTTOP\r\n\t\t\t\t\t\t\tKeiRo::Base::Coord2 refLT( rect.leftBottom().x(), rect.leftBottom().y() + rect.height() );\r\n\t\t\t\t\t\t\tif( minDist > (refLT-c).norm() ){\r\n\t\t\t\t\t\t\t\tif( _coveredRegion.isInside( c ) == true ) {\r\n\t\t\t\t\t\t\t\t\tclosestP = refLT;\r\n\t\t\t\t\t\t\t\t\tminDist = ( refLT - c ).norm();\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse if( _coveredRegion.isInside( refLT ) == false ){\r\n\t\t\t\t\t\t\t\t\tclosestP = refLT;\r\n\t\t\t\t\t\t\t\t\tminDist = (refLT-c).norm();\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//\t\t\t\t\tif ( j == 4 ) {\r\n\t\t\t\t\t//\t\t\t\t\t\tcerr << \"minDist = \" << minDist << endl;\r\n\t\t\t\t\t//\t\t\t\t\t\tcerr << \" closestP = \" << closestP;\r\n\t\t\t\t\t//\t\t\t\t\t}\r\n\t\t\t\t\tc = closestP;\r\n\r\n\t\t\t\t\t// build conjunction index\r\n\t\t\t\t\tfor( unsigned int m = 0; m < sortedLevel[ maxLevel-2 ].size(); m++ ){\r\n\t\t\t\t\t\tunsigned int id = sortedLevel[ maxLevel-2 ][ m ];\r\n\r\n\t\t\t\t\t\tFileIO::SVG *svgPtr = svgPtrVec[ id ];\r\n\t\t\t\t\t\tvector< KeiRo::Base::Polygon2 > &polygonVec = svgPtr->polygonVec();\r\n\t\t\t\t\t\tmap< unsigned int, KeiRo::Base::Rectangle2 > &treemapTargetMap = treemapVec[id].treemapTargetMap();\r\n\t\t\t\t\t\tfor( unsigned int n = 0; n < polygonVec.size(); n++ ){\r\n\t\t\t\t\t\t\tmap< unsigned int, KeiRo::Base::Rectangle2 >::iterator itT = treemapTargetMap.begin();\r\n\t\t\t\t\t\t\tstd::advance( itT, n );\r\n\t\t\t\t\t\t\tKeiRo::Base::Rectangle2 &rect = itT->second;\r\n\r\n\t\t\t\t\t\t\t// POINT_LEFTBOTTOM\r\n\t\t\t\t\t\t\tKeiRo::Base::Coord2 refLB( rect.leftBottom().x(), rect.leftBottom().y() );\r\n\t\t\t\t\t\t\tif( (refLB-closestP).norm() <= 0.5 ){\r\n\t\t\t\t\t\t\t\t_conjunctionIDMat[i][j].level.push_back( maxLevel-2 );\r\n\t\t\t\t\t\t\t\t_conjunctionIDMat[i][j].member.push_back( m );\r\n\t\t\t\t\t\t\t\t_conjunctionIDMat[i][j].polygonMember.push_back( n );\r\n\t\t\t\t\t\t\t\t_conjunctionIDMat[i][j].pointType.push_back( POINT_LEFTBOTTOM );\r\n\t\t\t\t\t\t\t\t_conjunctionIDMat[i][j].conjunctionType = CONJUNCTION_CORNER;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// POINT_RIGHTBOTTOM\r\n\t\t\t\t\t\t\tKeiRo::Base::Coord2 refRB( rect.leftBottom().x() + rect.width(), rect.leftBottom().y() );\r\n\t\t\t\t\t\t\tif( (refRB-closestP).norm() <= 0.5 ){\r\n\t\t\t\t\t\t\t\t_conjunctionIDMat[i][j].level.push_back( maxLevel-2 );\r\n\t\t\t\t\t\t\t\t_conjunctionIDMat[i][j].member.push_back( m );\r\n\t\t\t\t\t\t\t\t_conjunctionIDMat[i][j].polygonMember.push_back( n );\r\n\t\t\t\t\t\t\t\t_conjunctionIDMat[i][j].pointType.push_back( POINT_RIGHTBOTTOM );\r\n\t\t\t\t\t\t\t\t_conjunctionIDMat[i][j].conjunctionType = CONJUNCTION_CORNER;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// POINT_RIGHTTOP\r\n\t\t\t\t\t\t\tKeiRo::Base::Coord2 refRT( rect.leftBottom().x() + rect.width(), rect.leftBottom().y() + rect.height() );\r\n\t\t\t\t\t\t\tif( (refRT-closestP).norm() <= 0.5 ){\r\n\t\t\t\t\t\t\t\t_conjunctionIDMat[i][j].level.push_back( maxLevel-2 );\r\n\t\t\t\t\t\t\t\t_conjunctionIDMat[i][j].member.push_back( m );\r\n\t\t\t\t\t\t\t\t_conjunctionIDMat[i][j].polygonMember.push_back( n );\r\n\t\t\t\t\t\t\t\t_conjunctionIDMat[i][j].pointType.push_back( POINT_RIGHTTOP );\r\n\t\t\t\t\t\t\t\t_conjunctionIDMat[i][j].conjunctionType = CONJUNCTION_CORNER;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// POINT_LEFTTOP\r\n\t\t\t\t\t\t\tKeiRo::Base::Coord2 refLT( rect.leftBottom().x(), rect.leftBottom().y() + rect.height() );\r\n\t\t\t\t\t\t\tif( (refLT-closestP).norm() <= 0.5 ){\r\n\t\t\t\t\t\t\t\t_conjunctionIDMat[i][j].level.push_back( maxLevel-2 );\r\n\t\t\t\t\t\t\t\t_conjunctionIDMat[i][j].member.push_back( m );\r\n\t\t\t\t\t\t\t\t_conjunctionIDMat[i][j].polygonMember.push_back( n );\r\n\t\t\t\t\t\t\t\t_conjunctionIDMat[i][j].pointType.push_back( POINT_LEFTTOP );\r\n\t\t\t\t\t\t\t\t_conjunctionIDMat[i][j].conjunctionType = CONJUNCTION_CORNER;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//\t\t\t\t\tif( j == 4 ) cerr << \"test = \" << _conjunctionIDMat[i][j].level.size() << endl;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n#ifdef DEBUG\r\n\t\tfor( unsigned int i = 0; i < _conjunctionIDMat.size(); i++ ){\r\n\t\t\tfor( unsigned int j = 0; j < _conjunctionIDMat[i].size(); j++ ) {\r\n\t\t\t\tcerr << \"i = \" << i << \", j = \" << j << endl;\r\n\t\t\t\tif( _conjunctionIDMat[i][j].conjunctionType == CONJUNCTION_INCELLS ){\r\n\t\t\t\t\tcerr << \" type = \" << _conjunctionIDMat[i][j].conjunctionType << endl;\r\n\t\t\t\t\tcerr << \" level = \" << _conjunctionIDMat[i][j].level[0] << endl\r\n\t\t\t\t\t\t << \" member = \" << _conjunctionIDMat[i][j].member[0] << endl\r\n\t\t\t\t\t\t << \" polymember = \" << _conjunctionIDMat[i][j].polygonMember[0] << endl;\r\n\t\t\t\t}\r\n\t\t\t\tif( _conjunctionIDMat[i][j].conjunctionType == CONJUNCTION_NONCORNER ){\r\n\t\t\t\t\tcerr << \" type = \" << _conjunctionIDMat[i][j].conjunctionType << endl;\r\n\t\t\t\t\tcerr << \" level = \" << _conjunctionIDMat[i][j].level[0] << endl\r\n\t\t\t\t\t\t << \" member = \" << _conjunctionIDMat[i][j].member[0] << endl\r\n\t\t\t\t\t\t << \" polymember = \" << _conjunctionIDMat[i][j].polygonMember[0] << endl;\r\n\t\t\t\t}\r\n\t\t\t\tif( _conjunctionIDMat[i][j].conjunctionType == CONJUNCTION_CORNER ){\r\n\t\t\t\t\tfor( unsigned int k = 0; k < _conjunctionIDMat[i][j].level.size(); k++ ){\r\n\t\t\t\t\t\tcerr << \" type = \" << _conjunctionIDMat[i][j].conjunctionType << endl;\r\n\t\t\t\t\t\tcerr << \" level = \" << _conjunctionIDMat[i][j].level[k] << endl\r\n\t\t\t\t\t\t\t << \" member = \" << _conjunctionIDMat[i][j].member[k] << endl\r\n\t\t\t\t\t\t\t << \" polymember = \" << _conjunctionIDMat[i][j].polygonMember[k] << endl\r\n\t\t\t\t\t\t\t << \" pointtype = \" << _conjunctionIDMat[i][j].pointType[k] << endl;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tcerr << endl;\r\n\t\t\t}\r\n\t\t}\r\n#endif // DEBUG\r\n\r\n\t\t// normalize the path with treemap\r\n\t\t// adjust points in cells\r\n\t\tfor( unsigned int i = 0; i < _conjunctionIDMat.size(); i++ ) {\r\n\t\t\t//\t\t\tcerr << \"_conjunctionIDMat[i].size() = \" << _conjunctionIDMat[i].size() << endl;\r\n\t\t\t//\t\t\tcerr << \"_polylineVec[i].elementPointers().size() = \" << _polylineVec[i].elementPointers().size() << endl;\r\n\t\t\tfor( unsigned int j = 0; j < _conjunctionIDMat[ i ].size(); j++ ) {\r\n\r\n#ifdef SKIP\r\n\t\t\t\tif( _conjunctionIDMat[i][j].conjunctionType == CONJUNCTION_INCELLS ){\r\n\t\t\t\t\tunsigned int level = _conjunctionIDMat[i][j].level[0];\r\n\t\t\t\t\tunsigned int member = _conjunctionIDMat[i][j].member[0];\r\n\t\t\t\t\tunsigned int polygonMember = _conjunctionIDMat[i][j].polygonMember[0];\r\n#ifdef DEBUG\r\n\t\t\t\t\tcerr << \"level = \" << level << endl;\r\n\t\t\t\t\tcerr << \"member = \" << member << endl;\r\n\t\t\t\t\tcerr << \"polygonMember = \" << polygonMember << endl;\r\n#endif // DEBUG\r\n\t\t\t\t\tunsigned int id = sortedLevel[ level ][ member ];\r\n\t\t\t\t\tvector<  KeiRo::Base::Polygon2 > &polygonVec = svgPtrVec[ id ]->polygonVec();\r\n\t\t\t\t\tKeiRo::Base::Rectangle2 &bbox = polygonVec[ polygonMember ].boundingBox();\r\n\t\t\t\t\tmap< string, KeiRo::Base::Rectangle2 > &treemapTargetMap = treemapVec[id].treemapTargetMap();\r\n\t\t\t\t\tmap< string, KeiRo::Base::Rectangle2 >::iterator itT = treemapTargetMap.begin();\r\n\t\t\t\t\tstd::advance( itT, polygonMember );\r\n\t\t\t\t\tKeiRo::Base::Rectangle2 rectS;\r\n\t\t\t\t\trectS.leftBottom() = bbox.oldLeftBottom();\r\n\t\t\t\t\trectS.width() = bbox.oldWidth();\r\n\t\t\t\t\trectS.height() = bbox.oldHeight();\r\n\t\t\t\t\tKeiRo::Base::Rectangle2 &rectT = itT->second;\r\n\t\t\t\t\tdouble &x = _polylineVec[i].elements()[j].x();\r\n\t\t\t\t\tdouble &y = _polylineVec[i].elements()[j].y();\r\n#ifdef DEBUG\r\n\t\t\t\t\tcerr << \"rectS = \" << rectS;\r\n\t\t\t\t\tcerr << \"rectT = \" << rectT;\r\n#endif // DEBUG\r\n\t\t\t\t\tx = ( x - rectS.leftBottom().x() ) * rectT.width()/rectS.width() + rectT.leftBottom().x();\r\n\t\t\t\t\ty = ( y - rectS.leftBottom().y() ) * rectT.height()/rectS.height() + rectT.leftBottom().y();\r\n\t\t\t\t}\r\n#endif // SKIP\r\n\t\t\t\tif( ( j > 0 ) &&\r\n\t\t\t\t\t( _conjunctionIDMat[ i ][ j - 1 ].conjunctionType == CONJUNCTION_INCELLS ) &&\r\n\t\t\t\t\t( _conjunctionIDMat[ i ][ j ].conjunctionType == CONJUNCTION_NONCORNER ) ) {\r\n\r\n\t\t\t\t\tKeiRo::Base::Coord2 diff =\r\n\t\t\t\t\t\t\t_polylineVec[ i ].fixedElements()[ j ] - _polylineVec[ i ].fixedElements()[ j - 1 ];\r\n\r\n\t\t\t\t\tunsigned int level = _conjunctionIDMat[ i ][ j ].level[ 0 ];\r\n\t\t\t\t\tunsigned int member = _conjunctionIDMat[ i ][ j ].member[ 0 ];\r\n\t\t\t\t\tunsigned int polygonMember = _conjunctionIDMat[ i ][ j ].polygonMember[ 0 ];\r\n\r\n\t\t\t\t\tunsigned int id = sortedLevel[ level ][ member ];\r\n\t\t\t\t\tvector< KeiRo::Base::Polygon2 > &polygonVec = svgPtrVec[ id ]->polygonVec();\r\n\t\t\t\t\tKeiRo::Base::Rectangle2 &bbox = polygonVec[ polygonMember ].boundingBox();\r\n\t\t\t\t\tmap< unsigned int, KeiRo::Base::Rectangle2 > &treemapTargetMap = treemapVec[ id ].treemapTargetMap();\r\n\t\t\t\t\tmap< unsigned int, KeiRo::Base::Rectangle2 >::iterator itT = treemapTargetMap.begin();\r\n\t\t\t\t\tstd::advance( itT, polygonMember );\r\n\t\t\t\t\tKeiRo::Base::Rectangle2 &rectT = itT->second;\r\n\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ] = new KeiRo::Base::Coord2(\r\n\t\t\t\t\t\t\t_polylineVec[ i ].elements()[ j ].x(),\r\n\t\t\t\t\t\t\t_polylineVec[ i ].elements()[ j ].y() );\r\n\r\n\t\t\t\t\t// horizontal line\r\n\t\t\t\t\tif( fabs( diff.x() ) > fabs( diff.y() ) ) {\r\n\t\t\t\t\t\tif( diff.x() > 0 ) {\r\n\t\t\t\t\t\t\t// right border\r\n\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->x() = rectT.leftBottom().x() + rectT.width() - smallValue;\r\n\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->y() = _polylineVec[ i ].elementPointers()[ j - 1 ]->y();\r\n\t\t\t\t\t\t\t//\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->x() = _polylineVec[ i ].elements()[ j ].x() =\r\n\t\t\t\t\t\t\t//\t\t\t\t\t\t\t\t\trectT.leftBottom().x() + rectT.width() - 1.0;\r\n\t\t\t\t\t\t\t//\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->y() = _polylineVec[ i ].elements()[ j ].y() = _polylineVec[ i ].elementPointers()[ j - 1 ]->y();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t// left border\r\n\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->x() = rectT.leftBottom().x() + smallValue;\r\n\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->y() = _polylineVec[ i ].elementPointers()[ j - 1 ]->y();\r\n\t\t\t\t\t\t\t//\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->x() = _polylineVec[ i ].elements()[ j ].x() = rectT.leftBottom().x() + 1.0;\r\n\t\t\t\t\t\t\t//\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->y() = _polylineVec[ i ].elements()[ j ].y() = _polylineVec[ i ].elementPointers()[ j - 1 ]->y();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// vertical line\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tif( diff.y() > 0 ) {\r\n\t\t\t\t\t\t\t// top border\r\n\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->x() = _polylineVec[ i ].elementPointers()[ j - 1 ]->x();\r\n\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->y() = rectT.leftBottom().y() + rectT.height() - smallValue;\r\n\t\t\t\t\t\t\t//\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->x() = _polylineVec[ i ].elements()[ j ].x() = _polylineVec[ i ].elementPointers()[ j - 1 ]->x();\r\n\t\t\t\t\t\t\t//\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->y() = _polylineVec[ i ].elements()[ j ].y() =\r\n\t\t\t\t\t\t\t//\t\t\t\t\t\t\t\t\trectT.leftBottom().y() + rectT.height() - 1.0;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t// bottom border\r\n\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->x() = _polylineVec[ i ].elementPointers()[ j - 1 ]->x();\r\n\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->y() = rectT.leftBottom().y() + smallValue;\r\n\t\t\t\t\t\t\t//\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->x() = _polylineVec[ i ].elements()[ j ].x() = _polylineVec[ i ].elementPointers()[ j - 1 ]->x();\r\n\t\t\t\t\t\t\t//\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->y() = _polylineVec[ i ].elements()[ j ].y() = rectT.leftBottom().y() + 1.0;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t//\t\t\t\tif( j == 8 ) {\r\n\t\t\t\t//\t\t\t\t\tcerr << \"TEST = \" << j+1 << \", \" << _polylineVec[ i ].elementPointers()[ j + 1 ]->y() << endl;\r\n\t\t\t\t//\t\t\t\t\tcerr << \"_conjunctionIDMat[ i ][ j + 1 ].conjunctionType= \" << _conjunctionIDMat[ i ][ j + 1 ].conjunctionType << endl;\r\n\t\t\t\t//\t\t\t\t\tcerr << \"_conjunctionIDMat[ i ][ j ].conjunctionType = \" << _conjunctionIDMat[ i ][ j ].conjunctionType << endl;\r\n\t\t\t\t//\t\t\t\t}\r\n\r\n\t\t\t\tif( ( j < _conjunctionIDMat[ i ].size() - 1 ) &&\r\n\t\t\t\t\t( _conjunctionIDMat[ i ][ j + 1 ].conjunctionType == CONJUNCTION_INCELLS ) &&\r\n\t\t\t\t\t( _conjunctionIDMat[ i ][ j ].conjunctionType == CONJUNCTION_NONCORNER ) ) {\r\n\r\n\t\t\t\t\tKeiRo::Base::Coord2 diff =\r\n\t\t\t\t\t\t\t_polylineVec[ i ].fixedElements()[ j + 1 ] - _polylineVec[ i ].fixedElements()[ j ];\r\n\r\n\t\t\t\t\tunsigned int level = _conjunctionIDMat[ i ][ j ].level[ 0 ];\r\n\t\t\t\t\tunsigned int member = _conjunctionIDMat[ i ][ j ].member[ 0 ];\r\n\t\t\t\t\tunsigned int polygonMember = _conjunctionIDMat[ i ][ j ].polygonMember[ 0 ];\r\n\r\n\t\t\t\t\tunsigned int id = sortedLevel[ level ][ member ];\r\n\t\t\t\t\tvector< KeiRo::Base::Polygon2 > &polygonVec = svgPtrVec[ id ]->polygonVec();\r\n\t\t\t\t\tKeiRo::Base::Rectangle2 &bbox = polygonVec[ polygonMember ].boundingBox();\r\n\t\t\t\t\tmap< unsigned int, KeiRo::Base::Rectangle2 > &treemapTargetMap = treemapVec[ id ].treemapTargetMap();\r\n\t\t\t\t\tmap< unsigned int, KeiRo::Base::Rectangle2 >::iterator itT = treemapTargetMap.begin();\r\n\t\t\t\t\tstd::advance( itT, polygonMember );\r\n\t\t\t\t\tKeiRo::Base::Rectangle2 &rectT = itT->second;\r\n\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ] = new KeiRo::Base::Coord2(\r\n\t\t\t\t\t\t\t_polylineVec[ i ].elements()[ j ].x(),\r\n\t\t\t\t\t\t\t_polylineVec[ i ].elements()[ j ].y() );\r\n\r\n\t\t\t\t\t// horizontal line\r\n\t\t\t\t\tif( fabs( diff.x() ) > fabs( diff.y() ) ) {\r\n\t\t\t\t\t\tif( diff.x() < 0 ) {\r\n\t\t\t\t\t\t\t// right border\r\n\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->x() = rectT.leftBottom().x() + rectT.width() - 1.0;\r\n\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->y() = _polylineVec[ i ].elementPointers()[ j + 1 ]->y();\r\n\t\t\t\t\t\t\t//\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->x() = _polylineVec[ i ].elements()[ j ].x() = rectT.leftBottom().x() + rectT.width() - 1.0;\r\n\t\t\t\t\t\t\t//\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->y() = _polylineVec[ i ].elements()[ j ].y() = _polylineVec[ i ].elementPointers()[ j + 1 ]->y();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t// left border\r\n\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->x() = rectT.leftBottom().x() + 1.0;\r\n\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->y() = _polylineVec[ i ].elementPointers()[ j + 1 ]->y();\r\n\t\t\t\t\t\t\t//\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->x() = _polylineVec[ i ].elements()[ j ].x() = rectT.leftBottom().x() + 1.0;\r\n\t\t\t\t\t\t\t//\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->y() = _polylineVec[ i ].elements()[ j ].y() = _polylineVec[ i ].elementPointers()[ j + 1 ]->y();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// vertical line\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tif( diff.y() < 0 ) {\r\n\t\t\t\t\t\t\t// top border\r\n\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->x() = _polylineVec[ i ].elementPointers()[ j + 1 ]->x();\r\n\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->y() = rectT.leftBottom().y() + rectT.height() - 1.0;\r\n\t\t\t\t\t\t\t//\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->x() = _polylineVec[ i ].elements()[ j ].x() = _polylineVec[ i ].elementPointers()[ j + 1 ]->x();\r\n\t\t\t\t\t\t\t//\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->y() = _polylineVec[ i ].elements()[ j ].y() = rectT.leftBottom().y() + rectT.height() - 1.0;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t// bottom border\r\n\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->x() = _polylineVec[ i ].elementPointers()[ j + 1 ]->x();\r\n\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->y() = rectT.leftBottom().y() + 1.0;\r\n\t\t\t\t\t\t\t//\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->x() = _polylineVec[ i ].elements()[ j ].x() = _polylineVec[ i ].elementPointers()[ j + 1 ]->x();\r\n\t\t\t\t\t\t\t//\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->y() = _polylineVec[ i ].elements()[ j ].y() = rectT.leftBottom().y() + 1.0;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t//\t\t\t\t\tKeiRo::Base::Coord2 diff =\r\n\t\t\t\t\t//\t\t\t\t\t\t\t_polylineVec[ i ].fixedElements()[ j ] - _polylineVec[ i ].fixedElements()[ j + 1 ];\r\n\t\t\t\t\t//\r\n\t\t\t\t\t//\t\t\t\t\tunsigned int level = _conjunctionIDMat[ i ][ j ].level[ 0 ];\r\n\t\t\t\t\t//\t\t\t\t\tunsigned int member = _conjunctionIDMat[ i ][ j ].member[ 0 ];\r\n\t\t\t\t\t//\t\t\t\t\tunsigned int polygonMember = _conjunctionIDMat[ i ][ j ].polygonMember[ 0 ];\r\n\t\t\t\t\t//\r\n\t\t\t\t\t//\t\t\t\t\tunsigned int id = sortedLevel[ level ][ member ];\r\n\t\t\t\t\t//\t\t\t\t\tvector< KeiRo::Base::Polygon2 > &polygonVec = svgPtrVec[ id ]->polygonVec();\r\n\t\t\t\t\t//\t\t\t\t\tKeiRo::Base::Rectangle2 &bbox = polygonVec[ polygonMember ].boundingBox();\r\n\t\t\t\t\t//\t\t\t\t\tmap< string, KeiRo::Base::Rectangle2 > &treemapTargetMap = treemapVec[ id ].treemapTargetMap();\r\n\t\t\t\t\t//\t\t\t\t\tmap< string, KeiRo::Base::Rectangle2 >::iterator itT = treemapTargetMap.begin();\r\n\t\t\t\t\t//\t\t\t\t\tKeiRo::Base::Rectangle2 rectS;\r\n\t\t\t\t\t//\t\t\t\t\trectS.leftBottom() = bbox.oldLeftBottom();\r\n\t\t\t\t\t//\t\t\t\t\trectS.width() = bbox.oldWidth();\r\n\t\t\t\t\t//\t\t\t\t\trectS.height() = bbox.oldHeight();\r\n\t\t\t\t\t//\t\t\t\t\tstd::advance( itT, polygonMember );\r\n\t\t\t\t\t//\t\t\t\t\tKeiRo::Base::Rectangle2 &rectT = itT->second;\r\n\t\t\t\t\t//\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ] = new KeiRo::Base::Coord2;\r\n\t\t\t\t\t//\t\t\t\t\tdouble &x = _polylineVec[ i ].elementPointers()[ j + 1 ]->x();\r\n\t\t\t\t\t//\t\t\t\t\tdouble &y = _polylineVec[ i ].elementPointers()[ j + 1 ]->y();\r\n\t\t\t\t\t//\r\n\t\t\t\t\t//\t\t\t\t\t// horizontal line\r\n\t\t\t\t\t//\t\t\t\t\tif( fabs( diff.x() ) > fabs( diff.y() ) ) {\r\n\t\t\t\t\t//\t\t\t\t\t\tif( diff.x() > 0 ) {\r\n\t\t\t\t\t//\t\t\t\t\t\t\t// right border\r\n\t\t\t\t\t//\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->x() = _polylineVec[ i ].elements()[ j ].x() =\r\n\t\t\t\t\t//\t\t\t\t\t\t\t\t\trectT.leftBottom().x() + rectT.width();\r\n\t\t\t\t\t//\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->y() = y; //_polylineVec[ i ].elements()[ j ].y() = y;\r\n\t\t\t\t\t//\t\t\t\t\t\t}\r\n\t\t\t\t\t//\t\t\t\t\t\telse {\r\n\t\t\t\t\t//\t\t\t\t\t\t\t// left border\r\n\t\t\t\t\t//\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->x() = _polylineVec[ i ].elements()[ j ].x() = rectT.leftBottom().x();\r\n\t\t\t\t\t//\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->y() = y; // _polylineVec[ i ].elements()[ j ].y() = y;\r\n\t\t\t\t\t//\t\t\t\t\t\t}\r\n\t\t\t\t\t//\t\t\t\t\t}\r\n\t\t\t\t\t//\t\t\t\t\t\t// vertical line\r\n\t\t\t\t\t//\t\t\t\t\telse {\r\n\t\t\t\t\t//\t\t\t\t\t\tif( diff.y() > 0 ) {\r\n\t\t\t\t\t//\t\t\t\t\t\t\t// top border\r\n\t\t\t\t\t//\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->x() = x; // _polylineVec[ i ].elements()[ j ].x() = x;\r\n\t\t\t\t\t//\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->y() = _polylineVec[ i ].elements()[ j ].y() =\r\n\t\t\t\t\t//\t\t\t\t\t\t\t\t\trectT.leftBottom().y() + rectT.height();\r\n\t\t\t\t\t//\t\t\t\t\t\t}\r\n\t\t\t\t\t//\t\t\t\t\t\telse {\r\n\t\t\t\t\t//\t\t\t\t\t\t\t// bottom border\r\n\t\t\t\t\t//\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->x() = x; // _polylineVec[ i ].elements()[ j ].x() = x;\r\n\t\t\t\t\t//\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->y() = _polylineVec[ i ].elements()[ j ].y() = rectT.leftBottom().y();\r\n\t\t\t\t\t//\t\t\t\t\t\t}\r\n\t\t\t\t\t//\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t// adjust points at corner\r\n\t\t\t\tif( _conjunctionIDMat[ i ][ j ].conjunctionType == CONJUNCTION_CORNER ) {\r\n\r\n\t\t\t\t\tunsigned int level = _conjunctionIDMat[ i ][ j ].level[ 0 ];\r\n\t\t\t\t\tunsigned int member = _conjunctionIDMat[ i ][ j ].member[ 0 ];\r\n\t\t\t\t\tunsigned int polygonMember = _conjunctionIDMat[ i ][ j ].polygonMember[ 0 ];\r\n\t\t\t\t\tunsigned int pointType = _conjunctionIDMat[ i ][ j ].pointType[ 0 ];\r\n\r\n\t\t\t\t\tunsigned int id = sortedLevel[ level ][ member ];\r\n\t\t\t\t\tmap< unsigned int, KeiRo::Base::Rectangle2 > &treemapTargetMap = treemapVec[ id ].treemapTargetMap();\r\n\t\t\t\t\tmap< unsigned int, KeiRo::Base::Rectangle2 >::iterator itT = treemapTargetMap.begin();\r\n\t\t\t\t\tstd::advance( itT, polygonMember );\r\n\t\t\t\t\tKeiRo::Base::Rectangle2 &rect = itT->second;\r\n\r\n\t\t\t\t\tKeiRo::Base::Coord2 c;\r\n\t\t\t\t\tif( pointType == POINT_LEFTBOTTOM ) {\r\n\t\t\t\t\t\tc.x() = rect.leftBottom().x();\r\n\t\t\t\t\t\tc.y() = rect.leftBottom().y();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif( pointType == POINT_RIGHTBOTTOM ) {\r\n\t\t\t\t\t\tc.x() = rect.leftBottom().x() + rect.width();\r\n\t\t\t\t\t\tc.y() = rect.leftBottom().y();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif( pointType == POINT_RIGHTTOP ) {\r\n\t\t\t\t\t\tc.x() = rect.leftBottom().x() + rect.width();\r\n\t\t\t\t\t\tc.y() = rect.leftBottom().y() + rect.height();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif( pointType == POINT_LEFTTOP ) {\r\n\t\t\t\t\t\tc.x() = rect.leftBottom().x();\r\n\t\t\t\t\t\tc.y() = rect.leftBottom().y() + rect.height();\r\n\t\t\t\t\t}\r\n\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ] = new KeiRo::Base::Coord2;\r\n\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->x() = _polylineVec[ i ].elements()[ j ].x() = c.x();\r\n\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->y() = _polylineVec[ i ].elements()[ j ].y() = c.y();\r\n\t\t\t\t\t//\t\t\t\t\tif( j == 4 ){\r\n\t\t\t\t\t//\t\t\t\t\t\tcerr << \"i = \" << i << \" j = \" << j << endl;\r\n\t\t\t\t\t//\t\t\t\t\t\tcerr << \" level = \" << level << endl;\r\n\t\t\t\t\t//\t\t\t\t\t\tcerr << \" member = \" << member << endl;\r\n\t\t\t\t\t//\t\t\t\t\t\tcerr << \" polygonMember = \" << polygonMember << endl;\r\n\t\t\t\t\t//\t\t\t\t\t\tcerr << \" pointType = \" << pointType << endl;\r\n\t\t\t\t\t//\t\t\t\t\t\tcerr << \" c = \" << c << endl;\r\n\t\t\t\t\t//\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t//\r\n\t//  HierarchicalPath::_addIntermediatePoints --\tadd intermediate points at the corners\r\n\t//\r\n\t//  Inputs\r\n\t//\tstring filePath\r\n\t//\r\n\t//  Outputs\r\n\t//\tbool\r\n\t//\r\n\tvoid HierarchicalPath::_addIntermediatePoints( void )\r\n\t{\r\n\t\tvector< vector< unsigned int > > &sortedLevel = _hierarchicalTreemapPtr->sortedLevel();\r\n\t\tunsigned int maxLevel = sortedLevel.size();\r\n\t\tvector< FileIO::SVG * > &svgPtrVec = _metadataPtr->svgPtrVec();\r\n\t\tGraph::TreeDirectedGraph &svgTree = _metadataPtr->svgTree();\r\n\t\tvector< Treemap > &treemapVec = _hierarchicalTreemapPtr->treemapVec();\r\n\r\n\t\t/*\r\n\t\t\t\t// adjust close-by vertices\r\n\t\t\t\tfor( unsigned int i = 0; i < _polylineVec.size(); i++ ) {\r\n\t\t\t\t\tKeiRo::Base::Line2 &line = _polylineVec[ i ];\r\n\t\t\t\t\tfor( unsigned int j = 1; j < line.elements().size()-1; j++ ) {\r\n\r\n\t\t\t\t\t\tKeiRo::Base::Coord2 &c = line.elements()[j];\r\n\t\t\t\t\t\tdouble minDist = INFINITY;\r\n\t\t\t\t\t\tKeiRo::Base::Coord2 closestC( 0.0, 0.0 );\r\n\r\n\t\t\t\t\t\tif( _coveredRegion.isInside( c ) == false ){\r\n\t\t//\t\t\t\t\tif( _coveredRegion.isInside( line.elements()[j-1] ) == true ||\r\n\t\t//\t\t\t\t\t\t_coveredRegion.isInside( line.elements()[j+1] ) == true ){\r\n\t\t//\t\t\t\t\t\tclosestC = c;\r\n\t\t//\t\t\t\t\t}\r\n\t\t//\t\t\t\t\telse{\r\n\t\t\t\t\t\t\t\tfor( unsigned int k = 0; k < _outerCoordVec.size(); k++ ){\r\n\t\t\t\t\t\t\t\t\tdouble dist = ( _outerCoordVec[k]-c ).norm();\r\n\t\t\t\t\t\t\t\t\tif( minDist > dist ){\r\n\t\t//\t\t\t\t\t\t\tcerr << \"dist = \" << dist << endl;\r\n\t\t\t\t\t\t\t\t\t\tminDist = dist;\r\n\t\t\t\t\t\t\t\t\t\tclosestC = _outerCoordVec[k];\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif( minDist < INFINITY ) {\r\n\t\t\t\t\t\t\t\t\tc = closestC;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t//\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse{\r\n\t\t\t\t\t\t\tfor( unsigned int k = 0; k < _borderCoordVec.size(); k++ ){\r\n\t\t\t\t\t\t\t\tdouble dist = ( _borderCoordVec[k]-c ).norm();\r\n\t\t\t\t\t\t\t\tif( dist < 10 ){\r\n\t\t\t\t\t\t\t\t\tif( minDist > dist ){\r\n\t\t//\t\t\t\t\t\t\tcerr << \"dist = \" << dist << endl;\r\n\t\t\t\t\t\t\t\t\t\tminDist = dist;\r\n\t\t\t\t\t\t\t\t\t\tclosestC = _borderCoordVec[k];\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif( minDist < INFINITY ) {\r\n\t\t\t\t\t\t\t\tc = closestC;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor( unsigned int i = 0; i < _polylineVec.size(); i++ ) {\r\n\t\t\t\t\tfor( unsigned int j = 0; j < _polylineVec[ i ].elements().size(); j++ ) {\r\n\t\t\t\t\t\tcerr << \"B: \" << j << \", \" << _polylineVec[ i ].elements()[j];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t*/\r\n\r\n\t\t// add corner points as intermediate points\r\n\t\tfor( unsigned int i = 0; i < _polylineVec.size(); i++ ) {\r\n\r\n\t\t\tKeiRo::Base::Line2 line = _polylineVec[ i ];\r\n\t\t\tline.elements().clear();\r\n\t\t\tline.elements().push_back( _polylineVec[i].elements()[0] );\r\n\t\t\tfor( unsigned int j = 1; j < _polylineVec[ i ].elements().size(); j++ ) {\r\n\r\n\t\t\t\tif( _polylineVec[i].elements()[j-1] == _polylineVec[i].elements()[j] ){\r\n\t\t\t\t\tj++;\r\n\t\t\t\t}\r\n\t\t\t\tKeiRo::Base::Coord2 &prev = _polylineVec[i].elements()[j-1];\r\n\t\t\t\tKeiRo::Base::Coord2 &curr = _polylineVec[i].elements()[j];\r\n\t\t\t\tKeiRo::Base::Coord2 diff = curr - prev;\r\n\t\t\t\t//\t\t\t\tif ( j == 2 ){\r\n\t\t\t\t//\t\t\t\t\tcerr << \"prev = \" << prev;\r\n\t\t\t\t//\t\t\t\t\tcerr << \"curr = \" << curr;\r\n\t\t\t\t//\t\t\t\t}\r\n\t\t\t\tmap< double, KeiRo::Base::Coord2 > coordMap;\r\n\t\t\t\t//\t\t\t\tcerr << \"_borderCoordVec.size() = \" << _borderCoordVec.size() << endl;\r\n\r\n#ifdef DEBUG\r\n\t\t\t\tif ( j == 5 ){\r\n\t\t\t\t\tcerr << \"HERE\" << endl;\r\n\t\t\t\t\tcerr << \"prev = \" << prev;\r\n\t\t\t\t\tcerr << \"curr = \" << curr;\r\n\t\t\t\t}\r\n#endif // DEBUG\r\n\t\t\t\tfor( unsigned int k = 0; k < _borderCoordVec.size(); k++ ){\r\n\r\n\r\n\t\t\t\t\tif( fabs( diff.x() ) > 0.0 && fabs( diff.y() ) < 3.5 ){\r\n#ifdef DEBUG\r\n\t\t\t\t\t\tif ( j == 5 ){\r\n\t\t\t\t\t\t\tcerr << \"HERE\" << endl;\r\n\t\t\t\t\t\t\tcerr << \"coordVec[k] = \" << _borderCoordVec[k];\r\n\t\t\t\t\t\t\tcerr << \"prev = \" << prev;\r\n\t\t\t\t\t\t\tcerr << \"curr = \" << curr;\r\n\t\t\t\t\t\t\tcerr << \" fabs((coordVec[k]- prev).y()) = \" <<  fabs((_borderCoordVec[k]- prev).y()) << endl;\r\n\t\t\t\t\t\t}\r\n#endif // DEBUG\r\n\t\t\t\t\t\tif( ( _borderCoordVec[k].x() > MIN2(prev.x(), curr.x() ) ) &&\r\n\t\t\t\t\t\t\t( _borderCoordVec[k].x() < MAX2(prev.x(), curr.x() ) ) &&\r\n\t\t\t\t\t\t\t( fabs( (_borderCoordVec[k] - prev).x() ) > 1.0 ) &&\r\n\t\t\t\t\t\t\t( fabs( (_borderCoordVec[k] - curr).x() ) > 1.0 ) &&\r\n\t\t\t\t\t\t\t( fabs( (_borderCoordVec[k] - prev).y()) < 3.5 ) ){\r\n\t\t\t\t\t\t\tcoordMap.insert( pair< double, KeiRo::Base::Coord2  >( fabs( (_borderCoordVec[k] - prev).x() ), _borderCoordVec[k] ) );\r\n#ifdef DEBUG\r\n\t\t\t\t\t\t\tif ( j == 5 ){\r\n\t\t\t\t\t\t\t\tcerr << \"coordVec[k] = \" << coordVec[k];\r\n\t\t\t\t\t\t\t\tcerr << \"prev = \" << prev;\r\n\t\t\t\t\t\t\t\tcerr << \"curr = \" << curr;\r\n\t\t\t\t\t\t\t\tcerr << \" fabs((coordVec[k]- prev).y()) = \" <<  fabs((coordVec[k]- prev).y()) << endl;\r\n\t\t\t\t\t\t\t}\r\n#endif // DEBUG\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// vertical line\r\n\t\t\t\t\telse if( fabs( diff.y() ) > 0.0 && fabs( diff.x() ) < 3.5 ){\r\n\r\n\t\t\t\t\t\t//\t\t\t\t\t\tif ( j == 2 ){\r\n\t\t\t\t\t\t//\t\t\t\t\t\t\tcerr << \"k = \" << k << endl;\r\n\t\t\t\t\t\t//\t\t\t\t\t\t\tcerr << \"coordVec[k] = \" << _borderCoordVec[k];\r\n\t\t\t\t\t\t//\t\t\t\t\t\t\tcerr << \"prev = \" << prev;\r\n\t\t\t\t\t\t//\t\t\t\t\t\t\tcerr << \"curr = \" << curr;\r\n\t\t\t\t\t\t//\t\t\t\t\t\t\tcerr << \" fabs((coordVec[k]- prev).x()) = \" <<  fabs((_borderCoordVec[k]- prev).x()) << endl;\r\n\t\t\t\t\t\t//\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif( ( _borderCoordVec[k].y() > MIN2(prev.y(), curr.y() ) ) &&\r\n\t\t\t\t\t\t\t( _borderCoordVec[k].y() < MAX2(prev.y(), curr.y() ) ) &&\r\n\t\t\t\t\t\t\t( fabs( (_borderCoordVec[k] - prev).y() ) > 1.0 ) &&\r\n\t\t\t\t\t\t\t( fabs( (_borderCoordVec[k] - curr).y() ) > 1.0 ) &&\r\n\t\t\t\t\t\t\t( fabs( (_borderCoordVec[k] - prev).x()) < 3.5 ) ){\r\n\t\t\t\t\t\t\tcoordMap.insert( pair< double, KeiRo::Base::Coord2  >( fabs( (_borderCoordVec[k] - prev).y() ), _borderCoordVec[k] ) );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfor( map< double, KeiRo::Base::Coord2 >::iterator it = coordMap.begin();\r\n\t\t\t\t\t it != coordMap.end(); it++ ){\r\n\t\t\t\t\tif( ( line.elements()[ line.elements().size()-1 ] != it->second ) || ( _coveredRegion.isInside( curr ) == false ) )\r\n\t\t\t\t\t\tline.elements().push_back( it->second );\r\n\t\t\t\t\t//\t\t\t\t\tcerr << \"i = \" << line.elements().size() - 1 << \" \" << it->second;\r\n\t\t\t\t\t }\r\n\t\t\t\tif( ( line.elements()[ line.elements().size()-1 ] != curr ) || ( _coveredRegion.isInside( curr ) == false ) )\r\n\t\t\t\t\tline.elements().push_back( curr );\r\n\t\t\t\t//\t\t\t\tcerr << \"i = \" << line.elements().size() - 1 << \" \" << curr;\r\n\t\t\t\t//\t\t\t\tline.elements().push_back( _polylineVec[i].elements()[j] );\r\n\t\t\t}\r\n\t\t\tline.fixedElements() = line.oldElements() = line.elements();\r\n\t\t\t_polylineVec[ i ] = line;\r\n\t\t\t_polylineVec[i].initElementPointers();\r\n\t\t}\r\n\t}\r\n\r\n\t//\r\n\t//  HierarchicalPath::readSVGGlobal --\tread global svg file\r\n\t//\r\n\t//  Inputs\r\n\t//\tstring filePath\r\n\t//\r\n\t//  Outputs\r\n\t//\tbool\r\n\t//\r\n\tbool HierarchicalPath::readSVGGlobal( const QString fileName )\r\n\t{\r\n\t\t//\t\tif ( fileName.isEmpty() ){\r\n\t\t//\t\t\tcerr << \"something is wrong here... at \" << __LINE__ << \" in \" << __FILE__ << endl;\r\n\t\t//\t\t\treturn false;\r\n\t\t//\t\t}\r\n\t\t//\t\tcerr << \"globalpath fileName = \" << fileName.toStdString() << endl;\r\n\t\t//\r\n\t\t//\t\t_svgCanvas = getCanvasSize( fileName );\r\n\t\t//\t\tgetPathElements( fileName );\r\n\t\t//\r\n\t\t//\t\tfor( unsigned int i = 0; i < _polylineVec.size(); i++ ){\r\n\t\t//\t\t\t_polylineVec[i].initElementPointers();\r\n\t\t//\t\t}\r\n\r\n#ifdef DEBUG\r\n\t\tfor( unsigned int i = 0; i < _polylineVec.size(); i++ ){\r\n\t\t\tKeiRo::Base::Line2 &path = _polylineVec[ i ];\r\n\t\t\tcerr << \"path.elements() = \" << path.elements().size() << endl;\r\n\t\t\tcerr << \"path.oldElements() = \" << path.oldElements().size() << endl;\r\n\t\t}\r\n\t\tfor( unsigned int i = 0; i < _polylineVec.size(); i++ ){\r\n\t\t\tKeiRo::Base::Line2 &line = _polylineVec[i];\r\n\t\t\tcerr << \"i = \" << line;\r\n\t\t}\r\n#endif // DEBUG\r\n\t\treturn true;\r\n\t}\r\n\r\n\t//\r\n\t//  HierarchicalPath::buildTreemapRelationship --\tbuild paths and treemap relationship\r\n\t//\r\n\t//  Inputs\r\n\t//\tstring filePath\r\n\t//\r\n\t//  Outputs\r\n\t//\tbool\r\n\t//\r\n\r\n\tvoid HierarchicalPath::buildTreemapRelationship( void )\r\n\t{//not used in the current code\r\n\t\tvector< vector< unsigned int > > &sortedLevel = _hierarchicalTreemapPtr->sortedLevel();\r\n\t\tunsigned int maxLevel = _hierarchicalTreemapPtr->metadataPtr()->maxLevel();\r\n\t\tGraph::TreeDirectedGraph &graphmlTree    = _hierarchicalTreemapPtr->metadataPtr()->graphmlTree();\r\n\t\tvector< Treemap > &treemapVec = _hierarchicalTreemapPtr->treemapVec();\r\n\t\tmultimap< KeiRo::Base::Common::UIDPair,\r\n\t\t\t\tKeiRo::Base::Common::UIDPair >  &globalPathMap = _hierarchicalTreemapPtr->metadataPtr()->graphmlGlobalPath();\r\n\r\n\t\t//\t\tvector< FileIO::SVG * > &svgPtrVec = _metadataPtr->svgPtrVec();\r\n\t\t//\t\tGraph::TreeDirectedGraph &svgTree = _metadataPtr->svgTree();\r\n\r\n\t\t// find the largest scene area\r\n\t\tdouble minX = INFINITY, maxX = -INFINITY, minY = INFINITY, maxY = -INFINITY;\r\n\t\tfor( unsigned int i = 0; i < sortedLevel[0].size(); i++ ){\r\n\t\t\tunsigned int id = sortedLevel[0][i];\r\n\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd = vertex( id, graphmlTree );\r\n\t\t\tKeiRo::Base::Rectangle2 &bbox = *graphmlTree[vd].boundingBoxPtr;\r\n\t\t\tif( bbox.leftBottom().x() < minX ) minX = bbox.leftBottom().x();\r\n\t\t\tif( bbox.leftBottom().x() + bbox.width() > maxX ) maxX = bbox.leftBottom().x() + bbox.width();\r\n\t\t\tif( bbox.leftBottom().y() < minY ) minY = bbox.leftBottom().y();\r\n\t\t\tif( bbox.leftBottom().y() + bbox.height() > maxY ) maxY = bbox.leftBottom().y() + bbox.height();\r\n\r\n\t\t\t//\t\t\tFileIO::SVG *svgPtr = svgPtrVec[ id ];\r\n\t\t\t//\t\t\tvector<  KeiRo::Base::Polygon2 > &polygonVec = svgPtr->polygonVec();\r\n\t\t\t//\t\t\tfor( unsigned int j = 0; j < polygonVec.size(); j++ ){\r\n\t\t\t//\t\t\t\tKeiRo::Base::Polygon2 p;\r\n\t\t\t//\t\t\t\tp.elements() = polygonVec[j].fixedElements();\r\n\t\t\t//\t\t\t\tfor( unsigned int k = 0; k < p.elements().size(); k++ ){\r\n\t\t\t//\t\t\t\t\tif( p.elements()[k].x() < minX ) minX = p.elements()[k].x();\r\n\t\t\t//\t\t\t\t\tif( p.elements()[k].x() > maxX ) maxX = p.elements()[k].x();\r\n\t\t\t//\t\t\t\t\tif( p.elements()[k].y() < minY ) minY = p.elements()[k].y();\r\n\t\t\t//\t\t\t\t\tif( p.elements()[k].y() > maxY ) maxY = p.elements()[k].y();\r\n\t\t\t//\t\t\t\t}\r\n\t\t\t//\t\t\t}\r\n\t\t}\r\n\t\t_coveredRegion.leftBottom() = KeiRo::Base::Coord2( minX, minY );\r\n\t\t_coveredRegion.width() = maxX - minX;\r\n\t\t_coveredRegion.height() = maxY - minY;\r\n\t\tcerr << \"_coveredRegion = \" << _coveredRegion;\r\n\r\n\t\t_borderCoordVec.clear();\r\n\t\tdouble min_point_distance = 1.5;\r\n\t\t// collect corner points\r\n\t\tfor( unsigned int i = 0; i < sortedLevel[ maxLevel-2 ].size(); i++ ){\r\n\t\t\tunsigned int id = sortedLevel[ maxLevel-2 ][ i ];\r\n\r\n\t\t\t//\t\t\tFileIO::SVG *svgPtr = svgPtrVec[ id ];\r\n\t\t\t//\t\t\tvector<  KeiRo::Base::Polygon2 > &polygonVec = svgPtr->polygonVec();\r\n\t\t\tmap< unsigned int, KeiRo::Base::Rectangle2 > &treemapTargetMap = treemapVec[id].treemapTargetMap();\r\n\t\t\t//\t\t\tcerr << \"polygonVec.size() = \" << polygonVec.size() << endl;\r\n\t\t\tfor( unsigned int j = 0; j < treemapTargetMap.size(); j++ ) {\r\n\t\t\t\tmap< unsigned int, KeiRo::Base::Rectangle2 >::iterator itT = treemapTargetMap.begin();\r\n\t\t\t\tstd::advance( itT, j );\r\n\t\t\t\tKeiRo::Base::Coord2 corners[4];\r\n\t\t\t\tcorners[0] = itT->second.leftBottom();\r\n\t\t\t\tcorners[1] = itT->second.leftBottom() + KeiRo::Base::Coord2( itT->second.width(), 0.0 );\r\n\t\t\t\tcorners[2] = itT->second.leftBottom() + KeiRo::Base::Coord2( itT->second.width(), itT->second.height() );\r\n\t\t\t\tcorners[3] = itT->second.leftBottom() + KeiRo::Base::Coord2( 0.0, itT->second.height() );\r\n\r\n\t\t\t\tfor( unsigned int m = 0; m < 4; m++ ){\r\n\t\t\t\t\tbool isExisted = false;\r\n#ifdef DEBUG\r\n\t\t\t\t\tif( i == 0 && j == 0 ){\r\n\t\t\t\t\t\tcerr << \"m = \" << m << \",\" << corners[m];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif( i == 3 && j == 1 ){\r\n\t\t\t\t\t\tcerr << \"m = \" << m << \",\" << corners[m];\r\n\t\t\t\t\t}\r\n#endif // DEBUG\r\n\t\t\t\t\tfor( unsigned int n = 0; n < _borderCoordVec.size(); n++ ){\r\n\t\t\t\t\t\tif( ( corners[m]-_borderCoordVec[n] ).norm() < min_point_distance ){\r\n\t\t\t\t\t\t\tisExisted = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif( isExisted == false ){\r\n\t\t\t\t\t\t_borderCoordVec.push_back( corners[m] );\r\n\t\t\t\t\t\tif( _coveredRegion.isInside( corners[m] ) == false ){\r\n\t\t\t\t\t\t\t_outerCoordVec.push_back( corners[m] );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n#ifdef DEBUG\r\n\t\t// initialization\r\n\t\tfor( unsigned int i = 0; i < _polylineVec.size(); i++ ) {\r\n\t\t\tfor( unsigned int j = 0; j < _polylineVec[ i ].elements().size(); j++ ) {\r\n\t\t\t\tcerr << \"A: \" << j << \", \" << _polylineVec[ i ].elements()[j];\r\n\t\t\t\tcerr << \"  p\" << j << \", \" << *_polylineVec[ i ].elementPointers()[j];\r\n\t\t\t\tcerr << \"  f\" << j << \", \" << _polylineVec[ i ].fixedElements()[j];\r\n\t\t\t\t//\t\t\t\tcerr << \" type = \" << _conjunctionIDMat[i][j].conjunctionType << endl;\r\n\t\t\t}\r\n\t\t}\r\n#endif // DEBUG\r\n\r\n\t\t_endpointTreemapID.resize( _polylineVec.size() );\r\n\t\t_repositionPoints();\r\n#ifdef DEBUG\r\n\t\tcerr << \"############\" << endl;\r\n\t\tfor( unsigned int m = 0; m < _conjunctionIDMat.size(); m++ ){\r\n\t\t\tfor( unsigned int n = 0; n < _conjunctionIDMat[m].size(); n++ ) {\r\n\t\t\t\tif( _conjunctionIDMat[m][n].level.size() > 0 ){\r\n\t\t\t\t\tcerr << \"1st n = \" << n << endl;\r\n\t\t\t\t\tcerr << \"conType = \" << _conjunctionIDMat[m][n].conjunctionType << endl;\r\n\t\t\t\t\tif( _conjunctionIDMat[m][n].conjunctionType == CONJUNCTION_CORNER ){\r\n\t\t\t\t\t\t//\t\t\t\t\t\tcerr << \"m = \" << m << \", j = \" << n << endl;\r\n\t\t\t\t\t\tfor( unsigned int k = 0; k < _conjunctionIDMat[m][n].level.size(); k++ ){\r\n\t\t\t\t\t\t\t//\t\t\t\t\t\t\tcerr << \" level = \" << _conjunctionIDMat[m][n].level[k] << endl\r\n\t\t\t\t\t\t\t//\t\t\t\t\t\t\t     << \" member = \" << _conjunctionIDMat[m][n].member[k] << endl\r\n\t\t\t\t\t\t\t//\t\t\t\t\t\t\t     << \" polymember = \" << _conjunctionIDMat[m][n].polygonMember[k] << endl\r\n\t\t\t\t\t\t\t//\t\t\t\t\t\t\t     << \" type = \" << _conjunctionIDMat[m][n].pointType[k] << endl;\r\n\t\t\t\t\t\t\t//\t\t\t\t\t\t\tcerr << \" type = \" << _conjunctionIDMat[m][n].pointType[k] << endl;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t//\t\t\t\t\t\tcerr << endl;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n#endif // DEBUG\r\n#ifdef DEBUG\r\n\t\tfor( unsigned int i = 0; i < _polylineVec.size(); i++ ) {\r\n\t\t\tfor( unsigned int j = 0; j < _polylineVec[ i ].elements().size(); j++ ) {\r\n\t\t\t\tcerr << \"B: \" << j << \", \" << _polylineVec[ i ].elements()[j];\r\n\t\t\t\tcerr << \"  p\" << j << \", \" << *_polylineVec[ i ].elementPointers()[j];\r\n\t\t\t\tcerr << \"  f\" << j << \", \" << _polylineVec[ i ].fixedElements()[j];\r\n\t\t\t\tcerr << \" type = \" << _conjunctionIDMat[i][j].conjunctionType << endl;\r\n\t\t\t}\r\n\t\t}\r\n#endif // DEBUG\r\n\r\n\t\t_addIntermediatePoints();\r\n\r\n#ifdef DEBUG\r\n\t\tfor( unsigned int i = 0; i < _polylineVec.size(); i++ ) {\r\n\t\t\tfor( unsigned int j = 0; j < _polylineVec[ i ].elements().size(); j++ ) {\r\n\t\t\t\tcerr << \"C: \" << j << \", \" << _polylineVec[ i ].elements()[j];\r\n\t\t\t\tcerr << \"  p\" << j << \", \" << *_polylineVec[ i ].elementPointers()[j];\r\n\t\t\t\tcerr << \"  f\" << j << \", \" << _polylineVec[ i ].fixedElements()[j];\r\n\t\t\t}\r\n\t\t}\r\n#endif // DEBUG\r\n\r\n\t\t// find the corner points with 4 adjacent cell neighbors\r\n\t\tvector< KeiRo::Base::Coord2 > coordVec;\r\n\t\tvector< unsigned int > neighborCellNumberVec;\r\n\t\tvector< unsigned int > fourNeighborID;\r\n\r\n\t\tfor( unsigned int i = 0; i < sortedLevel[ maxLevel-2 ].size(); i++ ){\r\n\t\t\tunsigned int id = sortedLevel[ maxLevel-2 ][ i ];\r\n\t\t\tmap< unsigned int, KeiRo::Base::Rectangle2 > &treemapTargetMap = treemapVec[id].treemapTargetMap();\r\n\t\t\tfor( unsigned int j = 0; j < treemapTargetMap.size(); j++ ){\r\n\t\t\t\tmap< unsigned int, KeiRo::Base::Rectangle2 >::iterator itT = treemapTargetMap.begin();\r\n\t\t\t\tstd::advance( itT, j );\r\n\t\t\t\tKeiRo::Base::Rectangle2 &rect = itT->second;\r\n\t\t\t\tvector< KeiRo::Base::Coord2 > corners;\r\n\t\t\t\tcorners.resize(4 );\r\n\t\t\t\tcorners[0] = rect.leftBottom();\r\n\t\t\t\tcorners[1] = rect.leftBottom() + KeiRo::Base::Coord2( rect.width(), 0 );\r\n\t\t\t\tcorners[2] = rect.leftBottom() + KeiRo::Base::Coord2( rect.width(), rect.height() );\r\n\t\t\t\tcorners[3] = rect.leftBottom() + KeiRo::Base::Coord2( 0, rect.height() );\r\n\r\n\t\t\t\tfor( unsigned int m = 0; m < corners.size(); m++ ){\r\n\t\t\t\t\tbool isExisted = false;\r\n\t\t\t\t\tunsigned int index = 0;\r\n\t\t\t\t\tfor( unsigned int n = 0; n < coordVec.size(); n++ ){\r\n\r\n\t\t\t\t\t\tif( distanceBetween( corners[m], coordVec[n] ) < min_point_distance ){\r\n\t\t\t\t\t\t\tisExisted = true;\r\n\t\t\t\t\t\t\tindex = n;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif( isExisted == false ){\r\n\t\t\t\t\t\tcoordVec.push_back( corners[m] );\r\n\t\t\t\t\t\tneighborCellNumberVec.push_back( 1 );\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse{\r\n\t\t\t\t\t\tneighborCellNumberVec[ index ]++;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor( unsigned int i = 0; i < neighborCellNumberVec.size(); i++ ){\r\n\t\t\tif( neighborCellNumberVec[i] == 4 ) {\r\n\t\t\t\tfourNeighborID.push_back(i);\r\n\t\t\t}\r\n\t\t}\r\n\r\n#ifdef DEBUG\r\n\t\tfor( unsigned int i = 0; i < coordVec.size(); i++ ){\r\n\t\t\tcerr << \"neighborCellNumberVec[i] = \" << neighborCellNumberVec[i] << \", \" << coordVec[i];\r\n\t\t}\r\n\t\tcerr << \"\" << endl;\r\n\t\tfor( unsigned int k = 0; k < fourNeighborID.size(); k++ ){\r\n\t\t\tcerr << \"fourNeighborID = \" << fourNeighborID[k] << endl;\r\n\t\t}\r\n\r\n#endif // DEBUG\r\n\r\n\r\n\t\t// split an intermediate point with four cell neighbors into 2 points\r\n\t\tfor( unsigned int i = 0; i < _polylineVec.size(); i++ ) {\r\n\r\n\t\t\tvector< KeiRo::Base::Coord2 > elements;\r\n\t\t\t//\t\t\tcerr << \"A::_polylineVec[i].elements().size() = \" << _polylineVec[i].elements().size() << endl;\r\n\t\t\tfor( unsigned int j = 0; j < _polylineVec[i].elements().size(); j++ ){\r\n\r\n\t\t\t\t//\t\t\t\tcerr << \"j = \" << j << endl;\r\n\t\t\t\tKeiRo::Base::Coord2 &c = _polylineVec[ i ].elements()[j];\r\n\t\t\t\telements.push_back( c );\r\n\t\t\t\t//\t\t\t\tcerr << \"fourNeighborID.size() = \" << fourNeighborID.size() << endl;\r\n\t\t\t\t//\t\t\t\tdouble minDist = INFINITY;\r\n\t\t\t\tfor( unsigned int k = 0; k < fourNeighborID.size(); k++ ){\r\n\t\t\t\t\tKeiRo::Base::Coord2 newC;\r\n\t\t\t\t\tdouble distance = distanceBetween( c, coordVec[ fourNeighborID[k] ] );\r\n\t\t\t\t\t//\t\t\t\t\tif( j == 4 ){\r\n\t\t\t\t\t//\t\t\t\t\t\tcerr << \"k = \" << k << endl;\r\n\t\t\t\t\t//\t\t\t\t\t\tcerr << \"c = \" << c << endl;\r\n\t\t\t\t\t////\t\t\t\t\t\tcerr << \"coordVec[ fourNeighborID[k] ] = \" << coordVec[ fourNeighborID[k] ];\r\n\t\t\t\t\t//\t\t\t\t\t\tcerr << \" distance = \" << distance << endl;\r\n\t\t\t\t\t//\t\t\t\t\t}\r\n\t\t\t\t\tif( distance < 2.0 ) {\r\n\t\t\t\t\t\tnewC.x() = c.x();\r\n\t\t\t\t\t\tnewC.y() = c.y();\r\n\t\t\t\t\t\telements.push_back( newC );\r\n\t\t\t\t\t\t//\t\t\t\t\t\tminDist = distance;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t_polylineVec[i].fixedElements() = _polylineVec[i].oldElements() = _polylineVec[i].elements() = elements;\r\n\t\t\t_polylineVec[i].initElementPointers();\r\n\t\t}\r\n\r\n\t\t_repositionPoints();\r\n\r\n#ifdef DEBUG\r\n\t\tfor( unsigned int m = 0; m < _conjunctionIDMat.size(); m++ ){\r\n\t\t\tfor( unsigned int n = 0; n < _conjunctionIDMat[m].size(); n++ ) {\r\n\t\t\t\tif( _conjunctionIDMat[m][n].level.size() > 0 ){\r\n\t\t\t\t\tcerr << \"n = \" << n << endl;\r\n\t\t\t\t\tcerr << \"conType = \" << _conjunctionIDMat[m][n].conjunctionType << endl;\r\n\t\t\t\t\tif( _conjunctionIDMat[m][n].conjunctionType == CONJUNCTION_CORNER ){\r\n\t\t\t\t\t\t//\t\t\t\t\t\tcerr << \"m = \" << m << \", j = \" << n << endl;\r\n\t\t\t\t\t\tfor( unsigned int k = 0; k < _conjunctionIDMat[m][n].level.size(); k++ ){\r\n\t\t\t\t\t\t\t//\t\t\t\t\t\t\tcerr << \" level = \" << _conjunctionIDMat[m][n].level[k] << endl\r\n\t\t\t\t\t\t\t//\t\t\t\t\t\t\t     << \" member = \" << _conjunctionIDMat[m][n].member[k] << endl\r\n\t\t\t\t\t\t\t//\t\t\t\t\t\t\t     << \" polymember = \" << _conjunctionIDMat[m][n].polygonMember[k] << endl\r\n\t\t\t\t\t\t\t//\t\t\t\t\t\t\t     << \" type = \" << _conjunctionIDMat[m][n].pointType[k] << endl;\r\n\t\t\t\t\t\t\tcerr << \" type = \" << _conjunctionIDMat[m][n].pointType[k] << endl;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t//\t\t\t\t\t\tcerr << endl;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n#endif // DEBUG\r\n\r\n#ifdef DEGBUG\r\n\t\tfor( unsigned int i = 0; i < _polylineVec.size(); i++ ) {\r\n\t\t\tfor( unsigned int j = 0; j < _polylineVec[ i ].elements().size(); j++ ) {\r\n\t\t\t\tcerr << \"D: \" << j << \", \" << _polylineVec[ i ].elements()[j];\r\n\t\t\t\tcerr << \"  p\" << j << \", \" << *_polylineVec[ i ].elementPointers()[j];\r\n\t\t\t\tcerr << \"  f\" << j << \", \" << _polylineVec[ i ].fixedElements()[j];\r\n\t\t\t\tcerr << \" type = \" << _conjunctionIDMat[i][j].conjunctionType << endl;\r\n\t\t\t}\r\n\t\t}\r\n#endif // DEBUG\r\n\r\n\t\t// revisit wrong vertices\r\n\t\tfor( unsigned int i = 0; i < _conjunctionIDMat.size(); i++ ){\r\n\t\t\t//\t\t\tcerr << \"_conjunctionIDMat[i].size() = \" << _conjunctionIDMat[i].size() << endl;\r\n\t\t\t//\t\t\tcerr << \"_polylineVec[i].elementPointers().size() = \" << _polylineVec[i].elementPointers().size() << endl;\r\n\r\n\t\t\tfor( unsigned int j = 2; j < _conjunctionIDMat[i].size()-1; j++ ) {\r\n\r\n\t\t\t\tif( ( _conjunctionIDMat[i][j-1].conjunctionType == CONJUNCTION_CORNER ) &&\r\n\t\t\t\t( _conjunctionIDMat[i][j].conjunctionType == CONJUNCTION_CORNER ) ) {\r\n\t\t\t\t\tKeiRo::Base::Coord2 &preprev = *_polylineVec[i].elementPointers()[j-2];\r\n\t\t\t\t\tKeiRo::Base::Coord2 &prev = *_polylineVec[i].elementPointers()[j-1];\r\n\t\t\t\t\tKeiRo::Base::Coord2 &curr = *_polylineVec[i].elementPointers()[j];\r\n\t\t\t\t\tKeiRo::Base::Coord2 &post = *_polylineVec[i].elementPointers()[j+1];\r\n\r\n\t\t\t\t\tKeiRo::Base::Coord2 diffPrevA = preprev - prev;\r\n\t\t\t\t\tKeiRo::Base::Coord2 diffPrevB = curr - prev;\r\n\t\t\t\t\tKeiRo::Base::Coord2 diffCurrA = prev - curr;\r\n\t\t\t\t\tKeiRo::Base::Coord2 diffCurrB = post - curr;\r\n\r\n\t\t\t\t\t//\t\t\t\t\tcerr << \"j = \" << j << endl;\r\n\t\t\t\t\t//\t\t\t\t\tcerr << \"fabs( diffPrevA.x() ) = \" << fabs( diffPrevA.x() ) << endl;\r\n\t\t\t\t\t//\t\t\t\t\tcerr << \"fabs( diffPrevA.y() ) = \" << fabs( diffPrevA.y() ) << endl;\r\n\t\t\t\t\t//\t\t\t\t\tcerr << \"fabs( diffCurrB.x() ) = \" << fabs( diffCurrB.x() ) << endl;\r\n\t\t\t\t\t//\t\t\t\t\tcerr << \"fabs( diffCurrB.y() ) = \" << fabs( diffCurrB.y() ) << endl;\r\n\r\n\t\t\t\t\tbool isSwap = false;\r\n\r\n\t\t\t\t\t//\t\t\t\t\tif( fabs( diffPrevA.x() ) > _min_point_distance && fabs( diffPrevA.y() ) > _min_point_distance &&\r\n\t\t\t\t\t//\t\t\t\t\t    fabs( diffCurrB.x() ) > _min_point_distance && fabs( diffCurrB.y() ) > _min_point_distance ) {\r\n\t\t\t\t\t//\t\t\t\t\t\tisSwap = true;\r\n\t\t\t\t\t//\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// curr on preprev+prev\r\n\t\t\t\t\t//\t\t\t\t\tcerr << \"j = \" << j << endl;\r\n\t\t\t\t\t//\t\t\t\t\tcerr << \"preprev = \" << preprev;\r\n\t\t\t\t\t//\t\t\t\t\tcerr << \"prev = \" << prev;\r\n\t\t\t\t\t//\t\t\t\t\tcerr << \"curr = \" << curr;\r\n\t\t\t\t\t//\t\t\t\t\tcerr << \"post = \" << post;\r\n\t\t\t\t\tvector< KeiRo::Base::Coord2 > elements;\r\n\t\t\t\t\telements.push_back( preprev );\r\n\t\t\t\t\telements.push_back( prev );\r\n\t\t\t\t\tKeiRo::Base::Edge2 e1( elements );\r\n\t\t\t\t\t//\t\t\t\t\t\tcerr << \"ison = \" <<\r\n\t\t\t\t\tif( e1.isOnEdge( curr ) == true ){\r\n\t\t\t\t\t\tisSwap = true;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// prev on curr+post\r\n\t\t\t\t\telements.clear();\r\n\t\t\t\t\telements.push_back( curr );\r\n\t\t\t\t\telements.push_back( post );\r\n\t\t\t\t\tKeiRo::Base::Edge2 e2( elements );\r\n\t\t\t\t\tif( e2.isOnEdge( prev ) == true ){\r\n\t\t\t\t\t\tisSwap = true;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif( isSwap == true ){\r\n\t\t\t\t\t\tConjunctionIndex tmp = _conjunctionIDMat[i][j];\r\n\t\t\t\t\t\tKeiRo::Base::Coord2 *tmpC = _polylineVec[ i ].elementPointers()[j];\r\n\t\t\t\t\t\t// swap two sample points\r\n\t\t\t\t\t\t_conjunctionIDMat[i][j] = _conjunctionIDMat[i][j-1];\r\n\t\t\t\t\t\t_conjunctionIDMat[i][j-1] = tmp;\r\n\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[j] = _polylineVec[ i ].elementPointers()[j-1];\r\n\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[j-1] = tmpC;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//\t\t\t\tKeiRo::Base::Coord2 *prev = _polylineVec[i].elementPointers()[j-1];\r\n\t\t\t\t//\t\t\t\tKeiRo::Base::Coord2 *curr = _polylineVec[i].elementPointers()[j];\r\n\t\t\t\t//\t\t\t\tKeiRo::Base::Coord2 *post = _polylineVec[i].elementPointers()[j+1];\r\n\t\t\t\t//\r\n\t\t\t\t////\t\t\t\tif( j >= 8 ){\r\n\t\t\t\t////\t\t\t\t\tcerr << \"j = \" << j << endl;\r\n\t\t\t\t////\t\t\t\t\tcerr << \"prev = \" << *prev;\r\n\t\t\t\t////\t\t\t\t\tcerr << \"curr = \" << *curr;\r\n\t\t\t\t////\t\t\t\t\tcerr << \"post = \" << *post;\r\n\t\t\t\t////\t\t\t\t}\r\n\t\t\t\t//\t\t\t\tif( _conjunctionIDMat[i][j].conjunctionType == CONJUNCTION_CORNER ) {\r\n\t\t\t\t//\t\t\t\t\tif( fabs((*curr-*post).x()) > 1.0 &&  fabs((*curr-*post).y()) > 1.0 ) {\r\n\t\t\t\t//\t\t\t\t\t\tif( fabs((*post-*prev).x()) < 1.0 || fabs((*post-*prev).y()) < 1.0 ) {\r\n\t\t\t\t//\t\t\t\t\t\t\tConjunctionIndex tmp = _conjunctionIDMat[i][j];\r\n\t\t\t\t//\t\t\t\t\t\t\tKeiRo::Base::Coord2 *tmpC = _polylineVec[ i ].elementPointers()[j];\r\n\t\t\t\t//\t\t\t\t\t\t\t// swap two sample points\r\n\t\t\t\t//\t\t\t\t\t\t\t_conjunctionIDMat[i][j] = _conjunctionIDMat[i][j-1];\r\n\t\t\t\t//\t\t\t\t\t\t\t_conjunctionIDMat[i][j-1] = tmp;\r\n\t\t\t\t//\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[j] = _polylineVec[ i ].elementPointers()[j-1];\r\n\t\t\t\t//\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[j-1] = tmpC;\r\n\t\t\t\t//\t\t\t\t\t\t}\r\n\t\t\t\t//\t\t\t\t\t}\r\n\t\t\t\t//\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n#ifdef DEBUG\r\n\t\tfor( unsigned int m = 0; m < _conjunctionIDMat.size(); m++ ){\r\n\t\t\tfor( unsigned int n = 0; n < _conjunctionIDMat[m].size(); n++ ) {\r\n\t\t\t\tif( _conjunctionIDMat[m][n].level.size() > 0 ){\r\n\t\t\t\t\tif( _conjunctionIDMat[m][n].conjunctionType == CONJUNCTION_CORNER ){\r\n\t\t\t\t\t\tcerr << \"m = \" << m << \", j = \" << n << endl;\r\n\t\t\t\t\t\tfor( unsigned int k = 0; k < _conjunctionIDMat[m][n].level.size(); k++ ){\r\n\t\t\t\t\t\t\tcerr << \" level = \" << _conjunctionIDMat[m][n].level[k] << endl\r\n\t\t\t\t\t\t\t\t << \" member = \" << _conjunctionIDMat[m][n].member[k] << endl\r\n\t\t\t\t\t\t\t\t << \" polymember = \" << _conjunctionIDMat[m][n].polygonMember[k] << endl\r\n\t\t\t\t\t\t\t\t << \" type = \" << _conjunctionIDMat[m][n].pointType[k] << endl;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcerr << endl;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n#endif // DEBUG\r\n\t}\r\n\r\n\t//\r\n\t//  HierarchicalPath::buildPathGraph --\tbuild path graph\r\n\t//\r\n\t//  Inputs\r\n\t//\tvoid\r\n\t//\r\n\t//  Outputs\r\n\t//\tvoid\r\n\t//\r\n\tvoid HierarchicalPath::buildPathGraph( void )\r\n\t{\r\n        // initialization\r\n        _projectedVertexVec.clear();\r\n        _compressedPathGraph.clear();\r\n\r\n        // variables\r\n\t\tGraph::TreeDirectedGraph &graphmlTree = _metadataPtr->graphmlTree();\r\n\t\tmap< unsigned int, Graph::BaseUndirectedGraph >  &graphmlGraphMap   = _metadataPtr->graphmlGraphMap();\r\n\t\tvector< Lens::Treemap > &treemapVec = _hierarchicalTreemapPtr->treemapVec();\r\n    \tvector< vector< unsigned int > > &sortedLevel = _hierarchicalTreemapPtr->sortedLevel();\r\n    \tGraph::BaseUndirectedGraph &globalPathGraph = _compressedPathGraph.graph();\r\n\t\tmultimap< KeiRo::Base::Common::UIDPair,\r\n\t\t\t\tKeiRo::Base::Common::UIDPair >  &globalPathMap = _metadataPtr->graphmlGlobalPath();\r\n\t\tunsigned int maxLevel = _metadataPtr->maxLevel();\r\n\r\n    \t// build the graph from the second lowest level\r\n    \tunsigned int nID = 0, eID = 0;\r\n    \tvector< unsigned int > prevVDIndexVec;\r\n\r\n\t\t// add vertices that are projected from the detailed graphs to the treemap boundaries\r\n\t\tfor( multimap< KeiRo::Base::Common::UIDPair,\r\n\t\t\t\tKeiRo::Base::Common::UIDPair >::iterator it = globalPathMap.begin();\r\n\t\t\t    it != globalPathMap.end(); it++ ){\r\n\t\t\tKeiRo::Base::Common::UIDPair pairS = it->first;\r\n\t\t\tKeiRo::Base::Common::UIDPair pairT = it->second;\r\n\t\t\tunsigned int idS = pairS.first;\r\n\t\t\tunsigned int idT = pairT.first;\r\n\t\t\tunsigned int idGS = pairS.second;\r\n\t\t\tunsigned int idGT = pairT.second;\r\n\r\n\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdS = vertex( idS, graphmlTree );\r\n\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdT = vertex( idT, graphmlTree );\r\n\t\t\tGraph::BaseUndirectedGraph subGS = graphmlGraphMap.find( idS )->second;\r\n\t\t\tGraph::BaseUndirectedGraph subGT = graphmlGraphMap.find( idT )->second;\r\n\t\t\tGraph::BaseUndirectedGraph::vertex_descriptor vdSS = vertex( idGS, subGS );\r\n\t\t\tGraph::BaseUndirectedGraph::vertex_descriptor vdST = vertex( idGT, subGT );\r\n\r\n\t\t\t// cerr << \"s = \" << *subGS[vdSS].namePtr << \", t = \" << *subGS[vdST].namePtr << endl;\r\n\t\t\tKeiRo::Base::Coord2 &cS = *subGS[vdSS].coordPtr;\r\n\t\t\tKeiRo::Base::Coord2 &cT = *subGS[vdST].coordPtr;\r\n\t\t\tKeiRo::Base::Rectangle2 rectS = *graphmlTree[ vdS ].boundingBoxPtr,\r\n\t\t\t\t\t\t\t\t\trectT = *graphmlTree[ vdT ].boundingBoxPtr;\r\n\t\t\tKeiRo::Base::Coord2 projectedS = rectS.projectedOnBoundary( cS );\r\n\t\t\tKeiRo::Base::Coord2 projectedT = rectT.projectedOnBoundary( cT );\r\n\r\n\t\t\tunsigned int index = 0;\r\n\t\t\t// add source node projection\r\n\t\t\tif( _compressedPathGraph.findVertex( projectedS, graphmlTree[ vdS ].parentID, index ) == false ){\r\n\t\t\t\tindex = _compressedPathGraph.addVertex( projectedS, maxLevel-2, graphmlTree[ vdS ].parentID );\r\n\t\t\t\t_projectedVertexVec.insert( pair< KeiRo::Base::Common::UIDPair, unsigned int >( it->first, index ) );\r\n\t\t\t}\r\n\r\n\t\t\t// add target node projection\r\n\t\t\tif( _compressedPathGraph.findVertex( projectedT, graphmlTree[ vdT ].parentID, index ) == false ){\r\n\t\t\t\tindex = _compressedPathGraph.addVertex( projectedT, maxLevel-2, graphmlTree[ vdT ].parentID );\r\n\t\t\t\t_projectedVertexVec.insert( pair< KeiRo::Base::Common::UIDPair, unsigned int >( it->second, index ) );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// bottom up\r\n    \tfor( int m = maxLevel-2; m >= 0; m-- ) {\r\n    \t\tfor( unsigned int n = 0; n < sortedLevel[m].size(); n++ ) {\r\n\r\n    \t\t\tunsigned int id = sortedLevel[m][n];\r\n    \t\t\t// cerr << \"id = \" << id << \", level = \" << m << \", n = \" << n << endl;\r\n    \t\t\tmap< unsigned int, KeiRo::Base::Rectangle2 > &targetmap = treemapVec[id].treemapTargetMap();\r\n    \t\t\tvector< pair< unsigned int, unsigned int > > vertexPairs;\r\n\r\n    \t\t\t// check if on polygon borders, build bridge edges\r\n\t\t\t\t// valid from the second level\r\n    \t\t\tif( m != maxLevel-2 ) {\r\n\r\n\t\t\t\t    for( map< unsigned int, KeiRo::Base::Rectangle2 >::iterator it = targetmap.begin();\r\n\t\t\t\t         it != targetmap.end(); it++ ) {\r\n\r\n\t\t\t\t\t    KeiRo::Base::Rectangle2 &rectangle = it->second;\r\n\t\t\t\t\t    vector< KeiRo::Base::Coord2 > cornerCoords;\r\n\t\t\t\t\t    for( unsigned int i = 0; i < 4; i++ ) {\r\n\t\t\t\t\t\t    KeiRo::Base::Coord2 coord;\r\n\t\t\t\t\t\t    if( i == 0 ) {\r\n\t\t\t\t\t\t\t    coord.x() = rectangle.leftBottom().x();\r\n\t\t\t\t\t\t\t    coord.y() = rectangle.leftBottom().y();\r\n\t\t\t\t\t\t    }\r\n\t\t\t\t\t\t    else if( i == 1 ) {\r\n\t\t\t\t\t\t\t    coord.x() = rectangle.leftBottom().x() + rectangle.width();\r\n\t\t\t\t\t\t\t    coord.y() = rectangle.leftBottom().y();\r\n\t\t\t\t\t\t    }\r\n\t\t\t\t\t\t    else if( i == 2 ) {\r\n\t\t\t\t\t\t\t    coord.x() = rectangle.leftBottom().x() + rectangle.width();\r\n\t\t\t\t\t\t\t    coord.y() = rectangle.leftBottom().y() + rectangle.height();\r\n\t\t\t\t\t\t    }\r\n\t\t\t\t\t\t    else {\r\n\t\t\t\t\t\t\t    coord.x() = rectangle.leftBottom().x();\r\n\t\t\t\t\t\t\t    coord.y() = rectangle.leftBottom().y() + rectangle.height();\r\n\t\t\t\t\t\t    }\r\n\t\t\t\t\t\t    cornerCoords.push_back( coord );\r\n\t\t\t\t\t    }\r\n\r\n\t\t\t\t\t    for( unsigned int j = 0; j < cornerCoords.size(); j++ ) {\r\n\t\t\t\t\t\t    KeiRo::Base::Coord2 &coordS = cornerCoords[ j ];\r\n\t\t\t\t\t\t    KeiRo::Base::Coord2 &coordT = cornerCoords[ ( j + 1 ) % cornerCoords.size() ];\r\n\t\t\t\t\t\t    vector< KeiRo::Base::Coord2 > st;\r\n\t\t\t\t\t\t    st.push_back( coordS );\r\n\t\t\t\t\t\t    st.push_back( coordT );\r\n\t\t\t\t\t\t    KeiRo::Base::Edge2 e( st );\r\n\r\n\t\t\t\t\t\t    // add vertices\r\n\t\t\t\t\t\t    for( unsigned int k = 0; k < prevVDIndexVec.size(); k++ ) {\r\n\r\n\t\t\t\t\t\t\t    Graph::BaseUndirectedGraph::vertex_descriptor vd = vertex( prevVDIndexVec[ k ],\r\n\t\t\t\t\t\t\t                                                               globalPathGraph );\r\n\t\t\t\t\t\t\t    KeiRo::Base::Coord2 &coord = *globalPathGraph[ vd ].coordPtr;\r\n\r\n\t\t\t\t\t\t\t    if( e.isOnEdge( coord ) == true ) {\r\n\r\n\t\t\t\t\t\t\t\t    unsigned int index = 0;\r\n\t\t\t\t\t\t\t\t    bool isFound = _compressedPathGraph.findVertex( coord, id, index );\r\n\r\n\t\t\t\t\t\t\t\t    if( isFound == false ) {\r\n\r\n\t\t\t\t\t\t\t\t\t    index = _compressedPathGraph.addVertex( coord, m, id );\r\n\t\t\t\t\t\t\t\t\t    // add bridge edges\r\n\t\t\t\t\t\t\t\t\t    _compressedPathGraph.addBridgeEdge( prevVDIndexVec[ k ], index );\r\n\t\t\t\t\t\t\t\t    }\r\n\t\t\t\t\t\t\t\t    else {\r\n\t\t\t\t\t\t\t\t\t    // add bridge edges\r\n\t\t\t\t\t\t\t\t\t    _compressedPathGraph.addBridgeEdge( prevVDIndexVec[ k ], index );\r\n\t\t\t\t\t\t\t\t    }\r\n\t\t\t\t\t\t\t    }\r\n\t\t\t\t\t\t    }\r\n\t\t\t\t\t    }\r\n\t\t\t\t    }\r\n\t\t\t\t    prevVDIndexVec.clear();\r\n\t\t\t    }\r\n\r\n\t\t\t\t// build graph based on treemap boundaries\r\n                for( map< unsigned int, KeiRo::Base::Rectangle2 >::iterator it = targetmap.begin();\r\n                    it != targetmap.end(); it++ ){\r\n                \tKeiRo::Base::Rectangle2 &rectangle = it->second;\r\n//                \tcerr << \"rect = \" << rectangle;\r\n\r\n                \tvector< unsigned int > indexVec;\r\n                \tfor( unsigned int i = 0; i < 4; i++ ){\r\n\r\n                \t\tKeiRo::Base::Coord2 coord;\r\n                \t\tif( i == 0 ){\r\n                \t\t\tcoord.x() = rectangle.leftBottom().x();\r\n                \t\t\tcoord.y() = rectangle.leftBottom().y();\r\n                \t\t}\r\n                \t\telse if ( i == 1 ){\r\n                \t\t\tcoord.x() = rectangle.leftBottom().x() + rectangle.width();\r\n                \t\t\tcoord.y() = rectangle.leftBottom().y();\r\n                \t\t}\r\n                \t\telse if ( i == 2 ){\r\n                \t\t\tcoord.x() = rectangle.leftBottom().x() + rectangle.width();\r\n                \t\t\tcoord.y() = rectangle.leftBottom().y() + rectangle.height();\r\n                \t\t}\r\n                \t\telse {\r\n                \t\t\tcoord.x() = rectangle.leftBottom().x();\r\n                \t\t\tcoord.y() = rectangle.leftBottom().y() + rectangle.height();\r\n                \t\t}\r\n\r\n\t\t\t\t\t\tunsigned int index = 0;\r\n\r\n                \t\tif( _compressedPathGraph.findVertex( coord, id, index ) == true ){\r\n                \t\t}\r\n                \t\telse {\r\n                \t\t\tindex = _compressedPathGraph.addVertex( coord, m, id );\r\n                \t\t\tprevVDIndexVec.push_back( index );\r\n                \t\t}\r\n//                \t\tcerr << \"id = \" << id << \" i = \" << i << \" index = \" << index << \" coord = \" << coord;\r\n                \t\tindexVec.push_back( index );\r\n                \t}\r\n\r\n                \tfor( unsigned int i = 0; i < 4; i++ ){\r\n                \t\tvertexPairs.push_back( pair< unsigned int, unsigned int >( indexVec[i], indexVec[(i+1)%4] ) );\r\n                \t}\r\n                }\r\n\r\n                // add edges\r\n                for( unsigned int i = 0; i < vertexPairs.size(); i++ ){\r\n                \tunsigned int idS = vertexPairs[i].first;\r\n                \tunsigned int idT = vertexPairs[i].second;\r\n                \tvector< unsigned int > intermediateVec;\r\n                \t_compressedPathGraph.addEdge( idS, idT, intermediateVec, id, true );\r\n\r\n#ifdef SKIP\r\n\t\t\t\t\t// add intermediate vertices to the path graph\r\n//\t\t\t\t\tcerr << \"intermediateVec.size() = \" << intermediateVec.size() << endl;\r\n\t\t\t\t\tfor( unsigned int j = 0; j < intermediateVec.size(); j++ ){\r\n//\t\t\t\t\t\tcerr << \"intermediateVec[ j ] = \" << intermediateVec[ j ] << endl;\r\n\t\t\t\t\t\tprevVDIndexVec.push_back( intermediateVec[ j ] );\r\n\t\t\t\t\t}\r\n//\t\t\t\t\tcerr << endl;\r\n#endif // SKIP\r\n                }\r\n#ifdef DEBUG_HIERARCHICALPATH\r\n\t\t\t\tGraph::printGraph( globalPathGraph );\r\n//    \t\t\tcerr << \"nV = \" << num_vertices( globalPathGraph ) << \", nE = \" << num_edges( globalPathGraph ) << endl;\r\n#endif // DEBUG_HIERARCHICALPATH\r\n    \t\t}\r\n    \t}\r\n\t}\r\n\tvoid HierarchicalPath::rebuildPathGraph( void )\r\n\t{\r\n\t\t// initialization\r\n\t\t//_projectedVertexVec.clear();\r\n\t\t_compressedPathGraph.clear();\r\n\r\n\t\t// variables\r\n\t\tGraph::TreeDirectedGraph &graphmlTree = _metadataPtr->graphmlTree();\r\n\t\tmap< unsigned int, Graph::BaseUndirectedGraph >  &graphmlGraphMap   = _metadataPtr->graphmlGraphMap();\r\n\t\tvector< Lens::Treemap > &treemapVec = _hierarchicalTreemapPtr->treemapVec();\r\n\t\tvector< vector< unsigned int > > &sortedLevel = _hierarchicalTreemapPtr->sortedLevel();\r\n\t\tGraph::BaseUndirectedGraph &globalPathGraph = _compressedPathGraph2.graph();\r\n\t\tmultimap< KeiRo::Base::Common::UIDPair,\r\n\t\t\t\tKeiRo::Base::Common::UIDPair >  &globalPathMap = _metadataPtr->graphmlGlobalPath();\r\n\t\tunsigned int maxLevel = _metadataPtr->maxLevel();\r\n\r\n\t\t// build the graph from the second lowest level\r\n\t\tunsigned int nID = 0, eID = 0;\r\n\t\tvector< unsigned int > prevVDIndexVec;\r\n\r\n\t\t// add vertices that are projected from the detailed graphs to the treemap boundaries\r\n\t\tfor( multimap< KeiRo::Base::Common::UIDPair,\r\n\t\t\t\tKeiRo::Base::Common::UIDPair >::iterator it = globalPathMap.begin();\r\n\t\t\t\tit != globalPathMap.end(); it++ ){\r\n\t\t\tKeiRo::Base::Common::UIDPair pairS = it->first;\r\n\t\t\tKeiRo::Base::Common::UIDPair pairT = it->second;\r\n\t\t\tunsigned int idS = pairS.first;\r\n\t\t\tunsigned int idT = pairT.first;\r\n\t\t\tunsigned int idGS = pairS.second;\r\n\t\t\tunsigned int idGT = pairT.second;\r\n\r\n\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdS = vertex( idS, graphmlTree );\r\n\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdT = vertex( idT, graphmlTree );\r\n\t\t\tGraph::BaseUndirectedGraph subGS = graphmlGraphMap.find( idS )->second;\r\n\t\t\tGraph::BaseUndirectedGraph subGT = graphmlGraphMap.find( idT )->second;\r\n\t\t\tGraph::BaseUndirectedGraph::vertex_descriptor vdSS = vertex( idGS, subGS );\r\n\t\t\tGraph::BaseUndirectedGraph::vertex_descriptor vdST = vertex( idGT, subGT );\r\n\r\n\t\t\t// cerr << \"s = \" << *subGS[vdSS].namePtr << \", t = \" << *subGS[vdST].namePtr << endl;\r\n\t\t\tKeiRo::Base::Coord2 &cS = *subGS[vdSS].coordPtr;\r\n\t\t\tKeiRo::Base::Coord2 &cT = *subGS[vdST].coordPtr;\r\n\t\t\tKeiRo::Base::Rectangle2 rectS = *graphmlTree[ vdS ].boundingBoxPtr,\r\n\t\t\t\t\t\t\t\t\trectT = *graphmlTree[ vdT ].boundingBoxPtr;\r\n\t\t\tKeiRo::Base::Coord2 projectedS = rectS.projectedOnBoundary( cS );\r\n\t\t\tKeiRo::Base::Coord2 projectedT = rectT.projectedOnBoundary( cT );\r\n\r\n\t\t\tunsigned int index = 0;\r\n\t\t\t// add source node projection\r\n\t\t\tif( _compressedPathGraph2.findVertex( projectedS, graphmlTree[ vdS ].parentID, index ) == false ){\r\n\t\t\t\tindex = _compressedPathGraph2.addVertex( projectedS, maxLevel-2, graphmlTree[ vdS ].parentID );\r\n\t\t\t\t_projectedVertexVec2.insert( pair< KeiRo::Base::Common::UIDPair, unsigned int >( it->first, index ) );\r\n\t\t\t}\r\n\r\n\r\n\t\t\t// add target node projection\r\n\t\t\tif( _compressedPathGraph2.findVertex( projectedT, graphmlTree[ vdT ].parentID, index ) == false ){\r\n\t\t\t\tindex = _compressedPathGraph2.addVertex( projectedT, maxLevel-2, graphmlTree[ vdT ].parentID );\r\n\t\t\t\t_projectedVertexVec2.insert( pair< KeiRo::Base::Common::UIDPair, unsigned int >( it->second, index ) );\r\n\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t// bottom up\r\n\t\tfor( int m = maxLevel-2; m >= 0; m-- ) {\r\n\t\t\tfor( unsigned int n = 0; n < sortedLevel[m].size(); n++ ) {\r\n\r\n\t\t\t\tunsigned int id = sortedLevel[m][n];\r\n\t\t\t\t// cerr << \"id = \" << id << \", level = \" << m << \", n = \" << n << endl;\r\n\t\t\t\tmap< unsigned int, KeiRo::Base::Rectangle2 > &targetmap = treemapVec[id].treemapTargetMap();\r\n\t\t\t\tvector< pair< unsigned int, unsigned int > > vertexPairs;\r\n\r\n\t\t\t\t// check if on polygon borders, build bridge edges\r\n\t\t\t\t// valid from the second level\r\n\t\t\t\tif( m != maxLevel-2 ) {\r\n\r\n\t\t\t\t\tfor( map< unsigned int, KeiRo::Base::Rectangle2 >::iterator it = targetmap.begin();\r\n\t\t\t\t\t\t it != targetmap.end(); it++ ) {\r\n\r\n\t\t\t\t\t\tKeiRo::Base::Rectangle2 &rectangle = it->second;\r\n\t\t\t\t\t\tvector< KeiRo::Base::Coord2 > cornerCoords;\r\n\t\t\t\t\t\tfor( unsigned int i = 0; i < 4; i++ ) {\r\n\t\t\t\t\t\t\tKeiRo::Base::Coord2 coord;\r\n\t\t\t\t\t\t\tif( i == 0 ) {\r\n\t\t\t\t\t\t\t\tcoord.x() = rectangle.leftBottom().x();\r\n\t\t\t\t\t\t\t\tcoord.y() = rectangle.leftBottom().y();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse if( i == 1 ) {\r\n\t\t\t\t\t\t\t\tcoord.x() = rectangle.leftBottom().x() + rectangle.width();\r\n\t\t\t\t\t\t\t\tcoord.y() = rectangle.leftBottom().y();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse if( i == 2 ) {\r\n\t\t\t\t\t\t\t\tcoord.x() = rectangle.leftBottom().x() + rectangle.width();\r\n\t\t\t\t\t\t\t\tcoord.y() = rectangle.leftBottom().y() + rectangle.height();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\tcoord.x() = rectangle.leftBottom().x();\r\n\t\t\t\t\t\t\t\tcoord.y() = rectangle.leftBottom().y() + rectangle.height();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tcornerCoords.push_back( coord );\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tfor( unsigned int j = 0; j < cornerCoords.size(); j++ ) {\r\n\t\t\t\t\t\t\tKeiRo::Base::Coord2 &coordS = cornerCoords[ j ];\r\n\t\t\t\t\t\t\tKeiRo::Base::Coord2 &coordT = cornerCoords[ ( j + 1 ) % cornerCoords.size() ];\r\n\t\t\t\t\t\t\tvector< KeiRo::Base::Coord2 > st;\r\n\t\t\t\t\t\t\tst.push_back( coordS );\r\n\t\t\t\t\t\t\tst.push_back( coordT );\r\n\t\t\t\t\t\t\tKeiRo::Base::Edge2 e( st );\r\n\r\n\t\t\t\t\t\t\t// add vertices\r\n\t\t\t\t\t\t\tfor( unsigned int k = 0; k < prevVDIndexVec.size(); k++ ) {\r\n\r\n\t\t\t\t\t\t\t\tGraph::BaseUndirectedGraph::vertex_descriptor vd = vertex( prevVDIndexVec[ k ],\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   globalPathGraph );\r\n\t\t\t\t\t\t\t\tKeiRo::Base::Coord2 &coord = *globalPathGraph[ vd ].coordPtr;\r\n\r\n\t\t\t\t\t\t\t\tif( e.isOnEdge( coord ) == true ) {\r\n\r\n\t\t\t\t\t\t\t\t\tunsigned int index = 0;\r\n\t\t\t\t\t\t\t\t\tbool isFound = _compressedPathGraph2.findVertex( coord, id, index );\r\n\r\n\t\t\t\t\t\t\t\t\tif( isFound == false ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tindex = _compressedPathGraph2.addVertex( coord, m, id );\r\n\t\t\t\t\t\t\t\t\t\t// add bridge edges\r\n\t\t\t\t\t\t\t\t\t\t_compressedPathGraph2.addBridgeEdge( prevVDIndexVec[ k ], index );\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t\t// add bridge edges\r\n\t\t\t\t\t\t\t\t\t\t_compressedPathGraph2.addBridgeEdge( prevVDIndexVec[ k ], index );\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t }\r\n\t\t\t\t\tprevVDIndexVec.clear();\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// build graph based on treemap boundaries\r\n\t\t\t\tfor( map< unsigned int, KeiRo::Base::Rectangle2 >::iterator it = targetmap.begin();\r\n\t\t\t\t\tit != targetmap.end(); it++ ){\r\n\t\t\t\t\tKeiRo::Base::Rectangle2 &rectangle = it->second;\r\n\t\t\t\t\t//                \tcerr << \"rect = \" << rectangle;\r\n\r\n\t\t\t\t\tvector< unsigned int > indexVec;\r\n\t\t\t\t\tfor( unsigned int i = 0; i < 4; i++ ){\r\n\r\n\t\t\t\t\t\tKeiRo::Base::Coord2 coord;\r\n\t\t\t\t\t\tif( i == 0 ){\r\n\t\t\t\t\t\t\tcoord.x() = rectangle.leftBottom().x();\r\n\t\t\t\t\t\t\tcoord.y() = rectangle.leftBottom().y();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if ( i == 1 ){\r\n\t\t\t\t\t\t\tcoord.x() = rectangle.leftBottom().x() + rectangle.width();\r\n\t\t\t\t\t\t\tcoord.y() = rectangle.leftBottom().y();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if ( i == 2 ){\r\n\t\t\t\t\t\t\tcoord.x() = rectangle.leftBottom().x() + rectangle.width();\r\n\t\t\t\t\t\t\tcoord.y() = rectangle.leftBottom().y() + rectangle.height();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tcoord.x() = rectangle.leftBottom().x();\r\n\t\t\t\t\t\t\tcoord.y() = rectangle.leftBottom().y() + rectangle.height();\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tunsigned int index = 0;\r\n\r\n\t\t\t\t\t\tif( _compressedPathGraph2.findVertex( coord, id, index ) == true ){\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tindex = _compressedPathGraph2.addVertex( coord, m, id );\r\n\t\t\t\t\t\t\tprevVDIndexVec.push_back( index );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t//                \t\tcerr << \"id = \" << id << \" i = \" << i << \" index = \" << index << \" coord = \" << coord;\r\n\t\t\t\t\t\tindexVec.push_back( index );\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor( unsigned int i = 0; i < 4; i++ ){\r\n\t\t\t\t\t\tvertexPairs.push_back( pair< unsigned int, unsigned int >( indexVec[i], indexVec[(i+1)%4] ) );\r\n\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t// add edges\r\n\t\t\t\tfor( unsigned int i = 0; i < vertexPairs.size(); i++ ){\r\n\t\t\t\t\tunsigned int idS = vertexPairs[i].first;\r\n\t\t\t\t\tunsigned int idT = vertexPairs[i].second;\r\n\t\t\t\t\tvector< unsigned int > intermediateVec;\r\n\t\t\t\t\t_compressedPathGraph2.addEdge( idS, idT, intermediateVec, id, true );\r\n\r\n\t\t\t\t\t// add intermediate vertices to the path graph\r\n\t\t\t\t\t//\t\t\t\t\tcerr << \"intermediateVec.size() = \" << intermediateVec.size() << endl;\r\n\t\t\t\t\tfor( unsigned int j = 0; j < intermediateVec.size(); j++ ){\r\n\t\t\t\t\t\t//\t\t\t\t\t\tcerr << \"intermediateVec[ j ] = \" << intermediateVec[ j ] << endl;\r\n\t\t\t\t\t\tprevVDIndexVec.push_back( intermediateVec[ j ] );\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//\t\t\t\t\tcerr << endl;\r\n\t\t\t\t}\r\n#ifdef DEBUG_HIERARCHICALPATH\r\n\t\t\t\tGraph::printGraph( globalPathGraph );\r\n\t\t\t\t//    \t\t\tcerr << \"nV = \" << num_vertices( globalPathGraph ) << \", nE = \" << num_edges( globalPathGraph ) << endl;\r\n#endif // DEBUG_HIERARCHICALPATH\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t//\r\n\t//  HierarchicalPath::splitConjunctions --\tsplit conjunctions\r\n\t//\r\n\t//  Inputs\r\n\t//\tvoid\r\n\t//\r\n\t//  Outputs\r\n\t//\tvoid\r\n\t//\r\n\tvoid HierarchicalPath::_splitConjunctions( KeiRo::Base::Line2 &polyline, unsigned int idG,\r\n\t\t\t\t\t\t\t\t\t\t\t\t   vector< Conjunction > &conjunctionVec )\r\n\t{\r\n\t\tvector< vector< unsigned int > > &sortedLevel   = _hierarchicalTreemapPtr->sortedLevel();\r\n\t\tGraph::TreeDirectedGraph &graphmlTree           = _hierarchicalTreemapPtr->metadataPtr()->graphmlTree();\r\n\r\n\t\tGraph::BaseUndirectedGraph &globalPathGraph         = _compressedPathGraph.graph();\r\n\t\tGraph::BaseUndirectedGraph::vertex_descriptor vdG    = vertex( idG, globalPathGraph );\r\n\t\tunsigned int level = globalPathGraph[ vdG ].level + 1;\r\n\t\tKeiRo::Base::Coord2 &coord = *globalPathGraph[ vdG ].coordPtr;\r\n\t\tConjunction *preConj;\r\n\r\n\t\t// cerr << \"in _splitCong idG = \" << idG << \", level = \" << level << \" polyline.elementPointers().size() = \" << polyline.elementPointers().size() << endl;\r\n\r\n\t\tbool isFound = false;\r\n\t\tfor( unsigned int i = 0; i < sortedLevel[ level ].size(); i++ ) {\r\n\t\t\tunsigned int id = sortedLevel[ level ][i];\r\n\t\t\t//\t\t\tcerr << \" id = \" << id << endl;\r\n\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd = vertex( id, graphmlTree );\r\n\t\t\tKeiRo::Base::Rectangle2 &bbox = *graphmlTree[ vd ].boundingBoxPtr;\r\n\t\t\tKeiRo::Base::Coord2 *leftBottom = new KeiRo::Base::Coord2( bbox.leftBottom() );\r\n\t\t\tKeiRo::Base::Coord2 *rightBottom = new KeiRo::Base::Coord2( bbox.leftBottom() + KeiRo::Base::Coord2( bbox.width(), 0 ) );\r\n\t\t\tKeiRo::Base::Coord2 *rightTop = new KeiRo::Base::Coord2( bbox.leftBottom() + KeiRo::Base::Coord2( bbox.width(), bbox.height() ) );\r\n\t\t\tKeiRo::Base::Coord2 *leftTop = new KeiRo::Base::Coord2( bbox.leftBottom() + KeiRo::Base::Coord2( 0, bbox.height() ) );\r\n#ifdef DEBUG\r\n\t\t\tif( idG == 2 ){\r\n\t\t\t\tcerr << \"id = \" << id << endl;\r\n\t\t\t\tcerr << \"c = \" << coord;\r\n\t\t\t\tcerr << \"LB = \" << *leftBottom;\r\n\t\t\t\tcerr << \"RB = \" << *rightBottom;\r\n\t\t\t\tcerr << \"RT = \" << *rightTop;\r\n\t\t\t\tcerr << \"LT = \" << *leftTop;\r\n\t\t\t}\r\n#endif // DEBUG\r\n\t\t\tConjunction *conj = new Conjunction;\r\n\t\t\tconj->level = level;\r\n\t\t\tconj->conjunctionType  = CONJUNCTION_CORNER;\r\n\r\n\t\t\t// left-bottom\r\n\t\t\tif( (coord - *leftBottom).norm() == 0 ){\r\n\r\n\t\t\t\tif(isFound == true ){\r\n\t\t\t\t\tconj = preConj;\r\n\t\t\t\t\tconj->treemapID.push_back( id );\r\n\t\t\t\t\tconj->pointType.push_back( POINT_LEFTBOTTOM );\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tpolyline.elementPointers().push_back( leftBottom );\r\n\t\t\t\t\tconj->treemapID.push_back( id );\r\n\t\t\t\t\tconj->pointType.push_back( POINT_LEFTBOTTOM );\r\n\t\t\t\t\tconjunctionVec.push_back( *conj );\r\n\t\t\t\t\tisFound = true;\r\n\t\t\t\t\tpreConj = &conjunctionVec[conjunctionVec.size()-1];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// right-bottom\r\n\t\t\tif( (coord - *rightBottom).norm() == 0 ){\r\n\t\t\t\tif(isFound == true ) {\r\n\t\t\t\t\tconj = preConj;\r\n\t\t\t\t\tconj->treemapID.push_back( id );\r\n\t\t\t\t\tconj->pointType.push_back( POINT_RIGHTBOTTOM );\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tpolyline.elementPointers().push_back( rightBottom );\r\n\t\t\t\t\tconj->treemapID.push_back( id );\r\n\t\t\t\t\tconj->pointType.push_back( POINT_RIGHTBOTTOM );\r\n\t\t\t\t\tconjunctionVec.push_back( *conj );\r\n\t\t\t\t\tisFound = true;\r\n\t\t\t\t\tpreConj = &conjunctionVec[conjunctionVec.size()-1];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// right-top\r\n\t\t\tif( (coord - *rightTop).norm() == 0 ){\r\n\t\t\t\tif(isFound == true ) {\r\n\t\t\t\t\tconj = preConj;\r\n\t\t\t\t\tconj->treemapID.push_back( id );\r\n\t\t\t\t\tconj->pointType.push_back( POINT_RIGHTTOP );\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\r\n\t\t\t\t\tpolyline.elementPointers().push_back( rightTop );\r\n\t\t\t\t\tconj->treemapID.push_back( id );\r\n\t\t\t\t\tconj->pointType.push_back( POINT_RIGHTTOP );\r\n\t\t\t\t\tconjunctionVec.push_back( *conj );\r\n\t\t\t\t\tisFound = true;\r\n\t\t\t\t\tpreConj = &conjunctionVec[conjunctionVec.size()-1];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// left-top\r\n\t\t\tif( (coord - *leftTop).norm() == 0 ){\r\n\t\t\t\tif(isFound == true ) {\r\n\t\t\t\t\tconj = preConj;\r\n\t\t\t\t\tconj->treemapID.push_back( id );\r\n\t\t\t\t\tconj->pointType.push_back( POINT_LEFTTOP );\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tpolyline.elementPointers().push_back( leftTop );\r\n\t\t\t\t\tconj->treemapID.push_back( id );\r\n\t\t\t\t\tconj->pointType.push_back( POINT_LEFTTOP );\r\n\t\t\t\t\tconjunctionVec.push_back( *conj );\r\n\t\t\t\t\tisFound = true;\r\n\t\t\t\t\tpreConj = &conjunctionVec[conjunctionVec.size()-1];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n#ifdef DEBUG_HIERARCHICALPATH\r\n\t\tif( isFound == false ){\r\n\t\t\tcerr << \"The coordinate is not located at the cell corners. They are other projected nodes.\" << endl;\r\n\t\t}\r\n#endif // DEBUG_HIERARCHICALPATH\r\n\t}\r\n\r\n\t//\r\n\t//  HierarchicalPath::buildHierarchicalPaths --\tbuild hierarchical path\r\n\t//\r\n\t//  Inputs\r\n\t//\tvoid\r\n\t//\r\n\t//  Outputs\r\n\t//\tvoid\r\n\t//\r\n\tvoid HierarchicalPath::buildHierarchicalPaths( void )\r\n\t{\r\n\t\t// initialization\r\n\t\t_polylineVec.clear();\r\n\t\t_hierarchicalPathVec.clear();\r\n\r\n\t\t// variables\r\n\t\tGraph::TreeDirectedGraph    &graphmlTree    = _metadataPtr->graphmlTree();\r\n\t\tmultimap< KeiRo::Base::Common::UIDPair,\r\n\t\t\t\tKeiRo::Base::Common::UIDPair > &globalPath = _metadataPtr->graphmlGlobalPath();\r\n\t\tmap< unsigned int, Graph::BaseUndirectedGraph >  &graphmlGraphMap   = _metadataPtr->graphmlGraphMap();\r\n\r\n\t\tGraph::BaseUndirectedGraph & globalPathGraph = _compressedPathGraph.graph();\r\n\t\tGraph::PropertyGraph propG;\r\n\r\n\t\tGraph::VertexIndexMap  vertexIndex = get( vertex_index, propG );\r\n\t\tGraph::EdgeIndexMap    edgeIndex   = get( edge_index, propG );\r\n\t\tvector< double > unitWeight( num_edges( globalPathGraph ) );\r\n\r\n\r\n\r\n\t\t// copy the graph for calculating shortest paths\r\n\t\tBGL_FORALL_VERTICES( vd, globalPathGraph, Graph::BaseUndirectedGraph ) {\r\n\r\n\t\t\tGraph::PropertyGraph::vertex_descriptor vdNew = add_vertex( propG );\r\n\t\t}\r\n\t\tBGL_FORALL_EDGES( ed, globalPathGraph, Graph::BaseUndirectedGraph ) {\r\n\r\n\t\t\tGraph::BaseUndirectedGraph::vertex_descriptor vdS = source( ed, globalPathGraph );\r\n\t\t\tGraph::BaseUndirectedGraph::vertex_descriptor vdT = target( ed, globalPathGraph );\r\n\t\t\tGraph::PropertyGraph::vertex_descriptor src = vertex( globalPathGraph[ vdS ].id, propG );\r\n\t\t\tGraph::PropertyGraph::vertex_descriptor tar = vertex( globalPathGraph[ vdT ].id, propG );\r\n\r\n\t\t\tpair< Graph::PropertyGraph::edge_descriptor, unsigned int > foreE = add_edge( src, tar, propG );\r\n\t\t\tGraph::PropertyGraph::edge_descriptor foreED = foreE.first;\r\n\r\n\t\t\tedgeIndex[ foreED ] = globalPathGraph[ ed ].id;\r\n\t\t\tunitWeight[ globalPathGraph[ ed ].id ] = globalPathGraph[ ed ].weight;\r\n\t\t}\r\n\r\n\t\t// build the hierarchical path\r\n\t\tunsigned int pathIndex = 0;\r\n\t\tfor( multimap< KeiRo::Base::Common::UIDPair,\r\n\t\t\t\tKeiRo::Base::Common::UIDPair >::iterator it = globalPath.begin();\r\n\t\t\t it != globalPath.end(); it++ ){\r\n\r\n\t\t\tKeiRo::Base::Common::UIDPair pairS = it->first;\r\n\t\t\tKeiRo::Base::Common::UIDPair pairT = it->second;\r\n\t\t\tunsigned int idS = pairS.first;\r\n\t\t\tunsigned int idT = pairT.first;\r\n\t\t\tunsigned int idGS = pairS.second;\r\n\t\t\tunsigned int idGT = pairT.second;\r\n\t\t\tGraph::BaseUndirectedGraph subGS = graphmlGraphMap.find( idS )->second;\r\n\t\t\tGraph::BaseUndirectedGraph subGT = graphmlGraphMap.find( idT )->second;\r\n\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdS = vertex( idS, graphmlTree );\r\n\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdT = vertex( idT, graphmlTree );\r\n\t\t\tGraph::BaseUndirectedGraph::vertex_descriptor vdGS = vertex( idGS, subGS );\r\n\t\t\tGraph::BaseUndirectedGraph::vertex_descriptor vdGT = vertex( idGT, subGT );\r\n\r\n\t\t\tunsigned int idPGS = _projectedVertexVec.find( it->first )->second;\r\n\t\t\tunsigned int idPGT = _projectedVertexVec.find( it->second )->second;\r\n\r\n\r\n\r\n\r\n\t\t\tGraph::PropertyGraph::vertex_descriptor vdPS = vertex( idPGS, propG );\r\n\t\t\tGraph::PropertyGraph::vertex_descriptor vdPT = vertex( idPGT, propG );\r\n\r\n\t\t\t// find the shortest path\r\n\t\t\tvector< Graph::PropertyGraph::vertex_descriptor > parent( num_vertices( propG ) );\r\n\t\t\tvector< double > distance( num_vertices( propG ) );\r\n\t\t\tdijkstra_shortest_paths( propG, vdPT,\r\n\t\t\t\t\t\t\t\t\t predecessor_map( make_iterator_property_map( parent.begin(),\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  get( vertex_index, propG ) ) ).\r\n\t\t\t\t\t\t\t\t\t\t\t distance_map( make_iterator_property_map( distance.begin(),\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   get( vertex_index, propG ) ) ).\r\n\t\t\t\t\t\t\t\t\t\t\t weight_map( make_iterator_property_map( unitWeight.begin(),\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t get( edge_index, propG ) ) ) );\r\n\r\n\t\t\t// store the path ID to the LocalShortestPath\r\n\t\t\tGraph::PropertyGraph::vertex_descriptor current = vdPS;\r\n\t\t\tvector< unsigned int > path;\r\n\t\t\twhile( current != vdPT ) {\r\n\r\n\t\t\t\tpath.push_back( vertexIndex[ current ] );\r\n\t\t\t\tif( current == parent[ current ] ) {\r\n\t\t\t\t\tcerr << \"ERROR: cannot find the shortest path... at \" << __LINE__ << \" in \" << __FILE__ << endl;\r\n\t\t\t\t\tcerr << \"idPGS = \" << idPGS << \", idPGT = \" << idPGT << endl;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\tassert( false );\r\n\t\t\t\t}\r\n\t\t\t\tcurrent = parent[ current ];\r\n\t\t\t}\r\n\r\n\t\t\tpath.push_back( vertexIndex[ vdPT ] );\r\n\r\n\t\t\t_hierarchicalPathVec.push_back( path );\r\n\r\n\t\t\t//calculate the length\r\n\t\t\tdouble pathLength = 0.0;\r\n\t\t\tfor (size_t i = 0; i < path.size() - 1; ++i) {\r\n\t\t\t\tGraph::PropertyGraph::vertex_descriptor vdS = vertex(path[i], propG);\r\n\t\t\t\tGraph::PropertyGraph::vertex_descriptor vdT = vertex(path[i + 1], propG);\r\n\t\t\t\tGraph::PropertyGraph::edge_descriptor ed;\r\n\t\t\t\tbool found;\r\n\t\t\t\tboost::tie(ed, found) = edge(vdS, vdT, propG);\r\n\t\t\t\tif (found) {\r\n\t\t\t\t\tpathLength += unitWeight[edgeIndex[ed]];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t//vector for paths' lengths\r\n\t\t\t_pathLengths.push_back(pathLength);\r\n\r\n\t\t\t// create global path lines\r\n\t\t\tKeiRo::Base::Line2 polyline;\r\n\t\t\tvector< Conjunction > conjunctionVec;\r\n\r\n\t\t\tConjunction conjS, conjT;\r\n\t\t\t// add source\r\n\r\n\t\t\tpolyline.elementPointers().push_back( subGS[ vdGS ].coordPtr );\r\n\t\t\tconjS.level =graphmlTree[ vdS ].level;\r\n\t\t\tconjS.treemapID.push_back( idS );\r\n\t\t\tconjS.pointType.push_back( POINT_NOTYPE );\r\n\t\t\tconjS.conjunctionType  = CONJUNCTION_INCELLS;\r\n\t\t\tconjunctionVec.push_back( conjS );\r\n\r\n\t\t\tpathStartIdGS.push_back(idS);\r\n\r\n\t\t\t// Increment the counter for this idGS\r\n\t\t\tidGSCounter[idS]++;\r\n\r\n\t\t\t// first point (projected node)\r\n\t\t\tfor( unsigned int i = 0; i < 1; i++ ){\r\n\t\t\t\tGraph::BaseUndirectedGraph::vertex_descriptor vd = vertex( path[0], globalPathGraph );\r\n\t\t\t\tKeiRo::Base::Coord2 *coordPtr = new KeiRo::Base::Coord2( *globalPathGraph[vd].coordPtr );\r\n\r\n\t\t\t\tpolyline.elementPointers().push_back( coordPtr );\r\n\r\n\t\t\t\tConjunction conj;\r\n\t\t\t\tconj.level = graphmlTree[ vdS ].level;\r\n\t\t\t\tconj.treemapID.push_back( idS );\r\n\t\t\t\tconj.pointType.push_back( POINT_NOTYPE );\r\n\t\t\t\tconj.conjunctionType  = CONJUNCTION_NONCORNER;\r\n\t\t\t\tconjunctionVec.push_back( conj );\r\n\t\t\t}\r\n\t\t\t// middle points\r\n\t\t\tfor( unsigned int i = 1; i < path.size()-1; i++ ){\r\n\t\t\t\t_splitConjunctions( polyline, path[i], conjunctionVec );\r\n\t\t\t}\r\n\t\t\t// last point (projected node)\r\n\t\t\tfor( unsigned int i = path.size()-1; i < path.size(); i++ ){\r\n\t\t\t\tGraph::BaseUndirectedGraph::vertex_descriptor vd = vertex( path[i], globalPathGraph );\r\n\t\t\t\tKeiRo::Base::Coord2 *coordPtr = new KeiRo::Base::Coord2( *globalPathGraph[vd].coordPtr );\r\n\r\n\t\t\t\tpolyline.elementPointers().push_back( coordPtr );\r\n\r\n\t\t\t\tConjunction conj;\r\n\t\t\t\tconj.level =graphmlTree[ vdT ].level;\r\n\t\t\t\tconj.treemapID.push_back( idT );\r\n\t\t\t\tconj.pointType.push_back( POINT_NOTYPE );\r\n\t\t\t\tconj.conjunctionType  = CONJUNCTION_NONCORNER;\r\n\t\t\t\tconjunctionVec.push_back( conj );\r\n\t\t\t}\r\n\r\n\t\t\t// add target\r\n\t\t\tpolyline.elementPointers().push_back( subGT[ vdGT ].coordPtr );\r\n\t\t\tconjT.level =graphmlTree[ vdT ].level;\r\n\t\t\tconjT.treemapID.push_back( idT );\r\n\t\t\tconjT.pointType.push_back( POINT_NOTYPE );\r\n\t\t\tconjT.conjunctionType  = CONJUNCTION_INCELLS;\r\n\t\t\tconjunctionVec.push_back( conjT );\r\n\r\n\t\t\tpathStartIdGT.push_back(idT);\r\n\r\n\t\t\t// Increment the counter for this idGS\r\n\t\t\tidGTCounter[idT]++;\r\n\r\n\t\t\t// add the path for further usage\r\n\t\t\tmultimap< pair< KeiRo::Base::Common::UIDPair,\r\n\t\t\t\t\tKeiRo::Base::Common::UIDPair >, KeiRo::Base::Edge2 >::iterator itA = _metadataPtr->graphmlGlobalPathAttribute().begin();\r\n\t\t\tstd::advance( itA, pathIndex );\r\n\t\t\tKeiRo::Base::Edge2 edge = itA->second;\r\n\t\t\t_polylineVec.push_back( polyline );\r\n\t\t\t_edgeAttributeVec.push_back( edge );\r\n\t\t\t_conjunctionMat.push_back( conjunctionVec );\r\n\r\n\r\n\r\n#ifdef DEBUG_HIERARCHICALPATH\r\n\t\t\tif( pathIndex == 52) {\r\n\t\t\t\tcerr << \"path = \";\r\n\t\t\t\tfor( unsigned int i = 0; i< path.size();i++){\r\n\t\t\t\t\tcerr << path[i] << \" \";\r\n\t\t\t\t}\r\n\t\t\t\tcerr << endl;\r\n\r\n\t\t\t\tcerr << \"HERE: \" << pathIndex << endl;\r\n\t\t\t\tfor (unsigned int i = 0; i < conjunctionVec.size(); i++) {\r\n\t\t\t\t\tKeiRo::Base::Coord2 c = *polyline.elementPointers()[i];\r\n\t\t\t\t\tcerr << i << \": \"\r\n\t\t\t\t\t\t << \"(L\" << conjunctionVec[i].level << \", \"\r\n\t\t\t\t\t\t << \"C\" << conjunctionVec[i].conjunctionType << \") \" << c;\r\n\t\t\t\t\tfor(unsigned int j = 0; j < conjunctionVec[i].treemapID.size(); j++){\r\n\t\t\t\t\t\tcerr << \" T\" << conjunctionVec[i].treemapID[j] << \", \"\r\n\t\t\t\t\t\t\t   << \" P\" << conjunctionVec[i].pointType[j] << endl;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tcerr << endl;\r\n\t\t\t}\r\n\r\n\t\t\tif( pathIndex == 3 ){\r\n\t\t\t\tfor( unsigned int i = 0; i < polyline.elementPointers().size(); i++ ){\r\n\t\t\t\t\tcerr << \"i = \" << i\r\n\t\t\t\t\t\t << \", level = \" << conjunctionVec[i].level << \", treemapID = \"\r\n\t\t\t\t\t\t << conjunctionVec[i].treemapID\r\n\t\t\t\t\t\t << \", pointType = \" << conjunctionVec[i].pointType\r\n\t\t\t\t\t\t << \", conjunctionType = \" << conjunctionVec[i].conjunctionType\r\n\t\t\t\t\t\t << \", coord = \" << *polyline.elementPointers()[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tcerr << \"polyline.elementPointers() = \" << polyline.elementPointers().size() << endl;\r\n\t\t\tcerr << \"path \" << pathIndex << \":\" << endl;\r\n\t\t\tfor( unsigned int i = 0; i < path.size(); i++ ){\r\n\t\t\t\tcerr << path[i] << \", \";\r\n\t\t\t}\r\n\t\t\tcerr << endl;\r\n#endif // DEBUG_HIERARCHICALPATH\r\n\t\t\tpathIndex++;\r\n\t\t\t }\r\n\t\tcout << \"Starting idGS for each path:\" << endl;\r\n\t\tfor (size_t i = 0; i < pathStartIdGS.size(); ++i) {\r\n\t\t\tcout << \"Path \" << i << \" starts at idGS: \" << pathStartIdGS[i] << endl;\r\n\t\t}\r\n\r\n\t\tcout << \"\\nNumber of paths starting at each idGS:\" << endl;\r\n\t\tfor (const auto& pair : idGSCounter) {\r\n\t\t\tcout << \"idGS \" << pair.first << \": \" << pair.second << \" path(s)\" << endl;\r\n\t\t}\r\n\r\n\t\tcout << \"Starting idGT for each path:\" << endl;\r\n\t\tfor (size_t i = 0; i < pathStartIdGT.size(); ++i) {\r\n\t\t\tcout << \"Path \" << i << \" starts at idGT: \" << pathStartIdGT[i] << endl;\r\n\t\t}\r\n\r\n\t\tcout << \"\\nNumber of paths starting at each idGT:\" << endl;\r\n\t\tfor (const auto& pair : idGTCounter) {\r\n\t\t\tcout << \"idGT \" << pair.first << \": \" << pair.second << \" path(s)\" << endl;\r\n\t\t}\r\n\r\n\r\n\r\n\t}\r\n\r\n\r\n\t//\r\n\t//  HierarchicalPath::setFixedPaths --\tupdate the path when partition is changed\r\n\t//\r\n\t//  Inputs\r\n\t//\tstring filePath\r\n\t//\r\n\t//  Outputs\r\n\t//\tbool\r\n\t//\r\n\tvoid HierarchicalPath::setFixedPaths( void )\r\n\t{\r\n\t\tfor( unsigned int i = 0; i < _polylineVec.size(); i++ ) {\r\n\r\n\t\t\tKeiRo::Base::Line2 &path = _polylineVec[ i ];\r\n\r\n\t\t\t//\t\t\tcerr << \"my polyline.elementPointers() = \" << path.elementPointers().size() << endl;\r\n\r\n\t\t\tpath.oldElements().resize( path.elementPointers().size() );\r\n\t\t\tpath.fixedElements().resize( path.elementPointers().size() );\r\n\t\t\tpath.elements().resize( path.elementPointers().size() );\r\n\t\t\tfor( unsigned int j = 0; j < path.elements().size(); j++ ){\r\n\t\t\t\tpath.elements()[j] = *path.elementPointers()[j];\r\n\t\t\t\tpath.elementPointers()[j]->updateOldElement();\r\n\t\t\t\tpath.oldElements()[j].x() = path.elementPointers()[j]->x();\r\n\t\t\t\tpath.oldElements()[j].y() = path.elementPointers()[j]->y();\r\n\t\t\t\tpath.fixedElements()[j].x() = path.elementPointers()[j]->x();\r\n\t\t\t\tpath.fixedElements()[j].y() = path.elementPointers()[j]->y();\r\n\t\t\t}\r\n\t\t\tcerr << \"path in inital \" << i << endl;\r\n\t\t\tprint_path(i);\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t//\r\n\t//  HierarchicalPath::resetGlobalPaths --\tupdate the path when partition is changed\r\n\t//\r\n\t//  Inputs\r\n\t//\tstring filePath\r\n\t//\r\n\t//  Outputs\r\n\t//\tbool\r\n\t//\r\n\tvoid HierarchicalPath::resetGlobalPaths( void )\r\n\t{\r\n\t\tfor( unsigned int i = 0; i < _polylineVec.size(); i++ ) {\r\n\r\n\t\t\tKeiRo::Base::Line2 &path = _polylineVec[ i ];\r\n\t\t\tfor( unsigned int j = 0; j < path.elements().size(); j++ ){\r\n\t\t\t\tpath.oldElements()[j].x() = path.elementPointers()[j]->x();\r\n\t\t\t\tpath.oldElements()[j].y() = path.elementPointers()[j]->y();\r\n\t\t\t\tpath.elementPointers()[j]->x() = path.fixedElements()[j].x();\r\n\t\t\t\tpath.elementPointers()[j]->y() = path.fixedElements()[j].y();\r\n\t\t\t}\r\n\t\t}\r\n\t\t//\t\tcerr << \"resetGlobalPathss\" << endl;\r\n\t}\r\n\r\n\r\n\r\n\tdouble HierarchicalPath::distance(KeiRo::Base::Coord2 p1, KeiRo::Base::Coord2 p2) {\r\n\t\tdouble dx = std::abs(p1.x() - p2.x());\r\n\t\tdouble dy = std::abs(p1.y() - p2.y());\r\n\t\treturn dx + dy;\r\n\t}\r\n\r\n\r\n\r\n\tvoid HierarchicalPath::reorderPath(int p) {\r\n\t\tKeiRo::Base::Line2 &polyline = _polylineVec[ p ];\r\n\t\t//cerr<<\"reorder start !!!\" << p <<endl;\r\n\t\tstd::vector<unsigned int> reorderedIndices;\r\n\t\tstd::vector<bool> isVisited(polyline.elementPointers().size(), false);\r\n\t\tprint_path(p);\r\n\t\tunsigned int currentIndex = 0;\r\n\t\treorderedIndices.push_back(currentIndex);\r\n\t\tisVisited[currentIndex] = true;\r\n\r\n\t\twhile (reorderedIndices.size() < polyline.elementPointers().size()) {\r\n\t\t\tdouble minDistance = std::numeric_limits<double>::max();\r\n\t\t\tunsigned int nearestIndex = 0;\r\n\t\t\t//unsigned int removeIndex =-1;\r\n\r\n\t\t\tfor (unsigned int i = 0; i < polyline.elementPointers().size()-1; ++i) {\r\n\t\t\t\tif (!isVisited[i]) {\r\n\r\n\t\t\t\t\tdouble dist = distance(*polyline.elementPointers()[currentIndex], *polyline.elementPointers()[i]);\r\n\t\t\t\t\tbool isHorizontalOrVertical = (polyline.elementPointers()[currentIndex]->x() == polyline.elementPointers()[i]->x() ||\r\n\t\t\t\t\t\t\t\t\t\t\t\t   polyline.elementPointers()[currentIndex]->y() == polyline.elementPointers()[i]->y());\r\n\r\n\r\n\t\t\t\t\tif (isHorizontalOrVertical && dist < minDistance ) {\r\n\t\t\t\t\t\t//if horizontal\r\n\r\n\t\t\t\t\t\t\tif ( currentIndex != 0 && polyline.elementPointers()[currentIndex]->y() == polyline.elementPointers()[i]->y()&&\r\n\t\t\t\t\t\t\t\tpolyline.elementPointers()[currentIndex]->y() == polyline.elementPointers()[currentIndex-1]->y()) {\r\n\r\n\t\t\t\t\t\t\t\tif (polyline.elementPointers()[currentIndex]->x()< polyline.elementPointers()[currentIndex-1]->x() &&\r\n\t\t\t\t\t\t\t\t\tpolyline.elementPointers()[currentIndex]->x() > polyline.elementPointers()[i]->x()) {\r\n\r\n\t\t\t\t\t\t\t\t\tminDistance = dist;\r\n\t\t\t\t\t\t\t\t\tnearestIndex = i;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\telse {\r\n\r\n\t\t\t\t\t\t\tminDistance = dist;\r\n\t\t\t\t\t\t\tnearestIndex = i;\r\n\t\t\t\t\t\t}\r\n\r\n\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t//cerr <<\"found point?? \"<<endl;\r\n\r\n\t\t\tif (minDistance == std::numeric_limits<double>::max() ) {\r\n\r\n\t\t\t\t// No horizontal or vertical movement found, go back to the previous point\r\n\t\t\t\tisVisited[currentIndex] = true;\r\n\r\n\t\t\t\t// for (unsigned int w = 0; w < reorderedIndices.size(); w++)\r\n\t\t\t\t// \tcerr << \"(\" <<reorderedIndices[w] << \"\\t\";\r\n\t\t\t\t// cerr << endl;\r\n\t\t\t\treorderedIndices.pop_back();\r\n\r\n\r\n\t\t\t\t// for (unsigned int w = 0; w < reorderedIndices.size(); w++)\r\n\t\t\t\t// \tcerr << \"(\" <<reorderedIndices[w] << \"\\t\";\r\n\t\t\t\t// cerr << endl;\r\n\r\n\t\t\t\tcurrentIndex = reorderedIndices.back();\r\n\r\n\t\t\t} else {\r\n\t\t\t\t// Found a horizontal or vertical movement, push its index\r\n\t\t\t\treorderedIndices.push_back(nearestIndex);\r\n\r\n\t\t\t\t// for (unsigned int w = 0; w < reorderedIndices.size(); w++)\r\n\t\t\t\t// \tcerr << \"(\" <<reorderedIndices[w] << \"\\t\";\r\n\t\t\t\t//\r\n\t\t\t\t// cerr << endl;\r\n\t\t\t\tisVisited[nearestIndex] = true;\r\n\t\t\t\tcurrentIndex = nearestIndex;\r\n\t\t\t}\r\n\r\n\t\t\tif (nearestIndex == polyline.elementPointers().size() - 2) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t//reorderedIndices.push_back(polyline.elementPointers().size()-1);\r\n\r\n\r\n\r\n\t\tKeiRo::Base::Line2 tempVec ;\r\n\r\n\r\n\t\ttempVec.elementPointers().reserve(polyline.elementPointers().size());\r\n\t\tfor (const auto *ptr : polyline.elementPointers()) {\r\n\t\t\ttempVec.elementPointers().push_back(new KeiRo::Base::Coord2(*ptr));\r\n\t\t}\r\n\r\n\t\t// Create a deep copy of oldElements\r\n\t\ttempVec.oldElements().reserve(polyline.oldElements().size());\r\n\t\tfor (const auto &element : polyline.oldElements()) {\r\n\t\t\ttempVec.oldElements().push_back(element);\r\n\t\t}\r\n\r\n\t\t// Create a deep copy of fixedElements\r\n\t\ttempVec.fixedElements().reserve(polyline.fixedElements().size());\r\n\t\tfor (const auto& element : polyline.fixedElements()) {\r\n\t\t\ttempVec.fixedElements().push_back(element);\r\n\t\t}\r\n\r\n\t\t// Create a deep copy of elements\r\n\t\ttempVec.elements().reserve(polyline.elements().size());\r\n\t\tfor (const auto& element : polyline.elements()) {\r\n\t\t\ttempVec.elements().push_back(element);\r\n\t\t}\r\n\r\n\t\tvector<Conjunction> conjTemp;\r\n\t\tconjTemp.reserve(_conjunctionMat[p].size());\r\n\t\tfor (const auto element :_conjunctionMat[p]) {\r\n\t\t\tconjTemp.push_back(element);\r\n\t\t\t//cerr << \"point type \"<< element.pointType<<\"\\t\";\r\n\t\t}\r\n\r\n\t\tcerr<<endl;\r\n\t\tfor (int i = 0; i <= reorderedIndices.size() ; ++i) {\r\n\t\t\tif  (i != reorderedIndices.size() ) {\r\n\t\t\t\tint swapIndex = reorderedIndices[i];\r\n\t\t\t\t//cerr << i << \"\\t\"<<swapIndex<<endl;\r\n\t\t\t\tconst double sourceX = tempVec.elementPointers()[swapIndex]->oldElement()[0];\r\n\t\t\t\tconst double sourceY = tempVec.elementPointers()[swapIndex]->oldElement()[1];\r\n\r\n\t\t\t\t// Assign the values directly to polyline's oldElement\r\n\t\t\t\tdouble* targetElement = const_cast<double*>(polyline.elementPointers()[i]->oldElement());\r\n\t\t\t\ttargetElement[0] = sourceX;\r\n\t\t\t\ttargetElement[1] = sourceY;\r\n\r\n\t\t\t\tpolyline.elementPointers()[i]->x() = tempVec.elementPointers()[swapIndex]->x();\r\n\t\t\t\tpolyline.elementPointers()[i]->y() = tempVec.elementPointers()[swapIndex]->y();\r\n\r\n\t\t\t\tpolyline.oldElements()[i].x() = tempVec.oldElements()[swapIndex].x();\r\n\t\t\t\tpolyline.oldElements()[i].y() = tempVec.oldElements()[swapIndex].y();\r\n\r\n\t\t\t\tpolyline.fixedElements()[i].x() = tempVec.fixedElements()[swapIndex].x();\r\n\t\t\t\tpolyline.fixedElements()[i].y() = tempVec.fixedElements()[swapIndex].y();\r\n\r\n\t\t\t\tpolyline.elements()[i].x() = tempVec.elements()[swapIndex].x();\r\n\t\t\t\tpolyline.elements()[i].y() = tempVec.elements()[swapIndex].y();\r\n\r\n\r\n\r\n\r\n\t\t\t\t_conjunctionMat[p][i].level = conjTemp[swapIndex].level;\r\n\t\t\t\t_conjunctionMat[p][i].conjunctionType = conjTemp[swapIndex].conjunctionType;\r\n\t\t\t\t_conjunctionMat[p][i].pointType.resize(conjTemp[swapIndex].pointType.size());\r\n\t\t\t\t_conjunctionMat[p][i].treemapID.resize(conjTemp[swapIndex].treemapID.size());\r\n\r\n\t\t\t\t// Copy the pointType and treemapID values from the swapped element\r\n\t\t\t\tstd::copy(conjTemp[swapIndex].pointType.begin(), conjTemp[swapIndex].pointType.end(),\r\n\t\t\t\t\t\t  _conjunctionMat[p][i].pointType.begin());\r\n\t\t\t\tstd::copy(conjTemp[swapIndex].treemapID.begin(), conjTemp[swapIndex].treemapID.end(),\r\n\t\t\t\t\t\t  _conjunctionMat[p][i].treemapID.begin());\r\n\t\t\t}\r\n\t\t\telse {\r\n\r\n\t\t\t\tpolyline.elementPointers()[i] =  (polyline.elementPointers()[polyline.elementPointers().size()-1]);\r\n\r\n\t\t\t\tconst double sourceX = tempVec.elementPointers()[polyline.elementPointers().size()-1]->oldElement()[0];\r\n\t\t\t\tconst double sourceY = tempVec.elementPointers()[polyline.elementPointers().size()-1]->oldElement()[1];\r\n\r\n\t\t\t\t// Assign the values directly to polyline's oldElement\r\n\t\t\t\tdouble* targetElement = const_cast<double*>(polyline.elementPointers()[i]->oldElement());\r\n\t\t\t\ttargetElement[0] = sourceX;\r\n\t\t\t\ttargetElement[1] = sourceY;\r\n\r\n\t\t\t\tpolyline.oldElements()[i].x() = polyline.oldElements()[polyline.oldElements().size()-1].x();\r\n\t\t\t\tpolyline.oldElements()[i].y() = polyline.oldElements()[polyline.oldElements().size()-1].y();\r\n\t\t\t\t//cerr <<\"the point \"<< polyline.oldElements()[i].x()<<\",\"<<polyline.oldElements()[i].y()<<endl;\r\n\t\t\t\tpolyline.fixedElements()[i].x() = polyline.fixedElements()[polyline.fixedElements().size()-1].x();\r\n\t\t\t\tpolyline.fixedElements()[i].y() = polyline.fixedElements()[polyline.fixedElements().size()-1].y();\r\n\r\n\t\t\t\tpolyline.elements()[i].x() = polyline.elements()[polyline.elements().size()-1].x();\r\n\t\t\t\tpolyline.elements()[i].y() = polyline.elements()[polyline.elements().size()-1].y();\r\n\r\n\r\n\r\n\r\n\t\t\t\t_conjunctionMat[p][i].level = _conjunctionMat[p][_conjunctionMat[p].size() - 1].level;\r\n\t\t\t\t_conjunctionMat[p][i].conjunctionType = _conjunctionMat[p][_conjunctionMat[p].size() - 1].conjunctionType;\r\n\r\n\t\t\t\t// Clear the existing pointType and treemapID vectors\r\n\t\t\t\t_conjunctionMat[p][i].pointType.clear();\r\n\t\t\t\t_conjunctionMat[p][i].treemapID.clear();\r\n\r\n\t\t\t\t// Resize the pointType and treemapID vectors to match the size of the last element\r\n\t\t\t\t_conjunctionMat[p][i].pointType.resize(_conjunctionMat[p][_conjunctionMat[p].size() - 1].pointType.size());\r\n\t\t\t\t_conjunctionMat[p][i].treemapID.resize(_conjunctionMat[p][_conjunctionMat[p].size() - 1].treemapID.size());\r\n\r\n\t\t\t\t// Copy the pointType and treemapID values from the last element\r\n\t\t\t\tstd::copy(_conjunctionMat[p][_conjunctionMat[p].size() - 1].pointType.begin(),\r\n\t\t\t\t\t\t  _conjunctionMat[p][_conjunctionMat[p].size() - 1].pointType.end(),\r\n\t\t\t\t\t\t  _conjunctionMat[p][i].pointType.begin());\r\n\t\t\t\tstd::copy(_conjunctionMat[p][_conjunctionMat[p].size() - 1].treemapID.begin(),\r\n\t\t\t\t\t\t  _conjunctionMat[p][_conjunctionMat[p].size() - 1].treemapID.end(),\r\n\t\t\t\t\t\t  _conjunctionMat[p][i].treemapID.begin());\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t}\r\n\r\n\t\tif (polyline.elementPointers().size() != reorderedIndices.size()+1) {\r\n\t\t\t//resize the line\r\n\t\t\tpolyline.elementPointers().resize(reorderedIndices.size()+1);\r\n\t\t\tpolyline.oldElements().resize( reorderedIndices.size() +1);\r\n\t\t\tpolyline.fixedElements().resize( reorderedIndices.size() +1);\r\n\t\t\tpolyline.elements().resize( reorderedIndices.size() +1);\r\n\r\n\r\n\r\n\t\t\t_conjunctionMat[p].resize(reorderedIndices.size()+1);\r\n\t\t}\r\n\r\n\r\n\t\t//print_path(p);\r\n\r\n\r\n\t\tcerr << endl;\r\n\r\n\t\t// cerr << \"HERE: \" << p << endl;\r\n\t\t// for (unsigned int i = 0; i < _conjunctionMat[p].size(); i++) {\r\n\t\t// \tKeiRo::Base::Coord2 c = *polyline.elementPointers()[i];\r\n\t\t// \tcerr << i << \": \"\r\n\t\t// \t\t << \"(L\" << _conjunctionMat[p][i].level << \", \"\r\n\t\t// \t\t << \"C\" << _conjunctionMat[p][i].conjunctionType << \") \" << c;\r\n\t\t// \tfor(unsigned int j = 0; j < _conjunctionMat[p][i].treemapID.size(); j++){\r\n\t\t// \t\tcerr << \" T\" << _conjunctionMat[p][i].treemapID[j] << \", \"\r\n\t\t// \t\t\t   << \" P\" << _conjunctionMat[p][i].pointType[j] << endl;\r\n\t\t// \t}\r\n\t\t// }\r\n\t\t// cerr << endl;\r\n\r\n\r\n\r\n\r\n\t}\r\n\t//\r\n\t//  HierarchicalPath::update --\tupdate the path when partition is changed\r\n\t//\r\n\t//  Inputs\r\n\t//\tstring filePath\r\n\t//\r\n\t//  Outputs\r\n\t//\tbool\r\n\t//\r\n\tvoid HierarchicalPath::update( vector<LocalMove> &localMoves )\r\n\t{\r\n\r\n\r\n\r\n\t\tGraph::TreeDirectedGraph    &graphmlTree    = _metadataPtr->graphmlTree();\r\n\t\tmap< unsigned int, Graph::BaseUndirectedGraph >  &graphmlGraphMap   = _metadataPtr->graphmlGraphMap();\r\n\r\n\t\tfor( unsigned int i = 0; i < _polylineVec.size(); i++ ){\r\n\t\t\t//cerr <<\"_polylineVec \" << \"[i] \" << i << _polylineVec[i] <<endl;\r\n\t\t\tKeiRo::Base::Line2 &polyline = _polylineVec[i];\r\n\r\n\r\n\t\t\tpolyline.oldElements()[0].x() = polyline.elementPointers()[0]->oldElement()[0];\r\n\t\t\tpolyline.oldElements()[0].y() = polyline.elementPointers()[0]->oldElement()[1];\r\n\t\t\tpolyline.oldElements()[polyline.elements().size()-1].x() = polyline.elementPointers()[polyline.elements().size()-1]->oldElement()[0];\r\n\t\t\tpolyline.oldElements()[polyline.elements().size()-1].y() = polyline.elementPointers()[polyline.elements().size()-1]->oldElement()[1];\r\n\r\n\r\n\t\t\t//this is not including the first and last points that are INCELLS\r\n\t\t\tfor( unsigned int j = 1; j < polyline.elements().size()-1; j++ ) {\r\n\t\t\t\tpolyline.elementPointers()[j]->updateOldElement();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\r\n\t\t// update the new coordinates\r\n\t\tfor( unsigned int i = 0; i < _conjunctionMat.size(); i++ ){\r\n\t\t\tKeiRo::Base::Line2 &polyline = _polylineVec[i];\r\n\t\t\t_passed = false;\r\n\r\n\t\t\tfor( unsigned int j = 0; j < _conjunctionMat[i].size(); j++ ){\r\n\r\n\t\t\t\tConjunction &conj = _conjunctionMat[i][j];\r\n\t\t\t\t// unsigned int id = conj.treemapID;\r\n\t\t\t\t// POINTTYPE &pointType = conj.pointType;\r\n\t\t\t\t// CONJUNCTIONTYPE &conjunctionType = conj.conjunctionType;\r\n\t\t\t\tunsigned int id = conj.treemapID[0];\r\n\r\n\t\t\t\tPOINTTYPE &pointType = conj.pointType[0];\r\n\t\t\t\tCONJUNCTIONTYPE &conjunctionType = conj.conjunctionType;\r\n\r\n\r\n\t\t\t\t//the point is not the first or last one\r\n\r\n\t\t\t\tif( j != 0 && j!= _conjunctionMat[i].size()-1 && conjunctionType == CONJUNCTION_NONCORNER ){\r\n\r\n\t\t\t\t\tif (j > 0 && _conjunctionMat[i][j - 1].conjunctionType == CONJUNCTION_INCELLS &&\r\n\t\t\t\t\t\t_conjunctionMat[i][j].conjunctionType == CONJUNCTION_NONCORNER) {\r\n\t\t\t\t\t\tunsigned int id = _conjunctionMat[i][j].treemapID[0];\r\n\t\t\t\t\t\t//cerr <<\"id \"<< id <<endl;\r\n\r\n\t\t\t\t\t\t\tlocalMoves_updatePath(localMoves, i, j);\r\n\t\t\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd = vertex(id, graphmlTree);\r\n\t\t\t\t\t\tKeiRo::Base::Rectangle2 &bbox = *graphmlTree[vd].boundingBoxPtr;\r\n\r\n\t\t\t\t\t\t// Update the x-coordinate\r\n\t\t\t\t\t\tdouble &x = polyline.elementPointers()[j]->x();\r\n\t\t\t\t\t\tx = (x - bbox.oldLeftBottom().x()) * bbox.width() / bbox.oldWidth() + bbox.leftBottom().x();\r\n\r\n\t\t\t\t\t\t// Update the y-coordinate\r\n\t\t\t\t\t\tdouble &y = polyline.elementPointers()[j]->y();\r\n\t\t\t\t\t\ty = (y - bbox.oldLeftBottom().y()) * bbox.height() / bbox.oldHeight() + bbox.leftBottom().y();\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\telse if (j < _conjunctionMat[i].size() - 1 && _conjunctionMat[i][j + 1].conjunctionType == CONJUNCTION_INCELLS &&\r\n\t\t\t\t\t_conjunctionMat[i][j].conjunctionType == CONJUNCTION_NONCORNER) {\r\n\t\t\t\t\t\tunsigned int id = _conjunctionMat[i][j].treemapID[0];\r\n\t\t\t\t\t\t//cerr <<\"id \"<< id <<endl;\r\n\r\n\t\t\t\t\t\t\tlocalMoves_updatePath(localMoves, i, j);\r\n\r\n\r\n\t\t\t\t\t\tif (_skip) {\r\n\t\t\t\t\t\t\tj+=1;\r\n\t\t\t\t\t\t\t_skip=false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd = vertex(id, graphmlTree);\r\n\t\t\t\t\t\tKeiRo::Base::Rectangle2 &bbox = *graphmlTree[vd].boundingBoxPtr;\r\n\r\n\t\t\t\t\t\t// Update the x-coordinate\r\n\t\t\t\t\t\tdouble &x = polyline.elementPointers()[j]->x();\r\n\t\t\t\t\t\tx = (x - bbox.oldLeftBottom().x()) * bbox.width() / bbox.oldWidth() + bbox.leftBottom().x();\r\n\r\n\t\t\t\t\t\t// Update the y-coordinate\r\n\t\t\t\t\t\tdouble &y = polyline.elementPointers()[j]->y();\r\n\t\t\t\t\t\ty = (y - bbox.oldLeftBottom().y()) * bbox.height() / bbox.oldHeight() + bbox.leftBottom().y();\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\t// conjunctions on treemap boundaries\r\n\t\t\t\telse if( conjunctionType == CONJUNCTION_CORNER ){\r\n\t\t\t\t\t//when the vertecies are on corners, we want to make sure that they are allighed with the corener after the transformation\r\n\t\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd1 = vertex( id, graphmlTree );\r\n\t\t\t\t\tKeiRo::Base::Rectangle2 &bbox1 = *graphmlTree[vd1].boundingBoxPtr;\r\n\r\n\t\t\t\t\t//cerr <<\"id \"<< id <<endl;\r\n\t\t\t\t\t// store the old coordinates\r\n\t\t\t\t\tpolyline.oldElements()[j] = *polyline.elementPointers()[j];\r\n\r\n\r\n\t\t\t\t\t\tlocalMoves_updatePath(localMoves, i, j);\r\n\t\t\t\t\tif (stepBack) {\r\n\t\t\t\t\t\tj = j-1;\r\n\t\t\t\t\t\tstepBack =false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tconj = _conjunctionMat[i][j];\r\n\r\n\t\t\t\t\tvector<KeiRo::Base::Coord2> c(conj.treemapID.size());\r\n\t\t\t\t\tvector<double> distances(conj.treemapID.size());\r\n\t\t\t\t\tdouble maxDist = 0;\r\n\t\t\t\t\tunsigned int maxDistIndex = 0;\r\n\t\t\t\t\tKeiRo::Base::Coord2* cPrev = polyline.elementPointers()[j - 1];\r\n\r\n\r\n\t\t\t\t\tfor (unsigned int k = 0; k < conj.treemapID.size(); k++) {\r\n\t\t\t\t\t\t//cerr <<\"after localmove \"<<endl;\r\n\t\t\t\t\t\tunsigned int id = conj.treemapID[k];\r\n\r\n\r\n\t\t\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd = vertex(id, graphmlTree);\r\n\t\t\t\t\t\tKeiRo::Base::Rectangle2& rect = *graphmlTree[vd].boundingBoxPtr;\r\n\r\n\t\t\t\t\t\tPOINTTYPE pointType = conj.pointType[k];\r\n\r\n\t\t\t\t\t\tswitch (pointType) {\r\n\t\t\t\t\t\t\tcase POINT_LEFTBOTTOM:\r\n\t\t\t\t\t\t\t\tc[k].x() = rect.leftBottom().x();\r\n\t\t\t\t\t\t\tc[k].y() = rect.leftBottom().y();\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase POINT_RIGHTBOTTOM:\r\n\t\t\t\t\t\t\t\tc[k].x() = rect.leftBottom().x() + rect.width();\r\n\t\t\t\t\t\t\tc[k].y() = rect.leftBottom().y();\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase POINT_RIGHTTOP:\r\n\t\t\t\t\t\t\t\tc[k].x() = rect.leftBottom().x() + rect.width();\r\n\t\t\t\t\t\t\tc[k].y() = rect.leftBottom().y() + rect.height();\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase POINT_LEFTTOP:\r\n\t\t\t\t\t\t\t\tc[k].x() = rect.leftBottom().x();\r\n\t\t\t\t\t\t\tc[k].y() = rect.leftBottom().y() + rect.height();\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tdistances[k] = distanceBetween(*cPrev, c[k]);\r\n\t\t\t\t\t\tdouble dist = distanceBetween(*cPrev, c[k]);\r\n\t\t\t\t\t\tif (dist > maxDist) {\r\n\t\t\t\t\t\t\tmaxDist = dist;\r\n\t\t\t\t\t\t\tmaxDistIndex = k;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\tif (conj.treemapID.size() == 4 ) {\r\n\r\n\t\t\t\t\t\t// Create a vector of pairs: (distance, index)\r\n\t\t\t\t\t\tvector<pair<double, int>> distanceIndex;\r\n\t\t\t\t\t\tfor (int k = 0; k < conj.treemapID.size(); ++k) {\r\n\t\t\t\t\t\t\tdistanceIndex.push_back({distances[k], k});\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// Sort by distance in descending order\r\n\t\t\t\t\t\tstd::sort(distanceIndex.begin(), distanceIndex.end(), std::greater<pair<double, int>>());\r\n\r\n\t\t\t\t\t\tConjunction newConj1 = conj, newConj2 = conj;\r\n\t\t\t\t\t\tnewConj1.treemapID.clear();\r\n\t\t\t\t\t\tnewConj1.pointType.clear();\r\n\t\t\t\t\t\tnewConj2.treemapID.clear();\r\n\t\t\t\t\t\tnewConj2.pointType.clear();\r\n\r\n\t\t\t\t\t\t// Assign the two farthest corners to newConj1\r\n\t\t\t\t\t\tfor (int k = 0; k < 2; ++k) {\r\n\t\t\t\t\t\t\tint idx = distanceIndex[k].second;\r\n\t\t\t\t\t\t\tnewConj1.treemapID.push_back(conj.treemapID[idx]);\r\n\t\t\t\t\t\t\tnewConj1.pointType.push_back(conj.pointType[idx]);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tfor (int k = 2; k < 4; ++k) {\r\n\t\t\t\t\t\t\tint idx = distanceIndex[k].second;\r\n\t\t\t\t\t\t\tnewConj2.treemapID.push_back(conj.treemapID[idx]);\r\n\t\t\t\t\t\t\tnewConj2.pointType.push_back(conj.pointType[idx]);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Replace the original conjunction with newConj1\r\n\r\n\r\n\t\t\t\t\t\t// Add new vertex for newConj2\r\n\t\t\t\t\t\tif (distanceIndex.size() == 4 && maxDist != distanceIndex[3].first) {\r\n\t\t\t\t\t\t\tif ((c[maxDistIndex].x() != polyline.elementPointers()[j]->x() &&\r\n\t\t\t\t\t\t\t\tc[maxDistIndex].y() != polyline.elementPointers()[j]->y()) &&\r\n\t\t\t\t\t\t\t\t_conjunctionMat[i][j+1].conjunctionType != CONJUNCTION_NONCORNER)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t_passed = true;\r\n\t\t\t\t\t\t\t\t//cerr << \"do not swap\"<<endl;\r\n\t\t\t\t\t\t\t\t_conjunctionMat[i][j] = newConj2;\r\n\t\t\t\t\t\t\t\t//cerr <<\" size before \"<< polyline.elementPointers().size()<<endl;\r\n\t\t\t\t\t\t\t\taddNewVertex(i, j, newConj1.treemapID, j+1, CONJUNCTION_CORNER, newConj1.pointType,\r\n\t\t\t\t\t\t\t\t\t\t\t c[maxDistIndex].x(), c[maxDistIndex].y());\r\n\r\n\t\t\t\t\t\t\t\tpolyline.elementPointers()[j]->x() = c[distanceIndex[2].second].x();\r\n\t\t\t\t\t\t\t\tpolyline.elementPointers()[j]->y() = c[distanceIndex[2].second].y();\r\n\t\t\t\t\t\t\t\tpolyline.elementPointers()[j]->inLocalMove()=true;\r\n\t\t\t\t\t\t\t\tpolyline.elementPointers()[j+1]->inLocalMove()=true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse if ((c[maxDistIndex].x() != polyline.elementPointers()[j+1]->x() &&\r\n\t\t\t\t\t\t\t\tc[maxDistIndex].y() != polyline.elementPointers()[j+1]->y()) ) {\r\n\t\t\t\t\t\t\t\t//cerr <<\" swap\"<<endl;\r\n\t\t\t\t\t\t\t\t_passed = true;\r\n\r\n\t\t\t\t\t\t\t\t_conjunctionMat[i][j] = newConj1;\r\n\t\t\t\t\t\t\t\t//cerr <<\" size before \"<< polyline.elementPointers().size()<<endl;\r\n\t\t\t\t\t\t\t\taddNewVertex(i, j , newConj1.treemapID, j+1, CONJUNCTION_CORNER, newConj2.pointType,\r\n\t\t\t\t\t\t\t\t\t\t\t c[maxDistIndex].x(), c[maxDistIndex].y());\r\n\r\n\t\t\t\t\t\t\t\tpolyline.elementPointers()[j]->x() = c[distanceIndex[2].second].x();\r\n\t\t\t\t\t\t\t\tpolyline.elementPointers()[j]->y() = c[distanceIndex[2].second].y();\r\n\r\n\t\t\t\t\t\t\t\tpolyline.elementPointers()[j]->inLocalMove()=true;\r\n\t\t\t\t\t\t\t\tpolyline.elementPointers()[j+1]->inLocalMove()=true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t//\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\tpolyline.elementPointers()[j]->x() = c[maxDistIndex].x();\r\n\t\t\t\t\t\t\t\tpolyline.elementPointers()[j]->y() = c[maxDistIndex].y();\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tif (maxDistIndex >= 0 && maxDistIndex < c.size()) {\r\n\t\t\t\t\t\t\tpolyline.elementPointers()[j]->x() = c[maxDistIndex].x();\r\n\t\t\t\t\t\t\tpolyline.elementPointers()[j]->y() = c[maxDistIndex].y();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!localMoves.empty() || _passed){\r\n\r\n\t\t\t\t\tunsigned int ids, idt, idgs,idgt;\r\n\t\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd = vertex( id, graphmlTree );\r\n\t\t\t\t\tKeiRo::Base::Rectangle2 &bbox = *graphmlTree[vd].boundingBoxPtr;\r\n\t\t\t\t\tif (j == 0) {\r\n\t\t\t\t\t\tids = id;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (_passed ) {\r\n\r\n\r\n\t\t\t\t\t\tif(j == _conjunctionMat[i].size()-1) {\r\n\t\t\t\t\t\t\tids = _conjunctionMat[i][0].treemapID[0];\r\n\t\t\t\t\t\t\tidt = id;\r\n\t\t\t\t\t\t\t//cerr << \" ids \"<< ids << \" idt \"<< idt<<endl;\r\n\t\t\t\t\t\t\tmultimap< KeiRo::Base::Common::UIDPair,KeiRo::Base::Common::UIDPair >  &globalPathMap = _metadataPtr->graphmlGlobalPath();\r\n\t\t\t\t\t\t\t// to find the excat id for the node vertex not for the cell\r\n\t\t\t\t\t\t\t//we might have multiple paths between the two cells\r\n\t\t\t\t\t\t\tfor( multimap< KeiRo::Base::Common::UIDPair,\r\n\t\t\t\t\t\t\tKeiRo::Base::Common::UIDPair >::iterator it = globalPathMap.begin();\r\n\t\t\t\t\t\t\tit != globalPathMap.end(); it++ ) {\r\n\t\t\t\t\t\t\t\tif (it->first.first == ids && it->second.first == idt) {\r\n\r\n\t\t\t\t\t\t\t\t\tunsigned int idGS = it->first.second;\r\n\t\t\t\t\t\t\t\t\tunsigned int idGT = it->second.second;\r\n\t\t\t\t\t\t\t\t\tGraph::BaseUndirectedGraph subGS = graphmlGraphMap.find( ids )->second;\r\n\t\t\t\t\t\t\t\t\tGraph::BaseUndirectedGraph subGT = graphmlGraphMap.find( idt )->second;\r\n\t\t\t\t\t\t\t\t\tGraph::BaseUndirectedGraph::vertex_descriptor vdGS = vertex( idGS, subGS );\r\n\t\t\t\t\t\t\t\t\tGraph::BaseUndirectedGraph::vertex_descriptor vdGT = vertex( idGT, subGT );\r\n\r\n\t\t\t\t\t\t\t\t\tif (subGS[ vdGT ].coordPtr->x()== polyline.elementPointers()[j]->x()&&\r\n\t\t\t\t\t\t\t\t\t\tsubGS[ vdGT ].coordPtr->y()== polyline.elementPointers()[j]->y() &&\r\n\t\t\t\t\t\t\t\t\t\tsubGS[ vdGS ].coordPtr->x()== polyline.elementPointers()[0]->x()&&\r\n\t\t\t\t\t\t\t\t\t\tsubGS[ vdGS ].coordPtr->y()== polyline.elementPointers()[0]->y()) {\r\n\t\t\t\t\t\t\t\t\t\tidgt = idGT;\r\n\t\t\t\t\t\t\t\t\t\tidgs = idGS;\r\n\t\t\t\t\t\t\t\t\t\t//cerr << \" idgt \"<< idgt << \"idgs \"<<idgs<<endl;\r\n\t\t\t\t\t\t\t\t\t\tunsigned int idPGS = _projectedVertexVec.find( it->first )->second;\r\n\t\t\t\t\t\t\t\t\t\tunsigned int idPGT = _projectedVertexVec.find( it->second )->second;\r\n\r\n\t\t\t\t\t\t\t\t\t\tGraph::BaseUndirectedGraph::vertex_descriptor sourceP = vertex( idPGS, _compressedPathGraph.graph() );\r\n\t\t\t\t\t\t\t\t\t\tGraph::BaseUndirectedGraph::vertex_descriptor targetP = vertex( idPGT, _compressedPathGraph.graph() );\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\t\t\tbuildPathGraph();//clear before\r\n\t\t\t\t\t\t\t//_compressedPathGraph.graph().clear();\r\n\t\t\t\t\t\t\t//buildHierarchicalPaths();\r\n\t\t\t\t\t\t\tcompute_shortest_path(ids,idt, idgs,idgt,i);\r\n\t\t\t\t\t\t\tcerr <<\" shortest path computation finish \"<<endl;\r\n\r\n\t\t\t\t\t\t\t auto& shortestPath = _polylineVecShort.back();\r\n\t\t\t\t\t\t\t auto& shortestConjunction = _conjunctionMatShort.back();\r\n\r\n\t\t\t\t\t\t\t// Resize polyline to match the size of the shortest path\r\n\r\n\t\t\t\t\t\t\tshortestPath.oldElements().resize( shortestPath.elementPointers().size() );\r\n\t\t\t\t\t\t\tshortestPath.fixedElements().resize( shortestPath.elementPointers().size() );\r\n\t\t\t\t\t\t\tshortestPath.elements().resize( shortestPath.elementPointers().size() );\r\n\t\t\t\t\t\t\tfor( unsigned int j = 0; j < shortestPath.elements().size(); j++ ){\r\n\t\t\t\t\t\t\t\tshortestPath.elements()[j] = *shortestPath.elementPointers()[j];\r\n\t\t\t\t\t\t\t\tshortestPath.elementPointers()[j]->updateOldElement();\r\n\t\t\t\t\t\t\t\tshortestPath.oldElements()[j].x() = shortestPath.elementPointers()[j]->x();\r\n\t\t\t\t\t\t\t\tshortestPath.oldElements()[j].y() = shortestPath.elementPointers()[j]->y();\r\n\t\t\t\t\t\t\t\tshortestPath.fixedElements()[j].x() = shortestPath.elementPointers()[j]->x();\r\n\t\t\t\t\t\t\t\tshortestPath.fixedElements()[j].y() = shortestPath.elementPointers()[j]->y();\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tpolyline.elementPointers().resize(shortestPath.elementPointers().size());\r\n\t\t\t\t\t\t\t_conjunctionMat[i].resize(shortestConjunction.size());\r\n\r\n\t\t\t\t\t\t\tpolyline.oldElements().resize( shortestPath.elementPointers().size() );\r\n\t\t\t\t\t\t\tpolyline.fixedElements().resize( shortestPath.elementPointers().size() );\r\n\t\t\t\t\t\t\tpolyline.elements().resize( shortestPath.elementPointers().size() );\r\n\r\n\t\t\t\t\t\t\t// Copy data from shortest path to polyline\r\n\t\t\t\t\t\t\tfor (size_t js = 0; js < shortestPath.elementPointers().size(); ++js) {\r\n\t\t\t\t\t\t\t\t// Create a new Coord2 object and copy the data\r\n\t\t\t\t\t\t\t\tpolyline.elementPointers()[js] = shortestPath.elementPointers()[js];\r\n\r\n\t\t\t\t\t\t\t\tpolyline.elements()[js] = *polyline.elementPointers()[js];\r\n\t\t\t\t\t\t\t\tpolyline.elementPointers()[js]->updateOldElement();\r\n\t\t\t\t\t\t\t\tpolyline.oldElements()[js].x() = polyline.elementPointers()[js]->x();\r\n\t\t\t\t\t\t\t\tpolyline.oldElements()[js].y() = polyline.elementPointers()[js]->y();\r\n\t\t\t\t\t\t\t\tpolyline.fixedElements()[js].x() = polyline.elementPointers()[js]->x();\r\n\t\t\t\t\t\t\t\tpolyline.fixedElements()[js].y() = polyline.elementPointers()[js]->y();\r\n\r\n\t\t\t\t\t\t\t\tpolyline.elementPointers()[js]->inLocalMove()=true;\r\n\r\n\t\t\t\t\t\t\t\t_conjunctionMat[i][js].conjunctionType = shortestConjunction[js].conjunctionType;\r\n\t\t\t\t\t\t\t\t_conjunctionMat[i][js].treemapID = shortestConjunction[js].treemapID;\r\n\t\t\t\t\t\t\t\t_conjunctionMat[i][js].pointType = shortestConjunction[js].pointType;\r\n\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\tif (_skip) {\r\n\t\t\t\t\tj +=1;\r\n\t\t\t\t\t_skip=false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif(localMoves.empty() && !_passed )\r\n\t\t\t\treorderPath(i);\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tvoid HierarchicalPath::localMoves_updatePath(vector<LocalMove> &localMoves, int i, int j) {\r\n\t\t//retrieve the tree graph and the line segment\r\n\t\tGraph::TreeDirectedGraph    &graphmlTree    = _metadataPtr->graphmlTree();\r\n\t\tKeiRo::Base::Line2 &polyline = _polylineVec[i];\r\n\t\tdouble eps = 0.001;\r\n\t\t//cerr<<\"path in local update \"<< i <<endl;\r\n\t\t//if (i ==52 || i ==53 )\r\n\t\t//print_path(i);\r\n\t\t// loop over the local moves in order\r\n\t\t//cerr <<\"localMoves.size() localMoves_updatePath \" << localMoves.size()<<endl;\r\n\r\n\t\tfor(unsigned int m = 0; m < localMoves.size(); m++) {\r\n\r\n\t\t\tLocalMove move = localMoves[m];\r\n\t\t\t//check for each localmove if the segment between rectangles vertical\r\n\t\t\tif(!move.beforeSegmentHorizontal()) {\r\n\t\t//\t\tcerr << \"vertical segment in local move \" << m << endl;\r\n\t\t\t\tif(move.stretchMove()) {\r\n\t\t//\t\t\tcerr << \"stretch move \"<<endl;\r\n\r\n\r\n\t\t\t\t\tfor (int tid = 0 ; tid<_conjunctionMat[i][j].treemapID.size() ; tid++) {\r\n\r\n\t\t\t\t\t\t//left\r\n\t\t\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdBLB = vertex( move.beforeLeftBottomID() , graphmlTree );\r\n\t\t\t\t\t\tKeiRo::Base::Rectangle2 &bboxLB = *graphmlTree[ vdBLB ].boundingBoxPtr;\r\n\r\n\t\t\t\t\t\t//right\r\n\t\t\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdBRT = vertex( move.beforeRightTopID() , graphmlTree );\r\n\t\t\t\t\t\tKeiRo::Base::Rectangle2 &bboxRT = *graphmlTree[ vdBRT ].boundingBoxPtr;\r\n\r\n\t\t\t\t\t\t// distinguish the cases\r\n\t\t\t\t\t\t//handling the cases where the path ends at one rects but does not pass in between\r\n\t\t\t\t\t\tint case_number;\r\n\t\t\t\t\t\tif (bboxLB.width() > bboxLB.oldWidth() && bboxLB.leftBottom().y() > bboxRT.leftBottom().y()) {\r\n\t\t\t\t\t\t\t//left rect is up\r\n\t\t\t\t\t\t\tcerr <<\"case 1\"<<endl;\r\n\t\t\t\t\t\t\tcase_number = 1;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if (bboxLB.width() > bboxLB.oldWidth() && bboxLB.leftBottom().y() == bboxRT.leftBottom().y()) {\r\n\t\t\t\t\t\t\t//left rect is down\r\n\t\t\t\t\t\t\tcase_number = 2;\r\n\t\t\t\t\t\t\tcerr <<\"case 2\"<<endl;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if (bboxRT.width() > bboxRT.oldWidth() && bboxRT.leftBottom().y() > bboxLB.leftBottom().y()) {\r\n\t\t\t\t\t\t\t//right rect is up\r\n\t\t\t\t\t\t\tcase_number = 3;\r\n\t\t\t\t\t\t\tcerr <<\"case 3\"<<endl;\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if (bboxRT.width() > bboxRT.oldWidth() && bboxRT.leftBottom().y() == bboxLB.leftBottom().y()) {\r\n\t\t\t\t\t\t\t//right rect is douwn\r\n\t\t\t\t\t\t\tcase_number = 4;\r\n\t\t\t\t\t\t\tcerr <<\"case 4\"<<endl;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\r\n\r\n\t\t\t\t\t\tswitch (case_number) {\r\n\t\t\t\t\t\t\tcase 1: {\r\n\t\t\t\t\t\t\t\tif ( polyline.elementPointers()[j]->x() != bboxRT.oldLeftBottom().x()  && j == 1\r\n\t\t\t\t\t\t\t\t\t&& _conjunctionMat[i][j].conjunctionType == CONJUNCTION_NONCORNER\r\n\t\t\t\t\t\t\t\t\t&& (_conjunctionMat[i][j].treemapID[tid] == move.beforeLeftBottomID()  ||\r\n\t\t\t\t\t\t\t\t\t_conjunctionMat[i][j].treemapID[tid] == move.beforeRightTopID()) ) {\r\n\t\t\t\t\t\t\t\t\t_passed==true;\r\n\t\t\t\t\t\t\t\t\tif ( polyline.elementPointers()[j+1]->x() == bboxLB.oldLeftBottom().x()+bboxLB.oldWidth() &&\r\n\t\t\t\t\t\t\t\t\t\tpolyline.elementPointers()[j+2]->x() == bboxLB.oldLeftBottom().x()){\r\n\r\n\t\t\t\t\t\t\t\t\t\t//update j+1\r\n\t\t\t\t\t\t\t\t\t\t_conjunctionMat[i][j+1].treemapID.clear();\r\n\t\t\t\t\t\t\t\t\t\t_conjunctionMat[i][j+1].pointType.clear();\r\n\t\t\t\t\t\t\t\t\t\taddConj(i,move.beforeRightTopID(),j+1,POINT_LEFTTOP);\r\n\r\n\t\t\t\t\t\t\t\t\t\t//update j+2\r\n\t\t\t\t\t\t\t\t\t\t_conjunctionMat[i][j+2].treemapID.clear();\r\n\t\t\t\t\t\t\t\t\t\t_conjunctionMat[i][j+2].pointType.clear();\r\n\t\t\t\t\t\t\t\t\t\taddConj(i,move.afterLeftBottomID(),j+2,POINT_LEFTBOTTOM);\r\n\t\t\t\t\t\t\t\t\t\t_passed = true;\r\n\t\t\t\t\t\t\t\t\t\tpolyline.elementPointers()[j+1]->inLocalMove()=true;\r\n\t\t\t\t\t\t\t\t\t\tpolyline.elementPointers()[j+2]->inLocalMove()=true;\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\telse if (polyline.elementPointers()[j+1]->x() == bboxRT.oldLeftBottom().x()+bboxRT.oldWidth() ) {\r\n\t\t\t\t\t\t\t\t\t\t//cerr << \" line is going up to right!!\"<<endl;\r\n\t\t\t\t\t\t\t\t\t\t_conjunctionMat[i][j+1].treemapID.clear();\r\n\t\t\t\t\t\t\t\t\t\t_conjunctionMat[i][j+1].pointType.clear();\r\n\t\t\t\t\t\t\t\t\t\taddConj(i,move.afterLeftBottomID(),j+1,POINT_RIGHTTOP);\r\n\t\t\t\t\t\t\t\t\t\t//add new point\r\n\t\t\t\t\t\t\t\t\t\tvector<unsigned int> ids ;\r\n\t\t\t\t\t\t\t\t\t\tvector< POINTTYPE> pt;\r\n\r\n\t\t\t\t\t\t\t\t\t\tids.push_back(move.afterLeftBottomID());\r\n\t\t\t\t\t\t\t\t\t\tpt.push_back((pointTypes[POINT_RIGHTBOTTOM]));\r\n\r\n\t\t\t\t\t\t\t\t\t\tids.push_back(move.afterRightTopID());\r\n\t\t\t\t\t\t\t\t\t\tpt.push_back((pointTypes[POINT_RIGHTTOP]));\r\n\r\n\t\t\t\t\t\t\t\t\t\tdouble x = bboxLB.leftBottom().x()+ bboxLB.width();\r\n\t\t\t\t\t\t\t\t\t\tdouble y = bboxLB.leftBottom().y();\r\n\t\t\t\t\t\t\t\t\t\taddNewVertex(i,j,ids,j+1,CONJUNCTION_CORNER,pt,x,y);\r\n\t\t\t\t\t\t\t\t\t\t_passed = true;\r\n\t\t\t\t\t\t\t\t\t\tpolyline.elementPointers()[j+1]->inLocalMove()=true;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\telse if (polyline.elementPointers()[j+1]->x() == bboxLB.leftBottom().x() ||\r\n\t\t\t\t\t\t\t\t\t\tpolyline.elementPointers()[j+1]->x() == bboxLB.oldLeftBottom().x() ) {\r\n\t\t\t\t\t\t\t\t\t\t_passed=true;\r\n\t\t\t\t\t\t\t\t\t\tpolyline.elementPointers()[j+1]->inLocalMove()=true;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\r\n\r\n\r\n\t\t\t\t\t\t\t\tif ( polyline.elementPointers()[j]->x() != bboxRT.oldLeftBottom().x() && j == polyline.elementPointers().size()-2\r\n\t\t\t\t\t\t\t\t&& _conjunctionMat[i][j].conjunctionType == CONJUNCTION_NONCORNER &&\r\n\t\t\t\t\t\t\t\t(_conjunctionMat[i][j].treemapID[tid] == move.beforeLeftBottomID()  ||\r\n\t\t\t\t\t\t\t\t_conjunctionMat[i][j].treemapID[tid] == move.beforeRightTopID()) ) {\r\n\t\t\t\t\t\t\t\t\t//cerr <<\"the point ends at one of the rects \"<<endl;\r\n\t\t\t\t\t\t\t\t\t_passed=true;\r\n\t\t\t\t\t\t\t\t\t//case where left rect is smaller and up\r\n\r\n\t\t\t\t\t\t\t\t\tif (polyline.elementPointers()[j-1]->x() == bboxLB.leftBottom().x()+ bboxLB.width()&&\r\n\t\t\t\t\t\t\t\t\tpolyline.elementPointers()[j-2]->x() == bboxLB.leftBottom().x()) {\r\n\t\t\t\t\t\t\t\t\t\t//cerr << \"the point in between !!\"<<endl;\r\n\t\t\t\t\t\t\t\t\t\t//update j-1\r\n\t\t\t\t\t\t\t\t\t\tremoveConj(i,move.beforeLeftBottomID(),j-1,2);\r\n\t\t\t\t\t\t\t\t\t\tpolyline.elementPointers()[j-1]->x() = bboxRT.leftBottom().x();\r\n\t\t\t\t\t\t\t\t\t\tpolyline.elementPointers()[j-1]->y() = bboxRT.leftBottom().y() + bboxRT.height();\r\n\r\n\t\t\t\t\t\t\t\t\t\t//update j-2\r\n\t\t\t\t\t\t\t\t\t\t_conjunctionMat[i][j-2].treemapID.clear();\r\n\t\t\t\t\t\t\t\t\t\t_conjunctionMat[i][j-2].pointType.clear();\r\n\t\t\t\t\t\t\t\t\t\taddConj(i,move.afterLeftBottomID(),j-2,POINT_LEFTBOTTOM);\r\n\t\t\t\t\t\t\t\t\t\tpolyline.elementPointers()[j-2]->x() = bboxLB.leftBottom().x();\r\n\t\t\t\t\t\t\t\t\t\tpolyline.elementPointers()[j-2]->y() = bboxLB.leftBottom().y();\r\n\t\t\t\t\t\t\t\t\t\t_passed = true;\r\n\t\t\t\t\t\t\t\t\t\tpolyline.elementPointers()[j-2]->inLocalMove()=true;\r\n\t\t\t\t\t\t\t\t\t\tpolyline.elementPointers()[j-1]->inLocalMove()=true;\r\n\t\t\t\t\t\t\t\t\t\tpolyline.elementPointers()[j]->inLocalMove()=true;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\telse if (polyline.elementPointers()[j-1]->x() == bboxLB.leftBottom().x()) {\r\n\t\t\t\t\t\t\t\t\t\t\t//cerr << \"line is going down from right\"<<endl;\r\n\t\t\t\t\t\t\t\t\t\t\t_conjunctionMat[i][j-1].treemapID.clear();\r\n\t\t\t\t\t\t\t\t\t\t\t_conjunctionMat[i][j-1].pointType.clear();\r\n\r\n\t\t\t\t\t\t\t\t\t\t\taddConj(i,move.beforeLeftBottomID(),j-1,POINT_RIGHTTOP);\r\n\t\t\t\t\t\t\t\t\t\t\tpolyline.elementPointers()[j-1]->x() = bboxLB.leftBottom().x() + bboxLB.width();\r\n\t\t\t\t\t\t\t\t\t\t\tpolyline.elementPointers()[j-1]->y() = bboxLB.leftBottom().y() + bboxLB.height();\r\n\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t//add new point\r\n\t\t\t\t\t\t\t\t\t\t\tvector<unsigned int> ids ;\r\n\t\t\t\t\t\t\t\t\t\t\tvector< POINTTYPE> pt;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tids.push_back(move.beforeLeftBottomID());\r\n\t\t\t\t\t\t\t\t\t\t\tpt.push_back((pointTypes[POINT_RIGHTBOTTOM]));\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tids.push_back(move.beforeRightTopID());\r\n\t\t\t\t\t\t\t\t\t\t\tpt.push_back((pointTypes[POINT_RIGHTTOP]));\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tdouble x = polyline.elementPointers()[j-1]->x();\r\n\t\t\t\t\t\t\t\t\t\t\tdouble y = polyline.elementPointers()[j]->y();\r\n\r\n\t\t\t\t\t\t\t\t\t\t\taddNewVertex(i,j-1,ids,j,CONJUNCTION_CORNER,pt,x,y);\r\n\t\t\t\t\t\t\t\t\t\t_passed = true;\r\n\t\t\t\t\t\t\t\t\t\tpolyline.elementPointers()[j-2]->inLocalMove()=true;\r\n\t\t\t\t\t\t\t\t\t\tpolyline.elementPointers()[j-1]->inLocalMove()=true;\r\n\t\t\t\t\t\t\t\t\t\tpolyline.elementPointers()[j]->inLocalMove()=true;\r\n\r\n\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\telse if (polyline.elementPointers()[j-1]->x() == bboxLB.leftBottom().x() ||\r\n\t\t\t\t\t\t\t\t\t\tpolyline.elementPointers()[j-1]->x() == bboxLB.oldLeftBottom().x() ) {\r\n\t\t\t\t\t\t\t\t\t\t_passed=true;\r\n\t\t\t\t\t\t\t\t\t\tpolyline.elementPointers()[j-2]->inLocalMove()=true;\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tcase 2: {\r\n\t\t\t\t\t\t\t\tif ( polyline.elementPointers()[j]->x() != bboxRT.oldLeftBottom().x()  && j == 1\r\n\t\t\t\t\t\t\t\t\t&& _conjunctionMat[i][j].conjunctionType == CONJUNCTION_NONCORNER\r\n\t\t\t\t\t\t\t\t\t&& (_conjunctionMat[i][j].treemapID[tid] == move.beforeLeftBottomID()  ||\r\n\t\t\t\t\t\t\t\t\t_conjunctionMat[i][j].treemapID[tid] == move.beforeRightTopID()) ) {\r\n\r\n\t\t\t\t\t\t\t\t\t_passed =true;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tcase 3: {\r\n\t\t\t\t\t\t\t\tif ( polyline.elementPointers()[j]->x() != bboxRT.oldLeftBottom().x()  && j == 1\r\n\t\t\t\t\t\t\t\t\t&& _conjunctionMat[i][j].conjunctionType == CONJUNCTION_NONCORNER\r\n\t\t\t\t\t\t\t\t\t&& (_conjunctionMat[i][j].treemapID[tid] == move.beforeLeftBottomID()  ||\r\n\t\t\t\t\t\t\t\t\t_conjunctionMat[i][j].treemapID[tid] == move.beforeRightTopID()) ) {\r\n\r\n\t\t\t\t\t\t\t\t\t_passed =true;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tcase 4: {\r\n\t\t\t\t\t\t\t\tif ( polyline.elementPointers()[j]->x() != bboxRT.oldLeftBottom().x()  && j == 1\r\n\t\t\t\t\t\t\t\t\t&& _conjunctionMat[i][j].conjunctionType == CONJUNCTION_NONCORNER\r\n\t\t\t\t\t\t\t\t\t&& (_conjunctionMat[i][j].treemapID[tid] == move.beforeLeftBottomID()  ||\r\n\t\t\t\t\t\t\t\t\t_conjunctionMat[i][j].treemapID[tid] == move.beforeRightTopID()) ) {\r\n\r\n\t\t\t\t\t\t\t\t\t_passed =true;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t\t\tcerr << \"non of the cases \"<<endl;\r\n\r\n\t\t\t\t\t\t\t/*vector<unsigned int> ids ;\r\n\t\t\t\t\t\t\tvector< POINTTYPE> pt;\r\n\r\n\t\t\t\t\t\t\tids.push_back(move.afterLeftBottomID());\r\n\t\t\t\t\t\t\tpt.push_back((pointTypes[POINT_LEFTBOTTOM]));\r\n\r\n\t\t\t\t\t\t\tdouble x = polyline.elementPointers()[j-2]->x();\r\n\t\t\t\t\t\t\tdouble y = polyline.elementPointers()[j]->y();\r\n\t\t\t\t\t\t\taddNewVertex(i,j,ids,j-2,CONJUNCTION_CORNER,pt,x,y);\r\n*/\r\n\r\n\r\n\r\n\r\n\t\t\t\t\t\t\t}\r\n \t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\t\t// if( i == 69 && j==2) {\r\n\t\t\t\t\t\t// \tif (_conjunctionMat[i][j].conjunctionType == CONJUNCTION_NONCORNER && (_conjunctionMat[i][j].treemapID[tid] == move.beforeLeftBottomID()  ||\r\n\t\t\t\t\t\t// \t\t_conjunctionMat[i][j].treemapID[tid] == move.beforeRightTopID()) ){\r\n\t\t\t\t\t\t// \t\tcerr<<\"very1\"<<endl;\r\n\t\t\t\t\t\t// \t\t_conjunctionMat[i][j+1].treemapID.clear();\r\n\t\t\t\t\t\t// \t\t_conjunctionMat[i][j+1].pointType.clear();\r\n\t\t\t\t\t\t// \t\taddConj(i,move.beforeRightTopID(),j+1,POINT_RIGHTTOP);\r\n\t\t\t\t\t\t// \t\t}\r\n\t\t\t\t\t\t// }\r\n\t\t\t\t\t\t// if (i==69 && j == polyline.elementPointers().size()-2) {\r\n\t\t\t\t\t\t// \tif (_conjunctionMat[i][j].conjunctionType == CONJUNCTION_NONCORNER && (_conjunctionMat[i][j].treemapID[tid] == move.beforeLeftBottomID()  ||\r\n\t\t\t\t\t\t// \t\t_conjunctionMat[i][j].treemapID[tid] == move.beforeRightTopID()) ){\r\n\t\t\t\t\t\t// \t\tcerr<<\"very2\"<<endl;\r\n\t\t\t\t\t\t// \t\t_conjunctionMat[i][j-1].treemapID.clear();\r\n\t\t\t\t\t\t// \t\t_conjunctionMat[i][j-1].pointType.clear();\r\n\t\t\t\t\t\t// \t\t_conjunctionMat[i][j-1].treemapID.push_back(move.afterRightTopID());\r\n\t\t\t\t\t\t// \t\t_conjunctionMat[i][j-1].pointType.push_back(POINT_RIGHTTOP);\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\t// \t\t}\r\n\t\t\t\t\t\t// }\r\n\r\n\r\n\r\n\t\t\t\t\t//_conjunctionMat[i].size() - 1 != j + 2 &&\r\n\t\t\t\t\tif(\r\n\t\t\t\t\tabs(polyline.elementPointers()[j]->x() - polyline.elementPointers()[j + 1]->x()) <= eps ) {\r\n\t\t\t\t\t\t// check whether segment of path has same coordinate as segment of local move\r\n\t\t\t\t\t\t//cerr << \"the line segment is also vertical \"<<endl;\r\n\t\t\t\t\t\t//cerr << \" points \"<<polyline.elementPointers()[j]->x()<<\",\"<<polyline.elementPointers()[j]->y()<<endl;\r\n\t\t\t\t\t\t//if(polyline.elementPointers()[j]->x() == move.beforeSegmentCoord())    {\r\n\t\t\t\t\t\t//\tcerr << \"both line and segment have same x coord \"<<endl;\r\n\r\n\t\t\t\t\t\t//left\r\n\t\t\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdBLB = vertex( move.beforeLeftBottomID() , graphmlTree );\r\n\t\t\t\t\t\tKeiRo::Base::Rectangle2 &bboxLB = *graphmlTree[ vdBLB ].boundingBoxPtr;\r\n\r\n\t\t\t\t\t\t//right\r\n\t\t\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdBRT = vertex( move.beforeRightTopID() , graphmlTree );\r\n\t\t\t\t\t\tKeiRo::Base::Rectangle2 &bboxRT = *graphmlTree[ vdBRT ].boundingBoxPtr;\r\n\r\n\r\n\t\t\t\t\t\tif (polyline.elementPointers()[j]->x() >= bboxLB.oldLeftBottom().x() +bboxLB.oldWidth() &&\r\n\t\t\t\t\t\t\t\tpolyline.elementPointers()[j]->x() <= bboxRT.oldLeftBottom().x()) {\r\n\t\t\t\t\t\t\t//cerr <<\"the path is btween x coor of rects \"<<endl;\r\n\r\n\t\t\t\t\t\t\t//cerr << i<<\" \"<< j <<endl;\r\n\r\n\r\n\t\t\t\t\t\t\tif (bboxRT.oldHeight() < bboxLB.oldHeight()) {\r\n\t\t\t\t\t\t\t\t//cerr << \"the right rect is smaller \"<<endl;\r\n\t\t\t\t\t\t\t\tbool isRT = true;\r\n\t\t\t\t\t\t\t\t//primary box is the smaller\r\n\t\t\t\t\t\t\t\tKeiRo::Base::Rectangle2 primaryBox = bboxRT;\r\n\t\t\t\t\t\t\t\tKeiRo::Base::Rectangle2 secondaryBox = bboxLB;\r\n\t\t\t\t\t\t\t\tunsigned int primaryId = move.beforeRightTopID();\r\n\t\t\t\t\t\t\t\tunsigned int secondaryId = move.beforeLeftBottomID();\r\n\r\n\t\t\t\t\t\t\t\t//order the points of the segment\r\n\t\t\t\t\t\t\t\tdouble top = std::max(polyline.elementPointers()[j]->y(), polyline.elementPointers()[j+1]->y());\r\n\t\t\t\t\t\t\t\tdouble bottom = std::min(polyline.elementPointers()[j]->y(), polyline.elementPointers()[j+1]->y());\r\n\r\n\t\t\t\t\t\t\t\tif ((top == primaryBox.oldLeftBottom().y() + primaryBox.oldHeight()  && bottom >= primaryBox.oldLeftBottom().y() )\r\n\t\t\t\t\t\t\t\t\t|| (top <= primaryBox.oldLeftBottom().y() + bboxLB.oldHeight() && bottom == primaryBox.oldLeftBottom().y())) {\r\n\r\n\t\t\t\t\t\t\t\t\tif (bboxRT.oldLeftBottom().y() > bboxLB.oldLeftBottom().y()) {\r\n\t\t\t\t\t\t\t\t\t\t//cerr << \"right rect is up \"<<endl;\r\n\r\n\r\n\t\t\t\t\t\t\t\t\t\t_passed = true;\r\n\t\t\t\t\t\t\t\t\t\tpolyline.elementPointers()[j]->inLocalMove()=true;\r\n\r\n\r\n\t\t\t\t\t\t\t\t\t\t//cerr<< \"line i \"<< i <<\" central seg is within the two rects hights\" << endl;\r\n\t\t\t\t\t\t\t\t\t\tbool isCentral = true;\r\n\r\n\t\t\t\t\t\t\t\t\t\t//line is going down or up\r\n\t\t\t\t\t\t\t\t\t\tbool isRT = (top ==  polyline.elementPointers()[j]->y());\r\n\r\n\t\t\t\t\t\t\t\t\t\tint currentIdx =  (top == polyline.elementPointers()[j]->y()) ? j  : j + 1;\r\n\t\t\t\t\t\t\t\t\t\tint nextIdx =  (top == polyline.elementPointers()[j]->y()) ? j+1  : j ;\r\n\t\t\t\t\t\t\t\t\t\tint prevIdx = (top == polyline.elementPointers()[j]->y()) ? j-1  : j + 2;\r\n\r\n\t\t\t\t\t\t\t\t\t\tint removeCorner = 3;\r\n\t\t\t\t\t\t\t\t\t\tint storPt;\r\n\t\t\t\t\t\t\t\t\t\tint addFactor = 1;\r\n\r\n\t\t\t\t\t\t\t\t\t\tdouble x = primaryBox.leftBottom().x();\r\n\t\t\t\t\t\t\t\t\t\tdouble y = primaryBox.leftBottom().y();\r\n\r\n\r\n\t\t\t\t\t\t\t\t\t\thandleALL(i,j,currentIdx,nextIdx,prevIdx, removeCorner, addFactor,\r\n\t\t\t\t\t\t\t\t\t\t\tprimaryBox,secondaryBox,primaryId,secondaryId,isCentral, move,isRT, x,y);\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\t\t\t\t\telse if (bboxRT.oldLeftBottom().y() == bboxLB.oldLeftBottom().y()) {\r\n\t\t\t\t\t\t\t\t\t\t//cerr << \"right rect is down \"<<endl;\r\n\r\n\t\t\t\t\t\t\t\t\t\t_passed = true;\r\n\r\n\t\t\t\t\t\t\t\t\t\tpolyline.elementPointers()[j]->inLocalMove()=true;\r\n\t\t\t\t\t\t\t\t\t\t//cerr<< \"line i \"<< i <<\" central seg is within the two rects hights\" << endl;\r\n\t\t\t\t\t\t\t\t\t\tbool isCentral = true;\r\n\t\t\t\t\t\t\t\t\t\t//line is going down or up\r\n\t\t\t\t\t\t\t\t\t\tbool isDown = (top ==  polyline.elementPointers()[j]->y());\r\n\r\n\r\n\t\t\t\t\t\t\t\t\t\tint currentIdx = j ? top ==  polyline.elementPointers()[j]->y() : j+1;\r\n\t\t\t\t\t\t\t\t\t\tint nextIdx = j+1 ? top ==  polyline.elementPointers()[j]->y() : j;\r\n\t\t\t\t\t\t\t\t\t\tint prevIdx = j+2 ? top ==  polyline.elementPointers()[j]->y() : j-1;\r\n\t\t\t\t\t\t\t\t\t\tint removeCorner = 2;\r\n\t\t\t\t\t\t\t\t\t\tint storPt;\r\n\t\t\t\t\t\t\t\t\t\tint addFactor = -1;\r\n\r\n\t\t\t\t\t\t\t\t\t\tdouble x = polyline.elementPointers()[nextIdx]->x();\r\n\t\t\t\t\t\t\t\t\t\tdouble y = polyline.elementPointers()[currentIdx]->y();\r\n\r\n\r\n\t\t\t\t\t\t\t\t\t\t// handleALL(i,j,currentIdx,nextIdx,prevIdx, removeCorner, addFactor,\r\n\t\t\t\t\t\t\t\t\t\t// \tprimaryBox,secondaryBox,primaryId,secondaryId,isCentral, move,isRT,x,y);\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\r\n\r\n\t\t\t\t\t\t\tif (bboxRT.oldHeight() > bboxLB.oldHeight()) {\r\n\t\t\t\t\t\t\t\t//cerr << \"the left rect is smaller \"<<endl;\r\n\t\t\t\t\t\t\t\tbool isRT = false;\r\n\t\t\t\t\t\t\t\t//primary box is the smaller\r\n\r\n\t\t\t\t\t\t\t\tKeiRo::Base::Rectangle2 primaryBox = bboxLB;\r\n\t\t\t\t\t\t\t\tKeiRo::Base::Rectangle2 secondaryBox = bboxRT;\r\n\t\t\t\t\t\t\t\tunsigned int primaryId = move.beforeLeftBottomID();\r\n\t\t\t\t\t\t\t\tunsigned int secondaryId = move.beforeRightTopID();\r\n\r\n\t\t\t\t\t\t\t\t//order the points of the segment\r\n\t\t\t\t\t\t\t\tdouble top = std::max(polyline.elementPointers()[j]->y(), polyline.elementPointers()[j+1]->y());\r\n\t\t\t\t\t\t\t\tdouble bottom = std::min(polyline.elementPointers()[j]->y(), polyline.elementPointers()[j+1]->y());\r\n\r\n\t\t\t\t\t\t\t\tif ((top == primaryBox.oldLeftBottom().y() + primaryBox.oldHeight()  && bottom >= primaryBox.oldLeftBottom().y() )\r\n\t\t\t\t\t\t\t\t\t|| (top <= primaryBox.oldLeftBottom().y() + bboxLB.oldHeight() && bottom == primaryBox.oldLeftBottom().y())) {\r\n\r\n\t\t\t\t\t\t\t\t\tif (bboxLB.oldLeftBottom().y() > bboxRT.oldLeftBottom().y()) {\r\n\t\t\t\t\t\t\t\t\t\t//cerr <<\"left rect is up\"<<endl;\r\n\r\n\r\n\t\t\t\t\t\t\t\t\t\t_passed = true;\r\n\r\n\t\t\t\t\t\t\t\t\t\tpolyline.elementPointers()[j]->inLocalMove()=true;\r\n\t\t\t\t\t\t\t\t\t\t//cerr<< \"line i \"<< i <<\" centeral seg is within the two rects hights\" << endl;\r\n\r\n\t\t\t\t\t\t\t\t\t\t// handleCase(i, j, top == polyline.elementPointers()[j]->y(),move, bboxRT, bboxLB);\r\n\t\t\t\t\t\t\t\t\t\tbool isCentral = true;\r\n\r\n\t\t\t\t\t\t\t\t\t\t//line is going up or down\r\n\t\t\t\t\t\t\t\t\t\tint currentIdx = (top == polyline.elementPointers()[j]->y()) ? j  : j + 1;\r\n\t\t\t\t\t\t\t\t\t\tint nextIdx =  (top == polyline.elementPointers()[j]->y()) ? j + 1 : j;\r\n\t\t\t\t\t\t\t\t\t\tint prevIdx =  (top == polyline.elementPointers()[j]->y()) ? j - 1 : j +2 ;\r\n\t\t\t\t\t\t\t\t\t\tint removeCorner = 4;\r\n\t\t\t\t\t\t\t\t\t\tint storPt;\r\n\t\t\t\t\t\t\t\t\t\tint addFactor = -1;\r\n\t\t\t\t\t\t\t\t\t\tint isDR = (top == polyline.elementPointers()[j]->y()) ? true  : false;\r\n\r\n\r\n\r\n\t\t\t\t\t\t\t\t\t\tdouble x = primaryBox.leftBottom().x() + primaryBox.width();\r\n\t\t\t\t\t\t\t\t\t\tdouble y = primaryBox.leftBottom().y();\r\n\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tcerr <<endl;\r\n\t\t\t\t\t\t\t\t\t\t\thandleALL(i,j,currentIdx,nextIdx,prevIdx, removeCorner, addFactor,\r\n\t\t\t\t\t\t\t\t\t\t\tprimaryBox,secondaryBox,primaryId,secondaryId,isCentral, move,isDR, x,y);\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif (bboxLB.oldLeftBottom().y() == bboxRT.oldLeftBottom().y()) {\r\n\t\t\t\t\t\t\t\t\t\t//cerr <<\"left rect is down\"<<endl;\r\n\r\n\t\t\t\t\t\t\t\t\t\t//line is going down or up\r\n\t\t\t\t\t\t\t\t\t\t_passed = true;\r\n\r\n\t\t\t\t\t\t\t\t\t\tpolyline.elementPointers()[j]->inLocalMove()=true;\r\n\t\t\t\t\t\t\t\t\t\t//cerr<< \"line i \"<< i <<\" centeral seg is within the two rects hights\" << endl;\r\n\t\t\t\t\t\t\t\t\t\t// handleCase(i, j, top == polyline.elementPointers()[j]->y(),move, bboxRT, bboxLB);\r\n\t\t\t\t\t\t\t\t\t\tbool isCentral = true;\r\n\r\n\t\t\t\t\t\t\t\t\t\t//line is going up or down\r\n\t\t\t\t\t\t\t\t\t\tint currentIdx = j ? top ==  polyline.elementPointers()[j]->y() :j+1;\r\n\t\t\t\t\t\t\t\t\t\tint nextIdx = j+1 ?top ==  polyline.elementPointers()[j]->y() : j;\r\n\t\t\t\t\t\t\t\t\t\tint prevIdx = j+2 ?top ==  polyline.elementPointers()[j]->y() :j-1;\r\n\t\t\t\t\t\t\t\t\t\tint removeCorner = 1;\r\n\t\t\t\t\t\t\t\t\t\tint storPt;\r\n\t\t\t\t\t\t\t\t\t\tint addFactor = 1;\r\n\r\n\t\t\t\t\t\t\t\t\t\tdouble x = polyline.elementPointers()[nextIdx]->x();\r\n\t\t\t\t\t\t\t\t\t\tdouble y = polyline.elementPointers()[currentIdx]->y();\r\n\r\n\r\n\t\t\t\t\t\t\t\t\t\t// handleALL(i,j,currentIdx,nextIdx,prevIdx, removeCorner, addFactor,\r\n\t\t\t\t\t\t\t\t\t\t// \tprimaryBox,secondaryBox,primaryId,secondaryId,isCentral, move,isRT, x,y);\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\r\n\t\t\telse if ( move.beforeSegmentHorizontal()) {\r\n\t\t\t\tif(move.stretchMove()) {\r\n\t\t//\t\t\tcerr << \"stretch move \"<<endl;\r\n\t\t\t\t\tif(\r\n\t\t\t\t\tabs(polyline.elementPointers()[j]->y() - polyline.elementPointers()[j + 1]->y()) <= eps ) {\r\n\t\t\t\t\t\t// check whether segment of path has same coordinate as segment of local move\r\n\t\t\t\t\t\t//cerr << \"the line segment is also horizontal \"<<endl;\r\n\t\t\t\t\t\t//cerr << \" points \"<<polyline.elementPointers()[j]->x()<<\",\"<<polyline.elementPointers()[j]->y()<<endl;\r\n\t\t\t\t\t\t//left\r\n\t\t\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdBLB = vertex( move.beforeLeftBottomID() , graphmlTree );\r\n\t\t\t\t\t\tKeiRo::Base::Rectangle2 &bboxLB = *graphmlTree[ vdBLB ].boundingBoxPtr;\r\n\r\n\t\t\t\t\t\t//right\r\n\t\t\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdBRT = vertex( move.beforeRightTopID() , graphmlTree );\r\n\t\t\t\t\t\tKeiRo::Base::Rectangle2 &bboxRT = *graphmlTree[ vdBRT ].boundingBoxPtr;\r\n\r\n\r\n\t\t\t\t\t\tif (polyline.elementPointers()[j]->y() >= bboxLB.oldLeftBottom().y() +bboxLB.oldHeight() &&\r\n\t\t\t\t\t\t\t\tpolyline.elementPointers()[j]->y() <= bboxRT.oldLeftBottom().y()) {\r\n\t\t\t\t\t\t\t//cerr <<\" the path is between y coor of rects \"<<endl;\r\n\t\t\t\t\t\t\t//cerr << i<<\" \"<< j <<endl;\r\n\r\n\r\n\t\t\t\t\t\t\tif (bboxRT.oldWidth() < bboxLB.oldWidth()) {\r\n\t\t\t\t\t\t\t\t//cerr << \"the top rect is smaller \"<<endl;\r\n\t\t\t\t\t\t\t\tbool isRT = true;\r\n\t\t\t\t\t\t\t\t//primary box is the smaller\r\n\t\t\t\t\t\t\t\tKeiRo::Base::Rectangle2 primaryBox = bboxRT;\r\n\t\t\t\t\t\t\t\tKeiRo::Base::Rectangle2 secondaryBox = bboxLB;\r\n\t\t\t\t\t\t\t\tunsigned int primaryId = move.beforeRightTopID();\r\n\t\t\t\t\t\t\t\tunsigned int secondaryId = move.beforeLeftBottomID();\r\n\r\n\t\t\t\t\t\t\t\t//order the points of the segment (left to right)\r\n\t\t\t\t\t\t\t\tdouble left = std::min(polyline.elementPointers()[j]->x(), polyline.elementPointers()[j+1]->x());\r\n\t\t\t\t\t\t\t\tdouble right = std::max(polyline.elementPointers()[j]->x(), polyline.elementPointers()[j+1]->x());\r\n\t\t\t\t\t\t\t\tif ((left == primaryBox.oldLeftBottom().x()   && right <= primaryBox.oldLeftBottom().x() + primaryBox.oldWidth() )\r\n\t\t\t\t\t\t\t\t|| (left >= primaryBox.oldLeftBottom().x()  && right == primaryBox.oldLeftBottom().x()+primaryBox.oldWidth())) {\r\n\t\t\t\t\t\t\t\t\tif (bboxRT.oldLeftBottom().x() == bboxLB.oldLeftBottom().x()) {\r\n\t\t\t\t\t\t\t\t\t\t//cerr << \"top rect is left \"<<endl;\r\n\t\t\t\t\t\t\t\t\t\t_passed = true;\r\n\r\n\t\t\t\t\t\t\t\t\t\tpolyline.elementPointers()[j]->inLocalMove()=true;\r\n\t\t\t\t\t\t\t\t\t\t//cerr<< \"line i \"<< i <<\" central seg is within the two rects widths\" << endl;\r\n\t\t\t\t\t\t\t\t\t\tbool isCentral = true;\r\n\t\t\t\t\t\t\t\t\t\t//line is going right or left\r\n\r\n\t\t\t\t\t\t\t\t\t\tint currentIdx = j ? left ==  polyline.elementPointers()[j]->x() : j+1;\r\n\t\t\t\t\t\t\t\t\t\tint nextIdx = j+1 ? left ==  polyline.elementPointers()[j]->x() : j;\r\n\t\t\t\t\t\t\t\t\t\tint prevIdx = j-1 ?left ==  polyline.elementPointers()[j]->x() : j+2;\r\n\t\t\t\t\t\t\t\t\t\tint removeCorner = 4;\r\n\t\t\t\t\t\t\t\t\t\tint storPt;\r\n\t\t\t\t\t\t\t\t\t\tint addFactor = -3;\r\n\r\n\t\t\t\t\t\t\t\t\t\tdouble x = polyline.elementPointers()[nextIdx]->x();\r\n\t\t\t\t\t\t\t\t\t\tdouble y = polyline.elementPointers()[currentIdx]->y();\r\n\r\n\r\n\t\t\t\t\t\t\t\t\t\t// handleALL(i,j,currentIdx,nextIdx,prevIdx, removeCorner, addFactor,\r\n\t\t\t\t\t\t\t\t\t\t// \tprimaryBox,secondaryBox,primaryId,secondaryId,isCentral, move,isRT, x,y);\r\n\r\n\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif (bboxRT.oldLeftBottom().x() > bboxLB.oldLeftBottom().x()) {\r\n\t\t\t\t\t\t\t\t\t\t//cerr << \"top rect is right \"<<endl;\r\n\r\n\t\t\t\t\t\t\t\t\t\t_passed = true;\r\n\t\t\t\t\t\t\t\t\t\tpolyline.elementPointers()[j]->inLocalMove()=true;\r\n\t\t\t\t\t\t\t\t\t\t//cerr<< \"line i \"<< i <<\" central seg is within the two rects widths\" << endl;\r\n\t\t\t\t\t\t\t\t\t\tbool isCentral = true;\r\n\t\t\t\t\t\t\t\t\t\t//line is going up or down\r\n\r\n\t\t\t\t\t\t\t\t\t\tint currentIdx = j ?left ==  polyline.elementPointers()[j]->x(): j+1;\r\n\t\t\t\t\t\t\t\t\t\tint nextIdx = j+1 ?left ==  polyline.elementPointers()[j]->x() : j;\r\n\t\t\t\t\t\t\t\t\t\tint prevIdx = j+2 ? left ==  polyline.elementPointers()[j]->x() : j-1;\r\n\t\t\t\t\t\t\t\t\t\tint removeCorner = 3;\r\n\t\t\t\t\t\t\t\t\t\tint storPt;\r\n\t\t\t\t\t\t\t\t\t\tint addFactor = -1;\r\n\r\n\t\t\t\t\t\t\t\t\t\tdouble x = polyline.elementPointers()[currentIdx]->x();\r\n\t\t\t\t\t\t\t\t\t\tdouble y = polyline.elementPointers()[nextIdx]->y();\r\n\r\n\r\n\t\t\t\t\t\t\t\t\t\t// handleALL(i,j,currentIdx,nextIdx,prevIdx, removeCorner, addFactor,\r\n\t\t\t\t\t\t\t\t\t\t// \tprimaryBox,secondaryBox,primaryId,secondaryId,isCentral, move,isRT, x,y);\r\n\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse if (bboxRT.oldWidth() > bboxLB.oldWidth()) {\r\n\t\t\t\t\t\t\t\t//cerr << \"the bottom rect is smaller \"<<endl;\r\n\t\t\t\t\t\t\t\tbool isRT = true;\r\n\t\t\t\t\t\t\t\t//primary box is the smaller\r\n\t\t\t\t\t\t\t\tKeiRo::Base::Rectangle2 primaryBox = bboxLB;\r\n\t\t\t\t\t\t\t\tKeiRo::Base::Rectangle2 secondaryBox = bboxRT;\r\n\t\t\t\t\t\t\t\tunsigned int primaryId = move.beforeLeftBottomID();\r\n\t\t\t\t\t\t\t\tunsigned int secondaryId = move.beforeRightTopID();\r\n\r\n\t\t\t\t\t\t\t\t//order the points of the segment (left to right)\r\n\t\t\t\t\t\t\t\tdouble left = std::min(polyline.elementPointers()[j]->x(), polyline.elementPointers()[j+1]->x());\r\n\t\t\t\t\t\t\t\tdouble right = std::max(polyline.elementPointers()[j]->x(), polyline.elementPointers()[j+1]->x());\r\n\t\t\t\t\t\t\t\tif ((left == primaryBox.oldLeftBottom().x()   && right <= primaryBox.oldLeftBottom().x() + primaryBox.oldWidth() )\r\n\t\t\t\t\t\t\t\t|| (left >= primaryBox.oldLeftBottom().x()  && right == primaryBox.oldLeftBottom().x()+primaryBox.oldWidth())) {\r\n\t\t\t\t\t\t\t\t\tif (bboxRT.oldLeftBottom().x() == bboxLB.oldLeftBottom().x()) {\r\n\t\t\t\t\t\t\t\t\t\t//cerr << \"bottom rect is left \"<<endl;\r\n\t\t\t\t\t\t\t\t\t\t_passed = true;\r\n\t\t\t\t\t\t\t\t\t\tpolyline.elementPointers()[j]->inLocalMove()=true;\r\n\t\t\t\t\t\t\t\t\t\t//cerr<< \"line i \"<< i <<\" central seg is within the two rects widths\" << endl;\r\n\t\t\t\t\t\t\t\t\t\tbool isCentral = true;\r\n\t\t\t\t\t\t\t\t\t\t//line is going right or left\r\n\t\t\t\t\t\t\t\t\t\tint currentIdx = j ? left ==  polyline.elementPointers()[j]->x() : j+1;\r\n\t\t\t\t\t\t\t\t\t\tint nextIdx = j+1 ? left ==  polyline.elementPointers()[j]->x() : j;\r\n\t\t\t\t\t\t\t\t\t\tint prevIdx = j-1 ? left ==  polyline.elementPointers()[j]->x() : j+2;\r\n\t\t\t\t\t\t\t\t\t\tint removeCorner = 1;\r\n\t\t\t\t\t\t\t\t\t\tint storPt;\r\n\t\t\t\t\t\t\t\t\t\tint addFactor = +3;\r\n\r\n\t\t\t\t\t\t\t\t\t\tdouble x = polyline.elementPointers()[nextIdx]->x();\r\n\t\t\t\t\t\t\t\t\t\tdouble y = polyline.elementPointers()[currentIdx]->y();\r\n\r\n\r\n\t\t\t\t\t\t\t\t\t\t// handleALL(i,j,currentIdx,nextIdx,prevIdx, removeCorner, addFactor,\r\n\t\t\t\t\t\t\t\t\t\t// \tprimaryBox,secondaryBox,primaryId,secondaryId,isCentral, move,isRT, x,y);\r\n\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif (bboxRT.oldLeftBottom().x() < bboxLB.oldLeftBottom().x()) {\r\n\t\t\t\t\t\t\t\t\t\t//cerr << \"bottom rect is right \"<<endl;\r\n\t\t\t\t\t\t\t\t\t\t_passed = true;\r\n\t\t\t\t\t\t\t\t\t\tpolyline.elementPointers()[j]->inLocalMove()=true;\r\n\t\t\t\t\t\t\t\t\t\t//cerr<< \"line i \"<< i <<\" central seg is within the two rects widths\" << endl;\r\n\t\t\t\t\t\t\t\t\t\tbool isCentral = true;\r\n\t\t\t\t\t\t\t\t\t\t//line is going right or left\r\n\r\n\t\t\t\t\t\t\t\t\t\tint currentIdx = j ? left ==  polyline.elementPointers()[j]->x() : j+1;\r\n\t\t\t\t\t\t\t\t\t\tint nextIdx = j+1 ? left ==  polyline.elementPointers()[j]->x() : j;\r\n\t\t\t\t\t\t\t\t\t\tint prevIdx = j+2 ? left ==  polyline.elementPointers()[j]->x() : j-1;\r\n\t\t\t\t\t\t\t\t\t\tint removeCorner = 2;\r\n\t\t\t\t\t\t\t\t\t\tint storPt;\r\n\t\t\t\t\t\t\t\t\t\tint addFactor = 1;\r\n\r\n\t\t\t\t\t\t\t\t\t\tdouble x = polyline.elementPointers()[currentIdx]->x();\r\n\t\t\t\t\t\t\t\t\t\tdouble y = polyline.elementPointers()[nextIdx]->y();\r\n\r\n\r\n\t\t\t\t\t\t\t\t\t\t// handleALL(i,j,currentIdx,nextIdx,prevIdx, removeCorner, addFactor,\r\n\t\t\t\t\t\t\t\t\t\t// \tprimaryBox,secondaryBox,primaryId,secondaryId,isCentral, move,isRT, x,y);\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tvoid HierarchicalPath::checkPrevious (int i,int currentIdx,int prevIdx,\r\n\t\tKeiRo::Base::Rectangle2 primaryBox,unsigned int primaryId,int removeCorner, int addFactor, bool isRT)\r\n\t{\r\n\t\tKeiRo::Base::Line2 &polyline = _polylineVec[i];\r\n\t\t//if (isRT)\r\n\t\t{\r\n\t\t\tif (polyline.elementPointers()[prevIdx]->x() < polyline.elementPointers()[currentIdx]->x()) {\r\n\t\t\t\t//nothing\r\n\t\t\t\t//cerr << \"nothing \"<<endl;\r\n\t\t\t\t//check the level of prev only\r\n\t\t\t\tif (_conjunctionMat[i][prevIdx].level != _conjunctionMat[i][currentIdx].level) {\r\n\r\n\t\t\t\t\t_conjunctionMat[i][prevIdx].level = _conjunctionMat[i][currentIdx].level;\r\n\t\t\t\t\t_conjunctionMat[i][prevIdx].treemapID.clear();\r\n\t\t\t\t\t_conjunctionMat[i][prevIdx].pointType.clear();\r\n\t\t\t\t\t_conjunctionMat[i][prevIdx].treemapID.push_back(primaryId);\r\n\t\t\t\t\t_conjunctionMat[i][prevIdx].pointType.push_back(pointTypes[removeCorner ]);\r\n\t\t\t\t\t//stepBack = true;\r\n\t\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd = vertex(primaryId, _metadataPtr->graphmlTree());\r\n\t\t\t\t\tKeiRo::Base::Rectangle2& rect = *_metadataPtr->graphmlTree()[vd].boundingBoxPtr;\r\n\r\n\t\t\t\t\tswitch (pointTypes[removeCorner]) {\r\n\t\t\t\t\t\tcase POINT_LEFTBOTTOM:\r\n\t\t\t\t\t\t\tpolyline.elementPointers()[prevIdx]->x() = rect.leftBottom().x();\r\n\t\t\t\t\t\tpolyline.elementPointers()[prevIdx]->y() = rect.leftBottom().y();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase POINT_RIGHTBOTTOM:\r\n\t\t\t\t\t\t\tpolyline.elementPointers()[prevIdx]->x() = rect.leftBottom().x() + rect.width();\r\n\t\t\t\t\t\tpolyline.elementPointers()[prevIdx]->y() = rect.leftBottom().y();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase POINT_RIGHTTOP:\r\n\t\t\t\t\t\t\tpolyline.elementPointers()[prevIdx]->x() = rect.leftBottom().x() + rect.width();\r\n\t\t\t\t\t\tpolyline.elementPointers()[prevIdx]->y() = rect.leftBottom().y() + rect.height();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase POINT_LEFTTOP:\r\n\t\t\t\t\t\t\tpolyline.elementPointers()[prevIdx]->x() = rect.leftBottom().x();\r\n\t\t\t\t\t\tpolyline.elementPointers()[prevIdx]->y() = rect.leftBottom().y() + rect.height();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (polyline.elementPointers()[prevIdx]->x() > polyline.elementPointers()[currentIdx]->x()) {\r\n\t\t\t\t//Duplicate\r\n\t\t\t\t//cerr <<\"duplicate \"<<endl;\r\n\t\t\t\t//remove one\r\n\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t//add point\r\n\t\t\t\t//cerr<<\"add point \"<<endl;\r\n\t\t\t\tdouble x,y;\r\n\t\t\t\tx = polyline.elementPointers()[currentIdx]->x();\r\n\t\t\t\ty = polyline.elementPointers()[currentIdx]->y();\r\n\t\t\t\taddNewVertex(i,currentIdx,{primaryId},currentIdx,CONJUNCTION_NOTYPE,{POINT_NOTYPE},x,y);\r\n\t\t\t}\r\n\t\t}\r\n\t\t// else {\r\n\t\t// \tif (polyline.elementPointers()[prevIdx]->x() > polyline.elementPointers()[currentIdx]->x()) {\r\n\t\t// \t\t//nothing\r\n\t\t// \t\tcerr << \"nothing \"<<endl;\r\n\t\t// \t\t//check the level of prev only\r\n\t\t// \t\tif (_conjunctionMat[i][prevIdx].level != _conjunctionMat[i][currentIdx].level) {\r\n\t\t//\r\n\t\t// \t\t\t_conjunctionMat[i][prevIdx].level = _conjunctionMat[i][currentIdx].level;\r\n\t\t// \t\t\t_conjunctionMat[i][prevIdx].treemapID.clear();\r\n\t\t// \t\t\t_conjunctionMat[i][prevIdx].pointType.clear();\r\n\t\t// \t\t\t_conjunctionMat[i][prevIdx].treemapID.push_back(primaryId);\r\n\t\t// \t\t\t_conjunctionMat[i][prevIdx].pointType.push_back(pointTypes[removeCorner]);\r\n\t\t// \t\t\tGraph::TreeDirectedGraph::vertex_descriptor vd = vertex(primaryId, _metadataPtr->graphmlTree());\r\n\t\t// \t\t\tKeiRo::Base::Rectangle2& rect = *_metadataPtr->graphmlTree()[vd].boundingBoxPtr;\r\n\t\t// \t\t\t//stepBack = true;\r\n\t\t//\r\n\t\t// \t\t\tswitch (pointTypes[removeCorner]) {\r\n\t\t// \t\t\t\tcase POINT_LEFTBOTTOM:\r\n\t\t// \t\t\t\t\tpolyline.elementPointers()[prevIdx]->x() = rect.leftBottom().x();\r\n\t\t// \t\t\t\tpolyline.elementPointers()[prevIdx]->y() = rect.leftBottom().y();\r\n\t\t// \t\t\t\tbreak;\r\n\t\t// \t\t\t\tcase POINT_RIGHTBOTTOM:\r\n\t\t// \t\t\t\t\tpolyline.elementPointers()[prevIdx]->x() = rect.leftBottom().x() + rect.width();\r\n\t\t// \t\t\t\tpolyline.elementPointers()[prevIdx]->y() = rect.leftBottom().y();\r\n\t\t// \t\t\t\tbreak;\r\n\t\t// \t\t\t\tcase POINT_RIGHTTOP:\r\n\t\t// \t\t\t\t\tpolyline.elementPointers()[prevIdx]->x() = rect.leftBottom().x() + rect.width();\r\n\t\t// \t\t\t\tpolyline.elementPointers()[prevIdx]->y() = rect.leftBottom().y() + rect.height();\r\n\t\t// \t\t\t\tbreak;\r\n\t\t// \t\t\t\tcase POINT_LEFTTOP:\r\n\t\t// \t\t\t\t\tpolyline.elementPointers()[prevIdx]->x() = rect.leftBottom().x();\r\n\t\t// \t\t\t\tpolyline.elementPointers()[prevIdx]->y() = rect.leftBottom().y() + rect.height();\r\n\t\t// \t\t\t\tbreak;\r\n\t\t// \t\t\t}\r\n\t\t//\r\n\t\t//\r\n\t\t// \t\t}\r\n\t\t// \t}\r\n\t\t// \telse if (polyline.elementPointers()[prevIdx]->x() < polyline.elementPointers()[currentIdx]->x()) {\r\n\t\t// \t\t//Duplicate\r\n\t\t// \t\tcerr <<\"duplicate \"<<endl;\r\n\t\t// \t\t//remove one\r\n\t\t//\r\n\t\t// \t}\r\n\t\t// \telse {\r\n\t\t// \t\t//add point\r\n\t\t// \t\tcerr<<\"add point \"<<endl;\r\n\t\t// \t\tdouble x,y;\r\n\t\t// \t\tx = polyline.elementPointers()[currentIdx]->x();\r\n\t\t// \t\ty = polyline.elementPointers()[currentIdx]->y();\r\n\t\t// \t\taddNewVertex(i,currentIdx,{primaryId},currentIdx,CONJUNCTION_NOTYPE,{POINT_NOTYPE},x,y);\r\n\t\t// \t}\r\n\t\t// }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\t}\r\n\tvoid HierarchicalPath::handleALL(int i, int j, int currentIdx, int nextIdx, int PrevIdx, int Corner, int addFactor,\r\n\t\tKeiRo::Base::Rectangle2 primamryBox, KeiRo::Base::Rectangle2 secondaryBox, unsigned int primaryId,\r\n\t\tunsigned int secondaryId, bool isCenteralSeg, LocalMove moveType, bool isDR,double x, double y) {\r\n\r\n\t\tKeiRo::Base::Line2 &polyline = _polylineVec[i];\r\n\t\tint storPt;\r\n\r\n\t\tif (isCenteralSeg) {\r\n\r\n\t\t\tif (_conjunctionMat[i][PrevIdx].level != _conjunctionMat[i][currentIdx].level)\r\n\t\t\t\tcheckPrevious(i,currentIdx,PrevIdx,primamryBox,primaryId,Corner,addFactor,isDR);\r\n\r\n\t\t\tif (_conjunctionMat[i][nextIdx].conjunctionType == CONJUNCTION_CORNER &&\r\n\t\t\t\t_conjunctionMat[i][currentIdx].conjunctionType == CONJUNCTION_CORNER) {\r\n\r\n\t\t\t\tremoveConj(i, secondaryId, currentIdx, Corner);\r\n\r\n\t\t\t\t//the index of the primaryid in the itemID vector\r\n\t\t\t\tauto it = std::find(_conjunctionMat[i][nextIdx].treemapID.begin(), _conjunctionMat[i][nextIdx].treemapID.end(), primaryId);\r\n\t\t\t\tint storeIdx = std::distance(_conjunctionMat[i][nextIdx].treemapID.begin(), it);\r\n\r\n\t\t\t\tstorPt = _conjunctionMat[i][nextIdx].pointType[storeIdx];\r\n\r\n\t\t\t\t_conjunctionMat[i][nextIdx].treemapID.clear();\r\n\t\t\t\t_conjunctionMat[i][nextIdx].pointType.clear();\r\n\r\n\t\t\t\taddConj(i,secondaryId,nextIdx,pointTypes[Corner]);\r\n\r\n\t\t\t\t//add new point\r\n\t\t\t\tvector<unsigned int> ids ;\r\n\t\t\t\tvector< POINTTYPE> pt;\r\n\r\n\t\t\t\tids.push_back(primaryId);\r\n\t\t\t\tpt.push_back((pointTypes[storPt]));\r\n\r\n\t\t\t\tids.push_back(secondaryId);\r\n\t\t\t\tpt.push_back((pointTypes[Corner + addFactor]));\r\n\r\n\t\t\t\taddNewVertex(i,j,ids,j+1,CONJUNCTION_CORNER,pt,x,y);\r\n\r\n\r\n\t\t\t\taddConj ( i,  primaryId,  j+1,  pointTypes[storPt]);\r\n\t\t\t\taddConj ( i,  secondaryId,  j+1,  pointTypes[Corner + addFactor]);\r\n\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\telse if (_conjunctionMat[i][currentIdx].conjunctionType == CONJUNCTION_NONCORNER &&\r\n\t\t\t\t_conjunctionMat[i][nextIdx].conjunctionType == CONJUNCTION_CORNER ) {\r\n\r\n\t\t\t\tif (_conjunctionMat[i][currentIdx].treemapID[0] == secondaryId) {\r\n\r\n\t\t\t\t\tfor (int s = 0 ; s< _conjunctionMat[i][nextIdx].treemapID.size();s++) {\r\n\t\t\t\t\t\tif (_conjunctionMat[i][nextIdx].treemapID[s] == primaryId) {\r\n\t\t\t\t\t\t\tremoveConj(i,  primaryId, nextIdx, pointTypes[s]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if (_conjunctionMat[i][currentIdx].treemapID[0] == primaryId) {\r\n\r\n\r\n\t\t\t\t\t// _conjunctionMat[i][nextIdx].treemapID.clear();\r\n\t\t\t\t\t// _conjunctionMat[i][nextIdx].pointType.clear();\r\n\t\t\t\t\taddConj(i,secondaryId,nextIdx,pointTypes[Corner]);\r\n\r\n\t\t\t\t\tfor (int s = 0 ; s< _conjunctionMat[i][nextIdx].treemapID.size();s++) {\r\n\t\t\t\t\t\tif (_conjunctionMat[i][nextIdx].treemapID[s] == primaryId) {\r\n\t\t\t\t\t\t\tstorPt = _conjunctionMat[i][nextIdx].pointType[s];\r\n\t\t\t\t\t\t\tremoveConj(i,  primaryId, nextIdx, pointTypes[s]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t_conjunctionMat[i][nextIdx].treemapID.clear();\r\n\t\t\t\t\t_conjunctionMat[i][nextIdx].pointType.clear();\r\n\t\t\t\t\taddConj(i,secondaryId,nextIdx,pointTypes[Corner]);\r\n\t\t\t\t\t// for (int s = 0 ; s< _conjunctionMat[i][nextIdx].treemapID.size();s++) {\r\n\t\t\t\t\t// \tcerr << _conjunctionMat[i][nextIdx].treemapID[s]<<\":\"<<_conjunctionMat[i][nextIdx].pointType[s] <<\"\\t\";\r\n\t\t\t\t\t// }\r\n\t\t\t\t\t// cerr<<endl;\r\n\r\n\t\t\t\t\t//add new point\r\n\t\t\t\t\tvector<unsigned int> ids ;\r\n\t\t\t\t\tvector< POINTTYPE> pt;\r\n\r\n\r\n\t\t\t\t\tids.push_back(primaryId);\r\n\t\t\t\t\tpt.push_back((pointTypes[storPt]));\r\n\r\n\t\t\t\t\tids.push_back(secondaryId);\r\n\t\t\t\t\tpt.push_back((pointTypes[Corner + addFactor]));\r\n\r\n\t\t\t\t\taddNewVertex(i,j,ids,j+1,CONJUNCTION_CORNER,pt,x,y);\r\n\t\t\t\t\t_skip = true;\r\n\r\n\r\n\r\n\r\n\r\n#ifdef noncorner\r\n\t\t\t\t\t//add two points\r\n\t\t\t\t\tvector<unsigned int> ids1,ids2 ;\r\n\t\t\t\t\tvector< POINTTYPE> pt1,pt2;\r\n\r\n\t\t\t\t\tids1.push_back(moveType.beforeRightTopID());\r\n\t\t\t\t\tpt1.push_back((POINT_LEFTTOP));\r\n\r\n\r\n\t\t\t\t\tdouble x1 = bboxRT.leftBottom().x() ;\r\n\t\t\t\t\tdouble y1 = bboxRT.leftBottom().y() + bboxRT.height();\r\n\r\n\r\n\t\t\t\t\tids2.push_back(moveType.beforeLeftBottomID());\r\n\t\t\t\t\tpt2.push_back((POINT_RIGHTBOTTOM));\r\n\t\t\t\t\tids2.push_back(moveType.beforeRightTopID());\r\n\t\t\t\t\tpt2.push_back((POINT_RIGHTTOP));\r\n\r\n\t\t\t\t\tdouble x2 = bboxRT.leftBottom().x()+bboxRT.width();\r\n\t\t\t\t\tdouble y2 = bboxLB.leftBottom().y();\r\n\r\n\t\t\t\t\tif (isGoingDown) {\r\n\t\t\t\t\t\taddNewVertex(i,j,ids1,j+1,CONJUNCTION_CORNER, pt1,x1 ,y1);\r\n\t\t\t\t\t\taddNewVertex(i,j,ids2,j+1,CONJUNCTION_CORNER, pt2, x2,y2);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\r\n\t\t\t\t\t\taddNewVertex(i,j,ids2,j+1,CONJUNCTION_CORNER, pt2, x2,y2);\r\n\t\t\t\t\t\taddNewVertex(i,j,ids1,j+1,CONJUNCTION_CORNER, pt1,x1 ,y1);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n#endif\r\n\r\n\t\t}\r\n\t\telse if (!isCenteralSeg) {\r\n\t\t\t//cerr <<i<<\"bottom seg\"<<endl;\r\n#ifdef notCenteral\r\n\t\t\tif (isGoingDown) {\r\n\t\t\t\tif (_conjunctionMat[i][currentIndex].conjunctionType == CONJUNCTION_CORNER &&\r\n\t\t\t\t_conjunctionMat[i][nextIndex].conjunctionType == CONJUNCTION_CORNER) {\r\n\t\t\t\t\tremoveConj (i, moveType.beforeLeftBottomID(), currentIndex, 2) ;\r\n\t\t\t\t\taddConj ( i,  moveType.beforeRightTopID(),  currentIndex,  POINT_LEFTTOP);\r\n\t\t\t\t\t//no added point, already done with top segment\r\n\t\t\t\t}\r\n\t\t\t\telse if (_conjunctionMat[i][currentIndex].conjunctionType == CONJUNCTION_CORNER &&\r\n\t\t\t\t_conjunctionMat[i][nextIndex].conjunctionType == CONJUNCTION_NONCORNER) {\r\n\t\t\t\t\t//path ends\r\n\t\t\t\t\tif (_conjunctionMat[i][nextIndex].treemapID[0] == moveType.beforeRightTopID()) {\r\n\t\t\t\t\t\t_conjunctionMat[i][currentIndex].treemapID.clear();\r\n\t\t\t\t\t\t_conjunctionMat[i][currentIndex].pointType.clear();\r\n\t\t\t\t\t\taddConj ( i,  moveType.beforeRightTopID(),  currentIndex,  POINT_RIGHTTOP);\r\n\t\t\t\t\t\taddConj ( i,  moveType.beforeLeftBottomID(),  currentIndex,  POINT_RIGHTBOTTOM);\r\n\r\n\r\n\t\t\t\t\t\t//add one point\r\n\t\t\t\t\t\tvector<unsigned int> ids ;\r\n\t\t\t\t\t\tvector< POINTTYPE> pt;\r\n\r\n\t\t\t\t\t\tids.push_back(moveType.beforeRightTopID());\r\n\t\t\t\t\t\tpt.push_back((POINT_LEFTTOP));\r\n\t\t\t\t\t\tdouble x = bboxRT.leftBottom().x() ;\r\n\t\t\t\t\t\tdouble y = bboxRT.leftBottom().y() + bboxRT.height();\r\n\t\t\t\t\t\taddNewVertex(i,j,ids,currentIndex,CONJUNCTION_CORNER, pt,x ,y);\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n#endif\r\n\r\n\t\t}\r\n\t}\r\n\telse if (_conjunctionMat[i][currentIdx].conjunctionType == CONJUNCTION_CORNER &&\r\n\t\t\t\t_conjunctionMat[i][nextIdx].conjunctionType == CONJUNCTION_NONCORNER) {\r\n\t\tremoveConj(i,secondaryId,currentIdx,Corner);\r\n\r\n\r\n\r\n\t\t//the index of the primaryid in the itemID vector\r\n\t\tauto it = std::find(_conjunctionMat[i][currentIdx].treemapID.begin(), _conjunctionMat[i][currentIdx].treemapID.end(), primaryId);\r\n\t\tint storeIdx = std::distance(_conjunctionMat[i][currentIdx].treemapID.begin(), it);\r\n\r\n\t\tstorPt = _conjunctionMat[i][currentIdx].pointType[storeIdx];\r\n\r\n\t\tvector<unsigned int> ids1,ids2 ;\r\n\t\tvector< POINTTYPE> pt1,pt2;\r\n\r\n\t\tids1.push_back(primaryId);\r\n\t\tpt1.push_back(pointTypes[storPt+addFactor]);\r\n\t\tids1.push_back(secondaryId);\r\n\t\tpt1.push_back((pointTypes[Corner+addFactor]));\r\n\t\tdouble x1 = x ;\r\n\t\tdouble y1 = y;\r\n\r\n\t\tids2.push_back(secondaryId);\r\n\t\tpt2.push_back((pointTypes[Corner]));\r\n\t\tdouble x2 = secondaryBox.leftBottom().x();\r\n\t\tdouble y2 = y;\r\n\r\n\r\n\r\n\t\tif (isDR) {\r\n\t\t\taddNewVertex(i,j,ids2,j+1,CONJUNCTION_CORNER,pt2,x2,y2);\r\n\t\t\taddNewVertex(i,j,ids1,j+1,CONJUNCTION_CORNER,pt1,x1,y1);\r\n\t\t}\r\n\t\telse {\r\n\t\t\taddNewVertex(i,j,ids1,j+1,CONJUNCTION_CORNER,pt1,x1,y1);\r\n\t\t\t// for (int s = 0 ; s< _conjunctionMat[i][j+1].treemapID.size();s++) {\r\n\t\t\t// \t\tcerr <<  _conjunctionMat[i][j+1].treemapID[s]<<\":\"<<_conjunctionMat[i][j+1].pointType[s] ;\r\n\t\t\t// \t}\r\n\t\t\t// cerr<<endl;\r\n\r\n\t\t\taddNewVertex(i,j,ids2,j+1,CONJUNCTION_CORNER,pt2,x2,y2);\r\n\t\t}\r\n\r\n\t\t_skip = true;\r\n\r\n\r\n\t\t// _conjunctionMat[i][nextIdx].treemapID.clear();\r\n\t\t// _conjunctionMat[i][nextIdx].pointType.clear();\r\n\t\t// addConj(i,secondaryId,nextIdx,pointTypes[Corner]);\r\n\r\n\t}\r\n}\r\n}\r\n\r\n    void HierarchicalPath::update_previous_up(int i, double top, int curr, int prev, unsigned int id, bool add) {\r\n\t\t\tdouble eps = 0.001;\r\n\t\t\tKeiRo::Base::Line2 &polyline = _polylineVec[i];\r\n\t\t\t// cerr << \" polyline in update \"<< endl;\r\n\t\t\t// print_path(i);\r\n\t\t\tif (_conjunctionMat[i][prev].conjunctionType == CONJUNCTION_CORNER) {\r\n\t\t\t\t//check the previous point 3 cases\r\n\t\t\t\tif (polyline.elementPointers()[prev]->y() < polyline.elementPointers()[curr]->y()  &&\r\n\t\t\t\t\tpolyline.elementPointers()[prev]->x() > polyline.elementPointers()[curr]->x()) { //add point\r\n\t\t\t\t\t//cerr << \"the prev point is at right \" << polyline.elementPointers()[prev]->x() << \"    \" << polyline.elementPointers()[curr]->x()<<endl;\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\telse if (polyline.elementPointers()[prev]->y() < polyline.elementPointers()[curr]->y() &&\r\n\t\t\t\t\tpolyline.elementPointers()[prev]->x() < polyline.elementPointers()[curr]->x()) { //duplicate\r\n\t\t\t\t\t//cerr << \"the prev point is at left \" << endl;\r\n\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\telse if (polyline.elementPointers()[prev]->y() < polyline.elementPointers()[curr]->y() &&\r\n\t\t\t\t\tpolyline.elementPointers()[prev]->x() == polyline.elementPointers()[curr]->x())//&&\r\n\t\t\t\t\t//polyline.elementPointers()[prev]->x() == polyline.elementPointers()[curr]->x())\r\n\t\t\t\t\t\t//\r\n\t\t\t\t{ //add new point in middle way\r\n\t\t\t\t\t//cerr << \"the prev point is at bottom- same y \" << endl;\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n    void HierarchicalPath::update_next_up(int i, double top, int curr, int next, unsigned int id,bool add) {\r\n\t\t\tdouble eps = 0.001;\r\n\t\t\tKeiRo::Base::Line2 &polyline = _polylineVec[i];\r\n\r\n\t\t\tif (_conjunctionMat[i][next].conjunctionType == CONJUNCTION_CORNER) {\r\n\t\t\t\t//check the next point 3 cases\r\n\t\t\t\tif (polyline.elementPointers()[next]->y() - polyline.elementPointers()[curr]->y() <=eps &&\r\n\t\t\t\t\tpolyline.elementPointers()[next]->x() > polyline.elementPointers()[curr]->x()) { //add point\r\n\r\n\r\n\t\t\t\t\t//if(add)\r\n\t\t\t\t\t//addNewVertex(i,curr,id,curr,CONJUNCTION_CORNER);\r\n\t\t\t\t\t//addNewVertex(i,curr,id,curr,CONJUNCTION_CORNER);\r\n\t\t\t\t\t//else {\r\n\t\t\t\t\t// _conjunctionMat[i][next].treemapID = id;\r\n\t\t\t\t\t// _conjunctionMat[i][next].pointType = POINT_RIGHTBOTTOM; // not correct jsut to show\r\n\t\t\t\t\t//}\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\telse if (polyline.elementPointers()[next]->y() - polyline.elementPointers()[curr]->y() <=eps &&\r\n\t\t\t\t\tpolyline.elementPointers()[next]->x() < polyline.elementPointers()[curr]->x()) { //duplicate\r\n\t\t\t\t\t//cerr <<\"next point at left \"<< endl;\r\n\t\t\t\t\t// _conjunctionMat[i][next].treemapID = id;\r\n\t\t\t\t\t// _conjunctionMat[i][next].pointType = POINT_LEFTBOTTOM; //duplicate\r\n\t\t\t\t\t}\r\n\t\t\t\telse if (polyline.elementPointers()[next]->y() != polyline.elementPointers()[curr]->y()) { //add new point in middle\r\n\r\n\t\t\t\t\t//cerr << \"next point at same y \" <<endl;\r\n\t\t\t\t\t// _conjunctionMat[i][next].treemapID = id;\r\n\t\t\t\t\t// _conjunctionMat[i][next].pointType =POINT_RIGHTBOTTOM; //not correct i should add point\r\n\t\t\t\t\t// if (_conjunctionMat[i][next].treemapID != id)\r\n\t\t\t\t\t// \t//addNewVertex(i,curr,_conjunctionMat[i][next].treemapID,curr,CONJUNCTION_CORNER); //it can be a corner of above rect???\r\n\t\t\t\t\t// else\r\n\t\t\t\t\t// \t//addNewVertex(i,curr,id,curr,CONJUNCTION_NONCORNER); //it can be a corner of above rect???\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n    \tvoid HierarchicalPath::update_next_down(int i, double top, int curr, int next, unsigned int id,bool add) {\r\n\t\t\tdouble eps = 0.001;\r\n\t\t\tKeiRo::Base::Line2 &polyline = _polylineVec[i];\r\n\t\t\t\r\n\t\t\tif (_conjunctionMat[i][next].conjunctionType == CONJUNCTION_CORNER) {\r\n\t\t\t\t//check the next point 3 cases\r\n\t\t\t\t//cerr << \" next point is at right \"<<endl;\r\n\t\t\t\tif (polyline.elementPointers()[next]->y() - polyline.elementPointers()[curr]->y() <=eps &&\r\n\t\t\t\t\tpolyline.elementPointers()[next]->x() > polyline.elementPointers()[curr]->x()) { //add point\r\n\r\n\r\n\t\t\t\t\t//if(add)\r\n\t\t\t\t\t//addNewVertex(i,curr,id,curr,CONJUNCTION_CORNER);\r\n\t\t\t\t\t//addNewVertex(i,curr,id,curr,CONJUNCTION_CORNER);\r\n\t\t\t\t\t//else {\r\n\t\t\t\t\t// _conjunctionMat[i][next].treemapID = id;\r\n\t\t\t\t\t// _conjunctionMat[i][next].pointType = POINT_RIGHTBOTTOM; // not correct jsut to show\r\n\t\t\t\t\t//}\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\telse if (polyline.elementPointers()[next]->y() - polyline.elementPointers()[curr]->y() <=eps &&\r\n\t\t\t\t\tpolyline.elementPointers()[next]->x() < polyline.elementPointers()[curr]->x()) { //duplicate\r\n\t\t\t\t\t//cerr <<\"next point at left \"<< endl;\r\n\t\t\t\t\t// _conjunctionMat[i][next].treemapID = id;\r\n\t\t\t\t\t// _conjunctionMat[i][next].pointType = POINT_LEFTBOTTOM; //duplicate\r\n\t\t\t\t\t}\r\n\t\t\t\telse if (polyline.elementPointers()[next]->y() != polyline.elementPointers()[curr]->y()) { //add new point in middle\r\n\r\n\t\t\t\t\t//cerr << \"next point at same y \" <<endl;\r\n\t\t\t\t\t// _conjunctionMat[i][next].treemapID = id;\r\n\t\t\t\t\t// _conjunctionMat[i][next].pointType =POINT_RIGHTBOTTOM; //not correct i should add point\r\n\t\t\t\t\t// if (_conjunctionMat[i][next].treemapID != id)\r\n\t\t\t\t\t// \t//addNewVertex(i,curr,_conjunctionMat[i][next].treemapID,curr,CONJUNCTION_CORNER); //it can be a corner of above rect???\r\n\t\t\t\t\t// else\r\n\t\t\t\t\t// \t//addNewVertex(i,curr,id,curr,CONJUNCTION_NONCORNER); //it can be a corner of above rect???\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}\r\n\tvoid HierarchicalPath::removeConj (int i, unsigned int id, int pos, int p) {\r\n\r\n    \t// for (int s = 0; s<_conjunctionMat[i][pos].treemapID.size();s++) {\r\n    \t// \tcerr << _conjunctionMat[i][pos].treemapID[s]<<\":\"<< _conjunctionMat[i][pos].pointType[s]<<\"\\t\";\r\n\t    //\r\n    \t// }\r\n\r\n    \t_conjunctionMat[i][pos].treemapID.erase(std::remove(_conjunctionMat[i][pos].treemapID.begin(), _conjunctionMat[i][pos].treemapID.end(), id), _conjunctionMat[i][pos].treemapID.end());\r\n    \t_conjunctionMat[i][pos].pointType.erase(std::remove(_conjunctionMat[i][pos].pointType.begin(), _conjunctionMat[i][pos].pointType.end(), p), _conjunctionMat[i][pos].pointType.end());\r\n\r\n    \t// for (int s = 0; s<_conjunctionMat[i][pos].treemapID.size();s++) {\r\n    \t// \tcerr << _conjunctionMat[i][pos].treemapID[s]<<\":\"<< _conjunctionMat[i][pos].pointType[s]<<\"\\t\";\r\n    \t// }\r\n    \t// cerr<<endl;\r\n\r\n    }\r\n\tvoid HierarchicalPath::addConj (int i, unsigned int id, int pos, POINTTYPE p) {\r\n\r\n    \t// for (int s = 0; s<_conjunctionMat[i][pos].treemapID.size();s++) {\r\n    \t// \tcerr << _conjunctionMat[i][pos].treemapID[s]<<\":\"<< _conjunctionMat[i][pos].pointType[s]<<\"\\t\";\r\n\t    //\r\n    \t// }\r\n\r\n    \t_conjunctionMat[i][pos].treemapID.push_back(id);\r\n\t\t_conjunctionMat[i][pos].pointType.push_back(p);\r\n\r\n\r\n    \t// for (int s = 0; s<_conjunctionMat[i][pos].treemapID.size();s++) {\r\n    \t// \tcerr << _conjunctionMat[i][pos].treemapID[s]<<\":\"<< _conjunctionMat[i][pos].pointType[s]<<\"\\t\";\r\n    \t// }\r\n    \t// cerr<<endl;\r\n\r\n    }\r\n    void HierarchicalPath::addNewVertex (int i, int j, vector<unsigned int> id, int pos, CONJUNCTIONTYPE t, vector<POINTTYPE> p, double x,double y) {\r\n\tprint_path(i);\r\n\tif (i >= _polylineVec.size() || j >= _conjunctionMat[i].size()) {\r\n    \t\t//cerr << \"Error: Index out of bounds in addNewVertex\" << endl;\r\n    \t\treturn;\r\n    \t}\r\n\r\n    \tKeiRo::Base::Line2 &polyline = _polylineVec[i];\r\n\r\n    \t//cerr << \"conj size before: \" << _conjunctionMat[i][j].treemapID.size() << endl;\r\n\r\n    \t// Create new Coord2 object\r\n    \tauto* newCoord = new KeiRo::Base::Coord2(x, y);\r\n    \t//cerr << \"new coord \" << &newCoord << endl;\r\n\r\n    \t// Insert new coordinate\r\n    \tpolyline.elementPointers().insert(polyline.elementPointers().begin() + (j+1), newCoord);\r\n    \t//cerr << \"new point inserted into the polyline\" << endl;\r\n\r\n    \t// Create new Conjunction\r\n    \tConjunction newConj;\r\n    \tnewConj.level = _conjunctionMat[i][j].level;\r\n    \tnewConj.conjunctionType = CONJUNCTION_CORNER;\r\n    \tnewConj.treemapID = id;\r\n    \tnewConj.pointType = p;\r\n\r\n    \t// Insert new conjunction\r\n    \t_conjunctionMat[i].insert(_conjunctionMat[i].begin() + (j+1), newConj);\r\n\r\n    \t//cerr << \"conj size after: \" << _conjunctionMat[i][j+1].treemapID.size() << endl;\r\n    \t//cerr << \"new conj is added\" << endl;\r\n    \t//print_path(i);\r\n\r\n\r\n\r\n\t\t}\r\n\r\n\r\n    void HierarchicalPath::print_path( int i) {\r\n\t\t\tKeiRo::Base::Line2 &polyline = _polylineVec[i];\r\n\t\t\tcerr << \"print path \";\r\n\t\t\tfor (int s =0 ; s < polyline.elementPointers().size() ; s++) {\r\n\t\t\t\tcerr <<\"(\"<<polyline.elementPointers()[s]->x() <<\",\" << polyline.elementPointers()[s]->y() << \")\" << \"   \" ;\r\n\t\t\t}\r\n\t\t\tcerr <<endl;\r\n\r\n\t\t}\r\n\r\n    void HierarchicalPath::compute_shortest_path(unsigned int ids, unsigned int idt, unsigned int idgs, unsigned int idgt, int i) {\r\n\t\t\t// initialization\r\n\t\t\t//_polylineVec.clear();\r\n\t\t\t_hierarchicalPathVec.clear();\r\n\r\n\tKeiRo::Base::Line2 &oldPolyLine = _polylineVec[i];\r\n\t// variables\r\n\tGraph::TreeDirectedGraph    &graphmlTree    = _metadataPtr->graphmlTree();\r\n\tmultimap< KeiRo::Base::Common::UIDPair,\r\n\t\t\tKeiRo::Base::Common::UIDPair > &globalPath = _metadataPtr->graphmlGlobalPath();\r\n\tmap< unsigned int, Graph::BaseUndirectedGraph >  &graphmlGraphMap   = _metadataPtr->graphmlGraphMap();\r\n\r\n\tGraph::BaseUndirectedGraph & globalPathGraph = _compressedPathGraph.graph();\r\n\tGraph::PropertyGraph propG;\r\n\r\n\t\t\t// Property maps\r\n\t\t\tGraph::VertexIndexMap vertexIndex = get(vertex_index, propG);\r\n\t\t\tGraph::EdgeIndexMap edgeIndex = get(edge_index, propG);\r\n\t\t\tvector< double > unitWeight( num_edges( globalPathGraph ) );\r\n\r\n\t\t\tcerr << \" compute Shp!!\"<<endl;\r\n\t\t\t// Copy the vertices from globalPathGraph to propG\r\n\t\t\tBGL_FORALL_VERTICES(vd, globalPathGraph, Graph::BaseUndirectedGraph) {\r\n\t\t\t\tGraph::PropertyGraph::vertex_descriptor vdNew = add_vertex( propG );\r\n\t\t\t}\r\n\t\t\t//cerr << \" all vertices copied \"<<endl;\r\n\t\t\t//copy all the edges from globalPathGraph to propG\r\n\t\t\tBGL_FORALL_EDGES( ed, globalPathGraph, Graph::BaseUndirectedGraph ) {\r\n\r\n\t\t\t\tGraph::BaseUndirectedGraph::vertex_descriptor vdS = source( ed, globalPathGraph );\r\n\t\t\t\tGraph::BaseUndirectedGraph::vertex_descriptor vdT = target( ed, globalPathGraph );\r\n\t\t\t\tGraph::PropertyGraph::vertex_descriptor src = vertex( globalPathGraph[ vdS ].id, propG );\r\n\t\t\t\tGraph::PropertyGraph::vertex_descriptor tar = vertex( globalPathGraph[ vdT ].id, propG );\r\n\r\n\t\t\t\tpair< Graph::PropertyGraph::edge_descriptor, unsigned int > foreE = add_edge( src, tar, propG );\r\n\t\t\t\tGraph::PropertyGraph::edge_descriptor foreED = foreE.first;\r\n\r\n\t\t\t\tedgeIndex[ foreED ] = globalPathGraph[ ed ].id;\r\n\t\t\t\tunitWeight[ globalPathGraph[ ed ].id ] = globalPathGraph[ ed ].weight;\r\n\t\t\t}\r\n\t\t\t//cerr << \" all edges copied \"<<endl;\r\n\r\n\r\n\t\t\tunsigned int pathIndex = 0;\r\n\t\t\tfor( multimap< KeiRo::Base::Common::UIDPair,\r\n\t\t\t\t\tKeiRo::Base::Common::UIDPair >::iterator it = globalPath.begin();\r\n\t\t\t\t it != globalPath.end(); it++ ){\r\n\r\n\r\n\r\n\t\t\t\tif (it->first.first == ids && it->second.first == idt &&\r\n\t\t\t\t\tit->first.second == idgs && it->second.second == idgt) {\r\n\t\t\t\t\tKeiRo::Base::Common::UIDPair pairS = it->first;\r\n\t\t\t\t\tKeiRo::Base::Common::UIDPair pairT = it->second;\r\n\t\t\t\t\t//cerr << \"pairS.first \" <<pairS.first << \"pairT.first \"<<pairT.first<<endl;\r\n\t\t\t\t\t//cerr << \"found the source and target \"<<endl;\r\n\t\t\t\t\tunsigned int idS = pairS.first;\r\n\t\t\t\t\tunsigned int idT = pairT.first;\r\n\t\t\t\t\tunsigned int idGS = idgs;//pairS.second;\r\n\t\t\t\t\tunsigned int idGT = idgt;//pairT.second;\r\n\t\t\t\t\tGraph::BaseUndirectedGraph subGS = graphmlGraphMap.find( idS )->second;\r\n\t\t\t\t\tGraph::BaseUndirectedGraph subGT = graphmlGraphMap.find( idT )->second;\r\n\t\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdS = vertex( idS, graphmlTree );\r\n\t\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdT = vertex( idT, graphmlTree );\r\n\t\t\t\t\tGraph::BaseUndirectedGraph::vertex_descriptor vdGS = vertex( idGS, subGS );\r\n\t\t\t\t\tGraph::BaseUndirectedGraph::vertex_descriptor vdGT = vertex( idGT, subGT );\r\n\r\n\r\n\r\n\t\t\t\t\tunsigned int idPGS = _projectedVertexVec.find( it->first )->second;\r\n\t\t\t\t\tunsigned int idPGT = _projectedVertexVec.find( it->second )->second;\r\n\t\t\t\t\t//cerr << \" idPGS \"<< idPGS << \"idPGT \"<<idPGT<<endl;\r\n\r\n\t\t\t\t\t\tGraph::PropertyGraph::vertex_descriptor sourceVertex = vertex( idPGS, propG );\r\n\t\t\t\t\t\tGraph::PropertyGraph::vertex_descriptor targetVertex = vertex( idPGT, propG );\r\n\r\n\t\t\t\t\t\t// Calculate the shortest path for this specific source and target pair\r\n\t\t\t\t\t\tvector<Graph::PropertyGraph::vertex_descriptor> parent(num_vertices(propG));\r\n\t\t\t\t\t\tvector<double> distance(num_vertices(propG));\r\n\t\t\t\t\t\tdijkstra_shortest_paths(propG, targetVertex,\r\n\t\t\t\t\t\t\t\t\t\t\t\tpredecessor_map(make_iterator_property_map(parent.begin(), get(vertex_index, propG)))\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t.distance_map(make_iterator_property_map(distance.begin(), get(vertex_index, propG)))\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t.weight_map(make_iterator_property_map(unitWeight.begin(), get(edge_index, propG))));\r\n\r\n\t\t\t\t\t\t// Store the path ID to the LocalShortestPath\r\n\t\t\t\t\t\tvector<unsigned int> path;\r\n\t\t\t\t\t\tGraph::PropertyGraph::vertex_descriptor current = sourceVertex;\r\n\t\t\t\t\t\twhile (current != targetVertex) {\r\n\t\t\t\t\t\t\tpath.push_back(vertexIndex[current]);\r\n\t\t\t\t\t\t\tif (current == parent[current]) {\r\n\t\t\t\t\t\t\t\tcerr << \"ERROR: cannot find the shortest path... at \" << __LINE__ << \" in \" << __FILE__ << endl;\r\n\t\t\t\t\t\t\t\t// cerr << \"idPGS = \" << projectedSourceID << \", idPGT = \" << projectedTargetID << endl;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\tassert(false);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tcurrent = parent[current];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcerr << \"shortest path found \"<<endl;\r\n\t\t\t\t\t\tpath.push_back( vertexIndex[ targetVertex ] );\r\n\t\t\t\t\t\t_hierarchicalPathVec.push_back( path ); //not used\r\n\r\n\r\n\r\n\t\t\t\t\t//calculate the length\r\n\t\t\tdouble pathLength = 0.0;\r\n\t\t\tfor (size_t i = 0; i < path.size() - 1; ++i) {\r\n\t\t\t\tGraph::PropertyGraph::vertex_descriptor vdS = vertex(path[i], propG);\r\n\t\t\t\tGraph::PropertyGraph::vertex_descriptor vdT = vertex(path[i + 1], propG);\r\n\t\t\t\tGraph::PropertyGraph::edge_descriptor ed;\r\n\t\t\t\tbool found;\r\n\t\t\t\tboost::tie(ed, found) = edge(vdS, vdT, propG);\r\n\t\t\t\tif (found) {\r\n\t\t\t\t\tpathLength += unitWeight[edgeIndex[ed]];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t//vector for paths' lengths\r\n\t\t\t_pathLengthsShort.push_back(pathLength);\r\n\r\n\t\t\t\t\t\t// create global path lines\r\n\t\t\t\t\t\tKeiRo::Base::Line2 polyline;\r\n\t\t\t\t\t\tvector< Conjunction > conjunctionVec;\r\n\r\n\t\t\t\t\t\tConjunction conjS, conjT;\r\n\t\t\t\t\t// add source\r\n\t\t\t\t\t//polyline.elementPointers().push_back( subGS[ vdGS ].coordPtr )\r\n\t\t\t\t\tpolyline.elementPointers().push_back( oldPolyLine.elementPointers()[0]);\r\n\t\t\t\t\tconjS.level =graphmlTree[ vdS ].level;\r\n\t\t\t\t\tconjS.treemapID.push_back( idS );\r\n\t\t\t\t\tconjS.pointType.push_back( POINT_NOTYPE );\r\n\t\t\t\t\tconjS.conjunctionType  = CONJUNCTION_INCELLS;\r\n\t\t\t\t\tconjunctionVec.push_back( conjS );\r\n\r\n\t\t\t\t\t// first point (projected node)\r\n\t\t\t\t\tfor( unsigned int i = 0; i < 1; i++ ){\r\n\t\t\t\t\t\tGraph::BaseUndirectedGraph::vertex_descriptor vd = vertex( path[0], globalPathGraph );\r\n\t\t\t\t\t\tKeiRo::Base::Coord2 *coordPtr = new KeiRo::Base::Coord2( *globalPathGraph[vd].coordPtr );\r\n\t\t\t\t\t\t//KeiRo::Base::Coord2 *coordPtr = new KeiRo::Base::Coord2( *oldPolyLine.elementPointers()[0]);\r\n\r\n\t\t\t\t\t\tpolyline.elementPointers().push_back( coordPtr );\r\n\r\n\t\t\t\t\t\tConjunction conj;\r\n\t\t\t\t\t\tconj.level = graphmlTree[ vdS ].level;\r\n\t\t\t\t\t\tconj.treemapID.push_back( idS );\r\n\t\t\t\t\t\tconj.pointType.push_back( POINT_NOTYPE );\r\n\t\t\t\t\t\tconj.conjunctionType  = CONJUNCTION_NONCORNER;\r\n\t\t\t\t\t\tconjunctionVec.push_back( conj );\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// middle points\r\n\t\t\t\t\tfor( unsigned int i = 1; i < path.size()-1; i++ ){\r\n\t\t\t\t\t\t_splitConjunctions( polyline, path[i], conjunctionVec );\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// last point (projected node)\r\n\t\t\t\t\tfor( unsigned int i = path.size()-1; i < path.size(); i++ ){\r\n\t\t\t\t\t\tGraph::BaseUndirectedGraph::vertex_descriptor vd = vertex( path[i], globalPathGraph );\r\n\t\t\t\t\t\tKeiRo::Base::Coord2 *coordPtr = new KeiRo::Base::Coord2( *globalPathGraph[vd].coordPtr );\r\n\r\n\t\t\t\t\t\tpolyline.elementPointers().push_back( coordPtr );\r\n\r\n\t\t\t\t\t\tConjunction conj;\r\n\t\t\t\t\t\tconj.level =graphmlTree[ vdT ].level;\r\n\t\t\t\t\t\tconj.treemapID.push_back( idT );\r\n\t\t\t\t\t\tconj.pointType.push_back( POINT_NOTYPE );\r\n\t\t\t\t\t\tconj.conjunctionType  = CONJUNCTION_NONCORNER;\r\n\t\t\t\t\t\tconjunctionVec.push_back( conj );\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// add target\r\n\t\t\t\t\t//polyline.elementPointers().push_back( subGT[ vdGT ].coordPtr );\r\n\t\t\t\t\tpolyline.elementPointers().push_back( oldPolyLine.elementPointers()[oldPolyLine.elementPointers().size()-1] );\r\n\t\t\t\t\tconjT.level =graphmlTree[ vdT ].level;\r\n\t\t\t\t\tconjT.treemapID.push_back( idT );\r\n\t\t\t\t\tconjT.pointType.push_back( POINT_NOTYPE );\r\n\t\t\t\t\tconjT.conjunctionType  = CONJUNCTION_INCELLS;\r\n\t\t\t\t\tconjunctionVec.push_back( conjT );\r\n\r\n\t\t\t\t\t\t//\t\t\tif( pathIndex == 0 )\r\n\t\t\t\t\t\tmultimap< pair< KeiRo::Base::Common::UIDPair,\r\n\t\t\t\t\t\t\t\tKeiRo::Base::Common::UIDPair >, KeiRo::Base::Edge2 >::iterator itA = _metadataPtr->graphmlGlobalPathAttribute().begin();\r\n\r\n\r\n\r\n\t\t\t\t\t\tstd::advance( itA, pathIndex );\r\n\t\t\t\t\t\tKeiRo::Base::Edge2 edge = itA->second;\r\n\r\n\t\t\t\t\t\t_polylineVecShort.push_back( polyline );\r\n\r\n\t\t\t\t\t\tprint_path(_polylineVecShort.size()-1);\r\n\t\t\t\t\t\t_edgeAttributeVecShort.push_back( edge );// i have to change to the excat location\r\n\t\t\t\t\t\t_conjunctionMatShort.push_back( conjunctionVec );// same\r\n\r\n\t\t\t\t\t\tpathIndex++;\r\n\r\n\t\t\t\t\t//}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\r\n\r\n\t\t}\r\n\r\n\r\n\tvoid HierarchicalPath::addLocalMoveConjunctions( vector<LocalMove> localMoves, int i, int j )\r\n\t{\r\n#ifdef SKIP\r\n\t\tGraph::TreeDirectedGraph    &graphmlTree    = _metadataPtr->graphmlTree();\r\n\t\tKeiRo::Base::Line2 &polyline = _polylineVec[i];\r\n\t\t\r\n\t\t// loop through local moves and for each local move m\r\n\t\tfor(unsigned int m = 0; m < localMoves.size(); m++) {\r\n\t\t\r\n\t\t\tLocalMove move = localMoves[m];\r\n\t\t\tif(move.beforeSegmentHorizontal()) {\r\n\t\t\r\n\t\t\t\t// check whether segment of path is horizontal\r\n\t\t\t\t//segment j of polyline i --> polyline.elementPointers()[j]\r\n\t\t\t\t//comparing the coordinate of the segment associated with \"move\" to the correct coordinate (x or y) of the j-th segment of \"polyline\"\r\n\t\t\t\t// it is horizontal here so compare with y coord\r\n\t\t\t\tif( _conjunctionMat[i].size()-1 != j+1 && polyline.elementPointers()[j]->y() - polyline.elementPointers()[j+1]->y() == 0) {\r\n\t\t\t\t\t// check whether segment of path has same coordinate as segment of local move\r\n\t\t\t\t\t// TODO: make sure this also works when segment of path between rectangles, not just exact same coordinate as segment of local move\r\n\t\t\t\t\tif( polyline.elementPointers()[j]->y() == m.beforeSegmentCoord() ) {\r\n\t\t\t\t\t\t// get rectangles LB and RT in m\r\n\t\t\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdPLB = vertex( m.beforeLeftBottomID() , graphmlTree );\r\n\t\t\t\t\t\tKeiRo::Base::Rectangle2 &bboxLB = *graphmlTree[ vdPLB ].boundingBoxPtr;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdPRT = vertex( m.beforeRightTopID() , graphmlTree );\r\n\t\t\t\t\t\tKeiRo::Base::Rectangle2 &bboxRT = *graphmlTree[ vdPRT ].boundingBoxPtr;\r\n\t\t\t\t\r\n\t\t\t\t\t\t// order endpoints of segment of path \r\n\t\t\t\t\t\tdouble left, right;\r\n\t\t\t\t\t\tif( polyline.elementPointers()[j]->x() <= polyline.elementPointers()[j+1]->x() ) {\r\n\t\t\t\t\t\t\tleft = polyline.elementPointers()[j]->x();\r\n\t\t\t\t\t\t\tright = polyline.elementPointers()[j+1]->x();\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tleft = polyline.elementPointers()[j+1]->x();\r\n\t\t\t\t\t\t\tright = polyline.elementPointers()[j]->x();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// check if x-coordinates of LB and RT are between (or equal to) segment of path\r\n\t\t\t\t\t\tif( left < bboxLB.oldLeftBottom().x() + bboxLB.oldWidth() && bboxLB.oldLeftBottom().x() < right && \r\n\t\t\t\t\t\t\tleft < bboxRT.oldLeftBottom().x() + bboxRT.oldWidth() && bboxRT.oldLeftBottom().x() < right ) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// create new conjunction (one for stretch, two for flip)\r\n\t\t\t\t\t\t\tif( m.stretchMove() ) {\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tConjunction* newConj;\r\n\t\t\t\t\t\t\t\tnewConj.level = conj.level;\r\n\t\t\t\t\t\t\t\tnewConj.conjunctionType = CONJUNCTION_CORNER;\r\n\r\n                                KeiRo::Base::Coord2* newCoord;\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tif( m.beforeLeftBottomID() == m.afterLeftBottomID() ) { // LB (bottom) becomes left\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tif( m.strechedID() == m.beforeLeftBottomID() ) {\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t// TODO: set their (old) x- and y-coordinates to intermediate coordinates of LB/RT depending on configuration\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t} else { // RT streches\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t// TODO: set their (old) x- and y-coordinates to intermediate coordinates of LB/RT depending on configuration\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t} else { // LB (bottom) becomes right\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tif( m.strechedID() == m.beforeLeftBottomID() ) {\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t// TODO: set their (old) x- and y-coordinates to intermediate coordinates of LB/RT depending on configuration\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t} else { // RT streches\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t// TODO: set their (old) x- and y-coordinates to intermediate coordinates of LB/RT depending on configuration\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// add conjunction and coordinate to polyline after current index j\r\n\t\t\t\t\t\t\t\t_conjunctionMat[i].insert(j+1, *newConj);\r\n\t\t\t\t\t\t\t\tpolyline.elementPointers().insert(j+1, newCoord);\r\n\t\t\t\t\t\t\t\t// new coordinates will be set depending on corners of LB and RT in next iteration!\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t} else { // flip move\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tConjunction* newConj1;\r\n\t\t\t\t\t\t\t\tnewConj1.level = conj.level;\r\n\t\t\t\t\t\t\t\tnewConj1.conjunctionType = CONJUNCTION_CORNER;\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tConjunction* newConj2;\r\n\t\t\t\t\t\t\t\tnewConj2.level = conj.level;\r\n\t\t\t\t\t\t\t\tnewConj2.conjunctionType = CONJUNCTION_CORNER;\r\n\r\n                                KeiRo::Base::Coord2* newCoord1;\r\n                                KeiRo::Base::Coord2* newCoord2; //TODO: left and right endpoint of polyline segment determine order of coordinates!!\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tif( m.beforeLeftBottomID() == m.afterLeftBottomID() ) { // LB (bottom) becomes left\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// TODO: set their (old) x- and y-coordinates to intermediate coordinates of LB/RT depending on configuration\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t} else { // LB (bottom) becomes right\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// TODO: set their (old) x- and y-coordinates to intermediate coordinates of LB/RT depending on configuration\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// add conjunctions and coordinate to polylines after current index j\r\n\t\t\t\t\t\t\t\tConjunction conjArray[2] = {*newConj1, *newConj2};\r\n\t\t\t\t\t\t\t\t_conjunctionMat[i].insert(j+1, conjArray, conjArray+2);\r\n\r\n                                KeiRo::Base::Coord2* coordArray[2] = {newCoord1, newCoord2}\r\n\t\t\t\t\t\t\t\tpolyline.elementPointers().insert(j+1, coordArray, coordArray+2);\r\n\t\t\t\t\t\t\t\t// new coordinates will be set depending on corners of LB and RT in next iteration!\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else { // segment is vertical\r\n\t\t\t\t// TODO: analogous to above\r\n\t\t\t}\r\n\t\t}\r\n#endif // SKIP\r\n\t}\r\n\t\r\n\t//\r\n\t//  HierarchicalPath::update --\tupdate the path when partition is changed\r\n\t//\r\n\t//  Inputs\r\n\t//\tstring filePath\r\n\t//\r\n\t//  Outputs\r\n\t//\tbool\r\n\t//\r\n\tvoid HierarchicalPath::updateOld( void )\r\n\t{ // not used\r\n\t\tvector< vector< unsigned int > > &sortedLevel = _hierarchicalTreemapPtr->sortedLevel();\r\n\t\tunsigned int maxLevel = sortedLevel.size();\r\n\t\tvector< FileIO::SVG * > &svgPtrVec = _metadataPtr->svgPtrVec();\r\n\t\tvector< Treemap > &treemapVec = _hierarchicalTreemapPtr->treemapVec();\r\n\t\t\r\n\t\t// initialization\r\n\t\tfor( unsigned int i = 0; i < _polylineVec.size(); i++ ) {\r\n\t\t\tfor( unsigned int j = 0; j < _polylineVec[ i ].oldElements().size(); j++ ) {\r\n\t\t\t\t\r\n\t\t\t\tKeiRo::Base::Coord2 c;\r\n\t\t\t\tif( _conjunctionIDMat[ i ][ j ].conjunctionType == CONJUNCTION_INCELLS ) {\r\n\t\t\t\t\tc.x() = _polylineVec[ i ].elementPointers()[ j ]->oldElement()[ 0 ];\r\n\t\t\t\t\tc.y() = _polylineVec[ i ].elementPointers()[ j ]->oldElement()[ 1 ];\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tc.x() = _polylineVec[ i ].elementPointers()[ j ]->x();\r\n\t\t\t\t\tc.y() = _polylineVec[ i ].elementPointers()[ j ]->y();\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t_polylineVec[ i ].oldElements()[ j ].x() = c.x();\r\n\t\t\t\t_polylineVec[ i ].oldElements()[ j ].y() = c.y();\r\n\t\t\t}\r\n//\t\t\t_polylineVec[ i ].updateOldElementByPointers();\r\n\t\t}\r\n\t\t\r\n\t\t// update the path with treemap\r\n\t\tfor( unsigned int i = 0; i < _conjunctionIDMat.size(); i++ ) {\r\n\t\t\tfor( unsigned int j = 0; j < _conjunctionIDMat[ i ].size(); j++ ) {\r\n\t\t\t\t\r\n\t\t\t\t// adjust points in cells\r\n#ifdef SKIP\r\n\t\t\t\tif( _conjunctionIDMat[i][j].conjunctionType == CONJUNCTION_INCELLS ){\r\n\t\t\t\t\tunsigned int level = _conjunctionIDMat[i][j].level[0];\r\n\t\t\t\t\tunsigned int member = _conjunctionIDMat[i][j].member[0];\r\n\t\t\t\t\tunsigned int polygonMember = _conjunctionIDMat[i][j].polygonMember[0];\r\n#ifdef DEBUG\r\n\t\t\t\t\tcerr << \"level = \" << level << endl;\r\n\t\t\t\t\tcerr << \"member = \" << member << endl;\r\n\t\t\t\t\tcerr << \"polygonMember = \" << polygonMember << endl;\r\n#endif // DEBUG\r\n\t\t\t\t\tunsigned int id = sortedLevel[ level ][ member ];\r\n\t\t\t\t\tvector<  KeiRo::Base::Polygon2 > &polygonVec = svgPtrVec[ id ]->polygonVec();\r\n\t\t\t\t\tKeiRo::Base::Rectangle2 &bbox = polygonVec[ polygonMember ].boundingBox();\r\n\t\t\t\t\tmap< string, KeiRo::Base::Rectangle2 > &treemapTargetMap = treemapVec[id].treemapTargetMap();\r\n\t\t\t\t\tmap< string, KeiRo::Base::Rectangle2 >::iterator itT = treemapTargetMap.begin();\r\n\t\t\t\t\tstd::advance( itT, polygonMember );\r\n\t\t\t\t\tKeiRo::Base::Rectangle2 rectS;\r\n\t\t\t\t\trectS.leftBottom() = bbox.oldLeftBottom();\r\n\t\t\t\t\trectS.width() = bbox.oldWidth();\r\n\t\t\t\t\trectS.height() = bbox.oldHeight();\r\n\t\t\t\t\tKeiRo::Base::Rectangle2 &rectT = itT->second;\r\n\t\t\t\t\tKeiRo::Base::Coord2 &c = _polylineVec[i].elements()[j];\r\n\t\t\t\t\tc.x() = _polylineVec[i].elements()[j].x();\r\n\t\t\t\t\tc.y() = _polylineVec[i].elements()[j].y();\r\n#ifdef DEBUG\r\n\t\t\t\t\tcerr << \"rectS = \" << rectS;\r\n\t\t\t\t\tcerr << \"rectT = \" << rectT;\r\n#endif // DEBUG\r\n\t\t\t\t\tc.x() = ( c.x() - rectS.leftBottom().x() ) * rectT.width()/rectS.width() + rectT.leftBottom().x();\r\n\t\t\t\t\tc.y() = ( c.y() - rectS.leftBottom().y() ) * rectT.height()/rectS.height() + rectT.leftBottom().y();\r\n//\t\t\t\t\t_updatedPolylineVec[i].elements()[j] = c;\r\n\t\t\t\t}\r\n#endif // SKIP\r\n\t\t\t\tif( ( j > 0 ) &&\r\n\t\t\t\t    ( _conjunctionIDMat[ i ][ j - 1 ].conjunctionType == CONJUNCTION_INCELLS ) &&\r\n\t\t\t\t    ( _conjunctionIDMat[ i ][ j ].conjunctionType == CONJUNCTION_NONCORNER ) ) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tKeiRo::Base::Coord2 diff =\r\n\t\t\t\t\t\t\t_polylineVec[ i ].fixedElements()[ j ] - _polylineVec[ i ].fixedElements()[ j - 1 ];\r\n\t\t\t\t\t\r\n\t\t\t\t\tunsigned int level = _conjunctionIDMat[ i ][ j ].level[ 0 ];\r\n\t\t\t\t\tunsigned int member = _conjunctionIDMat[ i ][ j ].member[ 0 ];\r\n\t\t\t\t\tunsigned int polygonMember = _conjunctionIDMat[ i ][ j ].polygonMember[ 0 ];\r\n\r\n\t\t\t\t\tunsigned int id = sortedLevel[ level ][ member ];\r\n\t\t\t\t\tvector< KeiRo::Base::Polygon2 > &polygonVec = svgPtrVec[ id ]->polygonVec();\r\n\t\t\t\t\tKeiRo::Base::Rectangle2 &bbox = polygonVec[ polygonMember ].boundingBox();\r\n\t\t\t\t\tmap< unsigned int, KeiRo::Base::Rectangle2 > &treemapTargetMap = treemapVec[ id ].treemapTargetMap();\r\n\t\t\t\t\tmap< unsigned int, KeiRo::Base::Rectangle2 >::iterator itT = treemapTargetMap.begin();\r\n\t\t\t\t\tstd::advance( itT, polygonMember );\r\n\t\t\t\t\tKeiRo::Base::Rectangle2 &rectT = itT->second;\r\n\t\t\t\t\t\r\n\t\t\t\t\tKeiRo::Base::Coord2 c;\r\n\t\t\t\t\t// horizontal line\r\n\t\t\t\t\tif( fabs( diff.x() ) > fabs( diff.y() ) ) {\r\n\t\t\t\t\t\tif( diff.x() > 0 ) {\r\n\t\t\t\t\t\t\t// right border\r\n\t\t\t\t\t\t\tc.x() = rectT.leftBottom().x() + rectT.width();\r\n\t\t\t\t\t\t\tc.y() = _polylineVec[ i ].elementPointers()[ j - 1 ]->y();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t// left border\r\n\t\t\t\t\t\t\tc.x() = rectT.leftBottom().x();\r\n\t\t\t\t\t\t\tc.y() = _polylineVec[ i ].elementPointers()[ j - 1 ]->y();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\t// vertical line\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tif( diff.y() > 0 ) {\r\n\t\t\t\t\t\t\t// top border\r\n\t\t\t\t\t\t\tc.x() = _polylineVec[ i ].elementPointers()[ j - 1 ]->x();\r\n\t\t\t\t\t\t\tc.y() = rectT.leftBottom().y() + rectT.height();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t// bottom border\r\n\t\t\t\t\t\t\tc.x() = _polylineVec[ i ].elementPointers()[ j - 1 ]->x();\r\n\t\t\t\t\t\t\tc.y() = rectT.leftBottom().y();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->x() = c.x();\r\n\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->y() = c.y();\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif( ( j < _conjunctionIDMat[ i ].size() - 1 ) &&\r\n\t\t\t\t    ( _conjunctionIDMat[ i ][ j + 1 ].conjunctionType == CONJUNCTION_INCELLS ) &&\r\n\t\t\t\t    ( _conjunctionIDMat[ i ][ j ].conjunctionType == CONJUNCTION_NONCORNER ) ) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tKeiRo::Base::Coord2 diff =\r\n\t\t\t\t\t\t\t_polylineVec[ i ].fixedElements()[ j ] - _polylineVec[ i ].fixedElements()[ j + 1 ];\r\n\t\t\t\t\t\r\n\t\t\t\t\tunsigned int level = _conjunctionIDMat[ i ][ j ].level[ 0 ];\r\n\t\t\t\t\tunsigned int member = _conjunctionIDMat[ i ][ j ].member[ 0 ];\r\n\t\t\t\t\tunsigned int polygonMember = _conjunctionIDMat[ i ][ j ].polygonMember[ 0 ];\r\n\t\t\t\t\t\r\n\t\t\t\t\tunsigned int id = sortedLevel[ level ][ member ];\r\n\t\t\t\t\tvector< KeiRo::Base::Polygon2 > &polygonVec = svgPtrVec[ id ]->polygonVec();\r\n\t\t\t\t\tKeiRo::Base::Rectangle2 &bbox = polygonVec[ polygonMember ].boundingBox();\r\n\t\t\t\t\tmap< unsigned int, KeiRo::Base::Rectangle2 > &treemapTargetMap = treemapVec[ id ].treemapTargetMap();\r\n\t\t\t\t\tmap< unsigned int, KeiRo::Base::Rectangle2 >::iterator itT = treemapTargetMap.begin();\r\n\t\t\t\t\tKeiRo::Base::Rectangle2 rectS;\r\n\t\t\t\t\trectS.leftBottom() = bbox.oldLeftBottom();\r\n\t\t\t\t\trectS.width() = bbox.oldWidth();\r\n\t\t\t\t\trectS.height() = bbox.oldHeight();\r\n\t\t\t\t\tstd::advance( itT, polygonMember );\r\n\t\t\t\t\tKeiRo::Base::Rectangle2 &rectT = itT->second;\r\n\t\t\t\t\tdouble x = _polylineVec[ i ].elementPointers()[ j + 1 ]->x();\r\n\t\t\t\t\tdouble y = _polylineVec[ i ].elementPointers()[ j + 1 ]->y();\r\n\t\t\t\t\t\r\n\t\t\t\t\t// horizontal line\r\n\t\t\t\t\tKeiRo::Base::Coord2 c;\r\n\t\t\t\t\tif( fabs( diff.x() ) > fabs( diff.y() ) ) {\r\n\t\t\t\t\t\tif( diff.x() > 0 ) {\r\n\t\t\t\t\t\t\t// right border\r\n\t\t\t\t\t\t\tc.x() = rectT.leftBottom().x() + rectT.width();\r\n\t\t\t\t\t\t\tc.y() = y;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t// left border\r\n\t\t\t\t\t\t\tc.x() = rectT.leftBottom().x();\r\n\t\t\t\t\t\t\tc.y() = y;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\t// vertical line\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tif( diff.y() > 0 ) {\r\n\t\t\t\t\t\t\t// top border\r\n\t\t\t\t\t\t\tc.x() = x;\r\n\t\t\t\t\t\t\tc.y() = rectT.leftBottom().y() + rectT.height();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t// bottom border\r\n\t\t\t\t\t\t\tc.x() = x;\r\n\t\t\t\t\t\t\tc.y() = rectT.leftBottom().y();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->x() = c.x();\r\n\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->y() = c.y();\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif( _conjunctionIDMat[ i ][ j ].conjunctionType == CONJUNCTION_CORNER ) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tunsigned int kID = 0;\r\n\t\t\t\t\tdouble maxDist = 0;\r\n\t\t\t\t\tKeiRo::Base::Coord2 *cPrev = _polylineVec[ i ].elementPointers()[ j - 1 ];\r\n\t\t\t\t\tvector< KeiRo::Base::Coord2 > c;\r\n\r\n\t\t\t\t\tc.resize( _conjunctionIDMat[ i ][ j ].level.size() );\r\n//\t\t\t\t\tcerr << \" i = \" << i << \" j = \" << j << endl;\r\n//\t\t\t\t\tcerr << \" _conjunctionIDMat[ i ][ j ].level.size() = \" <<  _conjunctionIDMat[ i ][ j ].level.size() << endl;\r\n\t\t\t\t\tfor( unsigned int k = 0; k < _conjunctionIDMat[ i ][ j ].level.size(); k++ ) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tunsigned int level = _conjunctionIDMat[ i ][ j ].level[ k ];\r\n\t\t\t\t\t\tunsigned int member = _conjunctionIDMat[ i ][ j ].member[ k ];\r\n\t\t\t\t\t\tunsigned int polygonMember = _conjunctionIDMat[ i ][ j ].polygonMember[ k ];\r\n\t\t\t\t\t\tunsigned int pointType = _conjunctionIDMat[ i ][ j ].pointType[ k ];\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tunsigned int id = sortedLevel[ level ][ member ];\r\n\t\t\t\t\t\tmap< unsigned int, KeiRo::Base::Rectangle2 > &treemapTargetMap = treemapVec[ id ].treemapTargetMap();\r\n\t\t\t\t\t\tmap< unsigned int, KeiRo::Base::Rectangle2 >::iterator itT = treemapTargetMap.begin();\r\n\t\t\t\t\t\tstd::advance( itT, polygonMember );\r\n\t\t\t\t\t\tKeiRo::Base::Rectangle2 &rect = itT->second;\r\n#ifdef DEBUG\r\n\t\t\t\t\t\tif( i == 0 && j == 5 ) {\r\n\t\t\t\t\t\t\tcerr << \"i = \" << i << \" j = \" << j << endl;\r\n\t\t\t\t\t\t\tcerr << \"id = \" << id << endl;\r\n\t\t\t\t\t\t\tcerr << \"polygonMember = \" << polygonMember << endl;\r\n\t\t\t\t\t\t\tcerr << \"_polylineVec[ i ].elementPointers()[j] = \"\r\n\t\t\t\t\t\t\t\t << _polylineVec[ i ].elementPointers()[ j ] << endl;\r\n\t\t\t\t\t\t\tcerr << \"_polylineVec[ i ].elementPointers()[j] = \"\r\n\t\t\t\t\t\t\t\t << *_polylineVec[ i ].elementPointers()[ j ];\r\n\t\t\t\t\t\t\tcerr << \"size = \" << _conjunctionIDMat[ i ][ j ].level.size() << endl;\r\n\t\t\t\t\t\t\tcerr << \"rect = \" << rect << endl;\r\n\t\t\t\t\t\t}\r\n//\t\t\t\t\t\tif( i == 0 && j == 6 ) {\r\n//\t\t\t\t\t\t\tcerr << \"i = \" << i << \" j = \" << j << endl;\r\n//\t\t\t\t\t\t\tcerr << \"id = \" << id << endl;\r\n//\t\t\t\t\t\t\tcerr << \"polygonMember = \" << polygonMember << endl;\r\n//\t\t\t\t\t\t\tcerr << \"_polylineVec[ i ].elementPointers()[j] = \"\r\n//\t\t\t\t\t\t\t\t << _polylineVec[ i ].elementPointers()[ j ] << endl;\r\n//\t\t\t\t\t\t\tcerr << \"_polylineVec[ i ].elementPointers()[j] = \"\r\n//\t\t\t\t\t\t\t\t << *_polylineVec[ i ].elementPointers()[ j ];\r\n//\t\t\t\t\t\t\tcerr << \"size = \" << _conjunctionIDMat[ i ][ j ].level.size() << endl;\r\n//\t\t\t\t\t\t\tcerr << \"rect = \" << rect;\r\n//\t\t\t\t\t\t}\r\n#endif // DEBUG\r\n\t\t\t\t\t\tif( pointType == POINT_LEFTBOTTOM ) {\r\n\t\t\t\t\t\t\tc[ k ].x() = rect.leftBottom().x();\r\n\t\t\t\t\t\t\tc[ k ].y() = rect.leftBottom().y();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif( pointType == POINT_RIGHTBOTTOM ) {\r\n\t\t\t\t\t\t\tc[ k ].x() = rect.leftBottom().x() + rect.width();\r\n\t\t\t\t\t\t\tc[ k ].y() = rect.leftBottom().y();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif( pointType == POINT_RIGHTTOP ) {\r\n\t\t\t\t\t\t\tc[ k ].x() = rect.leftBottom().x() + rect.width();\r\n\t\t\t\t\t\t\tc[ k ].y() = rect.leftBottom().y() + rect.height();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif( pointType == POINT_LEFTTOP ) {\r\n\t\t\t\t\t\t\tc[ k ].x() = rect.leftBottom().x();\r\n\t\t\t\t\t\t\tc[ k ].y() = rect.leftBottom().y() + rect.height();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tdouble dist = distanceBetween( *cPrev, c[ k ] );\r\n\t\t\t\t\t\t\r\n//\t\t\t\t\t\tif( j == 5 ) {\r\n//\t\t\t\t\t\t\tcerr << \"k = \" << k << endl;\r\n//\t\t\t\t\t\t\tcerr << \"*cPrev = \" << *cPrev;\r\n//\t\t\t\t\t\t\tcerr << \"c[k] = \" << c[k];\r\n//\t\t\t\t\t\t\tcerr << \"dist = \" << dist << endl;\r\n//\t\t\t\t\t\t\tcerr << \"conjunctionIDMat[ i ][ j ].level.size() = \" << _conjunctionIDMat[ i ][ j ].level.size() << endl;\r\n//\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif( dist > maxDist ) {\r\n\t\t\t\t\t\t\tmaxDist = dist;\r\n\t\t\t\t\t\t\tkID = k;\r\n//\t\t\t\t\t\t\tcerr << \"dist > maxDist, dist = \" << dist << \" maxDist = \" << maxDist << endl;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n//\t\t\t\t\tif( j == 4 || j == 5 ) {\r\n//\t\t\t\t\t\tcerr << \"j = \" << j << \", KID = \" << kID << endl;\r\n//\t\t\t\t\t}\r\n\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->x() = c[ kID ].x();\r\n\t\t\t\t\t_polylineVec[ i ].elementPointers()[ j ]->y() = c[ kID ].y();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n//\t\t\t// revisit wrong vertices\r\n//\t\t\tfor( unsigned int j = 1; j < _conjunctionIDMat[i].size()-1; j++ ) {\r\n//\t\t\t\tKeiRo::Base::Coord2 *prev = _polylineVec[i].elementPointers()[j-1];\r\n//\t\t\t\tKeiRo::Base::Coord2 *curr = _polylineVec[i].elementPointers()[j];\r\n//\t\t\t\tKeiRo::Base::Coord2 *post = _polylineVec[i].elementPointers()[j+1];\r\n//\t\t\t\tif( _conjunctionIDMat[i][j].conjunctionType == CONJUNCTION_CORNER ) {\r\n//\t\t\t\t\tif( fabs((*curr-*post).x()) > 1.0 &&  fabs((*curr-*post).y()) > 1.0 ) {\r\n//\t\t\t\t\t\tif( fabs((*post-*prev).x()) < 1.0 || fabs((*post-*prev).y()) < 1.0 ) {\r\n//\t\t\t\t\t\t\tConjunctionIndex tmp = _conjunctionIDMat[i][j];\r\n//\t\t\t\t\t\t\tKeiRo::Base::Coord2 *tmpC = _polylineVec[ i ].elementPointers()[j];\r\n//\t\t\t\t\t\t\t// swap two sample points\r\n//\t\t\t\t\t\t\t_conjunctionIDMat[i][j] = _conjunctionIDMat[i][j-1];\r\n//\t\t\t\t\t\t\t_conjunctionIDMat[i][j-1] = tmp;\r\n//\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[j] = _polylineVec[ i ].elementPointers()[j-1];\r\n//\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[j-1] = tmpC;\r\n//\t\t\t\t\t\t}\r\n//\t\t\t\t\t}\r\n//\t\t\t\t}\r\n//\t\t\t}\r\n\t\t}\r\n//#ifdef SKIP\r\n\t\t\r\n\t\tfor( unsigned int i = 0; i < _conjunctionIDMat.size(); i++ ) {\r\n\r\n#ifdef DEBUG\r\n\t\t\tfor( unsigned int j = 0; j < _conjunctionIDMat[i].size(); j++ ) {\r\n\t\t\t\tcerr << *_polylineVec[i].elementPointers()[j];\r\n\t\t\t\tcerr << \" \" << _conjunctionIDMat[i][j].conjunctionType << endl;\r\n\t\t\t}\r\n#endif // DEBUG\r\n\t\t\t\r\n\t\t\tvector< KeiRo::Base::Coord2 > coordVec;\r\n\t\t\tvector< ConjunctionIndex > conjunctionIDVec;\r\n\t\t\tKeiRo::Base::Line2 &line = _polylineVec[ i ];\r\n\t\t\tbool isOneCornerPointVisisted = false;\r\n\t\t\tfor( unsigned int j = 0; j < _conjunctionIDMat[ i ].size(); j++ ) {\r\n\t\t\t\tif( isOneCornerPointVisisted == false )\r\n\t\t\t\t\tconjunctionIDVec.push_back( _conjunctionIDMat[ i ][ j ] );\r\n\t\t\t\tif( ( _conjunctionIDMat[ i ][ j ].conjunctionType == CONJUNCTION_NONCORNER ) ||\r\n\t\t\t\t    ( _conjunctionIDMat[ i ][ j ].conjunctionType == CONJUNCTION_CORNER ) ) {\r\n\t\t\t\t\tcoordVec.push_back( *_polylineVec[ i ].elementPointers()[ j ] );\r\n\t\t\t\t\tisOneCornerPointVisisted = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n#ifdef DEBUG\r\n\t\t\tcerr << \"original size = \" << _conjunctionIDMat[i].size() << endl;\r\n\t\t\tcerr << \"conjunctionIDVec.size() = \" << conjunctionIDVec.size() << endl;\r\n#endif // DEBUG\r\n\t\t\t\r\n\t\t\tstatic unsigned int countBad = 0, countGood = 0;\r\n\t\t\tunsigned int offset = conjunctionIDVec.size() - 1;\r\n\t\t\tvector< vector< unsigned int > > rangeMat;\r\n\t\t\t\r\n\t\t\tif( _isGoodPath( coordVec, offset, rangeMat ) == false ) {\r\n\r\n#ifdef DEBUG\r\n\t\t\t\tcerr << \"coordVec.size() = \" << coordVec.size() << endl;\r\n\t\t\t\tcerr << \"countBad = \" << countBad++ << endl;\r\n\t\t\t\tfor( unsigned int m = 0; m < rangeMat.size(); m++ ){\r\n\t\t\t\t\tcerr << \"( min, max ) = ( \" << rangeMat[m][0]+offset << \", \" << rangeMat[m][1]+offset << \" ) \" << endl;\r\n\t\t\t\t}\r\n#endif // DEBUG\r\n\t\t\t\t\r\n\t\t\t\tfor( unsigned int m = 0; m < rangeMat.size(); m++ ){\r\n\r\n\t\t\t\t\tunsigned int min = rangeMat[m][0];\r\n\t\t\t\t\tunsigned int max = rangeMat[m][1];\r\n\r\n\t\t\t\t\t// initialization\r\n\t\t\t\t\tvector< KeiRo::Base::Coord2 > subCoordVec;\r\n\t\t\t\t\tvector< unsigned int > subIDStack;\r\n\t\t\t\t\tvector< unsigned int > subBestStack;\r\n\t\t\t\t\tvector< bool > subIsVisitedVec( max-min+1 );\r\n\t\t\t\t\tdouble subLength = INFINITY;\r\n\t\t\t\t\tfor( unsigned int n = min; n < max+1; n++ ){\r\n\t\t\t\t\t\tsubCoordVec.push_back( coordVec[n] );\r\n\t\t\t\t\t\tsubIsVisitedVec[ n ] = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tsubIDStack.push_back( 0 );\r\n\t\t\t\t\tsubIsVisitedVec[ 0 ] = true;\r\n\t\t\t\t\t_reorderPaths( subCoordVec, subIDStack, subIsVisitedVec, subBestStack, subLength );\r\n\r\n\t\t\t\t\t// retrieve the path result\r\n\t\t\t\t\tif( subLength != INFINITY ) {\r\n#ifdef DEBUG\r\n\t\t\t\t\t\tcerr << \"subL = \" << subLength << endl;\r\n\t\t\t\t\t\tcerr << \"subIDStack = [ \";\r\n\t\t\t\t\t\tfor( unsigned int j = 0; j < subIDStack.size(); j++ ) {\r\n\t\t\t\t\t\t\tunsigned int id = offset + min + subIDStack[ j ];\r\n\t\t\t\t\t\t\tcerr << id << \", \";\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcerr << \" ]\" << endl;\r\n#endif // DEBUG\r\n\t\t\t\t\t\tfor( unsigned int j = 0; j < subIDStack.size(); j++ ) {\r\n\r\n\t\t\t\t\t\t\tunsigned int id = offset + min + subIDStack[ j ];\r\n\t\t\t\t\t\t\tline.elementPointers()[ id ]->x() = subCoordVec[ j ].x();\r\n\t\t\t\t\t\t\tline.elementPointers()[ id ]->y() = subCoordVec[ j ].y();\r\n//\t\t\t\t\t\tconjunctionIDVec.push_back( _conjunctionIDMat[i][ id+offset ] );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfor( unsigned int j = conjunctionIDVec.size(); j < _polylineVec[ i ].elements().size(); j++ ) {\r\n//\t\t\t\t\t\t    conjunctionIDVec.push_back( _conjunctionIDMat[i][ j ] );\r\n\t\t\t\t\t\t}\r\n//\t\t\t\t\t_conjunctionIDMat[ i ] = conjunctionIDVec;\r\n\r\n#ifdef DEBUG\r\n\t\t\t\t\t\tfor( unsigned int j = 0; j < line.elements().size(); j++ ) {\r\n\t\t\t\t\t\t\tcerr << *line.elementPointers()[ j ] << endl;\r\n\t\t\t\t\t\t}\r\n#endif // DEBUG\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n#ifdef DEBUG\r\n\t\t\telse {\r\n\t\t\t\t\tcerr << \"countGood = \" << countGood++ << endl;\r\n\t\t\t}\r\n\t\t\tcerr << \"length = \" << length << endl;\r\n#endif // DEBUG\r\n\t\t}\r\n\r\n\r\n// revisit wrong vertices\r\n//\t\t\tfor( unsigned int i = 0; i < _conjunctionIDMat.size(); i++ ){\r\n////\t\t\tcerr << \"_conjunctionIDMat[i].size() = \" << _conjunctionIDMat[i].size() << endl;\r\n////\t\t\tcerr << \"_polylineVec[i].elementPointers().size() = \" << _polylineVec[i].elementPointers().size() << endl;\r\n//\r\n//\t\t\t\tfor( unsigned int j = 2; j < _conjunctionIDMat[i].size()-1; j++ ) {\r\n//\r\n//\t\t\t\t\tif( ( _conjunctionIDMat[ i ][ j - 1 ].conjunctionType == CONJUNCTION_CORNER ) &&\r\n//\t\t\t\t\t    ( _conjunctionIDMat[ i ][ j ].conjunctionType == CONJUNCTION_CORNER ) ) {\r\n//\t\t\t\t\t\tKeiRo::Base::Coord2 &preprev = *_polylineVec[ i ].elementPointers()[ j - 2 ];\r\n//\t\t\t\t\t\tKeiRo::Base::Coord2 &prev = *_polylineVec[ i ].elementPointers()[ j - 1 ];\r\n//\t\t\t\t\t\tKeiRo::Base::Coord2 &curr = *_polylineVec[ i ].elementPointers()[ j ];\r\n//\t\t\t\t\t\tKeiRo::Base::Coord2 &post = *_polylineVec[ i ].elementPointers()[ j + 1 ];\r\n//\r\n//\t\t\t\t\t\tKeiRo::Base::Coord2 diffPrevA = preprev - prev;\r\n//\t\t\t\t\t\tKeiRo::Base::Coord2 diffPrevB = curr - prev;\r\n//\t\t\t\t\t\tKeiRo::Base::Coord2 diffCurrA = prev - curr;\r\n//\t\t\t\t\t\tKeiRo::Base::Coord2 diffCurrB = post - curr;\r\n//\r\n////\t\t\t\t\t\tcerr << \"j = \" << j << endl;\r\n//\t\t\t\t\t\tcerr << \"fabs( diffPrevA.x() ) = \" << fabs( diffPrevA.x() ) << endl;\r\n//\t\t\t\t\t\tcerr << \"fabs( diffPrevA.y() ) = \" << fabs( diffPrevA.y() ) << endl;\r\n//\t\t\t\t\t\tcerr << \"fabs( diffCurrB.x() ) = \" << fabs( diffCurrB.x() ) << endl;\r\n//\t\t\t\t\t\tcerr << \"fabs( diffCurrB.y() ) = \" << fabs( diffCurrB.y() ) << endl;\r\n//\r\n//\t\t\t\t\t\tbool isSwap = false;\r\n//\r\n//\t\t\t\t\t\tif( fabs( diffPrevA.x() ) > 5 && fabs( diffPrevA.y() ) > 5 ||\r\n//\t\t\t\t\t\t    fabs( diffCurrB.x() ) > 5 && fabs( diffCurrB.y() ) > 5 ) {\r\n////\t\t\t\t\t\tif( fabs( diffPrevA.x() ) > _min_point_distance && fabs( diffPrevA.y() ) > _min_point_distance &&\r\n////\t\t\t\t\t\t    fabs( diffCurrB.x() ) > _min_point_distance && fabs( diffCurrB.y() ) > _min_point_distance ) {\r\n//\t\t\t\t\t\t\tisSwap = true;\r\n//\t\t\t\t\t\t\tcerr << \"HERE?\" << endl;\r\n//\t\t\t\t\t\t}\r\n//\r\n//\t\t\t\t\t\t// curr on preprev+prev\r\n//\t\t\t\t\t\tcerr << \"j = \" << j << endl;\r\n//\t\t\t\t\t\tcerr << \"preprev = \" << preprev;\r\n//\t\t\t\t\t\tcerr << \"prev = \" << prev;\r\n//\t\t\t\t\t\tcerr << \"curr = \" << curr;\r\n//\t\t\t\t\t\tcerr << \"post = \" << post;\r\n//\t\t\t\t\t\tvector< KeiRo::Base::Coord2 > elements;\r\n//\t\t\t\t\t\telements.push_back( preprev );\r\n//\t\t\t\t\t\telements.push_back( prev );\r\n//\t\t\t\t\t\tKeiRo::Base::Edge2 e1( elements );\r\n//\t\t\t\t\t\tcerr << \"e1.isOnEdge( curr ) = \" << e1.isOnEdge( curr ) << endl;\r\n//\t\t\t\t\t\tif( e1.isOnEdge( curr ) == true ){\r\n//\t\t\t\t\t\t\tisSwap = true;\r\n//\t\t\t\t\t\t}\r\n//\r\n//\t\t\t\t\t\t// prev on curr+post\r\n//\t\t\t\t\t\telements.clear();\r\n//\t\t\t\t\t\telements.push_back( curr );\r\n//\t\t\t\t\t\telements.push_back( post );\r\n//\t\t\t\t\t\tKeiRo::Base::Edge2 e2( elements );\r\n//\t\t\t\t\t\tcerr << \" e2.isOnEdge( prev ) = \" << e2.isOnEdge( prev ) << endl;\r\n//\t\t\t\t\t\tif( e2.isOnEdge( prev ) == true ){\r\n//\t\t\t\t\t\t\tisSwap = true;\r\n//\t\t\t\t\t\t}\r\n//\r\n//\t\t\t\t\t\tif( isSwap == true ){\r\n//\t\t\t\t\t\t\tConjunctionIndex tmp = _conjunctionIDMat[i][j];\r\n//\t\t\t\t\t\t\tKeiRo::Base::Coord2 *tmpC = _polylineVec[ i ].elementPointers()[j];\r\n//\t\t\t\t\t\t\t// swap two sample points\r\n//\t\t\t\t\t\t\t_conjunctionIDMat[i][j] = _conjunctionIDMat[i][j-1];\r\n//\t\t\t\t\t\t\t_conjunctionIDMat[i][j-1] = tmp;\r\n//\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[j] = _polylineVec[ i ].elementPointers()[j-1];\r\n//\t\t\t\t\t\t\t_polylineVec[ i ].elementPointers()[j-1] = tmpC;\r\n//\t\t\t\t\t\t}\r\n//\t\t\t\t\t}\r\n//\t\t\t\t}\r\n//\t\t\t}\r\n//\t\t}\r\n\t}\r\n\t\r\n\tbool HierarchicalPath::_isGoodPath( vector< KeiRo::Base::Coord2 > &coordVec, unsigned int offset,\r\n\t\t\t\t\t\t\t\t   vector< vector< unsigned int > > &rangeMat )\r\n\t{\r\n    \tbool isGood = true;\r\n    \tint min = coordVec.size();\r\n    \tint max = 0;\r\n    \tunsigned int goodRange = 5;\r\n    \tunsigned int tolerance = 2;\r\n    \tunsigned int currentRange = 0;\r\n    \t\r\n    \tfor( unsigned int i = 1; i < coordVec.size(); i++ ){\r\n\t\t\r\n\t\t    KeiRo::Base::Coord2 &prev = coordVec[i-1];\r\n\t\t    KeiRo::Base::Coord2 &curr = coordVec[i];\r\n\t\t    KeiRo::Base::Coord2 diff = curr - prev;\r\n\r\n#ifdef DEBUG\r\n\t        cerr << \"currentRange = \" << currentRange << endl;\r\n#endif // DEBUG\r\n\t\t    if( fabs( diff.x() ) > 3.5 && fabs( diff.y() ) > 3.5 ){\r\n\t\t    \tif ( min > i ) min = i;\r\n\t\t    \tif ( max < i ) max = i;\r\n\t\t    \tcurrentRange = 0;\r\n\t\t    \tisGood = false;\r\n\t\t    }\r\n\t\t    else{\r\n\t\t    \tcurrentRange++;\r\n\t\t    }\r\n\t\t\r\n\t\t    if( (( currentRange > goodRange ) || ( i == coordVec.size()-1) ) && ( max != 0 ) ){\r\n\r\n\t\t\t    vector< unsigned int > rangeVec;\r\n\t\t\t    rangeVec.push_back( MAX2( 0, min-(int)tolerance-1 ) );\r\n\t\t\t    rangeVec.push_back( MIN2( max+(int)tolerance, coordVec.size()-1 ) );\r\n\t\t\t\trangeMat.push_back( rangeVec );\r\n\r\n\t\t\t    // reset\r\n\t\t\t    min = coordVec.size();\r\n\t\t\t    max = 0;\r\n\t\t    }\r\n\t    }\r\n#ifdef DEBUG\r\n    \tif( !isGood ){\r\n    \t\tfor( unsigned int i = 0; i < rangeMat.size(); i++ ){\r\n\t\t\t    cerr << \"( min, max ) = ( \" << rangeMat[i][0]+offset << \", \" << rangeMat[i][1]+offset << \" ) \" << endl;\r\n    \t\t}\r\n    \t}\r\n#endif // DEBUG\r\n    \treturn isGood;\r\n    }\r\n    \r\n\tbool HierarchicalPath::_reorderPaths( vector< KeiRo::Base::Coord2 > &coordVec,\r\n\t                                    vector< unsigned int > &idStack, vector< bool > &isVisitedVec,\r\n\t                                    vector< unsigned int > &bestStack, double &bestLength\r\n\t                                     )\r\n\t{\r\n    \tbool isFound = false;\r\n    \tbool atLeastOneIsNotVisited = false;\r\n    \t\r\n    \tfor( unsigned int i = 0; i < isVisitedVec.size(); i++ ){\r\n    \t\tif( isVisitedVec[i] == false ){\r\n    \t\t\tatLeastOneIsNotVisited = true;\r\n\t\t\t    if( fabs( coordVec[ idStack[idStack.size() - 1] ].x() - coordVec[ i ].x() ) <= 1 ||\r\n\t\t\t\t    fabs( coordVec[ idStack[idStack.size() - 1] ].y() - coordVec[ i ].y() ) <= 1\r\n\t\t\t\t\t){\r\n\t\t\t\t    idStack.push_back( i );\r\n\t\t\t\t    isVisitedVec[ i ] = true;\r\n#ifdef DEBUG\r\n\t\t\t\t    cout << \"->\" << i << \" \" << coordVec[i] <<  endl;\r\n#endif // DEBUG\r\n\t\t\t\t    isFound = _reorderPaths( coordVec, idStack, isVisitedVec, bestStack, bestLength );\r\n#ifdef DEBUG\r\n\t\t\t\t    cout << \"<-\" << i << \" \" << isFound << endl;\r\n#endif // DEBUG\r\n\t\t\t\t    if( isFound == false ) {\r\n\t\t\t\t    \t\r\n\t\t\t\t    \tidStack.pop_back();\r\n\t\t\t\t\t    isVisitedVec[ i ] = false;\r\n\t\t\t\t    }\r\n\t\t\t    } else {\r\n#ifdef DEBUG\r\n\t\t\t\t    cout << \"no \" << i << \" \" << coordVec[i] <<  endl;\r\n#endif // DEBUG\r\n\t\t\t    }\r\n\t\t    }\r\n    \t}\r\n    \tif( !atLeastOneIsNotVisited ){\r\n\r\n#ifdef DEBUG\r\n\t\t    for( unsigned int id : idStack ){\r\n    \t\t\tcout << id << \", \";\r\n    \t\t}\r\n    \t\tcout << endl;\r\n#endif // DEBUG\r\n\t\t    double length = 0.0;\r\n\t\t    for( unsigned int i = 1; i < idStack.size(); i++ ){\r\n\t\t    \tlength += (coordVec[i]-coordVec[i-1]).norm();\r\n\t\t    }\r\n\t\t    \r\n\t\t    if( length < bestLength ){\r\n\t\t    \tbestStack = idStack;\r\n\t\t    \tbestLength = length;\r\n\t\t    }\r\n\t\t    return true;\r\n    \t}\r\n        return isFound;\r\n\t}\r\n\t\r\n} // namespace Lens\r\n\r\n\r\n\t//remove duplicate\r\n\t// cerr << \"before remove \"<<endl;\r\n\t// for( unsigned int i = 0; i < _polylineVec.size(); i++ ) {\r\n\t// \tKeiRo::Base::Line2 &polyline = _polylineVec[i];\r\n\t// \tfor( unsigned int j = 0; j < _conjunctionMat[i].size()-1; j++ ) {\r\n\t// \t\t// remove duplicate points\r\n\t// \t\tif (polyline.elementPointers()[j]->x() == polyline.elementPointers()[j+1]->x() &&\r\n\t// polyline.elementPointers()[j]->y() == polyline.elementPointers()[j+1]->y()) {\r\n\t// \t\t\tcerr << \"duplicate in line \" << i << \" point \" << j <<endl;\r\n\t// \t\t\tauto it = polyline.elementPointers().begin() + j+1;\r\n\t// \t\t\tauto itC = _conjunctionMat[i].begin()+j+1;\r\n\t//\r\n\t//\r\n\t// \t\t\t_conjunctionMat[i].erase(itC);\r\n\t//\r\n\t// \t\t\tcerr << \"pathsize before \"<<polyline.elementPointers().size() <<endl;\r\n\t// \t\t\tpolyline.elementPointers().erase(it);\r\n\t// \t\t\tcerr << \"pathsize after \"<<polyline.elementPointers().size()<<endl;;\r\n\t// \t\t\tprint_path(i);\r\n\t// }\r\n\t// \t}\r\n\t// }
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ResponsiveLens/core/HierarchicalPath.cpp b/ResponsiveLens/core/HierarchicalPath.cpp
--- a/ResponsiveLens/core/HierarchicalPath.cpp	
+++ b/ResponsiveLens/core/HierarchicalPath.cpp	
@@ -1987,7 +1987,7 @@
 			_polylineVec.push_back( polyline );
 			_edgeAttributeVec.push_back( edge );
 			_conjunctionMat.push_back( conjunctionVec );
-
+print_path(pathIndex);
 
 
 #ifdef DEBUG_HIERARCHICALPATH
@@ -2030,27 +2030,28 @@
 			}
 			cerr << endl;
 #endif // DEBUG_HIERARCHICALPATH
+
 			pathIndex++;
 			 }
-		cout << "Starting idGS for each path:" << endl;
-		for (size_t i = 0; i < pathStartIdGS.size(); ++i) {
-			cout << "Path " << i << " starts at idGS: " << pathStartIdGS[i] << endl;
-		}
-
-		cout << "\nNumber of paths starting at each idGS:" << endl;
-		for (const auto& pair : idGSCounter) {
-			cout << "idGS " << pair.first << ": " << pair.second << " path(s)" << endl;
-		}
-
-		cout << "Starting idGT for each path:" << endl;
-		for (size_t i = 0; i < pathStartIdGT.size(); ++i) {
-			cout << "Path " << i << " starts at idGT: " << pathStartIdGT[i] << endl;
-		}
-
-		cout << "\nNumber of paths starting at each idGT:" << endl;
-		for (const auto& pair : idGTCounter) {
-			cout << "idGT " << pair.first << ": " << pair.second << " path(s)" << endl;
-		}
+		// cout << "Starting idGS for each path:" << endl;
+		// for (size_t i = 0; i < pathStartIdGS.size(); ++i) {
+		// 	cout << "Path " << i << " starts at idGS: " << pathStartIdGS[i] << endl;
+		// }
+		//
+		// cout << "\nNumber of paths starting at each idGS:" << endl;
+		// for (const auto& pair : idGSCounter) {
+		// 	cout << "idGS " << pair.first << ": " << pair.second << " path(s)" << endl;
+		// }
+		//
+		// cout << "Starting idGT for each path:" << endl;
+		// for (size_t i = 0; i < pathStartIdGT.size(); ++i) {
+		// 	cout << "Path " << i << " starts at idGT: " << pathStartIdGT[i] << endl;
+		// }
+		//
+		// cout << "\nNumber of paths starting at each idGT:" << endl;
+		// for (const auto& pair : idGTCounter) {
+		// 	cout << "idGT " << pair.first << ": " << pair.second << " path(s)" << endl;
+		// }
 
 
 
@@ -2085,8 +2086,8 @@
 				path.fixedElements()[j].x() = path.elementPointers()[j]->x();
 				path.fixedElements()[j].y() = path.elementPointers()[j]->y();
 			}
-			cerr << "path in inital " << i << endl;
-			print_path(i);
+			//cerr << "path in inital " << i << endl;
+			//print_path(i);
 		}
 
 	}
@@ -2130,7 +2131,7 @@
 		//cerr<<"reorder start !!!" << p <<endl;
 		std::vector<unsigned int> reorderedIndices;
 		std::vector<bool> isVisited(polyline.elementPointers().size(), false);
-		print_path(p);
+		//print_path(p);
 		unsigned int currentIndex = 0;
 		reorderedIndices.push_back(currentIndex);
 		isVisited[currentIndex] = true;
@@ -2348,7 +2349,7 @@
 		//print_path(p);
 
 
-		cerr << endl;
+		//cerr << endl;
 
 		// cerr << "HERE: " << p << endl;
 		// for (unsigned int i = 0; i < _conjunctionMat[p].size(); i++) {
@@ -2669,7 +2670,7 @@
 							//_compressedPathGraph.graph().clear();
 							//buildHierarchicalPaths();
 							compute_shortest_path(ids,idt, idgs,idgt,i);
-							cerr <<" shortest path computation finish "<<endl;
+							//cerr <<" shortest path computation finish "<<endl;
 
 							 auto& shortestPath = _polylineVecShort.back();
 							 auto& shortestConjunction = _conjunctionMatShort.back();
@@ -2723,8 +2724,8 @@
 				}
 			}
 
-			if(localMoves.empty() && !_passed )
-				reorderPath(i);
+			// if(localMoves.empty() && !_passed )
+			// 	reorderPath(i);
 		}
 
 	}
@@ -2735,602 +2736,954 @@
 		KeiRo::Base::Line2 &polyline = _polylineVec[i];
 		double eps = 0.001;
 		//cerr<<"path in local update "<< i <<endl;
-		//if (i ==52 || i ==53 )
-		//print_path(i);
+
 		// loop over the local moves in order
 		//cerr <<"localMoves.size() localMoves_updatePath " << localMoves.size()<<endl;
 
 		for(unsigned int m = 0; m < localMoves.size(); m++) {
 
 			LocalMove move = localMoves[m];
-			//check for each localmove if the segment between rectangles vertical
-			if(!move.beforeSegmentHorizontal()) {
-		//		cerr << "vertical segment in local move " << m << endl;
-				if(move.stretchMove()) {
-		//			cerr << "stretch move "<<endl;
-
-
-					for (int tid = 0 ; tid<_conjunctionMat[i][j].treemapID.size() ; tid++) {
-
-						//left
-						Graph::TreeDirectedGraph::vertex_descriptor vdBLB = vertex( move.beforeLeftBottomID() , graphmlTree );
-						KeiRo::Base::Rectangle2 &bboxLB = *graphmlTree[ vdBLB ].boundingBoxPtr;
-
-						//right
-						Graph::TreeDirectedGraph::vertex_descriptor vdBRT = vertex( move.beforeRightTopID() , graphmlTree );
-						KeiRo::Base::Rectangle2 &bboxRT = *graphmlTree[ vdBRT ].boundingBoxPtr;
-
-						// distinguish the cases
-						//handling the cases where the path ends at one rects but does not pass in between
-						int case_number;
-						if (bboxLB.width() > bboxLB.oldWidth() && bboxLB.leftBottom().y() > bboxRT.leftBottom().y()) {
-							//left rect is up
-							cerr <<"case 1"<<endl;
-							case_number = 1;
-						}
-						else if (bboxLB.width() > bboxLB.oldWidth() && bboxLB.leftBottom().y() == bboxRT.leftBottom().y()) {
-							//left rect is down
-							case_number = 2;
-							cerr <<"case 2"<<endl;
-						}
-						else if (bboxRT.width() > bboxRT.oldWidth() && bboxRT.leftBottom().y() > bboxLB.leftBottom().y()) {
-							//right rect is up
-							case_number = 3;
-							cerr <<"case 3"<<endl;
-
-						}
-						else if (bboxRT.width() > bboxRT.oldWidth() && bboxRT.leftBottom().y() == bboxLB.leftBottom().y()) {
-							//right rect is douwn
-							case_number = 4;
-							cerr <<"case 4"<<endl;
-
-						}
-
-
-
-						switch (case_number) {
-							case 1: {
-								if ( polyline.elementPointers()[j]->x() != bboxRT.oldLeftBottom().x()  && j == 1
-									&& _conjunctionMat[i][j].conjunctionType == CONJUNCTION_NONCORNER
-									&& (_conjunctionMat[i][j].treemapID[tid] == move.beforeLeftBottomID()  ||
-									_conjunctionMat[i][j].treemapID[tid] == move.beforeRightTopID()) ) {
-									_passed==true;
-									if ( polyline.elementPointers()[j+1]->x() == bboxLB.oldLeftBottom().x()+bboxLB.oldWidth() &&
-										polyline.elementPointers()[j+2]->x() == bboxLB.oldLeftBottom().x()){
-
-										//update j+1
-										_conjunctionMat[i][j+1].treemapID.clear();
-										_conjunctionMat[i][j+1].pointType.clear();
-										addConj(i,move.beforeRightTopID(),j+1,POINT_LEFTTOP);
-
-										//update j+2
-										_conjunctionMat[i][j+2].treemapID.clear();
-										_conjunctionMat[i][j+2].pointType.clear();
-										addConj(i,move.afterLeftBottomID(),j+2,POINT_LEFTBOTTOM);
-										_passed = true;
-										polyline.elementPointers()[j+1]->inLocalMove()=true;
-										polyline.elementPointers()[j+2]->inLocalMove()=true;
-
-										}
-									else if (polyline.elementPointers()[j+1]->x() == bboxRT.oldLeftBottom().x()+bboxRT.oldWidth() ) {
-										//cerr << " line is going up to right!!"<<endl;
-										_conjunctionMat[i][j+1].treemapID.clear();
-										_conjunctionMat[i][j+1].pointType.clear();
-										addConj(i,move.afterLeftBottomID(),j+1,POINT_RIGHTTOP);
-										//add new point
-										vector<unsigned int> ids ;
-										vector< POINTTYPE> pt;
-
-										ids.push_back(move.afterLeftBottomID());
-										pt.push_back((pointTypes[POINT_RIGHTBOTTOM]));
-
-										ids.push_back(move.afterRightTopID());
-										pt.push_back((pointTypes[POINT_RIGHTTOP]));
-
-										double x = bboxLB.leftBottom().x()+ bboxLB.width();
-										double y = bboxLB.leftBottom().y();
-										addNewVertex(i,j,ids,j+1,CONJUNCTION_CORNER,pt,x,y);
-										_passed = true;
-										polyline.elementPointers()[j+1]->inLocalMove()=true;
-									}
-									else if (polyline.elementPointers()[j+1]->x() == bboxLB.leftBottom().x() ||
-										polyline.elementPointers()[j+1]->x() == bboxLB.oldLeftBottom().x() ) {
-										_passed=true;
-										polyline.elementPointers()[j+1]->inLocalMove()=true;
-									}
-								}
-
-
-
-
-								if ( polyline.elementPointers()[j]->x() != bboxRT.oldLeftBottom().x() && j == polyline.elementPointers().size()-2
-								&& _conjunctionMat[i][j].conjunctionType == CONJUNCTION_NONCORNER &&
-								(_conjunctionMat[i][j].treemapID[tid] == move.beforeLeftBottomID()  ||
-								_conjunctionMat[i][j].treemapID[tid] == move.beforeRightTopID()) ) {
-									//cerr <<"the point ends at one of the rects "<<endl;
-									_passed=true;
-									//case where left rect is smaller and up
-
-									if (polyline.elementPointers()[j-1]->x() == bboxLB.leftBottom().x()+ bboxLB.width()&&
-									polyline.elementPointers()[j-2]->x() == bboxLB.leftBottom().x()) {
-										//cerr << "the point in between !!"<<endl;
-										//update j-1
-										removeConj(i,move.beforeLeftBottomID(),j-1,2);
-										polyline.elementPointers()[j-1]->x() = bboxRT.leftBottom().x();
-										polyline.elementPointers()[j-1]->y() = bboxRT.leftBottom().y() + bboxRT.height();
-
-										//update j-2
-										_conjunctionMat[i][j-2].treemapID.clear();
-										_conjunctionMat[i][j-2].pointType.clear();
-										addConj(i,move.afterLeftBottomID(),j-2,POINT_LEFTBOTTOM);
-										polyline.elementPointers()[j-2]->x() = bboxLB.leftBottom().x();
-										polyline.elementPointers()[j-2]->y() = bboxLB.leftBottom().y();
-										_passed = true;
-										polyline.elementPointers()[j-2]->inLocalMove()=true;
-										polyline.elementPointers()[j-1]->inLocalMove()=true;
-										polyline.elementPointers()[j]->inLocalMove()=true;
-									}
-									else if (polyline.elementPointers()[j-1]->x() == bboxLB.leftBottom().x()) {
-											//cerr << "line is going down from right"<<endl;
-											_conjunctionMat[i][j-1].treemapID.clear();
-											_conjunctionMat[i][j-1].pointType.clear();
-
-											addConj(i,move.beforeLeftBottomID(),j-1,POINT_RIGHTTOP);
-											polyline.elementPointers()[j-1]->x() = bboxLB.leftBottom().x() + bboxLB.width();
-											polyline.elementPointers()[j-1]->y() = bboxLB.leftBottom().y() + bboxLB.height();
-
-
-											//add new point
-											vector<unsigned int> ids ;
-											vector< POINTTYPE> pt;
-
-											ids.push_back(move.beforeLeftBottomID());
-											pt.push_back((pointTypes[POINT_RIGHTBOTTOM]));
-
-											ids.push_back(move.beforeRightTopID());
-											pt.push_back((pointTypes[POINT_RIGHTTOP]));
-
-											double x = polyline.elementPointers()[j-1]->x();
-											double y = polyline.elementPointers()[j]->y();
-
-											addNewVertex(i,j-1,ids,j,CONJUNCTION_CORNER,pt,x,y);
-										_passed = true;
-										polyline.elementPointers()[j-2]->inLocalMove()=true;
-										polyline.elementPointers()[j-1]->inLocalMove()=true;
-										polyline.elementPointers()[j]->inLocalMove()=true;
-
-
-
-									}
-
-									else if (polyline.elementPointers()[j-1]->x() == bboxLB.leftBottom().x() ||
-										polyline.elementPointers()[j-1]->x() == bboxLB.oldLeftBottom().x() ) {
-										_passed=true;
-										polyline.elementPointers()[j-2]->inLocalMove()=true;
-
-									}
-								}
-							}
-							case 2: {
-								if ( polyline.elementPointers()[j]->x() != bboxRT.oldLeftBottom().x()  && j == 1
-									&& _conjunctionMat[i][j].conjunctionType == CONJUNCTION_NONCORNER
-									&& (_conjunctionMat[i][j].treemapID[tid] == move.beforeLeftBottomID()  ||
-									_conjunctionMat[i][j].treemapID[tid] == move.beforeRightTopID()) ) {
-
-									_passed =true;
-									}
-							}
-							case 3: {
-								if ( polyline.elementPointers()[j]->x() != bboxRT.oldLeftBottom().x()  && j == 1
-									&& _conjunctionMat[i][j].conjunctionType == CONJUNCTION_NONCORNER
-									&& (_conjunctionMat[i][j].treemapID[tid] == move.beforeLeftBottomID()  ||
-									_conjunctionMat[i][j].treemapID[tid] == move.beforeRightTopID()) ) {
-
-									_passed =true;
-								}
-							}
-							case 4: {
-								if ( polyline.elementPointers()[j]->x() != bboxRT.oldLeftBottom().x()  && j == 1
-									&& _conjunctionMat[i][j].conjunctionType == CONJUNCTION_NONCORNER
-									&& (_conjunctionMat[i][j].treemapID[tid] == move.beforeLeftBottomID()  ||
-									_conjunctionMat[i][j].treemapID[tid] == move.beforeRightTopID()) ) {
-
-									_passed =true;
-									}
-							}
-								default:
-									cerr << "non of the cases "<<endl;
-
-							/*vector<unsigned int> ids ;
-							vector< POINTTYPE> pt;
-
-							ids.push_back(move.afterLeftBottomID());
-							pt.push_back((pointTypes[POINT_LEFTBOTTOM]));
-
-							double x = polyline.elementPointers()[j-2]->x();
-							double y = polyline.elementPointers()[j]->y();
-							addNewVertex(i,j,ids,j-2,CONJUNCTION_CORNER,pt,x,y);
-*/
-
-
-
-
-							}
- 					}
-
-
-						// if( i == 69 && j==2) {
-						// 	if (_conjunctionMat[i][j].conjunctionType == CONJUNCTION_NONCORNER && (_conjunctionMat[i][j].treemapID[tid] == move.beforeLeftBottomID()  ||
-						// 		_conjunctionMat[i][j].treemapID[tid] == move.beforeRightTopID()) ){
-						// 		cerr<<"very1"<<endl;
-						// 		_conjunctionMat[i][j+1].treemapID.clear();
-						// 		_conjunctionMat[i][j+1].pointType.clear();
-						// 		addConj(i,move.beforeRightTopID(),j+1,POINT_RIGHTTOP);
-						// 		}
-						// }
-						// if (i==69 && j == polyline.elementPointers().size()-2) {
-						// 	if (_conjunctionMat[i][j].conjunctionType == CONJUNCTION_NONCORNER && (_conjunctionMat[i][j].treemapID[tid] == move.beforeLeftBottomID()  ||
-						// 		_conjunctionMat[i][j].treemapID[tid] == move.beforeRightTopID()) ){
-						// 		cerr<<"very2"<<endl;
-						// 		_conjunctionMat[i][j-1].treemapID.clear();
-						// 		_conjunctionMat[i][j-1].pointType.clear();
-						// 		_conjunctionMat[i][j-1].treemapID.push_back(move.afterRightTopID());
-						// 		_conjunctionMat[i][j-1].pointType.push_back(POINT_RIGHTTOP);
-						//
-						// 		}
-						// }
-
-
-
-					//_conjunctionMat[i].size() - 1 != j + 2 &&
-					if(
-					abs(polyline.elementPointers()[j]->x() - polyline.elementPointers()[j + 1]->x()) <= eps ) {
-						// check whether segment of path has same coordinate as segment of local move
-						//cerr << "the line segment is also vertical "<<endl;
-						//cerr << " points "<<polyline.elementPointers()[j]->x()<<","<<polyline.elementPointers()[j]->y()<<endl;
-						//if(polyline.elementPointers()[j]->x() == move.beforeSegmentCoord())    {
-						//	cerr << "both line and segment have same x coord "<<endl;
-
-						//left
-						Graph::TreeDirectedGraph::vertex_descriptor vdBLB = vertex( move.beforeLeftBottomID() , graphmlTree );
-						KeiRo::Base::Rectangle2 &bboxLB = *graphmlTree[ vdBLB ].boundingBoxPtr;
+			//left
+			Graph::TreeDirectedGraph::vertex_descriptor vdBLB = vertex( move.beforeLeftBottomID() , graphmlTree );
+			KeiRo::Base::Rectangle2 &bboxLB = *graphmlTree[ vdBLB ].boundingBoxPtr;
 
-						//right
-						Graph::TreeDirectedGraph::vertex_descriptor vdBRT = vertex( move.beforeRightTopID() , graphmlTree );
-						KeiRo::Base::Rectangle2 &bboxRT = *graphmlTree[ vdBRT ].boundingBoxPtr;
+			//right
+			Graph::TreeDirectedGraph::vertex_descriptor vdBRT = vertex( move.beforeRightTopID() , graphmlTree );
+			KeiRo::Base::Rectangle2 &bboxRT = *graphmlTree[ vdBRT ].boundingBoxPtr;
 
-
-						if (polyline.elementPointers()[j]->x() >= bboxLB.oldLeftBottom().x() +bboxLB.oldWidth() &&
-								polyline.elementPointers()[j]->x() <= bboxRT.oldLeftBottom().x()) {
-							//cerr <<"the path is btween x coor of rects "<<endl;
-
-							//cerr << i<<" "<< j <<endl;
-
-
-							if (bboxRT.oldHeight() < bboxLB.oldHeight()) {
-								//cerr << "the right rect is smaller "<<endl;
-								bool isRT = true;
-								//primary box is the smaller
-								KeiRo::Base::Rectangle2 primaryBox = bboxRT;
-								KeiRo::Base::Rectangle2 secondaryBox = bboxLB;
-								unsigned int primaryId = move.beforeRightTopID();
-								unsigned int secondaryId = move.beforeLeftBottomID();
-
-								//order the points of the segment
-								double top = std::max(polyline.elementPointers()[j]->y(), polyline.elementPointers()[j+1]->y());
-								double bottom = std::min(polyline.elementPointers()[j]->y(), polyline.elementPointers()[j+1]->y());
-
-								if ((top == primaryBox.oldLeftBottom().y() + primaryBox.oldHeight()  && bottom >= primaryBox.oldLeftBottom().y() )
-									|| (top <= primaryBox.oldLeftBottom().y() + bboxLB.oldHeight() && bottom == primaryBox.oldLeftBottom().y())) {
-
-									if (bboxRT.oldLeftBottom().y() > bboxLB.oldLeftBottom().y()) {
-										//cerr << "right rect is up "<<endl;
-
-
-										_passed = true;
-										polyline.elementPointers()[j]->inLocalMove()=true;
-
-
-										//cerr<< "line i "<< i <<" central seg is within the two rects hights" << endl;
-										bool isCentral = true;
-
-										//line is going down or up
-										bool isRT = (top ==  polyline.elementPointers()[j]->y());
-
-										int currentIdx =  (top == polyline.elementPointers()[j]->y()) ? j  : j + 1;
-										int nextIdx =  (top == polyline.elementPointers()[j]->y()) ? j+1  : j ;
-										int prevIdx = (top == polyline.elementPointers()[j]->y()) ? j-1  : j + 2;
-
-										int removeCorner = 3;
-										int storPt;
-										int addFactor = 1;
-
-										double x = primaryBox.leftBottom().x();
-										double y = primaryBox.leftBottom().y();
+			if(!move.beforeSegmentHorizontal()) {
+				if(move.stretchMove()) {
+					if (bboxRT.oldHeight() < bboxLB.oldHeight()) {
+						//cerr << "the right rect is smaller "<<endl;
+						if (bboxRT.oldLeftBottom().y() > bboxLB.oldLeftBottom().y()) {
+							//cerr <<"right rect is up"<<endl;
+							if ( (polyline.elementPointers()[j]->x()== bboxLB.leftBottom().x() &&
+								polyline.elementPointers()[j]->y()== bboxLB.leftBottom().y()+ bboxLB.height() ) ||
+								(polyline.elementPointers()[j]->x()== bboxLB.leftBottom().x()+ bboxLB.width() &&
+								polyline.elementPointers()[j]->y()== bboxLB.leftBottom().y()+ bboxLB.height())||
+								(polyline.elementPointers()[j]->x()== bboxRT.leftBottom().x() +bboxRT.width() &&
+								polyline.elementPointers()[j]->y()== bboxRT.leftBottom().y() +bboxRT.height())||
+								(polyline.elementPointers()[j]->x()== bboxRT.leftBottom().x()&&
+								polyline.elementPointers()[j]->y()== bboxRT.leftBottom().y()))
+								_passed= true;
+							else if ( (polyline.elementPointers()[j]->x()== bboxLB.oldLeftBottom().x() &&
+								polyline.elementPointers()[j]->y()== bboxLB.oldLeftBottom().y()+ bboxLB.oldHeight() ) ||
+								(polyline.elementPointers()[j]->x()== bboxLB.oldLeftBottom().x()+ bboxLB.oldWidth() &&
+								polyline.elementPointers()[j]->y()== bboxLB.oldLeftBottom().y()+ bboxLB.oldHeight())||
+								(polyline.elementPointers()[j]->x()== bboxRT.oldLeftBottom().x() +bboxRT.oldWidth() &&
+								polyline.elementPointers()[j]->y()== bboxRT.oldLeftBottom().y() +bboxRT.oldHeight())||
+								(polyline.elementPointers()[j]->x()== bboxRT.oldLeftBottom().x()&&
+								polyline.elementPointers()[j]->y()== bboxRT.oldLeftBottom().y()))
+								_passed= true;
 
 
-										handleALL(i,j,currentIdx,nextIdx,prevIdx, removeCorner, addFactor,
-											primaryBox,secondaryBox,primaryId,secondaryId,isCentral, move,isRT, x,y);
-									}
-
-
-									else if (bboxRT.oldLeftBottom().y() == bboxLB.oldLeftBottom().y()) {
-										//cerr << "right rect is down "<<endl;
-
-										_passed = true;
-
-										polyline.elementPointers()[j]->inLocalMove()=true;
-										//cerr<< "line i "<< i <<" central seg is within the two rects hights" << endl;
-										bool isCentral = true;
-										//line is going down or up
-										bool isDown = (top ==  polyline.elementPointers()[j]->y());
+						}
+						else if (bboxRT.oldLeftBottom().y() == bboxLB.oldLeftBottom().y()){
+							//cerr <<"right rect is down"<<endl;
+							if ( (polyline.elementPointers()[j]->x()== bboxLB.leftBottom().x() &&
+								polyline.elementPointers()[j]->y()== bboxLB.leftBottom().y() ) ||
+								(polyline.elementPointers()[j]->x()== bboxLB.leftBottom().x()+ bboxLB.width() &&
+								polyline.elementPointers()[j]->y()== bboxLB.leftBottom().y())||
+								(polyline.elementPointers()[j]->x()== bboxRT.leftBottom().x() +bboxRT.width() &&
+								polyline.elementPointers()[j]->y()== bboxRT.leftBottom().y() )||
+								(polyline.elementPointers()[j]->x()== bboxRT.leftBottom().x()&&
+								polyline.elementPointers()[j]->y()== bboxRT.leftBottom().y() + bboxRT.height()))
+								_passed= true;
+							else if ( (polyline.elementPointers()[j]->x()== bboxLB.oldLeftBottom().x() &&
+								polyline.elementPointers()[j]->y()== bboxLB.oldLeftBottom().y() ) ||
+								(polyline.elementPointers()[j]->x()== bboxLB.oldLeftBottom().x()+ bboxLB.width() &&
+								polyline.elementPointers()[j]->y()== bboxLB.oldLeftBottom().y())||
+								(polyline.elementPointers()[j]->x()== bboxRT.oldLeftBottom().x() +bboxRT.width() &&
+								polyline.elementPointers()[j]->y()== bboxRT.oldLeftBottom().y() )||
+								(polyline.elementPointers()[j]->x()== bboxRT.oldLeftBottom().x()&&
+								polyline.elementPointers()[j]->y()== bboxRT.oldLeftBottom().y() + bboxRT.height()))
+								_passed= true;
 
-
-										int currentIdx = j ? top ==  polyline.elementPointers()[j]->y() : j+1;
-										int nextIdx = j+1 ? top ==  polyline.elementPointers()[j]->y() : j;
-										int prevIdx = j+2 ? top ==  polyline.elementPointers()[j]->y() : j-1;
-										int removeCorner = 2;
-										int storPt;
-										int addFactor = -1;
-
-										double x = polyline.elementPointers()[nextIdx]->x();
-										double y = polyline.elementPointers()[currentIdx]->y();
-
-
-										// handleALL(i,j,currentIdx,nextIdx,prevIdx, removeCorner, addFactor,
-										// 	primaryBox,secondaryBox,primaryId,secondaryId,isCentral, move,isRT,x,y);
-
-									}
-									}
+						}
 
-							}
+					}
 
-
-
-							if (bboxRT.oldHeight() > bboxLB.oldHeight()) {
-								//cerr << "the left rect is smaller "<<endl;
-								bool isRT = false;
-								//primary box is the smaller
-
-								KeiRo::Base::Rectangle2 primaryBox = bboxLB;
-								KeiRo::Base::Rectangle2 secondaryBox = bboxRT;
-								unsigned int primaryId = move.beforeLeftBottomID();
-								unsigned int secondaryId = move.beforeRightTopID();
-
-								//order the points of the segment
-								double top = std::max(polyline.elementPointers()[j]->y(), polyline.elementPointers()[j+1]->y());
-								double bottom = std::min(polyline.elementPointers()[j]->y(), polyline.elementPointers()[j+1]->y());
-
-								if ((top == primaryBox.oldLeftBottom().y() + primaryBox.oldHeight()  && bottom >= primaryBox.oldLeftBottom().y() )
-									|| (top <= primaryBox.oldLeftBottom().y() + bboxLB.oldHeight() && bottom == primaryBox.oldLeftBottom().y())) {
-
-									if (bboxLB.oldLeftBottom().y() > bboxRT.oldLeftBottom().y()) {
-										//cerr <<"left rect is up"<<endl;
-
-
-										_passed = true;
-
-										polyline.elementPointers()[j]->inLocalMove()=true;
-										//cerr<< "line i "<< i <<" centeral seg is within the two rects hights" << endl;
-
-										// handleCase(i, j, top == polyline.elementPointers()[j]->y(),move, bboxRT, bboxLB);
-										bool isCentral = true;
-
-										//line is going up or down
-										int currentIdx = (top == polyline.elementPointers()[j]->y()) ? j  : j + 1;
-										int nextIdx =  (top == polyline.elementPointers()[j]->y()) ? j + 1 : j;
-										int prevIdx =  (top == polyline.elementPointers()[j]->y()) ? j - 1 : j +2 ;
-										int removeCorner = 4;
-										int storPt;
-										int addFactor = -1;
-										int isDR = (top == polyline.elementPointers()[j]->y()) ? true  : false;
-
-
-
-										double x = primaryBox.leftBottom().x() + primaryBox.width();
-										double y = primaryBox.leftBottom().y();
-
-
-											cerr <<endl;
-											handleALL(i,j,currentIdx,nextIdx,prevIdx, removeCorner, addFactor,
-											primaryBox,secondaryBox,primaryId,secondaryId,isCentral, move,isDR, x,y);
-
-									}
-									if (bboxLB.oldLeftBottom().y() == bboxRT.oldLeftBottom().y()) {
-										//cerr <<"left rect is down"<<endl;
-
-										//line is going down or up
-										_passed = true;
-
-										polyline.elementPointers()[j]->inLocalMove()=true;
-										//cerr<< "line i "<< i <<" centeral seg is within the two rects hights" << endl;
-										// handleCase(i, j, top == polyline.elementPointers()[j]->y(),move, bboxRT, bboxLB);
-										bool isCentral = true;
-
-										//line is going up or down
-										int currentIdx = j ? top ==  polyline.elementPointers()[j]->y() :j+1;
-										int nextIdx = j+1 ?top ==  polyline.elementPointers()[j]->y() : j;
-										int prevIdx = j+2 ?top ==  polyline.elementPointers()[j]->y() :j-1;
-										int removeCorner = 1;
-										int storPt;
-										int addFactor = 1;
-
-										double x = polyline.elementPointers()[nextIdx]->x();
-										double y = polyline.elementPointers()[currentIdx]->y();
-
-
-										// handleALL(i,j,currentIdx,nextIdx,prevIdx, removeCorner, addFactor,
-										// 	primaryBox,secondaryBox,primaryId,secondaryId,isCentral, move,isRT, x,y);
+					else if (bboxRT.oldHeight() > bboxLB.oldHeight()) {
+						//cerr << "the left rect is smaller "<<endl;
+						if (bboxLB.oldLeftBottom().y() > bboxRT.oldLeftBottom().y()) {
+							//cerr <<"left rect is up"<<endl;
+							if ( (polyline.elementPointers()[j]->x()== bboxLB.leftBottom().x() &&
+								polyline.elementPointers()[j]->y()== bboxLB.leftBottom().y()+ bboxLB.height() ) ||
+								(polyline.elementPointers()[j]->x()== bboxLB.leftBottom().x()+ bboxLB.width() &&
+								polyline.elementPointers()[j]->y()== bboxLB.leftBottom().y()+ bboxLB.height())||
+								(polyline.elementPointers()[j]->x()== bboxRT.leftBottom().x() +bboxRT.width() &&
+								polyline.elementPointers()[j]->y()== bboxRT.leftBottom().y() +bboxRT.height())||
+								(polyline.elementPointers()[j]->x()== bboxLB.leftBottom().x() +bboxLB.width() &&
+								polyline.elementPointers()[j]->y()== bboxLB.leftBottom().y()))
+								_passed= true;
+							else if ( (polyline.elementPointers()[j]->x()== bboxLB.oldLeftBottom().x() &&
+								polyline.elementPointers()[j]->y()== bboxLB.oldLeftBottom().y()+ bboxLB.oldHeight() ) ||
+								(polyline.elementPointers()[j]->x()== bboxLB.oldLeftBottom().x()+ bboxLB.oldWidth() &&
+								polyline.elementPointers()[j]->y()== bboxLB.oldLeftBottom().y()+ bboxLB.oldHeight())||
+								(polyline.elementPointers()[j]->x()== bboxRT.oldLeftBottom().x() +bboxRT.oldWidth() &&
+								polyline.elementPointers()[j]->y()== bboxRT.oldLeftBottom().y() +bboxRT.oldHeight())||
+								(polyline.elementPointers()[j]->x()== bboxLB.oldLeftBottom().x()+bboxLB.oldWidth()&&
+								polyline.elementPointers()[j]->y()== bboxLB.oldLeftBottom().y()))
+								_passed= true;
+						}
+						else if (bboxRT.oldLeftBottom().y() == bboxLB.oldLeftBottom().y()){
+							//cerr <<"left rect is down"<<endl;
+							if ( (polyline.elementPointers()[j]->x()== bboxLB.leftBottom().x() &&
+								polyline.elementPointers()[j]->y()== bboxLB.leftBottom().y() ) ||
+								(polyline.elementPointers()[j]->x()== bboxLB.leftBottom().x()+ bboxLB.width() &&
+								polyline.elementPointers()[j]->y()== bboxLB.leftBottom().y())||
+								(polyline.elementPointers()[j]->x()== bboxRT.leftBottom().x() +bboxRT.width() &&
+								polyline.elementPointers()[j]->y()== bboxRT.leftBottom().y() )||
+								(polyline.elementPointers()[j]->x()== bboxLB.leftBottom().x() +bboxLB.width() &&
+								polyline.elementPointers()[j]->y()== bboxLB.leftBottom().y()+ bboxLB.height()))
+								_passed= true;
+							else if (  (polyline.elementPointers()[j]->x()== bboxLB.oldLeftBottom().x() &&
+								polyline.elementPointers()[j]->y()== bboxLB.oldLeftBottom().y() ) ||
+								(polyline.elementPointers()[j]->x()== bboxLB.oldLeftBottom().x()+ bboxLB.oldWidth() &&
+								polyline.elementPointers()[j]->y()== bboxLB.oldLeftBottom().y())||
+								(polyline.elementPointers()[j]->x()== bboxRT.oldLeftBottom().x() +bboxRT.oldWidth() &&
+								polyline.elementPointers()[j]->y()== bboxRT.oldLeftBottom().y() )||
+								(polyline.elementPointers()[j]->x()== bboxLB.oldLeftBottom().x() +bboxLB.oldWidth() &&
+								polyline.elementPointers()[j]->y()== bboxLB.oldLeftBottom().y()+ bboxLB.oldHeight()))
+								_passed= true;
 
-									}
-									}
-							}
-								}
-					}
+						}
+
+					}
+				}
+				else if (!move.stretchMove()) {
+					if ( (polyline.elementPointers()[j]->x()== bboxLB.leftBottom().x() &&
+								polyline.elementPointers()[j]->y()== bboxLB.leftBottom().y() ) ||
+								(polyline.elementPointers()[j]->x()== bboxLB.leftBottom().x()+ bboxLB.width() &&
+								polyline.elementPointers()[j]->y()== bboxLB.leftBottom().y())||
+								(polyline.elementPointers()[j]->x()== bboxRT.leftBottom().x() +bboxRT.width() &&
+								polyline.elementPointers()[j]->y()== bboxRT.leftBottom().y() )||
+								(polyline.elementPointers()[j]->x()== bboxLB.leftBottom().x() +bboxLB.width() &&
+								polyline.elementPointers()[j]->y()== bboxLB.leftBottom().y()+ bboxLB.height())||
+								(polyline.elementPointers()[j]->x()== bboxLB.leftBottom().x()  &&
+								polyline.elementPointers()[j]->y()== bboxLB.leftBottom().y()+ bboxLB.height())||
+								(polyline.elementPointers()[j]->x()== bboxRT.leftBottom().x() +bboxRT.width() &&
+								polyline.elementPointers()[j]->y()== bboxRT.leftBottom().y() + bboxRT.height() ))
+						_passed= true;
+					else if (  (polyline.elementPointers()[j]->x()== bboxLB.oldLeftBottom().x() &&
+								polyline.elementPointers()[j]->y()== bboxLB.oldLeftBottom().y() ) ||
+								(polyline.elementPointers()[j]->x()== bboxLB.oldLeftBottom().x()+ bboxLB.oldWidth() &&
+								polyline.elementPointers()[j]->y()== bboxLB.oldLeftBottom().y())||
+								(polyline.elementPointers()[j]->x()== bboxRT.oldLeftBottom().x() +bboxRT.oldWidth() &&
+								polyline.elementPointers()[j]->y()== bboxRT.oldLeftBottom().y() )||
+								(polyline.elementPointers()[j]->x()== bboxLB.oldLeftBottom().x() +bboxLB.oldWidth() &&
+								polyline.elementPointers()[j]->y()== bboxLB.oldLeftBottom().y()+ bboxLB.oldHeight())||
+								(polyline.elementPointers()[j]->x()== bboxLB.oldLeftBottom().x()  &&
+								polyline.elementPointers()[j]->y()== bboxLB.oldLeftBottom().y()+ bboxLB.oldHeight())||
+								(polyline.elementPointers()[j]->x()== bboxRT.oldLeftBottom().x() +bboxRT.oldWidth() &&
+								polyline.elementPointers()[j]->y()== bboxRT.oldLeftBottom().y() + bboxRT.oldHeight() ))
+						_passed= true;
 				}
 			}
-
-
-			else if ( move.beforeSegmentHorizontal()) {
+			else if(move.beforeSegmentHorizontal()) {
 				if(move.stretchMove()) {
-		//			cerr << "stretch move "<<endl;
-					if(
-					abs(polyline.elementPointers()[j]->y() - polyline.elementPointers()[j + 1]->y()) <= eps ) {
-						// check whether segment of path has same coordinate as segment of local move
-						//cerr << "the line segment is also horizontal "<<endl;
-						//cerr << " points "<<polyline.elementPointers()[j]->x()<<","<<polyline.elementPointers()[j]->y()<<endl;
-						//left
-						Graph::TreeDirectedGraph::vertex_descriptor vdBLB = vertex( move.beforeLeftBottomID() , graphmlTree );
-						KeiRo::Base::Rectangle2 &bboxLB = *graphmlTree[ vdBLB ].boundingBoxPtr;
-
-						//right
-						Graph::TreeDirectedGraph::vertex_descriptor vdBRT = vertex( move.beforeRightTopID() , graphmlTree );
-						KeiRo::Base::Rectangle2 &bboxRT = *graphmlTree[ vdBRT ].boundingBoxPtr;
-
-
-						if (polyline.elementPointers()[j]->y() >= bboxLB.oldLeftBottom().y() +bboxLB.oldHeight() &&
-								polyline.elementPointers()[j]->y() <= bboxRT.oldLeftBottom().y()) {
-							//cerr <<" the path is between y coor of rects "<<endl;
-							//cerr << i<<" "<< j <<endl;
-
-
-							if (bboxRT.oldWidth() < bboxLB.oldWidth()) {
-								//cerr << "the top rect is smaller "<<endl;
-								bool isRT = true;
-								//primary box is the smaller
-								KeiRo::Base::Rectangle2 primaryBox = bboxRT;
-								KeiRo::Base::Rectangle2 secondaryBox = bboxLB;
-								unsigned int primaryId = move.beforeRightTopID();
-								unsigned int secondaryId = move.beforeLeftBottomID();
-
-								//order the points of the segment (left to right)
-								double left = std::min(polyline.elementPointers()[j]->x(), polyline.elementPointers()[j+1]->x());
-								double right = std::max(polyline.elementPointers()[j]->x(), polyline.elementPointers()[j+1]->x());
-								if ((left == primaryBox.oldLeftBottom().x()   && right <= primaryBox.oldLeftBottom().x() + primaryBox.oldWidth() )
-								|| (left >= primaryBox.oldLeftBottom().x()  && right == primaryBox.oldLeftBottom().x()+primaryBox.oldWidth())) {
-									if (bboxRT.oldLeftBottom().x() == bboxLB.oldLeftBottom().x()) {
-										//cerr << "top rect is left "<<endl;
-										_passed = true;
-
-										polyline.elementPointers()[j]->inLocalMove()=true;
-										//cerr<< "line i "<< i <<" central seg is within the two rects widths" << endl;
-										bool isCentral = true;
-										//line is going right or left
-
-										int currentIdx = j ? left ==  polyline.elementPointers()[j]->x() : j+1;
-										int nextIdx = j+1 ? left ==  polyline.elementPointers()[j]->x() : j;
-										int prevIdx = j-1 ?left ==  polyline.elementPointers()[j]->x() : j+2;
-										int removeCorner = 4;
-										int storPt;
-										int addFactor = -3;
-
-										double x = polyline.elementPointers()[nextIdx]->x();
-										double y = polyline.elementPointers()[currentIdx]->y();
-
-
-										// handleALL(i,j,currentIdx,nextIdx,prevIdx, removeCorner, addFactor,
-										// 	primaryBox,secondaryBox,primaryId,secondaryId,isCentral, move,isRT, x,y);
-
-
-
-									}
-									if (bboxRT.oldLeftBottom().x() > bboxLB.oldLeftBottom().x()) {
-										//cerr << "top rect is right "<<endl;
-
-										_passed = true;
-										polyline.elementPointers()[j]->inLocalMove()=true;
-										//cerr<< "line i "<< i <<" central seg is within the two rects widths" << endl;
-										bool isCentral = true;
-										//line is going up or down
-
-										int currentIdx = j ?left ==  polyline.elementPointers()[j]->x(): j+1;
-										int nextIdx = j+1 ?left ==  polyline.elementPointers()[j]->x() : j;
-										int prevIdx = j+2 ? left ==  polyline.elementPointers()[j]->x() : j-1;
-										int removeCorner = 3;
-										int storPt;
-										int addFactor = -1;
-
-										double x = polyline.elementPointers()[currentIdx]->x();
-										double y = polyline.elementPointers()[nextIdx]->y();
-
-
-										// handleALL(i,j,currentIdx,nextIdx,prevIdx, removeCorner, addFactor,
-										// 	primaryBox,secondaryBox,primaryId,secondaryId,isCentral, move,isRT, x,y);
-
-
-									}
-								}
-
-							}
-							else if (bboxRT.oldWidth() > bboxLB.oldWidth()) {
-								//cerr << "the bottom rect is smaller "<<endl;
-								bool isRT = true;
-								//primary box is the smaller
-								KeiRo::Base::Rectangle2 primaryBox = bboxLB;
-								KeiRo::Base::Rectangle2 secondaryBox = bboxRT;
-								unsigned int primaryId = move.beforeLeftBottomID();
-								unsigned int secondaryId = move.beforeRightTopID();
-
-								//order the points of the segment (left to right)
-								double left = std::min(polyline.elementPointers()[j]->x(), polyline.elementPointers()[j+1]->x());
-								double right = std::max(polyline.elementPointers()[j]->x(), polyline.elementPointers()[j+1]->x());
-								if ((left == primaryBox.oldLeftBottom().x()   && right <= primaryBox.oldLeftBottom().x() + primaryBox.oldWidth() )
-								|| (left >= primaryBox.oldLeftBottom().x()  && right == primaryBox.oldLeftBottom().x()+primaryBox.oldWidth())) {
-									if (bboxRT.oldLeftBottom().x() == bboxLB.oldLeftBottom().x()) {
-										//cerr << "bottom rect is left "<<endl;
-										_passed = true;
-										polyline.elementPointers()[j]->inLocalMove()=true;
-										//cerr<< "line i "<< i <<" central seg is within the two rects widths" << endl;
-										bool isCentral = true;
-										//line is going right or left
-										int currentIdx = j ? left ==  polyline.elementPointers()[j]->x() : j+1;
-										int nextIdx = j+1 ? left ==  polyline.elementPointers()[j]->x() : j;
-										int prevIdx = j-1 ? left ==  polyline.elementPointers()[j]->x() : j+2;
-										int removeCorner = 1;
-										int storPt;
-										int addFactor = +3;
+					if (bboxRT.oldWidth() > bboxLB.oldWidth()) {
+						//cerr << "the bottom rect is smaller "<<endl;
+						if (bboxLB.oldLeftBottom().x() > bboxRT.oldLeftBottom().x()) {
+							//bottom rect is on the right
+							if ( (polyline.elementPointers()[j]->x()== bboxLB.leftBottom().x() &&
+								polyline.elementPointers()[j]->y()== bboxLB.leftBottom().y()+bboxLB.height() ) ||
+								(polyline.elementPointers()[j]->x()== bboxLB.leftBottom().x()+ bboxLB.width() &&
+								polyline.elementPointers()[j]->y()== bboxLB.leftBottom().y())||
+								(polyline.elementPointers()[j]->x()== bboxRT.leftBottom().x() +bboxRT.width() &&
+								polyline.elementPointers()[j]->y()== bboxRT.leftBottom().y() )||
+								(polyline.elementPointers()[j]->x()== bboxRT.leftBottom().x()+bboxRT.width()   &&
+								polyline.elementPointers()[j]->y()== bboxRT.leftBottom().y()+ bboxRT.height()))
+								_passed= true;
+							else if (  (polyline.elementPointers()[j]->x()== bboxLB.oldLeftBottom().x() &&
+								polyline.elementPointers()[j]->y()== bboxLB.oldLeftBottom().y()+bboxLB.oldHeight() ) ||
+								(polyline.elementPointers()[j]->x()== bboxLB.oldLeftBottom().x()+ bboxLB.oldWidth() &&
+								polyline.elementPointers()[j]->y()== bboxLB.oldLeftBottom().y())||
+								(polyline.elementPointers()[j]->x()== bboxRT.oldLeftBottom().x() +bboxRT.oldWidth() &&
+								polyline.elementPointers()[j]->y()== bboxRT.oldLeftBottom().y() )||
+								(polyline.elementPointers()[j]->x()== bboxRT.oldLeftBottom().x()+bboxRT.oldWidth()   &&
+								polyline.elementPointers()[j]->y()== bboxRT.oldLeftBottom().y()+ bboxRT.oldHeight()))
+								_passed= true;
+						}
+						else if (bboxLB.oldLeftBottom().x() == bboxRT.oldLeftBottom().x()) {
+							//bottom rect is on the left
+							if ( (polyline.elementPointers()[j]->x()== bboxLB.leftBottom().x() &&
+								polyline.elementPointers()[j]->y()== bboxLB.leftBottom().y() ) ||
+								(polyline.elementPointers()[j]->x()== bboxLB.leftBottom().x()+ bboxLB.width() &&
+								polyline.elementPointers()[j]->y()== bboxLB.leftBottom().y()+bboxLB.height())||
+								(polyline.elementPointers()[j]->x()== bboxRT.leftBottom().x()  &&
+								polyline.elementPointers()[j]->y()== bboxRT.leftBottom().y() )||
+								(polyline.elementPointers()[j]->x()== bboxRT.leftBottom().x()  &&
+								polyline.elementPointers()[j]->y()== bboxRT.leftBottom().y()+ bboxRT.height()))
+								_passed= true;
+							else if (  (polyline.elementPointers()[j]->x()== bboxLB.oldLeftBottom().x() &&
+								polyline.elementPointers()[j]->y()== bboxLB.oldLeftBottom().y() ) ||
+								(polyline.elementPointers()[j]->x()== bboxLB.oldLeftBottom().x()+ bboxLB.oldWidth() &&
+								polyline.elementPointers()[j]->y()== bboxLB.oldLeftBottom().y()+bboxLB.oldHeight())||
+								(polyline.elementPointers()[j]->x()== bboxRT.oldLeftBottom().x()  &&
+								polyline.elementPointers()[j]->y()== bboxRT.oldLeftBottom().y() )||
+								(polyline.elementPointers()[j]->x()== bboxRT.oldLeftBottom().x()  &&
+								polyline.elementPointers()[j]->y()== bboxRT.oldLeftBottom().y()+ bboxRT.oldHeight()))
+								_passed= true;
+						}
+					}
+					else if (bboxRT.oldWidth() < bboxLB.oldWidth()) {
+						//cerr << "the top rect is smaller "<<endl;
+						if (bboxLB.oldLeftBottom().x() > bboxRT.oldLeftBottom().x()) {
+							//top rect is on the right
+							if ( (polyline.elementPointers()[j]->x()== bboxLB.leftBottom().x() &&
+								polyline.elementPointers()[j]->y()== bboxLB.leftBottom().y()+bboxLB.height() ) ||
+								(polyline.elementPointers()[j]->x()== bboxLB.leftBottom().x()+ bboxLB.width() &&
+								polyline.elementPointers()[j]->y()== bboxLB.leftBottom().y())||
+								(polyline.elementPointers()[j]->x()== bboxRT.leftBottom().x() +bboxRT.width() &&
+								polyline.elementPointers()[j]->y()== bboxRT.leftBottom().y() )||
+								(polyline.elementPointers()[j]->x()== bboxRT.leftBottom().x()+bboxRT.width()   &&
+								polyline.elementPointers()[j]->y()== bboxRT.leftBottom().y()+ bboxRT.height()))
+								_passed= true;
+							else if (  (polyline.elementPointers()[j]->x()== bboxLB.oldLeftBottom().x() &&
+								polyline.elementPointers()[j]->y()== bboxLB.oldLeftBottom().y()+bboxLB.oldHeight() ) ||
+								(polyline.elementPointers()[j]->x()== bboxLB.oldLeftBottom().x()+ bboxLB.oldWidth() &&
+								polyline.elementPointers()[j]->y()== bboxLB.oldLeftBottom().y())||
+								(polyline.elementPointers()[j]->x()== bboxRT.oldLeftBottom().x() +bboxRT.oldWidth() &&
+								polyline.elementPointers()[j]->y()== bboxRT.oldLeftBottom().y() )||
+								(polyline.elementPointers()[j]->x()== bboxRT.oldLeftBottom().x()+bboxRT.oldWidth()   &&
+								polyline.elementPointers()[j]->y()== bboxRT.oldLeftBottom().y()+ bboxRT.oldHeight()))
+								_passed= true;
+						}
+						else if (bboxLB.oldLeftBottom().x() == bboxRT.oldLeftBottom().x()) {
+							//top rect is on the left
+							if ( (polyline.elementPointers()[j]->x()== bboxLB.leftBottom().x() &&
+								polyline.elementPointers()[j]->y()== bboxLB.leftBottom().y() ) ||
+								(polyline.elementPointers()[j]->x()== bboxLB.leftBottom().x()+ bboxLB.width() &&
+								polyline.elementPointers()[j]->y()== bboxLB.leftBottom().y()+bboxLB.height())||
+								(polyline.elementPointers()[j]->x()== bboxRT.leftBottom().x()  &&
+								polyline.elementPointers()[j]->y()== bboxRT.leftBottom().y() )||
+								(polyline.elementPointers()[j]->x()== bboxRT.leftBottom().x()  &&
+								polyline.elementPointers()[j]->y()== bboxRT.leftBottom().y()+ bboxRT.height()))
+								_passed= true;
+							else if (  (polyline.elementPointers()[j]->x()== bboxLB.oldLeftBottom().x() &&
+								polyline.elementPointers()[j]->y()== bboxLB.oldLeftBottom().y() ) ||
+								(polyline.elementPointers()[j]->x()== bboxLB.oldLeftBottom().x()+ bboxLB.oldWidth() &&
+								polyline.elementPointers()[j]->y()== bboxLB.oldLeftBottom().y()+bboxLB.oldHeight())||
+								(polyline.elementPointers()[j]->x()== bboxRT.oldLeftBottom().x()  &&
+								polyline.elementPointers()[j]->y()== bboxRT.oldLeftBottom().y() )||
+								(polyline.elementPointers()[j]->x()== bboxRT.oldLeftBottom().x()  &&
+								polyline.elementPointers()[j]->y()== bboxRT.oldLeftBottom().y()+ bboxRT.oldHeight()))
+								_passed= true;
+						}
+					}
+				}
+				else if (!move.stretchMove()) {
+					if ( (polyline.elementPointers()[j]->x()== bboxLB.leftBottom().x() &&
+								polyline.elementPointers()[j]->y()== bboxLB.leftBottom().y() ) ||
+								(polyline.elementPointers()[j]->x()== bboxLB.leftBottom().x()+ bboxLB.width() &&
+								polyline.elementPointers()[j]->y()== bboxLB.leftBottom().y())||
+								(polyline.elementPointers()[j]->x()== bboxRT.leftBottom().x() +bboxRT.width() &&
+								polyline.elementPointers()[j]->y()== bboxRT.leftBottom().y() )||
+								(polyline.elementPointers()[j]->x()== bboxLB.leftBottom().x() +bboxLB.width() &&
+								polyline.elementPointers()[j]->y()== bboxLB.leftBottom().y()+ bboxLB.height())||
+								(polyline.elementPointers()[j]->x()== bboxLB.leftBottom().x()  &&
+								polyline.elementPointers()[j]->y()== bboxLB.leftBottom().y()+ bboxLB.height())||
+								(polyline.elementPointers()[j]->x()== bboxRT.leftBottom().x() +bboxRT.width() &&
+								polyline.elementPointers()[j]->y()== bboxRT.leftBottom().y() + bboxRT.height() ))
+						_passed= true;
+					else if (  (polyline.elementPointers()[j]->x()== bboxLB.oldLeftBottom().x() &&
+								polyline.elementPointers()[j]->y()== bboxLB.oldLeftBottom().y() ) ||
+								(polyline.elementPointers()[j]->x()== bboxLB.oldLeftBottom().x()+ bboxLB.oldWidth() &&
+								polyline.elementPointers()[j]->y()== bboxLB.oldLeftBottom().y())||
+								(polyline.elementPointers()[j]->x()== bboxRT.oldLeftBottom().x() +bboxRT.oldWidth() &&
+								polyline.elementPointers()[j]->y()== bboxRT.oldLeftBottom().y() )||
+								(polyline.elementPointers()[j]->x()== bboxLB.oldLeftBottom().x() +bboxLB.oldWidth() &&
+								polyline.elementPointers()[j]->y()== bboxLB.oldLeftBottom().y()+ bboxLB.oldHeight())||
+								(polyline.elementPointers()[j]->x()== bboxLB.oldLeftBottom().x()  &&
+								polyline.elementPointers()[j]->y()== bboxLB.oldLeftBottom().y()+ bboxLB.oldHeight())||
+								(polyline.elementPointers()[j]->x()== bboxRT.oldLeftBottom().x() +bboxRT.oldWidth() &&
+								polyline.elementPointers()[j]->y()== bboxRT.oldLeftBottom().y() + bboxRT.oldHeight() ))
+						_passed= true;
 
-										double x = polyline.elementPointers()[nextIdx]->x();
-										double y = polyline.elementPointers()[currentIdx]->y();
 
-
-										// handleALL(i,j,currentIdx,nextIdx,prevIdx, removeCorner, addFactor,
-										// 	primaryBox,secondaryBox,primaryId,secondaryId,isCentral, move,isRT, x,y);
-
-
-									}
-									if (bboxRT.oldLeftBottom().x() < bboxLB.oldLeftBottom().x()) {
-										//cerr << "bottom rect is right "<<endl;
-										_passed = true;
-										polyline.elementPointers()[j]->inLocalMove()=true;
-										//cerr<< "line i "<< i <<" central seg is within the two rects widths" << endl;
-										bool isCentral = true;
-										//line is going right or left
-
-										int currentIdx = j ? left ==  polyline.elementPointers()[j]->x() : j+1;
-										int nextIdx = j+1 ? left ==  polyline.elementPointers()[j]->x() : j;
-										int prevIdx = j+2 ? left ==  polyline.elementPointers()[j]->x() : j-1;
-										int removeCorner = 2;
-										int storPt;
-										int addFactor = 1;
-
-										double x = polyline.elementPointers()[currentIdx]->x();
-										double y = polyline.elementPointers()[nextIdx]->y();
-
-
-										// handleALL(i,j,currentIdx,nextIdx,prevIdx, removeCorner, addFactor,
-										// 	primaryBox,secondaryBox,primaryId,secondaryId,isCentral, move,isRT, x,y);
-
-									}
-								}
-
-							}
-								}
-
-					}
-
-				}
-			}
+				}
+			}
+			// if ( polyline.elementPointers()[j]->x()== bboxLB.leftBottom().x() ||
+			// 		polyline.elementPointers()[j]->x()== bboxLB.leftBottom().x()+ bboxLB.width()||
+			// 		polyline.elementPointers()[j]->x()== bboxRT.leftBottom().x() +bboxRT.width()||
+			// 		polyline.elementPointers()[j]->y()== bboxLB.leftBottom().y() ||
+			// 		polyline.elementPointers()[j]->y()== bboxLB.leftBottom().y()+ bboxLB.height()||
+			// 		polyline.elementPointers()[j]->y()== bboxRT.leftBottom().y() +bboxRT.height()||
+			//
+			// 		polyline.elementPointers()[j]->x()== bboxLB.oldLeftBottom().x() ||
+			// 	   polyline.elementPointers()[j]->x()== bboxLB.oldLeftBottom().x()+ bboxLB.oldWidth()||
+			// 	   polyline.elementPointers()[j]->x()== bboxRT.oldLeftBottom().x() +bboxRT.oldWidth()||
+			// 	   polyline.elementPointers()[j]->y()== bboxLB.oldLeftBottom().y() ||
+			// 	   polyline.elementPointers()[j]->y()== bboxLB.oldLeftBottom().y()+ bboxLB.oldHeight()||
+			// 	   polyline.elementPointers()[j]->y()== bboxRT.oldLeftBottom().y() +bboxRT.oldHeight())
+			// 	_passed= true;
+			//check for each localmove if the segment between rectangles vertical
+// 			if(!move.beforeSegmentHorizontal()) {
+//
+// 				//if the line pass through any point
+//
+// 		//		cerr << "vertical segment in local move " << m << endl;
+// 				if(move.stretchMove()) {
+// 		//			cerr << "stretch move "<<endl;
+// 					//new idea last min (identify the 7 points)
+// 					//left
+// 					Graph::TreeDirectedGraph::vertex_descriptor vdBLB = vertex( move.beforeLeftBottomID() , graphmlTree );
+// 					KeiRo::Base::Rectangle2 &bboxLB = *graphmlTree[ vdBLB ].boundingBoxPtr;
+//
+// 					//right
+// 					Graph::TreeDirectedGraph::vertex_descriptor vdBRT = vertex( move.beforeRightTopID() , graphmlTree );
+// 					KeiRo::Base::Rectangle2 &bboxRT = *graphmlTree[ vdBRT ].boundingBoxPtr;
+//
+//
+//
+//
+//
+//
+// 					for (int tid = 0 ; tid<_conjunctionMat[i][j].treemapID.size() ; tid++) {
+//
+// 						//left
+// 						Graph::TreeDirectedGraph::vertex_descriptor vdBLB = vertex( move.beforeLeftBottomID() , graphmlTree );
+// 						KeiRo::Base::Rectangle2 &bboxLB = *graphmlTree[ vdBLB ].boundingBoxPtr;
+//
+// 						//right
+// 						Graph::TreeDirectedGraph::vertex_descriptor vdBRT = vertex( move.beforeRightTopID() , graphmlTree );
+// 						KeiRo::Base::Rectangle2 &bboxRT = *graphmlTree[ vdBRT ].boundingBoxPtr;
+//
+// 						// distinguish the cases
+// 						//handling the cases where the path ends at one rects but does not pass in between
+// 						int case_number;
+// 						if (bboxLB.width() > bboxLB.oldWidth() && bboxLB.leftBottom().y() > bboxRT.leftBottom().y()) {
+// 							//left rect is up
+// 							//cerr <<"case 1"<<endl;
+// 							case_number = 1;
+// 						}
+// 						else if (bboxLB.width() > bboxLB.oldWidth() && bboxLB.leftBottom().y() == bboxRT.leftBottom().y()) {
+// 							//left rect is down
+// 							case_number = 2;
+// 							//cerr <<"case 2"<<endl;
+// 						}
+// 						else if (bboxRT.width() > bboxRT.oldWidth() && bboxRT.leftBottom().y() > bboxLB.leftBottom().y()) {
+// 							//right rect is up
+// 							case_number = 3;
+// 							//cerr <<"case 3"<<endl;
+//
+// 						}
+// 						else if (bboxRT.width() > bboxRT.oldWidth() && bboxRT.leftBottom().y() == bboxLB.leftBottom().y()) {
+// 							//right rect is douwn
+// 							case_number = 4;
+// 							//cerr <<"case 4"<<endl;
+//
+// 						}
+//
+//
+//
+// 						switch (case_number) {
+// 							case 1: {
+// 								if ( polyline.elementPointers()[j]->x() != bboxRT.oldLeftBottom().x()  && j == 1
+// 									&& _conjunctionMat[i][j].conjunctionType == CONJUNCTION_NONCORNER
+// 									&& (_conjunctionMat[i][j].treemapID[tid] == move.beforeLeftBottomID()  ||
+// 									_conjunctionMat[i][j].treemapID[tid] == move.beforeRightTopID()) ) {
+// 									_passed==true;
+// 									if ( polyline.elementPointers()[j+1]->x() == bboxLB.oldLeftBottom().x()+bboxLB.oldWidth() &&
+// 										polyline.elementPointers()[j+2]->x() == bboxLB.oldLeftBottom().x()){
+//
+// 										//update j+1
+// 										_conjunctionMat[i][j+1].treemapID.clear();
+// 										_conjunctionMat[i][j+1].pointType.clear();
+// 										addConj(i,move.beforeRightTopID(),j+1,POINT_LEFTTOP);
+//
+// 										//update j+2
+// 										_conjunctionMat[i][j+2].treemapID.clear();
+// 										_conjunctionMat[i][j+2].pointType.clear();
+// 										addConj(i,move.afterLeftBottomID(),j+2,POINT_LEFTBOTTOM);
+// 										_passed = true;
+// 										polyline.elementPointers()[j+1]->inLocalMove()=true;
+// 										polyline.elementPointers()[j+2]->inLocalMove()=true;
+//
+// 										}
+// 									else if (polyline.elementPointers()[j+1]->x() == bboxRT.oldLeftBottom().x()+bboxRT.oldWidth() ) {
+// 										//cerr << " line is going up to right!!"<<endl;
+// 										_conjunctionMat[i][j+1].treemapID.clear();
+// 										_conjunctionMat[i][j+1].pointType.clear();
+// 										addConj(i,move.afterLeftBottomID(),j+1,POINT_RIGHTTOP);
+// 										//add new point
+// 										vector<unsigned int> ids ;
+// 										vector< POINTTYPE> pt;
+//
+// 										ids.push_back(move.afterLeftBottomID());
+// 										pt.push_back((pointTypes[POINT_RIGHTBOTTOM]));
+//
+// 										ids.push_back(move.afterRightTopID());
+// 										pt.push_back((pointTypes[POINT_RIGHTTOP]));
+//
+// 										double x = bboxLB.leftBottom().x()+ bboxLB.width();
+// 										double y = bboxLB.leftBottom().y();
+// 										addNewVertex(i,j,ids,j+1,CONJUNCTION_CORNER,pt,x,y);
+// 										_passed = true;
+// 										polyline.elementPointers()[j+1]->inLocalMove()=true;
+// 									}
+// 									else if (polyline.elementPointers()[j+1]->x() == bboxLB.leftBottom().x() ||
+// 										polyline.elementPointers()[j+1]->x() == bboxLB.oldLeftBottom().x() ) {
+// 										_passed=true;
+// 										polyline.elementPointers()[j+1]->inLocalMove()=true;
+// 									}
+// 								}
+//
+//
+//
+//
+// 								if ( polyline.elementPointers()[j]->x() != bboxRT.oldLeftBottom().x() && j == polyline.elementPointers().size()-2
+// 								&& _conjunctionMat[i][j].conjunctionType == CONJUNCTION_NONCORNER &&
+// 								(_conjunctionMat[i][j].treemapID[tid] == move.beforeLeftBottomID()  ||
+// 								_conjunctionMat[i][j].treemapID[tid] == move.beforeRightTopID()) ) {
+// 									//cerr <<"the point ends at one of the rects "<<endl;
+// 									_passed=true;
+// 									//case where left rect is smaller and up
+//
+// 									if (polyline.elementPointers()[j-1]->x() == bboxLB.leftBottom().x()+ bboxLB.width()&&
+// 									polyline.elementPointers()[j-2]->x() == bboxLB.leftBottom().x()) {
+// 										//cerr << "the point in between !!"<<endl;
+// 										//update j-1
+// 										removeConj(i,move.beforeLeftBottomID(),j-1,2);
+// 										polyline.elementPointers()[j-1]->x() = bboxRT.leftBottom().x();
+// 										polyline.elementPointers()[j-1]->y() = bboxRT.leftBottom().y() + bboxRT.height();
+//
+// 										//update j-2
+// 										_conjunctionMat[i][j-2].treemapID.clear();
+// 										_conjunctionMat[i][j-2].pointType.clear();
+// 										addConj(i,move.afterLeftBottomID(),j-2,POINT_LEFTBOTTOM);
+// 										polyline.elementPointers()[j-2]->x() = bboxLB.leftBottom().x();
+// 										polyline.elementPointers()[j-2]->y() = bboxLB.leftBottom().y();
+// 										_passed = true;
+// 										polyline.elementPointers()[j-2]->inLocalMove()=true;
+// 										polyline.elementPointers()[j-1]->inLocalMove()=true;
+// 										polyline.elementPointers()[j]->inLocalMove()=true;
+// 									}
+// 									else if (polyline.elementPointers()[j-1]->x() == bboxLB.leftBottom().x()) {
+// 											//cerr << "line is going down from right"<<endl;
+// 											_conjunctionMat[i][j-1].treemapID.clear();
+// 											_conjunctionMat[i][j-1].pointType.clear();
+//
+// 											addConj(i,move.beforeLeftBottomID(),j-1,POINT_RIGHTTOP);
+// 											polyline.elementPointers()[j-1]->x() = bboxLB.leftBottom().x() + bboxLB.width();
+// 											polyline.elementPointers()[j-1]->y() = bboxLB.leftBottom().y() + bboxLB.height();
+//
+//
+// 											//add new point
+// 											vector<unsigned int> ids ;
+// 											vector< POINTTYPE> pt;
+//
+// 											ids.push_back(move.beforeLeftBottomID());
+// 											pt.push_back((pointTypes[POINT_RIGHTBOTTOM]));
+//
+// 											ids.push_back(move.beforeRightTopID());
+// 											pt.push_back((pointTypes[POINT_RIGHTTOP]));
+//
+// 											double x = polyline.elementPointers()[j-1]->x();
+// 											double y = polyline.elementPointers()[j]->y();
+//
+// 											addNewVertex(i,j-1,ids,j,CONJUNCTION_CORNER,pt,x,y);
+// 										_passed = true;
+// 										polyline.elementPointers()[j-2]->inLocalMove()=true;
+// 										polyline.elementPointers()[j-1]->inLocalMove()=true;
+// 										polyline.elementPointers()[j]->inLocalMove()=true;
+//
+//
+//
+// 									}
+//
+// 									else if (polyline.elementPointers()[j-1]->x() == bboxLB.leftBottom().x() ||
+// 										polyline.elementPointers()[j-1]->x() == bboxLB.oldLeftBottom().x() ) {
+// 										_passed=true;
+// 										polyline.elementPointers()[j-2]->inLocalMove()=true;
+//
+// 									}
+// 								}
+// 							}
+// 							case 2: {
+// 								if ( polyline.elementPointers()[j]->x() != bboxRT.oldLeftBottom().x()  && j == 1
+// 									&& _conjunctionMat[i][j].conjunctionType == CONJUNCTION_NONCORNER
+// 									&& (_conjunctionMat[i][j].treemapID[tid] == move.beforeLeftBottomID()  ||
+// 									_conjunctionMat[i][j].treemapID[tid] == move.beforeRightTopID()) ) {
+//
+// 									_passed =true;
+// 									}
+// 							}
+// 							case 3: {
+// 								if ( polyline.elementPointers()[j]->x() != bboxRT.oldLeftBottom().x()  && j == 1
+// 									&& _conjunctionMat[i][j].conjunctionType == CONJUNCTION_NONCORNER
+// 									&& (_conjunctionMat[i][j].treemapID[tid] == move.beforeLeftBottomID()  ||
+// 									_conjunctionMat[i][j].treemapID[tid] == move.beforeRightTopID()) ) {
+//
+// 									_passed =true;
+// 								}
+// 							}
+// 							case 4: {
+// 								if ( polyline.elementPointers()[j]->x() != bboxRT.oldLeftBottom().x()  && j == 1
+// 									&& _conjunctionMat[i][j].conjunctionType == CONJUNCTION_NONCORNER
+// 									&& (_conjunctionMat[i][j].treemapID[tid] == move.beforeLeftBottomID()  ||
+// 									_conjunctionMat[i][j].treemapID[tid] == move.beforeRightTopID()) ) {
+//
+// 									_passed =true;
+// 									}
+// 							}
+// 								default:
+// 									cerr << "non of the cases "<<endl;
+//
+// 							/*vector<unsigned int> ids ;
+// 							vector< POINTTYPE> pt;
+//
+// 							ids.push_back(move.afterLeftBottomID());
+// 							pt.push_back((pointTypes[POINT_LEFTBOTTOM]));
+//
+// 							double x = polyline.elementPointers()[j-2]->x();
+// 							double y = polyline.elementPointers()[j]->y();
+// 							addNewVertex(i,j,ids,j-2,CONJUNCTION_CORNER,pt,x,y);
+// */
+//
+//
+//
+//
+// 							}
+//  					}
+//
+//
+// 						// if( i == 69 && j==2) {
+// 						// 	if (_conjunctionMat[i][j].conjunctionType == CONJUNCTION_NONCORNER && (_conjunctionMat[i][j].treemapID[tid] == move.beforeLeftBottomID()  ||
+// 						// 		_conjunctionMat[i][j].treemapID[tid] == move.beforeRightTopID()) ){
+// 						// 		cerr<<"very1"<<endl;
+// 						// 		_conjunctionMat[i][j+1].treemapID.clear();
+// 						// 		_conjunctionMat[i][j+1].pointType.clear();
+// 						// 		addConj(i,move.beforeRightTopID(),j+1,POINT_RIGHTTOP);
+// 						// 		}
+// 						// }
+// 						// if (i==69 && j == polyline.elementPointers().size()-2) {
+// 						// 	if (_conjunctionMat[i][j].conjunctionType == CONJUNCTION_NONCORNER && (_conjunctionMat[i][j].treemapID[tid] == move.beforeLeftBottomID()  ||
+// 						// 		_conjunctionMat[i][j].treemapID[tid] == move.beforeRightTopID()) ){
+// 						// 		cerr<<"very2"<<endl;
+// 						// 		_conjunctionMat[i][j-1].treemapID.clear();
+// 						// 		_conjunctionMat[i][j-1].pointType.clear();
+// 						// 		_conjunctionMat[i][j-1].treemapID.push_back(move.afterRightTopID());
+// 						// 		_conjunctionMat[i][j-1].pointType.push_back(POINT_RIGHTTOP);
+// 						//
+// 						// 		}
+// 						// }
+//
+//
+//
+// 					//_conjunctionMat[i].size() - 1 != j + 2 &&
+// 					if(
+// 					abs(polyline.elementPointers()[j]->x() - polyline.elementPointers()[j + 1]->x()) <= eps ) {
+// 						// check whether segment of path has same coordinate as segment of local move
+// 						//cerr << "the line segment is also vertical "<<endl;
+// 						//cerr << " points "<<polyline.elementPointers()[j]->x()<<","<<polyline.elementPointers()[j]->y()<<endl;
+// 						//if(polyline.elementPointers()[j]->x() == move.beforeSegmentCoord())    {
+// 						//	cerr << "both line and segment have same x coord "<<endl;
+//
+// 						//left
+// 						Graph::TreeDirectedGraph::vertex_descriptor vdBLB = vertex( move.beforeLeftBottomID() , graphmlTree );
+// 						KeiRo::Base::Rectangle2 &bboxLB = *graphmlTree[ vdBLB ].boundingBoxPtr;
+//
+// 						//right
+// 						Graph::TreeDirectedGraph::vertex_descriptor vdBRT = vertex( move.beforeRightTopID() , graphmlTree );
+// 						KeiRo::Base::Rectangle2 &bboxRT = *graphmlTree[ vdBRT ].boundingBoxPtr;
+//
+//
+// 						if (polyline.elementPointers()[j]->x() >= bboxLB.oldLeftBottom().x() +bboxLB.oldWidth() &&
+// 								polyline.elementPointers()[j]->x() <= bboxRT.oldLeftBottom().x()) {
+// 							//cerr <<"the path is btween x coor of rects "<<endl;
+//
+// 							//cerr << i<<" "<< j <<endl;
+//
+//
+// 							if (bboxRT.oldHeight() < bboxLB.oldHeight()) {
+// 								//cerr << "the right rect is smaller "<<endl;
+// 								bool isRT = true;
+// 								//primary box is the smaller
+// 								KeiRo::Base::Rectangle2 primaryBox = bboxRT;
+// 								KeiRo::Base::Rectangle2 secondaryBox = bboxLB;
+// 								unsigned int primaryId = move.beforeRightTopID();
+// 								unsigned int secondaryId = move.beforeLeftBottomID();
+//
+// 								//order the points of the segment
+// 								double top = std::max(polyline.elementPointers()[j]->y(), polyline.elementPointers()[j+1]->y());
+// 								double bottom = std::min(polyline.elementPointers()[j]->y(), polyline.elementPointers()[j+1]->y());
+//
+// 								if ((top == primaryBox.oldLeftBottom().y() + primaryBox.oldHeight()  && bottom >= primaryBox.oldLeftBottom().y() )
+// 									|| (top <= primaryBox.oldLeftBottom().y() + bboxLB.oldHeight() && bottom == primaryBox.oldLeftBottom().y())) {
+//
+// 									if (bboxRT.oldLeftBottom().y() > bboxLB.oldLeftBottom().y()) {
+// 										//cerr << "right rect is up "<<endl;
+//
+//
+// 										_passed = true;
+// 										polyline.elementPointers()[j]->inLocalMove()=true;
+//
+//
+// 										//cerr<< "line i "<< i <<" central seg is within the two rects hights" << endl;
+// 										bool isCentral = true;
+//
+// 										//line is going down or up
+// 										bool isRT = (top ==  polyline.elementPointers()[j]->y());
+//
+// 										int currentIdx =  (top == polyline.elementPointers()[j]->y()) ? j  : j + 1;
+// 										int nextIdx =  (top == polyline.elementPointers()[j]->y()) ? j+1  : j ;
+// 										int prevIdx = (top == polyline.elementPointers()[j]->y()) ? j-1  : j + 2;
+//
+// 										int removeCorner = 3;
+// 										int storPt;
+// 										int addFactor = 1;
+//
+// 										double x = primaryBox.leftBottom().x();
+// 										double y = primaryBox.leftBottom().y();
+//
+//
+// 										handleALL(i,j,currentIdx,nextIdx,prevIdx, removeCorner, addFactor,
+// 											primaryBox,secondaryBox,primaryId,secondaryId,isCentral, move,isRT, x,y);
+// 									}
+//
+//
+// 									else if (bboxRT.oldLeftBottom().y() == bboxLB.oldLeftBottom().y()) {
+// 										//cerr << "right rect is down "<<endl;
+//
+// 										_passed = true;
+//
+// 										polyline.elementPointers()[j]->inLocalMove()=true;
+// 										//cerr<< "line i "<< i <<" central seg is within the two rects hights" << endl;
+// 										bool isCentral = true;
+// 										//line is going down or up
+// 										bool isDown = (top ==  polyline.elementPointers()[j]->y());
+//
+//
+// 										int currentIdx = j ? top ==  polyline.elementPointers()[j]->y() : j+1;
+// 										int nextIdx = j+1 ? top ==  polyline.elementPointers()[j]->y() : j;
+// 										int prevIdx = j+2 ? top ==  polyline.elementPointers()[j]->y() : j-1;
+// 										int removeCorner = 2;
+// 										int storPt;
+// 										int addFactor = -1;
+//
+// 										double x = polyline.elementPointers()[nextIdx]->x();
+// 										double y = polyline.elementPointers()[currentIdx]->y();
+//
+//
+// 										// handleALL(i,j,currentIdx,nextIdx,prevIdx, removeCorner, addFactor,
+// 										// 	primaryBox,secondaryBox,primaryId,secondaryId,isCentral, move,isRT,x,y);
+//
+// 									}
+// 									}
+//
+// 							}
+//
+//
+//
+// 							if (bboxRT.oldHeight() > bboxLB.oldHeight()) {
+// 								//cerr << "the left rect is smaller "<<endl;
+// 								bool isRT = false;
+// 								//primary box is the smaller
+//
+// 								KeiRo::Base::Rectangle2 primaryBox = bboxLB;
+// 								KeiRo::Base::Rectangle2 secondaryBox = bboxRT;
+// 								unsigned int primaryId = move.beforeLeftBottomID();
+// 								unsigned int secondaryId = move.beforeRightTopID();
+//
+// 								//order the points of the segment
+// 								double top = std::max(polyline.elementPointers()[j]->y(), polyline.elementPointers()[j+1]->y());
+// 								double bottom = std::min(polyline.elementPointers()[j]->y(), polyline.elementPointers()[j+1]->y());
+//
+// 								if ((top == primaryBox.oldLeftBottom().y() + primaryBox.oldHeight()  && bottom >= primaryBox.oldLeftBottom().y() )
+// 									|| (top <= primaryBox.oldLeftBottom().y() + bboxLB.oldHeight() && bottom == primaryBox.oldLeftBottom().y())) {
+//
+// 									if (bboxLB.oldLeftBottom().y() > bboxRT.oldLeftBottom().y()) {
+// 										//cerr <<"left rect is up"<<endl;
+//
+//
+// 										_passed = true;
+//
+// 										polyline.elementPointers()[j]->inLocalMove()=true;
+// 										//cerr<< "line i "<< i <<" centeral seg is within the two rects hights" << endl;
+//
+// 										// handleCase(i, j, top == polyline.elementPointers()[j]->y(),move, bboxRT, bboxLB);
+// 										bool isCentral = true;
+//
+// 										//line is going up or down
+// 										int currentIdx = (top == polyline.elementPointers()[j]->y()) ? j  : j + 1;
+// 										int nextIdx =  (top == polyline.elementPointers()[j]->y()) ? j + 1 : j;
+// 										int prevIdx =  (top == polyline.elementPointers()[j]->y()) ? j - 1 : j +2 ;
+// 										int removeCorner = 4;
+// 										int storPt;
+// 										int addFactor = -1;
+// 										int isDR = (top == polyline.elementPointers()[j]->y()) ? true  : false;
+//
+//
+//
+// 										double x = primaryBox.leftBottom().x() + primaryBox.width();
+// 										double y = primaryBox.leftBottom().y();
+//
+//
+// 											cerr <<endl;
+// 											handleALL(i,j,currentIdx,nextIdx,prevIdx, removeCorner, addFactor,
+// 											primaryBox,secondaryBox,primaryId,secondaryId,isCentral, move,isDR, x,y);
+//
+// 									}
+// 									if (bboxLB.oldLeftBottom().y() == bboxRT.oldLeftBottom().y()) {
+// 										//cerr <<"left rect is down"<<endl;
+//
+// 										//line is going down or up
+// 										_passed = true;
+//
+// 										polyline.elementPointers()[j]->inLocalMove()=true;
+// 										//cerr<< "line i "<< i <<" centeral seg is within the two rects hights" << endl;
+// 										// handleCase(i, j, top == polyline.elementPointers()[j]->y(),move, bboxRT, bboxLB);
+// 										bool isCentral = true;
+//
+// 										//line is going up or down
+// 										int currentIdx = j ? top ==  polyline.elementPointers()[j]->y() :j+1;
+// 										int nextIdx = j+1 ?top ==  polyline.elementPointers()[j]->y() : j;
+// 										int prevIdx = j+2 ?top ==  polyline.elementPointers()[j]->y() :j-1;
+// 										int removeCorner = 1;
+// 										int storPt;
+// 										int addFactor = 1;
+//
+// 										double x = polyline.elementPointers()[nextIdx]->x();
+// 										double y = polyline.elementPointers()[currentIdx]->y();
+//
+//
+// 										// handleALL(i,j,currentIdx,nextIdx,prevIdx, removeCorner, addFactor,
+// 										// 	primaryBox,secondaryBox,primaryId,secondaryId,isCentral, move,isRT, x,y);
+//
+// 									}
+// 									}
+// 							}
+// 								}
+// 					}
+// 				}
+// 				else if (!move.stretchMove()) {//flip move
+//
+//
+//
+//
+// 					if(
+// 					abs(polyline.elementPointers()[j]->x() - polyline.elementPointers()[j + 1]->x()) <= eps ) {
+//
+// 						//left
+// 						Graph::TreeDirectedGraph::vertex_descriptor vdBLB = vertex( move.beforeLeftBottomID() , graphmlTree );
+// 						KeiRo::Base::Rectangle2 &bboxLB = *graphmlTree[ vdBLB ].boundingBoxPtr;
+//
+// 						//right
+// 						Graph::TreeDirectedGraph::vertex_descriptor vdBRT = vertex( move.beforeRightTopID() , graphmlTree );
+// 						KeiRo::Base::Rectangle2 &bboxRT = *graphmlTree[ vdBRT ].boundingBoxPtr;
+// 						if (polyline.elementPointers()[j]->x() == bboxLB.oldLeftBottom().x() +bboxLB.oldWidth() &&
+// 						polyline.elementPointers()[j]->x() == bboxRT.oldLeftBottom().x()&&
+// 						polyline.elementPointers()[j+1]->x() == bboxLB.oldLeftBottom().x() +bboxLB.oldWidth() &&
+// 						polyline.elementPointers()[j+1]->x() == bboxRT.oldLeftBottom().x()								) {
+// 							if ((polyline.elementPointers()[j]->y() == bboxLB.oldLeftBottom().y() +bboxLB.oldHeight()&&
+// 								polyline.elementPointers()[j+1]->y() == bboxLB.oldLeftBottom().y() )||
+// 								(polyline.elementPointers()[j]->y() == bboxLB.oldLeftBottom().y() &&
+// 									polyline.elementPointers()[j+1]->y() == bboxLB.oldLeftBottom().y() +bboxLB.oldHeight())) {
+// 								_passed=true;
+// 							}
+// 						}
+//
+// 					}
+// 				}
+// 			}
+//
+//
+// 			else if ( move.beforeSegmentHorizontal()) {
+// 				//left
+// 				Graph::TreeDirectedGraph::vertex_descriptor vdBLB = vertex( move.beforeLeftBottomID() , graphmlTree );
+// 				KeiRo::Base::Rectangle2 &bboxLB = *graphmlTree[ vdBLB ].boundingBoxPtr;
+//
+// 				//right
+// 				Graph::TreeDirectedGraph::vertex_descriptor vdBRT = vertex( move.beforeRightTopID() , graphmlTree );
+// 				KeiRo::Base::Rectangle2 &bboxRT = *graphmlTree[ vdBRT ].boundingBoxPtr;
+// 				//if the line pass through any point
+// 				if ( polyline.elementPointers()[j]->x()== bboxLB.leftBottom().x() ||
+// 					polyline.elementPointers()[j]->x()== bboxLB.leftBottom().x()+ bboxLB.width()||
+// 					polyline.elementPointers()[j]->x()== bboxRT.leftBottom().x() +bboxRT.width()||
+// 					polyline.elementPointers()[j]->y()== bboxLB.leftBottom().y() ||
+// 					polyline.elementPointers()[j]->y()== bboxLB.leftBottom().y()+ bboxLB.height()||
+// 					polyline.elementPointers()[j]->y()== bboxRT.leftBottom().y() +bboxRT.height())
+// 					_passed= true;
+// 				if(move.stretchMove()) {
+// 		//			cerr << "stretch move "<<endl;
+// 					if(
+// 					abs(polyline.elementPointers()[j]->y() - polyline.elementPointers()[j + 1]->y()) <= eps ) {
+// 						// check whether segment of path has same coordinate as segment of local move
+// 						//cerr << "the line segment is also horizontal "<<endl;
+// 						//cerr << " points "<<polyline.elementPointers()[j]->x()<<","<<polyline.elementPointers()[j]->y()<<endl;
+// 						//left
+// 						Graph::TreeDirectedGraph::vertex_descriptor vdBLB = vertex( move.beforeLeftBottomID() , graphmlTree );
+// 						KeiRo::Base::Rectangle2 &bboxLB = *graphmlTree[ vdBLB ].boundingBoxPtr;
+//
+// 						//right
+// 						Graph::TreeDirectedGraph::vertex_descriptor vdBRT = vertex( move.beforeRightTopID() , graphmlTree );
+// 						KeiRo::Base::Rectangle2 &bboxRT = *graphmlTree[ vdBRT ].boundingBoxPtr;
+//
+//
+// 						if (polyline.elementPointers()[j]->y() >= bboxLB.oldLeftBottom().y() +bboxLB.oldHeight() &&
+// 								polyline.elementPointers()[j]->y() <= bboxRT.oldLeftBottom().y()) {
+// 							//cerr <<" the path is between y coor of rects "<<endl;
+// 							//cerr << i<<" "<< j <<endl;
+//
+//
+// 							if (bboxRT.oldWidth() < bboxLB.oldWidth()) {
+// 								//cerr << "the top rect is smaller "<<endl;
+// 								bool isRT = true;
+// 								//primary box is the smaller
+// 								KeiRo::Base::Rectangle2 primaryBox = bboxRT;
+// 								KeiRo::Base::Rectangle2 secondaryBox = bboxLB;
+// 								unsigned int primaryId = move.beforeRightTopID();
+// 								unsigned int secondaryId = move.beforeLeftBottomID();
+//
+// 								//order the points of the segment (left to right)
+// 								double left = std::min(polyline.elementPointers()[j]->x(), polyline.elementPointers()[j+1]->x());
+// 								double right = std::max(polyline.elementPointers()[j]->x(), polyline.elementPointers()[j+1]->x());
+// 								if ((left == primaryBox.oldLeftBottom().x()   && right <= primaryBox.oldLeftBottom().x() + primaryBox.oldWidth() )
+// 								|| (left >= primaryBox.oldLeftBottom().x()  && right == primaryBox.oldLeftBottom().x()+primaryBox.oldWidth())) {
+// 									if (bboxRT.oldLeftBottom().x() == bboxLB.oldLeftBottom().x()) {
+// 										//cerr << "top rect is left "<<endl;
+// 										_passed = true;
+//
+// 										polyline.elementPointers()[j]->inLocalMove()=true;
+// 										//cerr<< "line i "<< i <<" central seg is within the two rects widths" << endl;
+// 										bool isCentral = true;
+// 										//line is going right or left
+//
+// 										int currentIdx = j ? left ==  polyline.elementPointers()[j]->x() : j+1;
+// 										int nextIdx = j+1 ? left ==  polyline.elementPointers()[j]->x() : j;
+// 										int prevIdx = j-1 ?left ==  polyline.elementPointers()[j]->x() : j+2;
+// 										int removeCorner = 4;
+// 										int storPt;
+// 										int addFactor = -3;
+//
+// 										double x = polyline.elementPointers()[nextIdx]->x();
+// 										double y = polyline.elementPointers()[currentIdx]->y();
+//
+//
+// 										// handleALL(i,j,currentIdx,nextIdx,prevIdx, removeCorner, addFactor,
+// 										// 	primaryBox,secondaryBox,primaryId,secondaryId,isCentral, move,isRT, x,y);
+//
+//
+//
+// 									}
+// 									if (bboxRT.oldLeftBottom().x() > bboxLB.oldLeftBottom().x()) {
+// 										//cerr << "top rect is right "<<endl;
+//
+// 										_passed = true;
+// 										polyline.elementPointers()[j]->inLocalMove()=true;
+// 										//cerr<< "line i "<< i <<" central seg is within the two rects widths" << endl;
+// 										bool isCentral = true;
+// 										//line is going up or down
+//
+// 										int currentIdx = j ?left ==  polyline.elementPointers()[j]->x(): j+1;
+// 										int nextIdx = j+1 ?left ==  polyline.elementPointers()[j]->x() : j;
+// 										int prevIdx = j+2 ? left ==  polyline.elementPointers()[j]->x() : j-1;
+// 										int removeCorner = 3;
+// 										int storPt;
+// 										int addFactor = -1;
+//
+// 										double x = polyline.elementPointers()[currentIdx]->x();
+// 										double y = polyline.elementPointers()[nextIdx]->y();
+//
+//
+// 										// handleALL(i,j,currentIdx,nextIdx,prevIdx, removeCorner, addFactor,
+// 										// 	primaryBox,secondaryBox,primaryId,secondaryId,isCentral, move,isRT, x,y);
+//
+//
+// 									}
+// 								}
+//
+// 							}
+// 							else if (bboxRT.oldWidth() > bboxLB.oldWidth()) {
+// 								//cerr << "the bottom rect is smaller "<<endl;
+// 								bool isRT = true;
+// 								//primary box is the smaller
+// 								KeiRo::Base::Rectangle2 primaryBox = bboxLB;
+// 								KeiRo::Base::Rectangle2 secondaryBox = bboxRT;
+// 								unsigned int primaryId = move.beforeLeftBottomID();
+// 								unsigned int secondaryId = move.beforeRightTopID();
+//
+// 								//order the points of the segment (left to right)
+// 								double left = std::min(polyline.elementPointers()[j]->x(), polyline.elementPointers()[j+1]->x());
+// 								double right = std::max(polyline.elementPointers()[j]->x(), polyline.elementPointers()[j+1]->x());
+// 								if ((left == primaryBox.oldLeftBottom().x()   && right <= primaryBox.oldLeftBottom().x() + primaryBox.oldWidth() )
+// 								|| (left >= primaryBox.oldLeftBottom().x()  && right == primaryBox.oldLeftBottom().x()+primaryBox.oldWidth())) {
+// 									if (bboxRT.oldLeftBottom().x() == bboxLB.oldLeftBottom().x()) {
+// 										//cerr << "bottom rect is left "<<endl;
+// 										_passed = true;
+// 										polyline.elementPointers()[j]->inLocalMove()=true;
+// 										//cerr<< "line i "<< i <<" central seg is within the two rects widths" << endl;
+// 										bool isCentral = true;
+// 										//line is going right or left
+// 										int currentIdx = j ? left ==  polyline.elementPointers()[j]->x() : j+1;
+// 										int nextIdx = j+1 ? left ==  polyline.elementPointers()[j]->x() : j;
+// 										int prevIdx = j-1 ? left ==  polyline.elementPointers()[j]->x() : j+2;
+// 										int removeCorner = 1;
+// 										int storPt;
+// 										int addFactor = +3;
+//
+// 										double x = polyline.elementPointers()[nextIdx]->x();
+// 										double y = polyline.elementPointers()[currentIdx]->y();
+//
+//
+// 										// handleALL(i,j,currentIdx,nextIdx,prevIdx, removeCorner, addFactor,
+// 										// 	primaryBox,secondaryBox,primaryId,secondaryId,isCentral, move,isRT, x,y);
+//
+//
+// 									}
+// 									if (bboxRT.oldLeftBottom().x() < bboxLB.oldLeftBottom().x()) {
+// 										//cerr << "bottom rect is right "<<endl;
+// 										_passed = true;
+// 										polyline.elementPointers()[j]->inLocalMove()=true;
+// 										//cerr<< "line i "<< i <<" central seg is within the two rects widths" << endl;
+// 										bool isCentral = true;
+// 										//line is going right or left
+//
+// 										int currentIdx = j ? left ==  polyline.elementPointers()[j]->x() : j+1;
+// 										int nextIdx = j+1 ? left ==  polyline.elementPointers()[j]->x() : j;
+// 										int prevIdx = j+2 ? left ==  polyline.elementPointers()[j]->x() : j-1;
+// 										int removeCorner = 2;
+// 										int storPt;
+// 										int addFactor = 1;
+//
+// 										double x = polyline.elementPointers()[currentIdx]->x();
+// 										double y = polyline.elementPointers()[nextIdx]->y();
+//
+//
+// 										// handleALL(i,j,currentIdx,nextIdx,prevIdx, removeCorner, addFactor,
+// 										// 	primaryBox,secondaryBox,primaryId,secondaryId,isCentral, move,isRT, x,y);
+//
+// 									}
+// 								}
+//
+// 							}
+// 								}
+//
+// 					}
+//
+// 				}
+// 				else if (!move.stretchMove()) {
+// 					if(
+// 					abs(polyline.elementPointers()[j]->y() - polyline.elementPointers()[j + 1]->y()) <= eps ) {
+// 						//left
+// 						Graph::TreeDirectedGraph::vertex_descriptor vdBLB = vertex( move.beforeLeftBottomID() , graphmlTree );
+// 						KeiRo::Base::Rectangle2 &bboxLB = *graphmlTree[ vdBLB ].boundingBoxPtr;
+//
+// 						//right
+// 						Graph::TreeDirectedGraph::vertex_descriptor vdBRT = vertex( move.beforeRightTopID() , graphmlTree );
+// 						KeiRo::Base::Rectangle2 &bboxRT = *graphmlTree[ vdBRT ].boundingBoxPtr;
+//
+//
+// 						if (polyline.elementPointers()[j]->y() == bboxLB.oldLeftBottom().y() +bboxLB.oldHeight() &&
+// 								polyline.elementPointers()[j]->y() == bboxRT.oldLeftBottom().y() ) {
+// 							_passed=true;
+// 						}
+//
+// 					}
+// 				}
+// 			}
 		}
 	}
 
@@ -3824,7 +4177,7 @@
 
     }
     void HierarchicalPath::addNewVertex (int i, int j, vector<unsigned int> id, int pos, CONJUNCTIONTYPE t, vector<POINTTYPE> p, double x,double y) {
-	print_path(i);
+	//print_path(i);
 	if (i >= _polylineVec.size() || j >= _conjunctionMat[i].size()) {
     		//cerr << "Error: Index out of bounds in addNewVertex" << endl;
     		return;
@@ -3891,7 +4244,7 @@
 			Graph::EdgeIndexMap edgeIndex = get(edge_index, propG);
 			vector< double > unitWeight( num_edges( globalPathGraph ) );
 
-			cerr << " compute Shp!!"<<endl;
+			//cerr << " compute Shp!!"<<endl;
 			// Copy the vertices from globalPathGraph to propG
 			BGL_FORALL_VERTICES(vd, globalPathGraph, Graph::BaseUndirectedGraph) {
 				Graph::PropertyGraph::vertex_descriptor vdNew = add_vertex( propG );
@@ -3968,7 +4321,7 @@
 							}
 							current = parent[current];
 						}
-						cerr << "shortest path found "<<endl;
+						//cerr << "shortest path found "<<endl;
 						path.push_back( vertexIndex[ targetVertex ] );
 						_hierarchicalPathVec.push_back( path ); //not used
 
@@ -4057,7 +4410,7 @@
 
 						_polylineVecShort.push_back( polyline );
 
-						print_path(_polylineVecShort.size()-1);
+						//print_path(_polylineVecShort.size()-1);
 						_edgeAttributeVecShort.push_back( edge );// i have to change to the excat location
 						_conjunctionMatShort.push_back( conjunctionVec );// same
 
Index: ResponsiveLens/core/Treemap.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//******************************************************************************\r\n// Treemap.cpp\r\n//\t: program file for Treemap\r\n//\r\n//------------------------------------------------------------------------------\r\n//\r\n//\tVer 1.00\t\tDate: Mon Mar 16 07:58:23 2020\r\n//\r\n//******************************************************************************\r\n\r\n//------------------------------------------------------------------------------\r\n//\tIncluding Header Files\r\n//------------------------------------------------------------------------------\r\n\r\n#include \"core/Treemap.h\"\r\n\r\nnamespace Lens {\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPrivate Functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  Treemap::_partitionCanvas -- partition the canvas\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void Treemap::_partitionCanvas( void )\r\n    {\r\n\t    // coordinate, polygon id, Left/Right\r\n\t    multimap< double, pair< unsigned int, bool > > horizontalTuple;\r\n\t    multimap< double, pair< unsigned int, bool > > verticalTuple;\r\n\t    vector< int > xVec;\r\n\t    xVec.push_back( _boundingBoxPtr->leftBottom().x() );\r\n\t    vector< int > yVec;\r\n\t    yVec.push_back( _boundingBoxPtr->leftBottom().y() );\r\n\t\t\r\n\t\tGraph::TreeDirectedGraph &graphmlTree = _metadataPtr->graphmlTree();\r\n\t    Graph::TreeDirectedGraph::vertex_descriptor vd = vertex( _id, graphmlTree );\r\n#ifdef Treemap_DEBUG\r\n\t\tcerr << \"_leftBottomCoordPtr = \" << *_leftBottomCoordPtr;\r\n\t\tcerr << \"*graphmlTree[ vd ].boundingBoxPtr = \" << *graphmlTree[ vd ].boundingBoxPtr;\r\n#endif // Treemap_DEBUG\r\n\t\t\t\r\n\t    Graph::TreeDirectedGraph::out_edge_iterator e, e_end;\r\n\t    for( tie( e, e_end ) = out_edges( vd, graphmlTree ); e != e_end; ++e ) {\r\n\t\t    Graph::TreeDirectedGraph::edge_descriptor ed = *e;\r\n\t\t    Graph::TreeDirectedGraph::vertex_descriptor vdT = target( ed, graphmlTree );\r\n\t\t\r\n            double minX = graphmlTree[ vdT ].boundingBoxPtr->leftBottom().x();\r\n\t\t    double maxX = graphmlTree[ vdT ].boundingBoxPtr->leftBottom().x() + graphmlTree[ vdT ].boundingBoxPtr->width();\r\n\t\t    double minY = graphmlTree[ vdT ].boundingBoxPtr->leftBottom().y();\r\n\t\t    double maxY = graphmlTree[ vdT ].boundingBoxPtr->leftBottom().y() + graphmlTree[ vdT ].boundingBoxPtr->height();\r\n\t\t\r\n#ifdef Treemap_DEBUG\r\n\t\t\t\tcerr << \"_id = \" << _id << endl\r\n\t\t\t\t\t << \"minX = \" << minX << endl\r\n\t\t\t\t\t << \"maxX = \" << maxX << endl\r\n\t\t\t\t\t << \"minY = \" << minY << endl\r\n\t\t\t\t\t << \"maxY = \" << maxY << endl << endl;\r\n#endif // Treemap_DEBUG\r\n\r\n\t\t    pair< unsigned int, bool > borderPair;\r\n\t\t    borderPair.first = graphmlTree[ vdT ].id;\r\n\t\t    // horizontal scan\r\n\t\t    // left\r\n\t\t    borderPair.second = 0;\r\n\t\t    horizontalTuple.insert( pair< double, pair< unsigned int, bool > >( minX, borderPair ) );\r\n\r\n\t\t    // right\r\n\t\t    borderPair.second = 1;\r\n\t\t    horizontalTuple.insert( pair< double, pair< unsigned int, bool > >( maxX, borderPair ) );\r\n\r\n\t\t    // vertical scan\r\n\t\t    // bottom\r\n\t\t    borderPair.second = 0;\r\n\t\t    verticalTuple.insert( pair< double, pair< unsigned int, bool > >( minY, borderPair ) );\r\n\r\n\t\t    // top\r\n\t\t    borderPair.second = 1;\r\n\t\t    verticalTuple.insert( pair< double, pair< unsigned int, bool > >( maxY, borderPair ) );\r\n\r\n\t    }\r\n\t\t\r\n\t    // horizontal\r\n\t    multimap< double, pair< unsigned int, bool > >::iterator itS = horizontalTuple.begin();\r\n\t    multimap< double, pair< unsigned int, bool > >::iterator itT = itS;\r\n\t    itT++;\r\n\t    for( ; itT != horizontalTuple.end(); itT++ ){\r\n//\t\t\tcerr << itT->first << \", \" << itT->second.first << \", \" << itT->second.second << endl;\r\n\t\t    if( itS->second.second == 1 && itT->second.second == 0 ){\r\n//\t\t\t\tcerr << 0.5 * ( itS->first + itT->first ) << endl;\r\n\t\t\t    xVec.push_back( round( 0.5 * ( itS->first + itT->first ) ) );\r\n\t\t    }\r\n\t\t    itS++;\r\n\t    }\r\n\t    xVec.push_back( round( _boundingBoxPtr->leftBottom().x() + _boundingBoxPtr->width() ) );\r\n\r\n\t    // vertical\r\n\t    itS = verticalTuple.begin();\r\n\t    itT = itS;\r\n\t    itT++;\r\n\t    for( ; itT != verticalTuple.end(); itT++ ){\r\n//\t\t\tcerr << itT->first << \", \" << itT->second.first << \", \" << itT->second.second << endl;\r\n\t\t    if( itS->second.second == 1 && itT->second.second == 0 ){\r\n//\t\t\t\tcerr << 0.5 * ( itS->first + itT->first ) << endl;\r\n\t\t\t    yVec.push_back( round( 0.5 * ( itS->first + itT->first ) ) );\r\n\t\t    }\r\n\t\t    itS++;\r\n\t    }\r\n\t    yVec.push_back( round( _boundingBoxPtr->leftBottom().y() + _boundingBoxPtr->height() ) );\r\n\t\t\r\n\t\t\r\n#ifdef Treemap_DEBUG\r\n\t\tcerr << \"_id = \" << _id << endl;\r\n\t    cerr << \"xVec[i] = \";\r\n\t\tfor( unsigned int i = 0; i < xVec.size(); i++ ){\r\n\t\t\tcerr << xVec[i] << \" \";\r\n\t\t}\r\n\t\tcerr << endl;\r\n\t    cerr << \"yVec[i] = \";\r\n\t\tfor( unsigned int i = 0; i < yVec.size(); i++ ){\r\n\t\t\tcerr << yVec[i] << \" \";\r\n\t\t}\r\n\t\tcerr << endl;\r\n#endif // Treemap_DEBUG\r\n\r\n\t    _rectMat.resize( yVec.size() - 1 );\r\n\t    vector< vector< int > > idMat( yVec.size() - 1 );\r\n\t    for( unsigned int i = 0; i < yVec.size()-1; i++ ){\r\n\t\t    for( unsigned int j = 0; j < xVec.size()-1; j++ ){\r\n\t\t\t    KeiRo::Base::Rectangle2 rect;\r\n\t\t\t    rect.leftBottom().x() = xVec[j];\r\n\t\t\t    rect.leftBottom().y() = yVec[i];\r\n\t\t\t    rect.width() = xVec[j+1] - xVec[j];\r\n\t\t\t    rect.height() = yVec[i+1] - yVec[i];\r\n\t\t\t    _rectMat[i].push_back( rect );\r\n\t\t    }\r\n\t\t\t\r\n\t\t\t// idMat initialization\r\n\t\t    idMat[i].resize( _rectMat[i].size() );\r\n\t\t    for( unsigned int j = 0; j < idMat[i].size(); j++ ){\r\n\t\t\t    idMat[i][j] = -1;\r\n\t\t    }\r\n\t    }\r\n\t\t\r\n#ifdef Treemap_DEBUG\r\n\t    cerr << \"init\" << endl;\r\n\t\tcerr << \"rectMat = \" << endl;\r\n\t\tfor( unsigned int i = 0; i < _rectMat.size(); i++ ){\r\n\t\t\tfor( unsigned int j = 0; j < _rectMat[i].size(); j++ ) {\r\n\t\t\t\tcerr << _rectMat[i][j];\r\n\t\t\t}\r\n\t\t}\r\n\t    cerr << endl;\r\n\t\r\n\t    cerr << \"idMat = \" << endl;\r\n\t    for( unsigned int i = 0; i < idMat.size(); i++ ){\r\n\t\t    for( unsigned int j = 0; j < idMat[i].size(); j++ ) {\r\n\t\t\t    cerr << idMat[i][j] << \" \";\r\n\t\t    }\r\n\t\t    cerr << endl;\r\n\t    }\r\n\t    cerr << endl;\r\n#endif // Treemap_DEBUG\r\n\r\n\t    for( unsigned int i = 0; i < _rectMat.size(); i++ ){\r\n\t\t    for( unsigned int j = 0; j < _rectMat[i].size(); j++ ) {\r\n\r\n\t\t\t    KeiRo::Base::Rectangle2 &rect = _rectMat[i][j];\r\n\t\t\t\r\n\t\t\t    Graph::TreeDirectedGraph::out_edge_iterator e, e_end;\r\n\t\t\t    for( tie( e, e_end ) = out_edges( vd, graphmlTree ); e != e_end; ++e ) {\r\n\t\t\t\t    Graph::TreeDirectedGraph::edge_descriptor ed = *e;\r\n\t\t\t\t    Graph::TreeDirectedGraph::vertex_descriptor vdT = target( ed, graphmlTree );\r\n\t\t\t\t\r\n\t\t\t\t    KeiRo::Base::Rectangle2 &poly = *graphmlTree[ vdT ].boundingBoxPtr;\r\n\t\t\t\t    double area;\r\n\r\n#ifdef Treemap_DEBUG\r\n\t\t\t\t    if( _id == 1 ){\r\n\t\t\t\t\t\tcerr << \"k = \" << k << endl;\r\n\t\t\t\t\t\tcerr << \" area = \" << area << endl;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif( i == 4 && j == 1 ){\r\n\t\t\t\t\t\tKeiRo::Base::Rectangle2 p1 = polygonVec[0].boundingBox();\r\n\t\t\t\t\t\tKeiRo::Base::Rectangle2 p2 = polygonVec[8].boundingBox();\r\n\t\t\t\t\t\tdouble area1;\r\n\t\t\t\t\t\tdouble area2;\r\n\t\t\t\t\t\trect.isOverlap( p1, area1 );\r\n\t\t\t\t\t\trect.isOverlap( p2, area2 );\r\n\t\t\t\t\t\tcerr << \"rect = \" << rect;\r\n\t\t\t\t\t\tcerr << \"p1 = \" << p1;\r\n\t\t\t\t\t\tcerr << \"p2 = \" << p2;\r\n\t\t\t\t\t\tcerr << \"0: \" << area1 << endl;\r\n\t\t\t\t\t\tcerr << \"8: \" << area2 << endl;\r\n\t\t\t\t\t}\r\n#endif // Treemap_DEBUG\r\n\t\t\t\t\t\r\n\t\t\t\t    if( idMat[i][j] == -1 ){\r\n\t\t\t\t\t    if( rect.isOverlap( poly, area ) ){\r\n\t\t\t\t\t\t    idMat[i][j] = graphmlTree[ vdT ].id;\r\n\t\t\t\t\t    }\r\n\t\t\t\t    }\r\n\t\t\t\t    else{\r\n\t\t\t\t\t    double oldArea;\r\n\t\t\t\t\t    Graph::TreeDirectedGraph::vertex_descriptor vd = vertex( idMat[i][j], graphmlTree );\r\n\t\t\t\t\t    KeiRo::Base::Rectangle2 &oldPoly = *graphmlTree[ vd ].boundingBoxPtr;\r\n\t\t\t\t\t    rect.isOverlap( oldPoly, oldArea );\r\n\t\t\t\t\t    if( rect.isOverlap( poly, area ) ){\r\n\t\t\t\t\t\t    if( area > oldArea ) idMat[i][j] = graphmlTree[ vdT ].id;\r\n\t\t\t\t\t    }\r\n\t\t\t\t    }\r\n\t\t\t    }\r\n\t\t    }\r\n\t    }\r\n\t\r\n#ifdef Treemap_DEBUG\r\n\t    cerr << \"rectMat = \" << endl;\r\n\t    for( unsigned int i = 0; i < _rectMat.size(); i++ ){\r\n\t\t    for( unsigned int j = 0; j < _rectMat[i].size(); j++ ) {\r\n\t\t\t    cerr << _rectMat[i][j];\r\n\t\t    }\r\n\t    }\r\n\t    cerr << endl;\r\n\t\r\n\t    cerr << \"idMat = \" << endl;\r\n\t    for( unsigned int i = 0; i < idMat.size(); i++ ){\r\n\t\t    for( unsigned int j = 0; j < idMat[i].size(); j++ ) {\r\n\t\t\t    cerr << idMat[i][j] << \" \";\r\n\t\t    }\r\n\t\t    cerr << endl;\r\n\t    }\r\n\t    cerr << endl;\r\n#endif // Treemap_DEBUG\r\n\t\t\r\n\t    for( tie( e, e_end ) = out_edges( vd, graphmlTree ); e != e_end; ++e ) {\r\n\r\n\t\t    Graph::TreeDirectedGraph::edge_descriptor ed = *e;\r\n\t\t    Graph::TreeDirectedGraph::vertex_descriptor vdT = target( ed, graphmlTree );\r\n\t\t\r\n\t\t    KeiRo::Base::Rectangle2 rect;\r\n\t\t    stringstream ss;\r\n\t\t    ss << setw(DIGIT_LIMIT ) << setfill( '0') << graphmlTree[ vdT ].id;\r\n\t\t    string n = \"root/\" + ss.str();\r\n//\t\t\tcerr << \"ss.str() = \" << ss.str() << endl;\r\n\r\n\t\t    _treemapTargetMap.insert( pair< unsigned int, KeiRo::Base::Rectangle2 >( graphmlTree[ vdT ].id, rect ) );\r\n\t\t    map< unsigned int, KeiRo::Base::Rectangle2 >::iterator it = _treemapTargetMap.find( graphmlTree[ vdT ].id );\r\n\r\n\t\t    bool isFirst = true;\r\n\t\t    for( unsigned int i = 0; i < idMat.size(); i++ ){\r\n\t\t\t    for( unsigned int j = 0; j < idMat[i].size(); j++ ) {\r\n\r\n\t\t\t\t    if( idMat[i][j] == graphmlTree[ vdT ].id ){\r\n\r\n\t\t\t\t\t    if( isFirst == true ){\r\n\t\t\t\t\t\t    isFirst = false;\r\n\t\t\t\t\t\t    it->second.name() = \"root/\" + ss.str();\r\n\t\t\t\t\t\t    it->second.id() = idMat[i][j];\r\n\t\t\t\t\t\t    it->second.leftBottom() = _rectMat[i][j].leftBottom();\r\n\t\t\t\t\t\t    it->second.width() = _rectMat[i][j].width();\r\n\t\t\t\t\t\t    it->second.height() = _rectMat[i][j].height();\r\n#ifdef Treemap_DEBGU\r\n\t\t\t\t\t\t    cerr << \"k = \" << k << endl;\r\n\t\t\t\t\t\t\tcerr << \"first = \" << it->second;\r\n\t\t\t\t\t\t\tcerr << \"it->second.name() = \" << it->second.name() << endl;\r\n#endif // Treemap_DEBUG\r\n\t\t\t\t\t    }\r\n\t\t\t\t\t    else{\r\n\t\t\t\t\t\t    KeiRo::Base::Coord2 lba = _rectMat[i][j].leftBottom();\r\n\t\t\t\t\t\t    KeiRo::Base::Coord2 tra = _rectMat[i][j].leftBottom() + KeiRo::Base::Coord2( _rectMat[i][j].width(), _rectMat[i][j].height() );\r\n\t\t\t\t\t\t    KeiRo::Base::Coord2 lbb = it->second.leftBottom();\r\n\t\t\t\t\t\t    KeiRo::Base::Coord2 trb = it->second.leftBottom() + KeiRo::Base::Coord2( it->second.width(), it->second.height() );\r\n\r\n\t\t\t\t\t\t    KeiRo::Base::Coord2 lb, tr;\r\n\t\t\t\t\t\t    lb.x() = MIN2( lba.x(), lbb.x() );\r\n\t\t\t\t\t\t    lb.y() = MIN2( lba.y(), lbb.y() );\r\n\t\t\t\t\t\t    tr.x() = MAX2( tra.x(), trb.x() );\r\n\t\t\t\t\t\t    tr.y() = MAX2( tra.y(), trb.y() );\r\n\r\n#ifdef Treemap_DEBUG\r\n\t\t\t\t\t\t    cerr << \"> first = \" << it->second;\r\n\t\t\t\t\t\t\tcerr << \"it->second.name() = \" << it->second.name() << endl;\r\n\t\t\t\t\t\t\tif( k == 1 ){\r\n\t\t\t\t\t\t\t\tcerr << \"lba = \" << lba;\r\n\t\t\t\t\t\t\t\tcerr << \"tra = \" << tra;\r\n\t\t\t\t\t\t\t\tcerr << \"lbb = \" << lbb;\r\n\t\t\t\t\t\t\t\tcerr << \"trb = \" << trb;\r\n\t\t\t\t\t\t\t\tcerr << \"lb = \" << lb;\r\n\t\t\t\t\t\t\t\tcerr << \"tr = \" << tr;\r\n\t\t\t\t\t\t\t\tcerr << endl;\r\n\t\t\t\t\t\t\t}\r\n#endif // Treemap_DEBUG\r\n\t\t\t\t\t\t    it->second.leftBottom().x() = lb.x();\r\n\t\t\t\t\t\t    it->second.leftBottom().y() = lb.y();\r\n\t\t\t\t\t\t    it->second.width() = tr.x() - lb.x();\r\n\t\t\t\t\t\t    it->second.height() = tr.y() - lb.y();\r\n\t\t\t\t\t    }\r\n\t\t\t\t    }\r\n\t\t\t    }\r\n\t\t    }\r\n\r\n\t\t    // normalization\r\n\t\t    graphmlTree[ vdT ].boundingBoxPtr->leftBottom().x() = it->second.leftBottom().x();\r\n\t\t    graphmlTree[ vdT ].boundingBoxPtr->leftBottom().y() = it->second.leftBottom().y();\r\n\t\t    graphmlTree[ vdT ].boundingBoxPtr->width() = it->second.width();\r\n\t\t    graphmlTree[ vdT ].boundingBoxPtr->height() = it->second.height();\r\n//\t\t    graphmlTree[ vdT ].boundingBoxPtr->normalization( r );\r\n\t    }\r\n\r\n\r\n\t    unsigned int largeIndex = num_vertices( graphmlTree );\r\n\t    for( unsigned int i = 0; i < idMat.size(); i++ ){\r\n\t\t    for( unsigned int j = 0; j < idMat[i].size(); j++ ) {\r\n\r\n\t\t\t    if( idMat[i][j] == -1 ){\r\n\t\t\t\t\t\r\n\t\t\t\t    KeiRo::Base::Rectangle2 rect;\r\n\t\t\t\t    stringstream ss;\r\n\t\t\t\t    ss << setw(DIGIT_LIMIT ) << setfill( '0') << largeIndex;\r\n\t\t\t\t    _treemapTargetMap.insert( pair< unsigned int, KeiRo::Base::Rectangle2 >( largeIndex, rect ) );\r\n\t\t\t\t    map< unsigned int, KeiRo::Base::Rectangle2 >::iterator it = _treemapTargetMap.find( largeIndex );\r\n\r\n\t\t\t\t    it->second.name() = \"root/\" + ss.str();\r\n\t\t\t\t    it->second.id() = largeIndex;\r\n\t\t\t\t    it->second.leftBottom() = _rectMat[i][j].leftBottom();\r\n\t\t\t\t    it->second.width() = _rectMat[i][j].width();\r\n\t\t\t\t    it->second.height() = _rectMat[i][j].height();\r\n\t\t\t\t    it->second.updateOldElement();\r\n\t\t\t\t    largeIndex++;\r\n\t\t\t    }\r\n\t\t    }\r\n\t    }\r\n\r\n\r\n#ifdef Treemap_DEBUG\r\n\t    // handle zero space\r\n\t\tfor( map< string, KeiRo::Base::Rectangle2 >::iterator it = _treemapTargetMap.begin();\r\n\t\t     it != _treemapTargetMap.end(); it++ ) {\r\n\t\t\tcerr << \"name = \" << it->first << endl;\r\n\t\t\tcerr << \"r = \" << it->second;\r\n\t\t}\r\n\t\tcerr << endl;\r\n#endif // Treemap_DEBUG\r\n\t}\r\n\t\r\n\t//------------------------------------------------------------------------------\r\n    //\tProtected Functions\r\n    //------------------------------------------------------------------------------\r\n\t//\r\n\t//  Treemap::_init -- initialize the graph.\r\n\t//\r\n\t//  Inputs\r\n\t//  none\r\n\t//\r\n\t//  Outputs\r\n\t//  none\r\n\t//\r\n\tvoid Treemap::_init( MetaData *__metadataPtr,\r\n\t                     KeiRo::Base::Rectangle2 *__boundingBoxPtr )\r\n\t{\r\n\t\t_metadataPtr = __metadataPtr;\r\n\t\t_boundingBoxPtr = __boundingBoxPtr;\r\n\t\t_boundingBoxPtr->oldWidth() = _boundingBoxPtr->width();\r\n\t\t_boundingBoxPtr->oldHeight() = _boundingBoxPtr->height();\r\n\t}\r\n\t\r\n\tvoid Treemap::initLeafTreemap( void ) {\r\n\r\n\t\tmap< unsigned int, Graph::BaseUndirectedGraph > &graphmlGraphMap = _metadataPtr->graphmlGraphMap();\r\n\t\tGraph::TreeDirectedGraph &graphmlTree = _metadataPtr->graphmlTree();\r\n\t\t\r\n\t\tQFont font( QFont( \"Arial\", 12, QFont::Normal, false ) );\r\n\t\tQFontMetrics fm( font );\r\n\t\t\r\n\t\tGraph::BaseUndirectedGraph &subGraph = graphmlGraphMap.find( _id )->second;\r\n\t\t\r\n\t\tKeiRo::Base::Rectangle2 &bbox = *_boundingBoxPtr;\r\n\t\tdouble borderW = _metadataPtr->borderWidth() * ( _metadataPtr->maxLevel()-1 );\r\n\t\tdouble borderH = _metadataPtr->borderWidth() * ( _metadataPtr->maxLevel()-1 );\r\n//\t\tdouble borderW = MIN2( 1.5*_metadataPtr->borderWidth(), 0.2*bbox.width() );\r\n//\t\tdouble borderH = MIN2( 1.5*_metadataPtr->borderWidth(), 0.2*bbox.height() );\r\n//\t\tdouble borderWidth = _metadataPtr->borderWidth();\r\n\r\n\t\tdouble minX = INFINITY, maxX = -INFINITY, minY = INFINITY, maxY = -INFINITY;\r\n\t\t\r\n\t\t// iterate edges\r\n\t\tBGL_FORALL_EDGES( ed, subGraph, Graph::BaseUndirectedGraph ) {\r\n\t\t\t\r\n\t\t\tKeiRo::Base::Edge2 &edge = subGraph[ ed ].edge;\r\n\t\t\tfor( unsigned int i = 0; i < edge.elements().size(); i++ ) {\r\n\t\t\t\t\r\n\t\t\t\tKeiRo::Base::Coord2 &c = edge.elements()[i];\r\n\t\t\t\t\r\n\t\t\t\tif( minX > c.x() ) minX = c.x();\r\n\t\t\t\tif( maxX < c.x() ) maxX = c.x();\r\n\t\t\t\tif( minY > c.y() ) minY = c.y();\r\n\t\t\t\tif( maxY < c.y() ) maxY = c.y();\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// iterate vertices\r\n\t\tBGL_FORALL_VERTICES( vd, subGraph, Graph::BaseUndirectedGraph ) {\r\n\t\t\t\r\n\t\t\tint pxFntWidth = 0.5 * fm.width( QString::fromStdString( *subGraph[ vd ].namePtr ) );\r\n\t\t\tint\tpxFntHeight = fm.height();\r\n\t\t\t\r\n\t\t\tif( minX > subGraph[ vd ].coordPtr->x() - pxFntWidth ) minX = subGraph[ vd ].coordPtr->x() - pxFntWidth;\r\n\t\t\tif( maxX < subGraph[ vd ].coordPtr->x() + pxFntWidth ) maxX = subGraph[ vd ].coordPtr->x() + pxFntWidth;\r\n\t\t\tif( minY > subGraph[ vd ].coordPtr->y() - pxFntHeight ) minY = subGraph[ vd ].coordPtr->y() - pxFntHeight;\r\n\t\t\tif( maxY < subGraph[ vd ].coordPtr->y() + pxFntHeight ) maxY = subGraph[ vd ].coordPtr->y() + pxFntHeight;\r\n\t\t}\r\n\t\tminX -= borderW;\r\n\t\tmaxX += borderW;\r\n\t\tminY -= borderH;\r\n\t\tmaxY += borderH;\r\n\t\t\r\n\t\t// update edges\r\n\t\tBGL_FORALL_EDGES( ed, subGraph, Graph::BaseUndirectedGraph ) {\r\n\t\t\t\r\n\t\t\tKeiRo::Base::Edge2 &edge = subGraph[ ed ].edge;\r\n\t\t\tfor( unsigned int i = 0; i < edge.elements().size(); i++ ) {\r\n\t\t\t\t\r\n\t\t\t\tKeiRo::Base::Coord2 &c = edge.elements()[i];\r\n\t\t\t\tc.x() = ( c.x() - minX ) / ( maxX - minX ) * bbox.width() + bbox.leftBottom().x();\r\n\t\t\t\tc.y() = ( c.y() - minY ) / ( maxY - minY ) * bbox.height() + bbox.leftBottom().y();\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// update vertices\r\n\t\tBGL_FORALL_VERTICES( vd, subGraph, Graph::BaseUndirectedGraph ) {\r\n\t\t\tsubGraph[ vd ].coordPtr->x() = ( subGraph[ vd ].coordPtr->x() - minX ) / ( maxX - minX ) * bbox.width() + bbox.leftBottom().x();\r\n\t\t\tsubGraph[ vd ].coordPtr->y() = ( subGraph[ vd ].coordPtr->y() - minY ) / ( maxY - minY ) * bbox.height() + bbox.leftBottom().y();\r\n\t\t}\r\n\t}\r\n\t\r\n\tvoid Treemap::initNonLeafTreemap( void )\r\n\t{\r\n\t\tvector< KeiRo::Base::Polygon2 > &polygonVec = _svgPtr->polygonVec();\r\n\t\tGraph::TreeDirectedGraph &graphmlTree = _metadataPtr->graphmlTree();\r\n\t\tGraph::TreeDirectedGraph::vertex_descriptor vdC = vertex( _id, graphmlTree );\r\n\r\n\t\tdouble oldTotalArea = 0.0;\r\n\t\tdouble totalArea = 0.0;\r\n\t\r\n\t\t_partitionCanvas();\r\n\t\tGraph::TreeDirectedGraph::out_edge_iterator e, e_end;\r\n\t\tfor( tie( e, e_end ) = out_edges( vdC, graphmlTree ); e != e_end; ++e ) {\r\n\t\t\tGraph::TreeDirectedGraph::edge_descriptor ed = *e;\r\n\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdT = target( ed, graphmlTree );\r\n\t\t\tunsigned int id = graphmlTree[ vdT ].id;\r\n\t\t\ttotalArea += graphmlTree[ vdT ].boundingBoxPtr->width() * graphmlTree[ vdT ].boundingBoxPtr->height();\r\n\t\t\toldTotalArea += graphmlTree[ vdT ].boundingBoxPtr->oldWidth() * graphmlTree[ vdT ].boundingBoxPtr->oldHeight();\r\n#ifdef Treemap_DEBUG\r\n\t\t\tcerr << \"id = \" << id\r\n\t\t\t     << \", area = \" << graphmlTree[ vdT ].boundingBoxPtr->width() * graphmlTree[ vdT ].boundingBoxPtr->height()\r\n\t\t\t\t << \", oareaw = \" << graphmlTree[ vdT ].boundingBoxPtr->oldWidth()\r\n\t\t\t\t << \", oareah = \" << graphmlTree[ vdT ].boundingBoxPtr->oldHeight()\r\n\t\t\t     << \", oarea = \" << graphmlTree[ vdT ].boundingBoxPtr->oldWidth() * graphmlTree[ vdT ].boundingBoxPtr->oldHeight() << endl;\r\n#endif // Treemap_DEBUG\r\n\t\t}\r\n\t\tdouble ratio = _boundingBoxPtr->width() * _boundingBoxPtr->height() / oldTotalArea;\r\n\t\t\r\n#ifdef Treemap_DEBUG\r\n\t\tcerr << \"oldTotalArea = \" << oldTotalArea << endl;\r\n\t\tcerr << \"totalArea = \" << totalArea << endl;\r\n\t\tcerr << \"bbox = \" << *_widthPtr * *_heightPtr << endl;\r\n\t\tcerr << \"ratio = \" << ratio << endl;\r\n\t\tcerr << \"_treemapTargetMap.size() = \" << _treemapTargetMap.size() << endl;\r\n#endif // Treemap_DEBUG\r\n\t\t\r\n\t\t// create size map\r\n\t\tint sum = 0;\r\n\t\tfor( int i = 0; i < _treemapTargetMap.size(); i++ ){\r\n\t\t\t\r\n\t\t\tmap< unsigned int, KeiRo::Base::Rectangle2 >::iterator it = _treemapTargetMap.begin();\r\n\t\t\tstd::advance( it, i );\r\n\t\t\t\r\n\t\t\tstring name = it->second.name();\r\n            unsigned int id = it->second.id();\r\n\r\n\t\t\tdouble size1 = 0.0, size2 = 0.0;\r\n\t\t\tGraph::TreeDirectedGraph::vertex_descriptor vdT = vertex( id, graphmlTree );\r\n\t\t\tGraph::TreeDirectedGraph::degree_size_type degrees = out_degree( vdC, graphmlTree );\r\n\r\n\t\t\tif( i >= degrees ){\r\n\t\t\t\tsize1 = it->second.width() * it->second.height();\r\n\t\t\t\tsize2 = 0.0;\r\n\t\t\t}\r\n\t\t\telse if( ( degrees > 0 ) && ( i == degrees-1 ) ){\r\n\t\t\t\t// the last piece, sum up to screen space\r\n\t\t\t\tsize2 = size1 = _boundingBoxPtr->width() * _boundingBoxPtr->height() - sum;\r\n\t\t\t}\r\n\t\t\telse{\r\n//\t\t\t\tsize2 = size1 = round( graphmlTree[ vd ].boundingBoxPtr->oldWidth() * graphmlTree[ vd ].boundingBoxPtr->oldHeight() );\r\n\t\t\t\tsize2 = size1 = round( ratio * graphmlTree[ vdT ].boundingBoxPtr->oldWidth() * graphmlTree[ vdT ].boundingBoxPtr->oldHeight() );\r\n#ifdef Treemap_DEBUG\r\n\t\t\t\tcerr << \"size1 = \" << size1\r\n\t\t\t\t\t << \" ow = \" << graphmlTree[ vdT ].boundingBoxPtr->oldWidth()\r\n\t\t\t\t\t << \" oh = \" << graphmlTree[ vdT ].boundingBoxPtr->oldHeight() << endl;\r\n#endif // Treemap_DEBUG\r\n\t\t\t\tsum += size1;\r\n\t\t\t}\r\n\r\n\t\t\t_treemapSizeMap.insert( pair< unsigned int, pair< double, double > > (\r\n\t\t\t\t\tid, pair< double, double >( size1, size2 ) ));\r\n\t\t\t_treemapFixedSizeMap.insert( pair< unsigned int, pair< double, double > > (\r\n\t\t\t\t\tid, pair< unsigned int, double >( size1, size2 ) ));\r\n\t\t}\r\n\t\t\r\n#ifdef Treemap_DEBUG\r\n\t\tBGL_FORALL_VERTICES( vd, graphmlTree, Graph::TreeDirectedGraph ) {\r\n\t\t\t\r\n\t\t\tcerr << \" D::id = \" << graphmlTree[ vd ].id\r\n\t\t\t     << \" boundingBox = \" << *graphmlTree[ vd ].boundingBoxPtr;\r\n\t\t}\r\n\t\tcerr << endl;\r\n\t\t\r\n\t\tcerr << \"_treemapTargetMap.size() = \" << _treemapTargetMap.size() << endl;\r\n\t\tfor( map< string, KeiRo::Base::Rectangle2 >::iterator it = _treemapTargetMap.begin();\r\n\t\t\t it != _treemapTargetMap.end(); it++ ){\r\n\t\t\tcerr << it->first << \", \" << it->second;\r\n\t\t}\r\n\r\n\t\tcerr << \"_treemapSizeMap.size() = \" << _treemapSizeMap.size() << endl;\r\n\t\tfor(  map< string, pair< double, double > > ::iterator it = _treemapSizeMap.begin();\r\n\t\t     it != _treemapSizeMap.end(); it++ ){\r\n\t\t\tcerr << it->first << \", ( \" << it->second.first << \", \" << it->second.second << \" )\" << endl;\r\n\t\t}\r\n\t\tcerr << endl;\r\n#endif // Treemap_DEBUG\r\n\t\t\r\n    }\r\n\r\n    //\r\n    //  Treemap::_clear -- clear the treemap\r\n    //\r\n    //  Inputs\r\n    //  none\r\n    //\r\n    //  Outputs\r\n    //  none\r\n    //\r\n    void Treemap::_clear( void )\r\n    {\r\n\t    _treemapFixedSizeMap.clear();\r\n\t    _treemapSizeMap.clear();\r\n\t    _treemapSourceMap.clear();\r\n\t    _treemapTargetMap.clear();\r\n\t    _treemapCellGraphicsPtrVec.clear();\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tPublic functions\r\n    //------------------------------------------------------------------------------\r\n    //------------------------------------------------------------------------------\r\n    //\tConstructors & Destructors\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  Treemap::Treemap --\tdefault constructor\r\n    //\r\n    //  Inputs\r\n    //\tnone\r\n    //\r\n    //  Outputs\r\n    //\tnone\r\n    //\r\n    Treemap::Treemap()\r\n    {\r\n        _id = 0;\r\n\t    _level = 0;\r\n\t    _tmpFolder = \"/tmp\";\r\n\t\r\n\t    _metadataPtr = NULL;\r\n\t    _svgPtr = NULL;\r\n\t    _boundingBoxPtr = NULL;\r\n\t\t\r\n\t    // create tmp folder for stable treemap command\r\n\t    QString filePath =\r\n\t\t\t    qApp->applicationDirPath() + QString::fromStdString( _tmpFolder );\r\n\t\r\n\t    // create the temporary folder\r\n\t    _inputFolder = filePath.toStdString() + \"/input\";\r\n\t    _outputFolder = filePath.toStdString() + \"/output\";\r\n    }\r\n\t\r\n\t//\r\n\t//  Treemap::Treemap --\tcopy constructor\r\n\t//\r\n\t//  Inputs\r\n\t//\tnone\r\n\t//\r\n\t//  Outputs\r\n\t//\tnone\r\n\t//\r\n\tTreemap::Treemap( const Treemap & t )\r\n\t{\r\n\t\t_metadataPtr = t._metadataPtr;\r\n\t\t\r\n\t\t_svgPtr = t._svgPtr;\r\n\t\t_boundingBoxPtr = t._boundingBoxPtr;\r\n\r\n        _id = t._id;\r\n        _level = t._level;\r\n        _tmpFolder = t._tmpFolder;\r\n\t\t_inputFolder = t._inputFolder;\r\n\t\t_outputFolder = t._outputFolder;\r\n\t\t\r\n\t\t_treemapFixedSizeMap = t._treemapFixedSizeMap;\r\n\t\t_treemapSizeMap = t._treemapSizeMap;\r\n\t\t_treemapSourceMap = t._treemapSourceMap;\r\n\t\t_treemapTargetMap = t._treemapTargetMap;\r\n\t\t_rectMat = t._rectMat;\r\n\t\t_treemapCellGraphicsPtrVec = t._treemapCellGraphicsPtrVec;\r\n\t}\r\n\r\n    //\r\n    //  Treemap::~Treemap --\tdestructor\r\n    //\r\n    //  Inputs\r\n    //\tnone\r\n    //\r\n    //  Outputs\r\n    //\tnone\r\n    //\r\n    Treemap::~Treemap()\r\n    {\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tAssignment operators\r\n    //------------------------------------------------------------------------------\r\n\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tSpecial functions\r\n    //------------------------------------------------------------------------------\r\n    //\r\n    //  Treemap::prepareTreemap --\tprepare the Treemap configuration\r\n    //\r\n    //  Inputs\r\n    //\tnone\r\n    //\r\n    //  Outputs\r\n    //\tnone\r\n    //\r\n    void Treemap::prepareTreemap( void )\r\n    {\r\n        QString dataFolder = qApp->applicationDirPath() + QString( \"/tmp/input/data_\") + QString::number( _id );\r\n\t    QString rectFolder = qApp->applicationDirPath() + QString( \"/tmp/input/rect_\") + QString::number( _id );\r\n\t    \r\n\t    if( !QDir( dataFolder ).exists() ){\r\n\t\t    QDir().mkdir( dataFolder );\r\n\t\t    cerr << \"create a tmp folder!\" << endl;\r\n\t    }\r\n\t    if( !QDir( rectFolder ).exists() ){\r\n\t\t    QDir().mkdir( rectFolder );\r\n\t\t    cerr << \"create a tmp folder!\" << endl;\r\n\t    }\r\n\t\r\n\t    string filename = dataFolder.toStdString() + \"/treemap.txt\";\r\n\t    ofstream            ofs( filename );\r\n\t\r\n\t    if ( !ofs ) {\r\n\t\t    cerr << \"Cannot open the target file : \" << filename << endl;\r\n\t\t    return;\r\n\t    }\r\n\t\r\n#ifdef Treemap_DEBUG\r\n\t    cerr << \" now writing the treemap data for stable treemap approach... \" << endl;\r\n\t    cerr << \" treemapID = \" << _id << endl;\r\n\t    cerr << \" filename = \" << filename << endl;\r\n\t    cerr << \" treemapTargetMap = \" << _treemapTargetMap.size() << endl;\r\n\t    cerr << \" treemapSizeMap = \" << _treemapSizeMap.size() << endl;\r\n#endif // Treemap_DEBUG\r\n\r\n\t    for( unsigned int i = 0; i < _treemapSizeMap.size(); i++ ){\r\n\t\t\r\n\t    \tmap< unsigned int, pair< double, double > >::iterator it = _treemapSizeMap.begin();\r\n\t\t    map< unsigned int, KeiRo::Base::Rectangle2 >::iterator itc = _treemapTargetMap.begin();\r\n\t\t    std::advance( it, i );\r\n\t\t    std::advance( itc, i );\r\n\t\t    double timestep1 = it->second.first;\r\n\t\t    double timestep2 = it->second.second;\r\n\r\n#ifdef Treemap_DEBUG\r\n\t\t    cerr << itc->second.name() << \",root,\"\r\n\t\t        << KeiRo::Base::Common::to_string_with_precision( timestep1 ) << \",\"\r\n\t\t        << KeiRo::Base::Common::to_string_with_precision( timestep2 ) << endl;\r\n#endif // Treemap_DEBUG\r\n\r\n\t\t    ofs << itc->second.name() << \",root,\"\r\n\t\t        << KeiRo::Base::Common::to_string_with_precision( timestep1 ) << \",\"\r\n\t\t        << KeiRo::Base::Common::to_string_with_precision( timestep2 ) << endl;\r\n\t    }\r\n\t\r\n\t    ofs.close();\r\n\t\r\n\t    // export stable treemap data\r\n\t    string rectname = rectFolder.toStdString() + \"/rect.txt\";\r\n\t    ofstream            ofr( rectname );\r\n\t\r\n\t    if ( !ofr ) {\r\n\t\t    cerr << \"Cannot open the target file : \" << rectname << endl;\r\n\t\t    return;\r\n\t    }\r\n\t    // cerr << \" now writing the treemap data for stable treemap approach... \" << endl;\r\n\t\r\n\t    for( unsigned int i = 0; i < _treemapTargetMap.size(); i++ ){\r\n\t\t\r\n\t\t    map< unsigned int, KeiRo::Base::Rectangle2 >::iterator it = _treemapTargetMap.begin();\r\n\t\t    std::advance( it, i );\r\n\t\t    KeiRo::Base::Coord2 c = _boundingBoxPtr->oldLeftBottom();\r\n\t\t\t\r\n #ifdef Treemap_DEBUG\r\n\t\t    cerr << \"TEST = \"\r\n\t\t         << it->second.name() << \",\"\r\n\t\t\t\t << \"c.x = \" << c.x() << \",\"\r\n\t\t         << KeiRo::Base::Common::to_string_with_precision( it->second.leftBottom().x() - c.x() ) << \",\"\r\n\t\t         << KeiRo::Base::Common::to_string_with_precision( it->second.leftBottom().y() - c.y() ) << \",\"\r\n\t\t         << KeiRo::Base::Common::to_string_with_precision( it->second.width() ) << \",\"\r\n\t\t         << KeiRo::Base::Common::to_string_with_precision( it->second.height() ) << endl;\r\n #endif // Treemap_DEBUG\r\n\t\t    ofr << it->second.name() << \",\"\r\n\t\t        << KeiRo::Base::Common::to_string_with_precision( it->second.leftBottom().x() - c.x() ) << \",\"\r\n\t\t        << KeiRo::Base::Common::to_string_with_precision( it->second.leftBottom().y() - c.y() ) << \",\"\r\n\t\t        << KeiRo::Base::Common::to_string_with_precision( it->second.width() ) << \",\"\r\n\t\t        << KeiRo::Base::Common::to_string_with_precision( it->second.height() ) << endl;\r\n\t    }\r\n\t\r\n\t    ofr.close();\r\n    }\r\n\r\n\t   \r\n    //\r\n    //  Treemap::createTreemap --\tcreate a Treemap from the samples\r\n    //\r\n    //  Inputs\r\n    //\tnone\r\n    //\r\n    //  Outputs\r\n    //\tnone\r\n    //\r\n    void Treemap::createTreemap( void )\r\n    {\r\n#ifdef Treemap_DEBUG\r\n\t    cerr << \"p = \" << p << endl;\r\n\t\t\t    cerr << \"label = \" << label << endl;\r\n\t\t\t\tcerr << \" LeftBottomX = \" << LeftBottomX << endl;\r\n\t\t\t\tcerr << \" LeftBottomY = \" << LeftBottomY << endl;\r\n\t\t\t\tcerr << \" width = \" << width << endl;\r\n\t\t\t\tcerr << \" height = \" << height << endl;\r\n#endif  // TTreemap_DEBUG\r\n\t\t\t\t\r\n\t    // update treemap cell\r\n\t    for( unsigned int i = 0; i < _treemapTargetMap.size(); i++ ){\r\n\t\t\r\n\t\t    map< unsigned int, KeiRo::Base::Rectangle2 >::iterator    itc = _treemapTargetMap.begin();\r\n\t\t    std::advance( itc, i );\r\n\t\t\r\n\t\t    double w = itc->second.width();\r\n\t\t    double h = itc->second.height();\r\n\t\t    double x = itc->second.leftBottom().x();\r\n\t\t    double y = itc->second.leftBottom().y();\r\n\t\t\r\n\t\t    KeiRo::Base::Rectangle2 p;\r\n\t\t    p.name() = itc->second.name();\r\n\t\t    p.id() = itc->second.id();\r\n\t\t    p.leftBottom() = KeiRo::Base::Coord2( x, y );\r\n\t\t    p.width() = w;\r\n\t\t    p.height() = h;\r\n\r\n\t\t    _treemapSourceMap.insert( pair< unsigned int, KeiRo::Base::Rectangle2 >( p.id(), p ) );\r\n\r\n#ifdef Treemap_DEBUG\r\n\t\t\tcerr << \"createTreemap: \" << endl;\r\n\t\t\tcerr << \"treemapID = \" << _id << endl;\r\n\t\t    cerr << \"i = \" << i << endl;\r\n\t\t    cerr << \" name = \" << p.name() << endl;\r\n\t\t    cerr << \" p = \" << p << endl;\r\n#endif // Treemap_DEBUG\r\n\t    }\r\n    }\r\n    \r\n\t\r\n\t//\r\n\t//  Treemap::updateTreemap --\tupdate the Treemap\r\n\t//\r\n\t//  Inputs\r\n\t//\tnone\r\n\t//\r\n\t//  Outputs\r\n\t//\ta vector of LocalMoves\r\n\t//\r\n\tvector<LocalMove> Treemap::updateTreemap( void )\r\n\t{\r\n\t\t// HARDCODED BOOLEAN FOR VERSION OF stable treemaps via local moves\r\n\t\tbool stable = true;\r\n#ifdef Treemap_DEBUG\r\n\t\tcerr << \"_treemapSourceMap:\" << endl;\r\n\t\tfor( map< string, KeiRo::Base::Polygon2 >::iterator it = _treemapSourceMap.begin();\r\n\t\t\t it != _treemapSourceMap.end(); it++ ){\r\n\t\t\tcerr << \"it->first = \" << it->first << endl;\r\n\t\t}\r\n\t\tcerr << \"_treemapTargetMap:\" << endl;\r\n\t\tfor( map< string, KeiRo::Base::Polygon2 >::iterator it = _treemapTargetMap.begin();\r\n\t\t     it != _treemapTargetMap.end(); it++ ){\r\n\t\t\tcerr << \"it->first = \" << it->first << endl;\r\n\t\t}\r\n#endif // Treemap_DEBUG\r\n\t\t\r\n\t\t_treemapSourceMap = _treemapTargetMap;\r\n\t\t\r\n\t\tQString filePath =\r\n\t\t\t\tqApp->applicationDirPath() + QString::fromStdString( _tmpFolder );\r\n\t\t\r\n\t\tstring cm;\r\n\t\tstring technique;\r\n\t\tif(stable) {\r\n\t\t\ttechnique = \"ssv\";\r\n\t\t} else {\r\n\t\t\ttechnique = \"ssv2\";\r\n\t\t}\r\n\t\t\r\n\t\tcerr << \"_widthPtr = \" << _boundingBoxPtr->width() << \" _heightPtr = \" << _boundingBoxPtr->height() << endl;\r\n\t\tcerr << \"_owidthPtr = \" << _boundingBoxPtr->oldWidth() << \" _oheightPtr = \" << _boundingBoxPtr->oldHeight() << endl;\r\n\t\t\r\n#ifdef __linux__\r\n        cerr << \"HERE *************** \" << endl;\r\n//        char cwd[256];\r\n//        getcwd(cwd, 256);\r\n//        string cwd_str = string(cwd);\r\n//        system( \"pwd\");\r\n//        cerr << \"HERE pwd = \" << cwd_str.c_str() << endl;\r\n        cm = string( \"mkdir tmp/input/data/; mkdir tmp/input/rect/;cp tmp/input/data_\" ) + string( to_string( _id ) ) + string( \"/treemap.txt tmp/input/data/treemap.txt\" ) + string( \";\" ) +\r\n             \t     string( \"cp -r tmp/input/rect_\" ) + string( to_string( _id ) ) + string( \"/rect.txt tmp/input/rect/rect.txt\" ) + string(\";\" ) +\r\n \t\t string( \"rm -r tmp/output/output_\") + string( to_string( _id ) ) + \"/;\"+\r\n                 string( \"cd ../../ResponsiveLens/thirdparty/TreemapComparison/code/StableTreemap/;\") +\r\n\t         string( \"java -classpath \\\"libraries/opencsv-3.7.jar:libraries/jama-1.0.3.jar:src\\\"\" ) +\r\n\t         \" UserControl/Simulator -technique \" + technique + \" -inputfolder \" +\r\n\t         filePath.toStdString() + \"/input/data\" +\r\n\t         \" -baseline false -outputfolder \" +\r\n\t\t filePath.toStdString() + \"/output/output_\" + string( to_string( _id ) ) + \"/\"+\r\n\t\t \" -width \" + to_string( (int)_boundingBoxPtr->oldWidth() ) + \" -height \" + to_string( (int)_boundingBoxPtr->oldHeight() ) + string(\";\");\r\n#endif  // __linux__\r\n#ifdef __APPLE__\r\n\t    cm = string( \"cp -r tmp/input/data_\" ) + string( to_string( _id ) ) + string( \"/ tmp/input/data/\" ) + string(\r\n\t    \t\t\";\" ) +\r\n             string( \"cp -r tmp/input/rect_\" ) + string( to_string( _id ) ) + string( \"/ tmp/input/rect/\" ) + string(\r\n             \t\t\";\" ) +\r\n \t\t     string( \"rm -r tmp/output/output_\") + string( to_string( _id ) ) + \"/;\"+\r\n             string( \"cd ../../ResponsiveLens/thirdparty/TreemapComparison/code/StableTreemap/;\") +\r\n\t\t     string( \"rm .DS_Store;\") +\r\n\t\t     string( \"rm */.DS_Store;\") +\r\n\t\t     string( \"rm */*/.DS_Store;\") +\r\n\t\t     string( \"rm */*/*/.DS_Store;\") +\r\n\t\t     string( \"java -classpath \\\"libraries/opencsv-3.7.jar:libraries/jama-1.0.3.jar:src\\\"\" ) +\r\n\t\t     \" UserControl/Simulator -technique \" + technique + \" -inputfolder \" +\r\n\t\t     filePath.toStdString() + \"/input/data/\"\r\n\t\t     \" -baseline false -outputfolder \" +\r\n\t\t     filePath.toStdString() + \"/output/output_\" + string( to_string( _id ) ) + \"/\"+\r\n\t\t     \" -width \" + to_string( (int)_boundingBoxPtr->oldWidth() ) + \" -height \" + to_string( (int)_boundingBoxPtr->oldHeight() ) + string(\";\");\r\n#endif  // __APPLE__\r\n#ifdef Treemap_DEBUG\r\n\t\tcerr << \"width = \" << *_widthPtr << \" height = \" << *_heightPtr << endl;\r\n\t\tcerr << \"gridwidth = \" << _gridWidth << \" gridheight = \" << _gridHeight << endl;\r\n#endif // Treemap_DEBUG\r\n        cerr << \"cm = \" << cm << endl << endl << endl << endl;\r\n\r\n\t\tsystem( cm.c_str() );\r\n\r\n\t\t// update source map\r\n\t\tGraph::TreeDirectedGraph &graphmlTree = _metadataPtr->graphmlTree();\r\n\t\tGraph::TreeDirectedGraph::vertex_descriptor vd = vertex( _id, graphmlTree );\r\n\t\tGraph::TreeDirectedGraph::degree_size_type degrees = out_degree( vd, graphmlTree );\r\n\t\tvector< map< unsigned int, KeiRo::Base::Rectangle2 >::iterator > removeSVec;\r\n\t\tvector< map< unsigned int, KeiRo::Base::Rectangle2 >::iterator > removeTVec;\r\n\t\tfor( unsigned int i = 0; i < _treemapTargetMap.size(); i++ ){\r\n\t\t\tmap< unsigned int, KeiRo::Base::Rectangle2 >::iterator itS = _treemapSourceMap.begin();\r\n\t\t\tmap< unsigned int, KeiRo::Base::Rectangle2 >::iterator itT = _treemapTargetMap.begin();\r\n\t\t\tstd::advance( itS, i );\r\n\t\t\tstd::advance( itT, i );\r\n\t\t\titS->second.leftBottom().x()    = itT->second.leftBottom().x();\r\n\t\t\titS->second.leftBottom().y()    = itT->second.leftBottom().y();\r\n\t\t\titS->second.width()             = itT->second.width();\r\n\t\t\titS->second.height()            = itT->second.height();\r\n\t\t\tif( i >= degrees ){\r\n\t\t\t\tremoveSVec.push_back( itS );\r\n\t\t\t\tremoveTVec.push_back( itT );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// vector to store all the local moves found by stable treemap algorithm\r\n\t\tvector<LocalMove> localMoves;\r\n\r\n\t\t// read the output file\r\n\t\tfor( unsigned int i = 0; i < 2; i++ ){\r\n\r\n\t\t\tstring techname;\r\n\t\t\tif(stable) {\r\n\t\t\t\ttechname = \"Local4Moves1Repeats\";\r\n\t\t\t} else {\r\n\t\t\t\ttechname = \"Local0Moves0Repeats\";\r\n\t\t\t}\r\n\t\t\tstring filename = filePath.toStdString() + \"/output/output_\" + to_string( _id ) +\r\n\t\t\t\t\t\"/\" + techname + \"/treemap.txt/\" + \"t\" + to_string(i) + \".rect\";\r\n#ifdef Treemap_DEBUG\r\n\t\t\tcerr << \"Treemap::filename = \" << filename << endl;\r\n#endif // Treemap_DEBUG\r\n\t\t\tifstream        ifs( filename );\r\n\t\t\tstring          line;\r\n\t\t\t// char            buf[ MAX_STR ];\r\n\r\n\t\t\tif ( !ifs ) {\r\n\t\t\t\tcerr << \"Cannot open the target file : \" << filename << endl;\r\n\t\t\t\treturn localMoves;\r\n\t\t\t}\r\n\r\n\t\t\twhile ( std::getline( ifs, line ) && line != \"LocalMoves\") {\r\n\r\n\t\t\t\tstd::stringstream lstr( line );\r\n\t\t\t\tstring label, LeftBottomX, LeftBottomY, width, height;\r\n\r\n\t\t\t\t//------------------------------------------------------------------------------\r\n\t\t\t\t//  Read line\r\n\t\t\t\t//------------------------------------------------------------------------------\r\n\t\t\t\tgetline( lstr, label, ',');\r\n\t\t\t\tgetline( lstr, LeftBottomX, ',');\r\n\t\t\t\tgetline( lstr, LeftBottomY, ',');\r\n\t\t\t\tgetline( lstr, width, ',');\r\n\t\t\t\tgetline( lstr, height, ',');\r\n\r\n\t\t\t\tdouble w = stod( width );\r\n\t\t\t\tdouble h = stod( height );\r\n\t\t\t\tdouble sx = stod( LeftBottomX );\r\n\t\t\t\tdouble sy = stod( LeftBottomY );\r\n\t\t\t\tdouble tx = sx+w;\r\n\t\t\t\tdouble ty = sy+h;\r\n\t\t\t\tint gx = round( sx );\r\n\t\t\t\tint gy = round( sy );\r\n\t\t\t\tint gw = round( tx ) - gx;\r\n\t\t\t\tint gh = round( ty ) - gy;\r\n\r\n\t\t\t\tunsigned int id = stoi( label.substr (5,DIGIT_LIMIT ) );\r\n\r\n\t\t\t\tif( i == 1 ) {\r\n\r\n\r\n\t\t\t\t\tmap< unsigned int, KeiRo::Base::Rectangle2 >::iterator it = _treemapTargetMap.find( id );\r\n\t\t\t\t\tmap< unsigned int, KeiRo::Base::Rectangle2 >::iterator itS = _treemapSourceMap.find( id );\r\n\r\n\t\t\t\t\tint sgx = round( (double)gx * _boundingBoxPtr->width()/(double)_boundingBoxPtr->oldWidth() );\r\n\t\t\t\t\tint sgy = round( (double)gy * _boundingBoxPtr->height()/(double)_boundingBoxPtr->oldHeight() );\r\n\t\t\t\t\tint tgx = round( (double)(gx+gw) * _boundingBoxPtr->width()/(double)_boundingBoxPtr->oldWidth() );\r\n\t\t\t\t\tint tgy = round( (double)(gy+gh) * _boundingBoxPtr->height()/(double)_boundingBoxPtr->oldHeight() );\r\n\t\t\t\t\tint sgw = tgx - sgx;\r\n\t\t\t\t\tint sgh = tgy - sgy;\r\n\t\t\t\t\tit->second.leftBottom().x() = sgx + _boundingBoxPtr->leftBottom().x();\r\n\t\t\t\t\tit->second.leftBottom().y() = sgy + _boundingBoxPtr->leftBottom().y();\r\n\t\t\t\t\tit->second.width()      = sgw;\r\n\t\t\t\t\tit->second.height()     = sgh;\r\n\r\n#ifdef TREEMAP_DEBUG\r\n\t\t\t\t\tcerr << \"label = \" << label << endl;\r\n\t\t\t\t\tcerr << \"id = \" << id << endl;\r\n\t\t\t\t\tif( label == \"root/00003\" ){\r\n\t\t\t\t\t\tcerr << \"_boundingBoxPtr = \" << *_boundingBoxPtr;\r\n\t\t\t\t\t\tcerr << \"gx = \" << gx << \", gy = \" << gy << endl;\r\n\t\t\t\t\t\tcerr << \"sgx = \" << sgx << \", sgy = \" << sgy << endl;\r\n\t\t\t\t\t\tcerr << \"tgx = \" << tgx << \", tgy = \" << tgy << endl;\r\n\t\t\t\t\t\tcerr << \"source = \" << itS->second;\r\n\t\t\t\t\t\tcerr << \"target = \" << it->second;\r\n\t\t\t\t\t}\r\n#endif  // TREEMAP_DEBUG\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tcerr << \"Local moves start\" << endl;\r\n\r\n\t\t\twhile ( std::getline( ifs, line ) ) {\r\n\r\n\t\t\t\tstd::stringstream lstr( line );\r\n\t\t\t\tstring horVert, segmentCoord, leftBottomBefore, rightTopBefore, leftBottomAfter, rightTopAfter, stretched;\r\n\r\n\t\t\t\tgetline( lstr, horVert, ',');\r\n\t\t\t\tgetline( lstr, segmentCoord, ',');\r\n\t\t\t\tgetline( lstr, leftBottomBefore, ',');\r\n\t\t\t\tgetline( lstr, rightTopBefore, ',');\r\n\t\t\t\tgetline( lstr, leftBottomAfter, ',');\r\n\t\t\t\tgetline( lstr, rightTopAfter, ',');\r\n\r\n\t\t\t\tbool horizontal = false;\r\n\t\t\t\tif(horVert.compare(\"horizontal\") == 0) {\r\n\t\t\t\t\thorizontal = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdouble segCoord = stod( segmentCoord );\r\n\t\t\t\tunsigned int beforeLBID = stoi( leftBottomBefore.substr(5, DIGIT_LIMIT ) );\r\n\t\t\t\tunsigned int beforeRTID = stoi( rightTopBefore.substr(5, DIGIT_LIMIT) );\r\n\t\t\t\tunsigned int afterLBID = stoi( leftBottomAfter.substr(5, DIGIT_LIMIT ) );\r\n                               unsigned int afterRTID = stoi( rightTopAfter.substr(5, DIGIT_LIMIT) );\r\n\r\n\t\t\t\t// save the local move\r\n\t\t\t\tLocalMove* move;\r\n\r\n\r\n\r\n\t\t\t\tif ( getline( lstr, stretched, ',') ) {\r\n\t\t\t\t\tunsigned int stretchedID = stoi( stretched.substr(5, DIGIT_LIMIT) );\r\n\t\t\t\t\tmove = new LocalMove(horizontal, segCoord, stretchedID, beforeLBID, beforeRTID, afterLBID, afterRTID);\r\n\t\t\t\t\t//cerr << \"Rectangle \" << stretched << \" stretches\" << endl;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tmove = new LocalMove(horizontal, segCoord, beforeLBID, beforeRTID, afterLBID, afterRTID);\r\n\t\t\t\t\t//cerr << \"Rectangles flip\" << endl;\r\n\t\t\t\t}\r\n\t\t\t\tcerr << \"printmove: \" <<endl\r\n\t\t\t\t\t<< \"beforeSegmentHorizontal: \" << move->beforeSegmentHorizontal() << endl\r\n\t\t\t\t<< \"_beforeSegmentCoord: \" << move->beforeSegmentCoord() << endl\r\n\t\t\t\t<< \"_stretchMove: \" << move->stretchMove() << endl\r\n\t\t\t\t<< \"_beforeLeftBottomID: \" << move->beforeLeftBottomID() << endl\r\n\t\t\t\t<< \"_beforeRightTopID: \" << move->beforeRightTopID() << endl\r\n\t\t\t\t<< \"_afterLeftBottomID: \" << move->afterLeftBottomID() << endl\r\n\t\t\t\t<< \"_afterRightTopID: \" << move->afterRightTopID()<< endl;\r\n\r\n\t\t\t\tlocalMoves.push_back(*move);\r\n\t\t\t}\r\n\r\n\t\t\tcerr << \"Local moves end with \" << localMoves.size() << \" moves\" << endl;\r\n\t\t}\r\n\r\n\t\tcerr << \"Returning local moves at address \" << &localMoves << endl;\r\n\r\n\r\n\r\n\t\treturn localMoves;\r\n\t}\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tFriend functions\r\n    //------------------------------------------------------------------------------\r\n\r\n\r\n    //------------------------------------------------------------------------------\r\n    //\tI/O functions\r\n    //------------------------------------------------------------------------------\r\n}\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ResponsiveLens/core/Treemap.cpp b/ResponsiveLens/core/Treemap.cpp
--- a/ResponsiveLens/core/Treemap.cpp	
+++ b/ResponsiveLens/core/Treemap.cpp	
@@ -697,7 +697,7 @@
 		        << KeiRo::Base::Common::to_string_with_precision( timestep1 ) << ","
 		        << KeiRo::Base::Common::to_string_with_precision( timestep2 ) << endl;
 	    }
-	
+
 	    ofs.close();
 	
 	    // export stable treemap data
@@ -869,7 +869,7 @@
 		cerr << "width = " << *_widthPtr << " height = " << *_heightPtr << endl;
 		cerr << "gridwidth = " << _gridWidth << " gridheight = " << _gridHeight << endl;
 #endif // Treemap_DEBUG
-        cerr << "cm = " << cm << endl << endl << endl << endl;
+        //cerr << "cm = " << cm << endl << endl << endl << endl;
 
 		system( cm.c_str() );
 
@@ -980,7 +980,7 @@
 				}
 			}
 
-			cerr << "Local moves start" << endl;
+			//cerr << "Local moves start" << endl;
 
 			while ( std::getline( ifs, line ) ) {
 
@@ -1018,14 +1018,14 @@
 					move = new LocalMove(horizontal, segCoord, beforeLBID, beforeRTID, afterLBID, afterRTID);
 					//cerr << "Rectangles flip" << endl;
 				}
-				cerr << "printmove: " <<endl
-					<< "beforeSegmentHorizontal: " << move->beforeSegmentHorizontal() << endl
-				<< "_beforeSegmentCoord: " << move->beforeSegmentCoord() << endl
-				<< "_stretchMove: " << move->stretchMove() << endl
-				<< "_beforeLeftBottomID: " << move->beforeLeftBottomID() << endl
-				<< "_beforeRightTopID: " << move->beforeRightTopID() << endl
-				<< "_afterLeftBottomID: " << move->afterLeftBottomID() << endl
-				<< "_afterRightTopID: " << move->afterRightTopID()<< endl;
+				// cerr << "printmove: " <<endl
+				// 	<< "beforeSegmentHorizontal: " << move->beforeSegmentHorizontal() << endl
+				// << "_beforeSegmentCoord: " << move->beforeSegmentCoord() << endl
+				// << "_stretchMove: " << move->stretchMove() << endl
+				// << "_beforeLeftBottomID: " << move->beforeLeftBottomID() << endl
+				// << "_beforeRightTopID: " << move->beforeRightTopID() << endl
+				// << "_afterLeftBottomID: " << move->afterLeftBottomID() << endl
+				// << "_afterRightTopID: " << move->afterRightTopID()<< endl;
 
 				localMoves.push_back(*move);
 			}
